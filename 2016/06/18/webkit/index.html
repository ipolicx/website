<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>深入剖析-WebKit - IP</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="article">
<meta property="og:title" content="深入剖析-WebKit">
<meta property="og:url" content="https://www.policx.com/2016/06/18/webkit/index.html">
<meta property="og:site_name" content="IP">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://images.pexels.com/photos/34600/pexels-photo.jpg?auto=compress&cs=tinysrgb&dpr=2&w=500">
<meta property="og:updated_time" content="2019-07-13T08:14:22.598Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入剖析-WebKit">
<meta name="twitter:image" content="https://images.pexels.com/photos/34600/pexels-photo.jpg?auto=compress&cs=tinysrgb&dpr=2&w=500">







<link rel="icon" href="/images/favicon.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-142191817-2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-142191817-2');
</script>


    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.gif" alt="深入剖析-WebKit" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">主页</a>
                
                <a class="navbar-item" href="/archives">归档</a>
                
                <a class="navbar-item" href="/categories">分类</a>
                
                <a class="navbar-item" href="/tags">标签</a>
                
                <a class="navbar-item" href="/message">留言板</a>
                
                <a class="navbar-item" href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Instagram" href="https://www.instagram.com/aragakiyui_fanspage/">
                        
                        <i class="fab fa-instagram"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <!-- 布局 -->
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-6-tablet is-6-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-image">
        <span class="image is-7by1">
            <img class="thumbnail" src="https://images.pexels.com/photos/34600/pexels-photo.jpg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500" alt="深入剖析-WebKit">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-06-18T02:00:59.000Z">2016-06-18</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 小时 读完 (大约 31434 个字)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span>次访问
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                深入剖析-WebKit
            
        </h1>
        <div class="content">
            <ul>
<li><a id="more"></a>
<h2 id="HTML-标准"><a href="#HTML-标准" class="headerlink" title="HTML 标准"></a>HTML 标准</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3></li>
<li>HTML DOM 树的插入状态规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode</a></li>
<li>HTML Tokenize 规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a> <a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="noopener">https://dev.w3.org/html5/spec-preview/tokenization.html</a></li>
<li>HTMLElement 堆栈规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a></li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。</p>
<p>1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。</p>
<p>1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。</p>
<p>1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。</p>
<p>2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。</p>
<p>2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。</p>
<p>2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio / video 音频视频，3D/graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。</p>
<p>完整的浏览器发展史可以在这里看：<a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>
<h2 id="WebKit-全貌"><a href="#WebKit-全貌" class="headerlink" title="WebKit 全貌"></a>WebKit 全貌</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。<br>先看看它的大模块：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/45.png" alt="45"><br>WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/46.png" alt="46"><br>整个 WebKit 架构，如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/49.png" alt="49"><br>实线部分是共享的，虚线部分会根据不同的平台有不同的实现。</p>
<p>下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/74.png" alt="74"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/01.png" alt="01"></p>
<p>解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。</p>
<p>DOM Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/02.png" alt="02"><br>从网页 URL 到构建完 DOM 树的过程如图<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/47.png" alt="47"></p>
<p>CSS Rule Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/03.png" alt="03"></p>
<p>通过上面的两个数构造的 Style Context Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/04.png" alt="04"></p>
<p>浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/48.png" alt="48"></p>
<p>计算每个 Node 的位置，执行 Layout 过程<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/05.png" alt="05"></p>
<p>Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。</p>
<h3 id="WebKit-源代码结构说明"><a href="#WebKit-源代码结构说明" class="headerlink" title="WebKit 源代码结构说明"></a>WebKit 源代码结构说明</h3><ul>
<li>JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。</li>
<li>WebCore：浏览器渲染引擎，包含了各个核心模块。</li>
<li>WebCore/css：CSS 解释器，CSS 规则等。</li>
<li>WebCore/dom：各种 DOM 元素和 DOM Tree 结构相关的类。</li>
<li>WebCore/html：HTML 解释器和各种 HTML 元素等相关内容。</li>
<li>WebCore/rendering：Render Object 相关，还有页面渲染的样式和布局等。</li>
<li>WebCore/inspector：网页调试工具。</li>
<li>WebCore/loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。</li>
<li>WebCore/page：页面相关的操作，页面结构和交互事件等。</li>
<li>WebCore/platform：各个平台相关的代码，比如 iOS，Mac 等</li>
<li>WebCore/storage：存储相关，比如 WebStorage，Index DB 等接口的实现。</li>
<li>WebCore/workers：Worker 线程封装，提供 JS 多线程执行环境。</li>
<li>WebCore/xml：XML 相关比如 XML Parser，XPath，XSLT 等。</li>
<li>WebCore/accessibility：图形控件访问接口。</li>
<li>WebCore/bindings：DOM 元素和 JS 绑定的接口。</li>
<li>WebCore/bridge：C，JavaScript 和 Objective-C 的桥接。</li>
<li>WebCore/editing：页面编辑相关，比如 DOM 修改，拼写检查等。</li>
<li>WebCore/history：Page Cache 实现前进后退浏览记录等。</li>
<li>WebCore/mathml：数学表达式在网页中的规范代码实现。</li>
<li>WebCore/plugins：NPPlugin 的支持接口</li>
<li>WebCore/svg：矢量图形的支持。</li>
<li>WebKit：平台相关的接口，每个目录都是不同的平台接口实现。</li>
<li>WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。</li>
<li>DumpRenderTree：用于生成 RenderTree</li>
<li>TestWebKitAPI：测试 WebKit 的 API 的测试代码</li>
</ul>
<h3 id="WebKit-代码风格"><a href="#WebKit-代码风格" class="headerlink" title="WebKit 代码风格"></a>WebKit 代码风格</h3><ul>
<li>内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。</li>
<li>代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。</li>
<li>代码编写风格：可以在官网查看到：<a href="https://webkit.org/code-style-guidelines/" target="_blank" rel="noopener">https://webkit.org/code-style-guidelines/</a> 想给 WebKit 做贡献的同学们可以好好看看了。</li>
</ul>
<h3 id="WebKit-的设计模式"><a href="#WebKit-的设计模式" class="headerlink" title="WebKit 的设计模式"></a>WebKit 的设计模式</h3><p>下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。</p>
<ul>
<li>单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。</li>
<li>工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。</li>
<li>观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。</li>
<li>组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。</li>
<li>命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。</li>
</ul>
<h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/06.png" alt="06"></p>
<ul>
<li>Frame：中心类，通过它找其它类</li>
<li>FrameLoader：加载资源用的</li>
<li>Document：具体实现是 HTMLDocument</li>
<li>Page：窗口的操作</li>
<li>EventHandler：输入事件的处理，比如键盘，鼠标，触屏等</li>
</ul>
<h4 id="WebCore-Frame"><a href="#WebCore-Frame" class="headerlink" title="WebCore::Frame"></a>WebCore::Frame</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/29.png" alt="29"></p>
<ul>
<li>FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。</li>
<li>FrameLoader：frame 的加载</li>
<li>NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。</li>
<li>DOMWindow：管理 DOM 相关的事件，属性和消息。</li>
<li>FrameView：Frame 的排版。</li>
<li>Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。</li>
<li>ScriptController：管理 js 脚本。</li>
<li>Editor：管理页面比如 copy，paste和输入等编辑操作。</li>
<li>SelectionController：管理 Frame 里的选择操作。</li>
<li>AnimationControlle：动画控制。</li>
<li>EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。</li>
</ul>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/43.png" alt="43"><br>上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/44.png" alt="44"></p>
<h3 id="Frame-的主要接口"><a href="#Frame-的主要接口" class="headerlink" title="Frame 的主要接口"></a>Frame 的主要接口</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(page);</span><br><span class="line">    ASSERT(client);</span><br><span class="line">    return adoptRef(*new Frame(*page, ownerElement, *client));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。<br>初始调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webPage::setView</span><br><span class="line">webPage::setViewportSize</span><br><span class="line">webPage::mainFrame</span><br><span class="line">webPagePrivate::createMainFrame</span><br><span class="line">webFrameData::webFrameData</span><br><span class="line">Frame::create</span><br></pre></td></tr></table></figure>

<p>解析中发现 iframe 时的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FrameLoader::finishedLoading</span><br><span class="line">HTMLDocumentParser::append</span><br><span class="line">HTMLTreeBuilder::processToken</span><br><span class="line">HTMLElementBase::openURL</span><br><span class="line">SubFrameLoader::requestFrame</span><br><span class="line">FrameLoaderClient::creatFrame</span><br><span class="line">webFrameData::webFrameData</span><br><span class="line">Frame::create</span><br></pre></td></tr></table></figure>

<h4 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">void Frame::createView(const IntSize&amp; viewportSize, const Color&amp; backgroundColor, bool transparent,</span><br><span class="line">    const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,</span><br><span class="line">    bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,</span><br><span class="line">    ScrollbarMode verticalScrollbarMode, bool verticalLock)</span><br></pre></td></tr></table></figure>

<p>会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。<br>调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">FrameLoader::commitProvisionalLoad</span><br><span class="line">FrameLoader::transitionToCommitted</span><br><span class="line">FrameLoaderClient::transitionToCommittedForNewPage</span><br><span class="line">Frame::createView</span><br></pre></td></tr></table></figure>

<h4 id="setDocument"><a href="#setDocument" class="headerlink" title="setDocument"></a>setDocument</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)</span><br></pre></td></tr></table></figure>

<p>用来关联 Frame 和 Document 对象<br>Frame 初始化调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">WebFrame::webFrame</span><br><span class="line">webFramePrivate::init</span><br><span class="line">Frame::init</span><br><span class="line">FrameLoader::init</span><br><span class="line">DocumentWriter::begin</span><br><span class="line">Frame::setDocument</span><br></pre></td></tr></table></figure>

<p>js 脚本更改数据时的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">DocumentLoader::receivedData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">FrameLoaderClient::committedLoad</span><br><span class="line">DocumentLoader::commitData</span><br><span class="line">DocumentWriter::setEncoding</span><br><span class="line">DocumentWriter::willSetEncoding</span><br><span class="line">FrameLoader::receivedFirstData</span><br><span class="line">DocumentWriter::begin</span><br><span class="line">FrameLoader::clear</span><br><span class="line">Frame::setDocument</span><br></pre></td></tr></table></figure>

<h2 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h2><p>全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。</p>
<h3 id="Smart-ptr-智能指针"><a href="#Smart-ptr-智能指针" class="headerlink" title="Smart ptr 智能指针"></a>Smart ptr 智能指针</h3><p>对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。</p>
<p>智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。</p>
<p>智能指针的实现方式：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPtr &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef T ValueType;</span><br><span class="line">        typedef ValueType *PtrType;</span><br><span class="line">        </span><br><span class="line">        //构造析构函数</span><br><span class="line">        SmartPtr() :m_ptr(NULL) &#123;&#125;</span><br><span class="line">        SmartPtr(PtrType ptr) :m_ptr(ptr) &#123;&#125;</span><br><span class="line">        ~SmartPtr() &#123; </span><br><span class="line">            if(m_ptr) delete m_ptr; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //拷贝构造函数</span><br><span class="line">        SmartPtr(const SmartPtr&lt;T&gt;&amp; o); //堆上分配的对象</span><br><span class="line">        template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; o);</span><br><span class="line">        </span><br><span class="line">        //拷贝赋值运算符</span><br><span class="line">        template&lt;typename U&gt; SmartPtr&amp; operator = (const SmartPtr&lt;U&gt;&amp; o);</span><br><span class="line"></span><br><span class="line">        //指针运算，是为了让智能指针在行为上更类似原生指针</span><br><span class="line">        ValueType&amp; operator*() const &#123; </span><br><span class="line">            return *m_ptr; </span><br><span class="line">        &#125;</span><br><span class="line">        PtrType operator-&gt;() const &#123;</span><br><span class="line">            return m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //逻辑运算符重载</span><br><span class="line">        //对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr)</span><br><span class="line">        bool operator!() const &#123;</span><br><span class="line">            return !m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //转成 raw ptr</span><br><span class="line">        operator PtrType() &#123;</span><br><span class="line">            return m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        PtrType m_ptr;</span><br><span class="line">&#125;</span><br><span class="line">//创建智能指针对象格式</span><br><span class="line">SmartPtr(new ValueType());</span><br></pre></td></tr></table></figure>

<h3 id="RefPtr"><a href="#RefPtr" class="headerlink" title="RefPtr"></a>RefPtr</h3><p>RefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF/Source/wtf/RefCounted.h 里。类模板的定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">class RefCountedBase &#123;</span><br><span class="line">public:</span><br><span class="line">    void ref() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line">        ++m_refCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasOneRef() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT(!m_deletionHasBegun);</span><br><span class="line">#endif</span><br><span class="line">        return m_refCount == 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned refCount() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_refCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void relaxAdoptionRequirement()</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(m_adoptionIsRequired);</span><br><span class="line">        m_adoptionIsRequired = false;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    RefCountedBase()</span><br><span class="line">        : m_refCount(1)</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        , m_deletionHasBegun(false)</span><br><span class="line">        , m_adoptionIsRequired(true)</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~RefCountedBase()</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT(m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns whether the pointer should be freed or not.</span><br><span class="line">    bool derefBase() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        ASSERT(m_refCount);</span><br><span class="line">        unsigned tempRefCount = m_refCount - 1;</span><br><span class="line">        if (!tempRefCount) &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">            m_deletionHasBegun = true;</span><br><span class="line">#endif</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        m_refCount = tempRefCount;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    bool deletionHasBegun() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_deletionHasBegun;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    friend void adopted(RefCountedBase*);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    mutable unsigned m_refCount;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    mutable bool m_deletionHasBegun;</span><br><span class="line">    mutable bool m_adoptionIsRequired;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; class RefCounted : public RefCountedBase &#123;</span><br><span class="line">    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;</span><br><span class="line">public:</span><br><span class="line">    void deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (derefBase())</span><br><span class="line">            delete static_cast&lt;const T*&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    RefCounted() &#123; &#125;</span><br><span class="line">    ~RefCounted()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted<class>即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。</class></p>
<h3 id="Assert-断言的实现和应用"><a href="#Assert-断言的实现和应用" class="headerlink" title="Assert 断言的实现和应用"></a>Assert 断言的实现和应用</h3><p>断言在 WTF 里是这样定义的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">#define ASSERT(assertion) do &#123; \</span><br><span class="line">    if (!(assertion)) &#123; \</span><br><span class="line">        //打印用</span><br><span class="line">        WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \</span><br><span class="line">        //重点</span><br><span class="line">        CRASH(); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">#ifndef CRASH</span><br><span class="line">#if defined(NDEBUG) &amp;&amp; OS(DARWIN)</span><br><span class="line">// Crash with a SIGTRAP i.e EXC_BREAKPOINT.</span><br><span class="line">// We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily</span><br><span class="line">// trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.</span><br><span class="line">#define CRASH() do &#123; \</span><br><span class="line">    //直接 inline 汇编代码</span><br><span class="line">    WTFBreakpointTrap(); \</span><br><span class="line">    __builtin_unreachable(); \</span><br><span class="line">&#125; while (0)</span><br><span class="line">#else</span><br><span class="line">#define CRASH() WTFCrash()</span><br><span class="line">#endif</span><br><span class="line">#endif // !defined(CRASH)</span><br><span class="line"></span><br><span class="line">//根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏</span><br><span class="line">#if CPU(X86_64) || CPU(X86)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;int3&quot;)</span><br><span class="line">#elif CPU(ARM_THUMB2)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;bkpt #0&quot;)</span><br><span class="line">#elif CPU(ARM64)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;brk #0&quot;)</span><br><span class="line">#else</span><br><span class="line">#define WTFBreakpointTrap() WTFCrash() // Not implemented.</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">#define WTF_MAKE_FAST_ALLOCATED \</span><br><span class="line">public: \</span><br><span class="line">    void* operator new(size_t, void* p) &#123; return p; &#125; \</span><br><span class="line">    void* operator new[](size_t, void* p) &#123; return p; &#125; \</span><br><span class="line">    \</span><br><span class="line">    void* operator new(size_t size) \</span><br><span class="line">    &#123; \</span><br><span class="line">        return ::WTF::fastMalloc(size); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void operator delete(void* p) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ::WTF::fastFree(p); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void* operator new[](size_t size) \</span><br><span class="line">    &#123; \</span><br><span class="line">        return ::WTF::fastMalloc(size); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void operator delete[](void* p) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ::WTF::fastFree(p); \</span><br><span class="line">    &#125; \</span><br><span class="line">    void* operator new(size_t, NotNullTag, void* location) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ASSERT(location); \</span><br><span class="line">        return location; \</span><br><span class="line">    &#125; \</span><br><span class="line">private: \</span><br><span class="line">typedef int __thisIsHereToForceASemicolonAfterThisMacro</span><br></pre></td></tr></table></figure>

<p>这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void* fastMalloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_IS_WITHIN_LIMIT(size);</span><br><span class="line">    return bmalloc::api::malloc(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：<a href="https://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">https://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。</p>
<h4 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h4><p>WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">template&lt;typename T, size_t inlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, size_t minCapacity = 16, typename Malloc = FastMalloc&gt;</span><br><span class="line">class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; &#123;</span><br><span class="line">    WTF_MAKE_FAST_ALLOCATED;</span><br><span class="line">private:</span><br><span class="line">    //VectorBuffer 是内部存储数据的容器</span><br><span class="line">    typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</span><br><span class="line">    //Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里</span><br><span class="line">    typedef VectorTypeOperations&lt;T&gt; TypeOperations;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    typedef T ValueType;</span><br><span class="line">    //iterator 直接使用的原生指针</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line"></span><br><span class="line">    Vector()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unlike in std::vector, this constructor does not initialize POD types.</span><br><span class="line">    explicit Vector(size_t size)</span><br><span class="line">        : Base(size, size)</span><br><span class="line">    &#123;</span><br><span class="line">        asanSetInitialBufferSizeTo(size);</span><br><span class="line"></span><br><span class="line">        if (begin())</span><br><span class="line">            TypeOperations::initialize(begin(), end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(size_t size, const T&amp; val)</span><br><span class="line">        : Base(size, size)</span><br><span class="line">    &#123;</span><br><span class="line">        asanSetInitialBufferSizeTo(size);</span><br><span class="line"></span><br><span class="line">        if (begin())</span><br><span class="line">            TypeOperations::uninitializedFill(begin(), end(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(std::initializer_list&lt;T&gt; initializerList)</span><br><span class="line">    &#123;</span><br><span class="line">        reserveInitialCapacity(initializerList.size());</span><br><span class="line"></span><br><span class="line">        asanSetInitialBufferSizeTo(initializerList.size());</span><br><span class="line"></span><br><span class="line">        for (const auto&amp; element : initializerList)</span><br><span class="line">            uncheckedAppend(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_size)</span><br><span class="line">            TypeOperations::destruct(begin(), end());</span><br><span class="line"></span><br><span class="line">        asanSetBufferSizeToFullCapacity(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(const Vector&amp;);</span><br><span class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span><br><span class="line">    explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    Vector&amp; operator=(const Vector&amp;);</span><br><span class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span><br><span class="line">    Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    Vector(Vector&amp;&amp;);</span><br><span class="line">    Vector&amp; operator=(Vector&amp;&amp;);</span><br><span class="line">    </span><br><span class="line">    //返回 Vector 里元素个数</span><br><span class="line">    size_t size() const &#123; return m_size; &#125;</span><br><span class="line">    static ptrdiff_t sizeMemoryOffset() &#123; return OBJECT_OFFSETOF(Vector, m_size); &#125;</span><br><span class="line">    </span><br><span class="line">    //返回的是 Vector 中的容量，容量随着元素增加和删除而变化</span><br><span class="line">    size_t capacity() const &#123; return Base::capacity(); &#125;</span><br><span class="line">    bool isEmpty() const &#123; return !size(); &#125;</span><br><span class="line">    </span><br><span class="line">    //这里提供的是数组的访问功能</span><br><span class="line">    T&amp; at(size_t i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(i &gt;= size()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; at(size_t i) const </span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(i &gt;= size()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; at(Checked&lt;size_t&gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        RELEASE_ASSERT(i &lt; size());</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; at(Checked&lt;size_t&gt; i) const</span><br><span class="line">    &#123;</span><br><span class="line">        RELEASE_ASSERT(i &lt; size());</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //返回数组中第几个元素</span><br><span class="line">    T&amp; operator[](size_t i) &#123; return at(i); &#125;</span><br><span class="line">    const T&amp; operator[](size_t i) const &#123; return at(i); &#125;</span><br><span class="line">    T&amp; operator[](Checked&lt;size_t&gt; i) &#123; return at(i); &#125;</span><br><span class="line">    const T&amp; operator[](Checked&lt;size_t&gt; i) const &#123; return at(i); &#125;</span><br><span class="line"></span><br><span class="line">    T* data() &#123; return Base::buffer(); &#125;</span><br><span class="line">    const T* data() const &#123; return Base::buffer(); &#125;</span><br><span class="line">    static ptrdiff_t dataMemoryOffset() &#123; return Base::bufferMemoryOffset(); &#125;</span><br><span class="line">    //迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。</span><br><span class="line">    iterator begin() &#123; return data(); &#125;</span><br><span class="line">    iterator end() &#123; return begin() + m_size; &#125;</span><br><span class="line">    const_iterator begin() const &#123; return data(); &#125;</span><br><span class="line">    const_iterator end() const &#123; return begin() + m_size; &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;</span><br><span class="line">    reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;</span><br><span class="line">    const_reverse_iterator rbegin() const &#123; return const_reverse_iterator(end()); &#125;</span><br><span class="line">    const_reverse_iterator rend() const &#123; return const_reverse_iterator(begin()); &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; first() &#123; return at(0); &#125;</span><br><span class="line">    const T&amp; first() const &#123; return at(0); &#125;</span><br><span class="line">    T&amp; last() &#123; return at(size() - 1); &#125;</span><br><span class="line">    const T&amp; last() const &#123; return at(size() - 1); &#125;</span><br><span class="line">    </span><br><span class="line">    T takeLast()</span><br><span class="line">    &#123;</span><br><span class="line">        T result = WTFMove(last());</span><br><span class="line">        removeLast();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好</span><br><span class="line">    template&lt;typename U&gt; bool contains(const U&amp;) const;</span><br><span class="line">    template&lt;typename U&gt; size_t find(const U&amp;) const;</span><br><span class="line">    template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;</span><br><span class="line">    template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;</span><br><span class="line">    </span><br><span class="line">    template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);</span><br><span class="line">    </span><br><span class="line">    //实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力</span><br><span class="line">    void shrink(size_t size);</span><br><span class="line">    void grow(size_t size);</span><br><span class="line">    void resize(size_t size);</span><br><span class="line">    void resizeToFit(size_t size);</span><br><span class="line">    void reserveCapacity(size_t newCapacity);</span><br><span class="line">    bool tryReserveCapacity(size_t newCapacity);</span><br><span class="line">    void reserveInitialCapacity(size_t initialCapacity);</span><br><span class="line">    void shrinkCapacity(size_t newCapacity);</span><br><span class="line">    void shrinkToFit() &#123; shrinkCapacity(size()); &#125;</span><br><span class="line"></span><br><span class="line">    void clear() &#123; shrinkCapacity(0); &#125;</span><br><span class="line"></span><br><span class="line">    void append(ValueType&amp;&amp; value) &#123; append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</span><br><span class="line">    template&lt;typename U&gt; void append(U&amp;&amp;);</span><br><span class="line">    template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);</span><br><span class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    void uncheckedAppend(ValueType&amp;&amp; value) &#123; uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</span><br><span class="line">    template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; void append(const U*, size_t);</span><br><span class="line">    template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);</span><br><span class="line">    template&lt;typename U&gt; bool tryAppend(const U*, size_t);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; void insert(size_t position, const U*, size_t);</span><br><span class="line">    template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);</span><br><span class="line">    template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    void remove(size_t position);</span><br><span class="line">    void remove(size_t position, size_t length);</span><br><span class="line">    template&lt;typename U&gt; bool removeFirst(const U&amp;);</span><br><span class="line">    template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);</span><br><span class="line">    template&lt;typename U&gt; unsigned removeAll(const U&amp;);</span><br><span class="line">    template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);</span><br><span class="line"></span><br><span class="line">    void removeLast() </span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(isEmpty()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        shrink(size() - 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void fill(const T&amp;, size_t);</span><br><span class="line">    void fill(const T&amp; val) &#123; fill(val, size()); &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);</span><br><span class="line"></span><br><span class="line">    MallocPtr&lt;T&gt; releaseBuffer();</span><br><span class="line"></span><br><span class="line">    void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">#if ASAN_ENABLED</span><br><span class="line">        if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.</span><br><span class="line">            return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // Make it possible to copy inline buffers.</span><br><span class="line">        asanSetBufferSizeToFullCapacity();</span><br><span class="line">        other.asanSetBufferSizeToFullCapacity();</span><br><span class="line"></span><br><span class="line">        Base::swap(other, m_size, other.m_size);</span><br><span class="line">        std::swap(m_size, other.m_size);</span><br><span class="line"></span><br><span class="line">        asanSetInitialBufferSizeTo(m_size);</span><br><span class="line">        other.asanSetInitialBufferSizeTo(other.m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reverse();</span><br><span class="line"></span><br><span class="line">    void checkConsistency();</span><br><span class="line"></span><br><span class="line">    template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void expandCapacity(size_t newMinCapacity);</span><br><span class="line">    T* expandCapacity(size_t newMinCapacity, T*);</span><br><span class="line">    bool tryExpandCapacity(size_t newMinCapacity);</span><br><span class="line">    const T* tryExpandCapacity(size_t newMinCapacity, const T*);</span><br><span class="line">    template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); </span><br><span class="line">    template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);</span><br><span class="line">    template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);</span><br><span class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    void asanSetInitialBufferSizeTo(size_t);</span><br><span class="line">    void asanSetBufferSizeToFullCapacity(size_t);</span><br><span class="line">    void asanSetBufferSizeToFullCapacity() &#123; asanSetBufferSizeToFullCapacity(size()); &#125;</span><br><span class="line"></span><br><span class="line">    void asanBufferSizeWillChangeTo(size_t);</span><br><span class="line"></span><br><span class="line">    using Base::m_size;</span><br><span class="line">    using Base::buffer;</span><br><span class="line">    using Base::capacity;</span><br><span class="line">    using Base::swap;</span><br><span class="line">    using Base::allocateBuffer;</span><br><span class="line">    using Base::deallocateBuffer;</span><br><span class="line">    using Base::tryAllocateBuffer;</span><br><span class="line">    using Base::shouldReallocateBuffer;</span><br><span class="line">    using Base::reallocateBuffer;</span><br><span class="line">    using Base::restoreInlineBufferIfNeeded;</span><br><span class="line">    using Base::releaseBuffer;</span><br><span class="line">#if ASAN_ENABLED</span><br><span class="line">    using Base::endOfBuffer;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h4><p>HashTable 实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">    template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span><br><span class="line">    class HashTable &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;</span><br><span class="line">        typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;</span><br><span class="line">        typedef Traits ValueTraits;</span><br><span class="line">        typedef Key KeyType;</span><br><span class="line">        typedef Value ValueType;</span><br><span class="line">        typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;</span><br><span class="line">        typedef HashTableAddResult&lt;iterator&gt; AddResult;</span><br><span class="line"></span><br><span class="line">#if DUMP_HASHTABLE_STATS_PER_TABLE</span><br><span class="line">        struct Stats &#123;</span><br><span class="line">            Stats()</span><br><span class="line">                : numAccesses(0)</span><br><span class="line">                , numRehashes(0)</span><br><span class="line">                , numRemoves(0)</span><br><span class="line">                , numReinserts(0)</span><br><span class="line">                , maxCollisions(0)</span><br><span class="line">                , numCollisions(0)</span><br><span class="line">                , collisionGraph()</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            unsigned numAccesses;</span><br><span class="line">            unsigned numRehashes;</span><br><span class="line">            unsigned numRemoves;</span><br><span class="line">            unsigned numReinserts;</span><br><span class="line"></span><br><span class="line">            unsigned maxCollisions;</span><br><span class="line">            unsigned numCollisions;</span><br><span class="line">            unsigned collisionGraph[4096];</span><br><span class="line"></span><br><span class="line">            void recordCollisionAtCount(unsigned count)</span><br><span class="line">            &#123;</span><br><span class="line">                if (count &gt; maxCollisions)</span><br><span class="line">                    maxCollisions = count;</span><br><span class="line">                numCollisions++;</span><br><span class="line">                collisionGraph[count]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            void dumpStats()</span><br><span class="line">            &#123;</span><br><span class="line">                dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);</span><br><span class="line">                dataLogF(&quot;%d accesses\n&quot;, numAccesses);</span><br><span class="line">                dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses);</span><br><span class="line">                dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);</span><br><span class="line">                for (unsigned i = 1; i &lt;= maxCollisions; i++) &#123;</span><br><span class="line">                    dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses);</span><br><span class="line">                &#125;</span><br><span class="line">                dataLogF(&quot;%d rehashes\n&quot;, numRehashes);</span><br><span class="line">                dataLogF(&quot;%d reinserts\n&quot;, numReinserts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        HashTable();</span><br><span class="line">        ~HashTable() </span><br><span class="line">        &#123;</span><br><span class="line">            invalidateIterators(); </span><br><span class="line">            if (m_table)</span><br><span class="line">                deallocateTable(m_table, m_tableSize);</span><br><span class="line">#if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION</span><br><span class="line">            m_table = (ValueType*)(uintptr_t)0xbbadbeef;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashTable(const HashTable&amp;);</span><br><span class="line">        void swap(HashTable&amp;);</span><br><span class="line">        HashTable&amp; operator=(const HashTable&amp;);</span><br><span class="line"></span><br><span class="line">        HashTable(HashTable&amp;&amp;);</span><br><span class="line">        HashTable&amp; operator=(HashTable&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        // When the hash table is empty, just return the same iterator for end as for begin.</span><br><span class="line">        // This is more efficient because we don&apos;t have to skip all the empty and deleted</span><br><span class="line">        // buckets, and iterating an empty table is a common case that&apos;s worth optimizing.</span><br><span class="line">        iterator begin() &#123; return isEmpty() ? end() : makeIterator(m_table); &#125;</span><br><span class="line">        iterator end() &#123; return makeKnownGoodIterator(m_table + m_tableSize); &#125;</span><br><span class="line">        const_iterator begin() const &#123; return isEmpty() ? end() : makeConstIterator(m_table); &#125;</span><br><span class="line">        const_iterator end() const &#123; return makeKnownGoodConstIterator(m_table + m_tableSize); &#125;</span><br><span class="line"></span><br><span class="line">        unsigned size() const &#123; return m_keyCount; &#125;</span><br><span class="line">        unsigned capacity() const &#123; return m_tableSize; &#125;</span><br><span class="line">        bool isEmpty() const &#123; return !m_keyCount; &#125;</span><br><span class="line"></span><br><span class="line">        AddResult add(const ValueType&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); &#125;</span><br><span class="line">        AddResult add(ValueType&amp;&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); &#125;</span><br><span class="line"></span><br><span class="line">        // A special version of add() that finds the object by hashing and comparing</span><br><span class="line">        // with some other type, to avoid the cost of type conversion if the object is already</span><br><span class="line">        // in the table.</span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        iterator find(const KeyType&amp; key) &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        const_iterator find(const KeyType&amp; key) const &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        bool contains(const KeyType&amp; key) const &#123; return contains&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;</span><br><span class="line"></span><br><span class="line">        void remove(const KeyType&amp;);</span><br><span class="line">        void remove(iterator);</span><br><span class="line">        void removeWithoutEntryConsistencyCheck(iterator);</span><br><span class="line">        void removeWithoutEntryConsistencyCheck(const_iterator);</span><br><span class="line">        template&lt;typename Functor&gt;</span><br><span class="line">        void removeIf(const Functor&amp;);</span><br><span class="line">        void clear();</span><br><span class="line"></span><br><span class="line">        static bool isEmptyBucket(const ValueType&amp; value) &#123; return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); &#125;</span><br><span class="line">        static bool isDeletedBucket(const ValueType&amp; value) &#123; return KeyTraits::isDeletedValue(Extractor::extract(value)); &#125;</span><br><span class="line">        static bool isEmptyOrDeletedBucket(const ValueType&amp; value) &#123; return isEmptyBucket(value) || isDeletedBucket(value); &#125;</span><br><span class="line"></span><br><span class="line">        ValueType* lookup(const Key&amp; key) &#123; return lookup&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">        void checkTableConsistency() const;</span><br><span class="line">#else</span><br><span class="line">        static void checkTableConsistency() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line">#if CHECK_HASHTABLE_CONSISTENCY</span><br><span class="line">        void internalCheckTableConsistency() const &#123; checkTableConsistency(); &#125;</span><br><span class="line">        void internalCheckTableConsistencyExceptSize() const &#123; checkTableConsistencyExceptSize(); &#125;</span><br><span class="line">#else</span><br><span class="line">        static void internalCheckTableConsistencyExceptSize() &#123; &#125;</span><br><span class="line">        static void internalCheckTableConsistency() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        static ValueType* allocateTable(unsigned size);</span><br><span class="line">        static void deallocateTable(ValueType* table, unsigned size);</span><br><span class="line"></span><br><span class="line">        typedef std::pair&lt;ValueType*, bool&gt; LookupType;</span><br><span class="line">        typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;</span><br><span class="line"></span><br><span class="line">        LookupType lookupForWriting(const Key&amp; key) &#123; return lookupForWriting&lt;IdentityTranslatorType&gt;(key); &#125;;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);</span><br><span class="line"></span><br><span class="line">        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);</span><br><span class="line">        void removeAndInvalidate(ValueType*);</span><br><span class="line">        void remove(ValueType*);</span><br><span class="line"></span><br><span class="line">        bool shouldExpand() const &#123; return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; &#125;</span><br><span class="line">        bool mustRehashInPlace() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize * 2; &#125;</span><br><span class="line">        bool shouldShrink() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; &#125;</span><br><span class="line">        ValueType* expand(ValueType* entry = nullptr);</span><br><span class="line">        void shrink() &#123; rehash(m_tableSize / 2, nullptr); &#125;</span><br><span class="line"></span><br><span class="line">        ValueType* rehash(unsigned newTableSize, ValueType* entry);</span><br><span class="line">        ValueType* reinsert(ValueType&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        static void initializeBucket(ValueType&amp; bucket);</span><br><span class="line">        static void deleteBucket(ValueType&amp; bucket) &#123; hashTraitsDeleteBucket&lt;Traits&gt;(bucket); &#125;</span><br><span class="line"></span><br><span class="line">        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)</span><br><span class="line">            &#123; return FullLookupType(LookupType(position, found), hash); &#125;</span><br><span class="line"></span><br><span class="line">        iterator makeIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize); &#125;</span><br><span class="line">        const_iterator makeConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize); &#125;</span><br><span class="line">        iterator makeKnownGoodIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</span><br><span class="line">        const_iterator makeKnownGoodConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">        void checkTableConsistencyExceptSize() const;</span><br><span class="line">#else</span><br><span class="line">        static void checkTableConsistencyExceptSize() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if CHECK_HASHTABLE_ITERATORS</span><br><span class="line">        void invalidateIterators();</span><br><span class="line">#else</span><br><span class="line">        static void invalidateIterators() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        static const unsigned m_maxLoad = 2;</span><br><span class="line">        static const unsigned m_minLoad = 6;</span><br><span class="line"></span><br><span class="line">        ValueType* m_table;</span><br><span class="line">        unsigned m_tableSize;</span><br><span class="line">        unsigned m_tableSizeMask;</span><br><span class="line">        unsigned m_keyCount;</span><br><span class="line">        unsigned m_deletedCount;</span><br><span class="line"></span><br><span class="line">#if CHECK_HASHTABLE_ITERATORS</span><br><span class="line">    public:</span><br><span class="line">        // All access to m_iterators should be guarded with m_mutex.</span><br><span class="line">        mutable const_iterator* m_iterators;</span><br><span class="line">        // Use std::unique_ptr so HashTable can still be memmove&apos;d or memcpy&apos;ed.</span><br><span class="line">        mutable std::unique_ptr&lt;Lock&gt; m_mutex;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if DUMP_HASHTABLE_STATS_PER_TABLE</span><br><span class="line">    public:</span><br><span class="line">        mutable std::unique_ptr&lt;Stats&gt; m_stats;</span><br><span class="line">#endif</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>完整具体的实现可以查看 WTF/Source/wtf/HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF/Source/wtf/MessageQueue.h 里有对消息队列的定义：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">// The queue takes ownership of messages and transfer it to the new owner</span><br><span class="line">// when messages are fetched from the queue.</span><br><span class="line">// Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.</span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">class MessageQueue &#123;</span><br><span class="line">    WTF_MAKE_NONCOPYABLE(MessageQueue);</span><br><span class="line">public:</span><br><span class="line">    MessageQueue() : m_killed(false) &#123; &#125;</span><br><span class="line">    ~MessageQueue();</span><br><span class="line"></span><br><span class="line">    void append(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    void appendAndKill(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    bool appendAndCheckEmpty(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    void prepend(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;DataType&gt; waitForMessage();</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; tryGetMessage();</span><br><span class="line">    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; takeAllMessages();</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; tryGetMessageIgnoringKilled();</span><br><span class="line">    template&lt;typename Predicate&gt;</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime);</span><br><span class="line"></span><br><span class="line">    template&lt;typename Predicate&gt;</span><br><span class="line">    void removeIf(Predicate&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    void kill();</span><br><span class="line">    bool killed() const;</span><br><span class="line"></span><br><span class="line">    // The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time.</span><br><span class="line">    bool isEmpty();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装</span><br><span class="line">    mutable Lock m_mutex;</span><br><span class="line">    </span><br><span class="line">    //Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程</span><br><span class="line">    Condition m_condition;</span><br><span class="line">    </span><br><span class="line">    //内部主要存储结构</span><br><span class="line">    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; m_queue;</span><br><span class="line">    bool m_killed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I/O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore/platform/network 里。如果是 iOS 就在 WebCore/platform/network/iOS 里，如果 Mac 就在 WebCore/platform/network/mac 里。</p>
<h3 id="Loader-的资源"><a href="#Loader-的资源" class="headerlink" title="Loader 的资源"></a>Loader 的资源</h3><p>网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型：</p>
<ul>
<li>HTML：页面主文件</li>
<li>JavaScript：单独的文件后者直接在 HTML 代码里</li>
<li>CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里</li>
<li>图片：各种编码图片比如 jpg 和 png</li>
<li>SVG：矢量图片</li>
<li>CSS Shader：为 CSS 带来 3D 图形特性</li>
<li>音频视频：多媒体资源以及视频字幕</li>
<li>字体：自定义的字体</li>
<li>XSL：对 XSLT 语言编写的文件支持</li>
</ul>
<p>WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/50.png" alt="50"></p>
<h3 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h3><p>加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/07.png" alt="07"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/39.png" alt="39"></p>
<ul>
<li>MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。</li>
<li>CacheResourceLoader：缓存资源读取。</li>
<li>资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。</li>
<li>DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。</li>
</ul>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/08.png" alt="08"></p>
<p>解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。</p>
<p>这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。</p>
<p>整个资源加载过程，这篇文章有详细的介绍：<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/</a></p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/30.png" alt="30"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/77.png" alt="77"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/78.png" alt="78"></p>
<ul>
<li>Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。</li>
<li>SubFrameLoader：维护子 Frame。</li>
<li>DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。</li>
<li>DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。</li>
<li>HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。</li>
<li>ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。</li>
<li>SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。</li>
<li>FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。</li>
<li>PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。</li>
</ul>
<h3 id="FrameLoader-的主要接口"><a href="#FrameLoader-的主要接口" class="headerlink" title="FrameLoader 的主要接口"></a>FrameLoader 的主要接口</h3><h4 id="Frame-init"><a href="#Frame-init" class="headerlink" title="Frame::init"></a>Frame::init</h4><p>FrameLoader 自身的初始化。<br>初始化的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)</span><br><span class="line">WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)</span><br><span class="line">Frame::init()</span><br><span class="line">FrameLoader::init()</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-commitProvisionalLoad"><a href="#FrameLoader-commitProvisionalLoad" class="headerlink" title="FrameLoader::commitProvisionalLoad"></a>FrameLoader::commitProvisionalLoad</h4><p>提交 provisional 阶段时下载的数据<br>完成 Document loading 的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DocumentLoader::finishLoading</span><br><span class="line">DocumentLoader::commitIfReady</span><br><span class="line">FrameLoader::commitProvisionalLoad</span><br></pre></td></tr></table></figure>

<p>资源数据接受提交调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader::didReceiveData</span><br><span class="line">MainResourceLoader::addData</span><br><span class="line">DocumentLoader::receiveData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">DocumentLoader::commitIfReady</span><br><span class="line">DocumentLoader::commitProvisionalLoad</span><br></pre></td></tr></table></figure>

<h4 id="Frame-finishedLoading"><a href="#Frame-finishedLoading" class="headerlink" title="Frame::finishedLoading"></a>Frame::finishedLoading</h4><p>网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。<br>函数的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader::didFinishLoading</span><br><span class="line">MainResourceLoader::didFinishLoading</span><br><span class="line">FrameLoader::finishedLoading</span><br><span class="line">FrameLoader::init()</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-finishedParsing"><a href="#FrameLoader-finishedParsing" class="headerlink" title="FrameLoader::finishedParsing"></a>FrameLoader::finishedParsing</h4><p>完成解析时调用的接口<br>调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DocumentWritter::end</span><br><span class="line">Document::finishParsing</span><br><span class="line">Document::finishedParsing</span><br><span class="line">FrameLoader::finishedParsing</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-load-FrameLoadRequest-amp-amp-request"><a href="#FrameLoader-load-FrameLoadRequest-amp-amp-request" class="headerlink" title="FrameLoader::load(FrameLoadRequest&amp;&amp; request)"></a>FrameLoader::load(FrameLoadRequest&amp;&amp; request)</h4><p>加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">//创建 DocumentLoader</span><br><span class="line">void FrameLoader::load(FrameLoadRequest&amp;&amp; request)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_inStopAllLoaders)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!request.frameName().isEmpty()) &#123;</span><br><span class="line">        Frame* frame = findFrameForNavigation(request.frameName());</span><br><span class="line">        if (frame) &#123;</span><br><span class="line">            request.setShouldCheckNewWindowPolicy(false);</span><br><span class="line">            if (&amp;frame-&gt;loader() != this) &#123;</span><br><span class="line">                frame-&gt;loader().load(WTFMove(request));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (request.shouldCheckNewWindowPolicy()) &#123;</span><br><span class="line">        NavigationAction action &#123; request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() &#125;;</span><br><span class="line">        policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), nullptr, request.frameName(), [this] (const ResourceRequest&amp; request, FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, bool shouldContinue) &#123;</span><br><span class="line">            continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!request.hasSubstituteData())</span><br><span class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</span><br><span class="line">    //FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。</span><br><span class="line">    Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());</span><br><span class="line">    applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);</span><br><span class="line"></span><br><span class="line">    load(loader.ptr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//完善 request 信息</span><br><span class="line">void FrameLoader::load(DocumentLoader* newDocumentLoader)</span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest&amp; r = newDocumentLoader-&gt;request();</span><br><span class="line">    //ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。</span><br><span class="line">    addExtraFieldsToMainResourceRequest(r);</span><br><span class="line">    FrameLoadType type;</span><br><span class="line"></span><br><span class="line">    if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) &#123;</span><br><span class="line">        r.setCachePolicy(ReloadIgnoringCacheData);</span><br><span class="line">        type = FrameLoadType::Same;</span><br><span class="line">    &#125; else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType == FrameLoadType::Reload)</span><br><span class="line">        type = FrameLoadType::Reload;</span><br><span class="line">    else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid())</span><br><span class="line">        type = FrameLoadType::RedirectWithLockedBackForwardList;</span><br><span class="line">    else</span><br><span class="line">        type = FrameLoadType::Standard;</span><br><span class="line"></span><br><span class="line">    if (m_documentLoader)</span><br><span class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</span><br><span class="line">    </span><br><span class="line">    if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</span><br><span class="line">        history().saveDocumentAndScrollState();</span><br><span class="line">        ASSERT(type == FrameLoadType::Standard);</span><br><span class="line">        type = FrameLoadType::Reload;</span><br><span class="line">    &#125;</span><br><span class="line">    loadWithDocumentLoader(newDocumentLoader, type, 0, AllowNavigationToInvalidURL::Yes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//校验检查</span><br><span class="line">void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</span><br><span class="line">&#123;</span><br><span class="line">    // Retain because dispatchBeforeLoadEvent may release the last reference to it.</span><br><span class="line">    Ref&lt;Frame&gt; protect(m_frame);</span><br><span class="line"></span><br><span class="line">    ASSERT(m_client.hasWebView());</span><br><span class="line">    ASSERT(m_frame.view());</span><br><span class="line"></span><br><span class="line">    if (!isNavigationAllowed())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (m_frame.document())</span><br><span class="line">        m_previousURL = m_frame.document()-&gt;url();</span><br><span class="line"></span><br><span class="line">    const URL&amp; newURL = loader-&gt;request().url();</span><br><span class="line">    // Log main frame navigation types.</span><br><span class="line">    if (m_frame.isMainFrame()) &#123;</span><br><span class="line">        if (auto* page = m_frame.page())</span><br><span class="line">            page-&gt;mainFrameLoadStarted(newURL, type);</span><br><span class="line">static_cast&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyChecker().setLoadType(type);</span><br><span class="line">    bool isFormSubmission = formState;</span><br><span class="line"></span><br><span class="line">    const String&amp; httpMethod = loader-&gt;request().httpMethod();</span><br><span class="line"></span><br><span class="line">    if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) &#123;</span><br><span class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</span><br><span class="line">        NavigationAction action &#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;;</span><br><span class="line"></span><br><span class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</span><br><span class="line">        oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());</span><br><span class="line">        policyChecker().stopCheck();</span><br><span class="line">        policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, oldDocumentLoader.get(), formState, [this] (const ResourceRequest&amp; request, FormState*, bool shouldContinue) &#123;</span><br><span class="line">            continueFragmentScrollAfterNavigationPolicy(request, shouldContinue);</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Frame* parent = m_frame.tree().parent())</span><br><span class="line">        loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());</span><br><span class="line"></span><br><span class="line">    policyChecker().stopCheck();</span><br><span class="line">    </span><br><span class="line">    //把 DocumentLoader 赋给 m_policyDocumentLoader</span><br><span class="line">    setPolicyDocumentLoader(loader);</span><br><span class="line">    </span><br><span class="line">    //将请求信息记在 loader.m_triggeringAction 中</span><br><span class="line">    if (loader-&gt;triggeringAction().isEmpty())</span><br><span class="line">        loader-&gt;setTriggeringAction(&#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;);</span><br><span class="line"></span><br><span class="line">    if (Element* ownerElement = m_frame.ownerElement()) &#123;</span><br><span class="line">        if (!m_stateMachine.committedFirstRealDocumentLoad()</span><br><span class="line">            &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) &#123;</span><br><span class="line">            continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false, allowNavigationToInvalidURL);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求</span><br><span class="line">    policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, loader, formState, [this, allowNavigationToInvalidURL] (const ResourceRequest&amp; request, FormState* formState, bool shouldContinue) &#123;</span><br><span class="line">        //shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。</span><br><span class="line">        continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, bool shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</span><br><span class="line">&#123;</span><br><span class="line">    // If we loaded an alternate page to replace an unreachableURL, we&apos;ll get in here with a</span><br><span class="line">    // nil policyDataSource because loading the alternate page will have passed</span><br><span class="line">    // through this method already, nested; otherwise, policyDataSource should still be set.</span><br><span class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</span><br><span class="line"></span><br><span class="line">    bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;</span><br><span class="line"></span><br><span class="line">    bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();</span><br><span class="line"></span><br><span class="line">    // Three reasons we can&apos;t continue:</span><br><span class="line">    //    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this </span><br><span class="line">    //       is the user responding Cancel to the form repost nag sheet.</span><br><span class="line">    //    2) User responded Cancel to an alert popped up by the before unload event handler.</span><br><span class="line">    //    3) The request&apos;s URL is invalid and navigation to invalid URLs is disallowed.</span><br><span class="line">    bool canContinue = shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;</span><br><span class="line"></span><br><span class="line">    if (!canContinue) &#123;</span><br><span class="line">        // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we </span><br><span class="line">        // need to report that the client redirect was cancelled.</span><br><span class="line">        // FIXME: The client should be told about ignored non-quick redirects, too.</span><br><span class="line">        if (m_quickRedirectComing)</span><br><span class="line">            clientRedirectCancelledOrFinished(false);</span><br><span class="line"></span><br><span class="line">        setPolicyDocumentLoader(nullptr);</span><br><span class="line"></span><br><span class="line">        // If the navigation request came from the back/forward menu, and we punt on it, we have the </span><br><span class="line">        // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,</span><br><span class="line">        // we only do this when punting a navigation for the target frame or top-level frame.  </span><br><span class="line">        if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) &#123;</span><br><span class="line">            if (Page* page = m_frame.page()) &#123;</span><br><span class="line">                if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem()) &#123;</span><br><span class="line">                    page-&gt;backForward().setCurrentItem(resetItem);</span><br><span class="line">                    m_frame.loader().client().updateGlobalHistoryItemForPage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FrameLoadType type = policyChecker().loadType();</span><br><span class="line">    // A new navigation is in progress, so don&apos;t clear the history&apos;s provisional item.</span><br><span class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</span><br><span class="line">    </span><br><span class="line">    // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</span><br><span class="line">    // might detach the current FrameLoader, in which case we should bail on this newly defunct load. </span><br><span class="line">    if (!m_frame.page())</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //把 DocumentLoader 赋值给 m_provisionalDocumentLoader</span><br><span class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</span><br><span class="line">    m_loadType = type;</span><br><span class="line">    //设置 FrameLoader 状态为 Provisional</span><br><span class="line">    setState(FrameStateProvisional);</span><br><span class="line"></span><br><span class="line">    setPolicyDocumentLoader(nullptr);</span><br><span class="line"></span><br><span class="line">    if (isBackForwardLoadType(type)) &#123;</span><br><span class="line">        auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();</span><br><span class="line">        if (history().provisionalItem()-&gt;isInPageCache()) &#123;</span><br><span class="line">            diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</span><br><span class="line">            loadProvisionalItemFromCachedPage();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!formState) &#123;</span><br><span class="line">        continueLoadAfterWillSubmitForm();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_client.dispatchWillSubmitForm(*formState, [this] (PolicyAction action) &#123;</span><br><span class="line">        policyChecker().continueLoadAfterWillSubmitForm(action);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。</p>
<h3 id="WebKit-网络处理"><a href="#WebKit-网络处理" class="headerlink" title="WebKit 网络处理"></a>WebKit 网络处理</h3><p>WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore/platform/network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。</p>
<h3 id="ResourceHandle-的相关类"><a href="#ResourceHandle-的相关类" class="headerlink" title="ResourceHandle 的相关类"></a>ResourceHandle 的相关类</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/31.png" alt="31"></p>
<ul>
<li>ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。</li>
<li>MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存</li>
<li>SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。</li>
<li>ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。</li>
</ul>
<h3 id="ResourceHandleClient"><a href="#ResourceHandleClient" class="headerlink" title="ResourceHandleClient"></a>ResourceHandleClient</h3><p>ResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class ResourceHandleClient &#123;</span><br><span class="line">public:</span><br><span class="line">    WEBCORE_EXPORT ResourceHandleClient();</span><br><span class="line">    WEBCORE_EXPORT virtual ~ResourceHandleClient();</span><br><span class="line"></span><br><span class="line">    WEBCORE_EXPORT virtual ResourceRequest willSendRequest(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);</span><br><span class="line">    virtual void didSendData(ResourceHandle*, unsigned long long /*bytesSent*/, unsigned long long /*totalBytesToBeSent*/) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功</span><br><span class="line">    virtual void didReceiveResponse(ResourceHandle*, ResourceResponse&amp;&amp;) &#123; &#125;</span><br><span class="line">    //收到服务器端包含请求数据的响应包</span><br><span class="line">    virtual void didReceiveData(ResourceHandle*, const char*, unsigned, int /*encodedDataLength*/) &#123; &#125;</span><br><span class="line">    WEBCORE_EXPORT virtual void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength);</span><br><span class="line">    //接受过程结束</span><br><span class="line">    virtual void didFinishLoading(ResourceHandle*) &#123; &#125;</span><br><span class="line">    //接受失败</span><br><span class="line">    virtual void didFail(ResourceHandle*, const ResourceError&amp;) &#123; &#125;</span><br><span class="line">    virtual void wasBlocked(ResourceHandle*) &#123; &#125;</span><br><span class="line">    virtual void cannotShowURL(ResourceHandle*) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool usesAsyncCallbacks() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool loadingSynchronousXHR() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    // Client will call ResourceHandle::continueDidReceiveResponse() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;);</span><br><span class="line"></span><br><span class="line">#if USE(PROTECTION_SPACE_AUTH_CALLBACK)</span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp;);</span><br><span class="line">#endif</span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.</span><br><span class="line">#if USE(CFURLCONNECTION)</span><br><span class="line">    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, CFCachedURLResponseRef);</span><br><span class="line">#elif PLATFORM(COCOA)</span><br><span class="line">    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse *);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE(SOUP)</span><br><span class="line">    virtual char* getOrCreateReadBuffer(size_t /*requestedLength*/, size_t&amp; /*actualLength*/) &#123; return 0; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    virtual bool shouldUseCredentialStorage(ResourceHandle*) &#123; return false; &#125;</span><br><span class="line">    virtual void didReceiveAuthenticationChallenge(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;</span><br><span class="line">#if USE(PROTECTION_SPACE_AUTH_CALLBACK)</span><br><span class="line">    virtual bool canAuthenticateAgainstProtectionSpace(ResourceHandle*, const ProtectionSpace&amp;) &#123; return false; &#125;</span><br><span class="line">#endif</span><br><span class="line">    virtual void receivedCancellation(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS) || USE(CFURLCONNECTION)</span><br><span class="line">    virtual RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) &#123; return nullptr; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE(CFURLCONNECTION)</span><br><span class="line">    virtual CFCachedURLResponseRef willCacheResponse(ResourceHandle*, CFCachedURLResponseRef response) &#123; return response; &#125;</span><br><span class="line">#if PLATFORM(WIN)</span><br><span class="line">    virtual bool shouldCacheResponse(ResourceHandle*, CFCachedURLResponseRef) &#123; return true; &#125;</span><br><span class="line">#endif // PLATFORM(WIN)</span><br><span class="line"></span><br><span class="line">#elif PLATFORM(COCOA)</span><br><span class="line">    virtual NSCachedURLResponse *willCacheResponse(ResourceHandle*, NSCachedURLResponse *response) &#123; return response; &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与 ResourceHandleClient 相关的类如下<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/80.png" alt="80"></p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/98.png" alt="98"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/32.png" alt="32"></p>
<h4 id="MainResourceLoader-的加载顺序"><a href="#MainResourceLoader-的加载顺序" class="headerlink" title="MainResourceLoader 的加载顺序"></a>MainResourceLoader 的加载顺序</h4><p>MainResourceLoader 加载的是 html 文本资源。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/79.png" alt="79"></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">MainResourceLoader::load</span><br><span class="line">MainResourceLoader::loadNow</span><br><span class="line">MainResourceLoader::willSendRequest</span><br><span class="line">ResourceLoader::willSendRequest //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。</span><br><span class="line">PolicyChecker::checkNavigationPolicy //检查 NavigationPolicy 可以过滤一些重复的请求</span><br><span class="line">ResourceHandle::create 开始发网络请求</span><br><span class="line">MainResourceLoader::didReceiveResponse //主资源收到第一个 HTTP 的响应回调，处理 HTTP header</span><br><span class="line">PolicyChecker:: checkContentPolicy //进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求</span><br><span class="line">MainResourceLoader::continueAfterContentPolicy //看看 ContentPolicy 检查后是否有错误</span><br><span class="line">ResourceLoader::didReceiveResponse //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span><br><span class="line">MainResourceLoader::didReceiveData //主资源开始接受 body 数据</span><br><span class="line">ResourceLoader::didReceiveData //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span><br><span class="line">MainResourceLoader::addData</span><br><span class="line">DocumentLoader::receivedData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">FrameLoader::commitProvisionalLoad //从 provisional 状态到 Committed 状态</span><br><span class="line">FrameLoaderClientQt::committedLoad</span><br><span class="line">DocumentLoader::commitData</span><br><span class="line">DocumentWriter::setEncoding</span><br><span class="line">DocumentWriter::addData</span><br><span class="line">DocumentParser::appendByte</span><br><span class="line">DecodedDataDocumentParser::appendBytes //编码处理</span><br><span class="line">HTMLDocumentParser::append //解析 HTML</span><br><span class="line">MainResourceLoader::didFinishLoading</span><br><span class="line">FrameLoader::finishedLoading</span><br><span class="line">DocumentLoader::finishedLoading</span><br><span class="line">FrameLoader::finishedLoadingDocument</span><br><span class="line">DocumentWriter::end</span><br><span class="line">Document::finishParsing</span><br><span class="line">HTMLDocumentParser::finish</span><br></pre></td></tr></table></figure>

<p>在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。</p>
<p>在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void ResourceLoader::addDataOrBuffer(const char* data, unsigned length, SharedBuffer* buffer, DataPayloadType dataPayloadType)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_options.dataBufferingPolicy == DoNotBufferData)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!m_resourceData || dataPayloadType == DataPayloadWholeResource) &#123;</span><br><span class="line">        if (buffer)</span><br><span class="line">            m_resourceData = buffer;</span><br><span class="line">        else</span><br><span class="line">            m_resourceData = SharedBuffer::create(data, length);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (buffer)</span><br><span class="line">        m_resourceData-&gt;append(*buffer);</span><br><span class="line">    else</span><br><span class="line">        m_resourceData-&gt;append(data, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DocumentLoader::commitLoad(const char* data, int length)</span><br><span class="line">&#123;</span><br><span class="line">    // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource</span><br><span class="line">    // by starting a new load, so retain temporarily.</span><br><span class="line">    RefPtr&lt;Frame&gt; protectedFrame(m_frame);</span><br><span class="line">    Ref&lt;DocumentLoader&gt; protectedThis(*this);</span><br><span class="line"></span><br><span class="line">    commitIfReady();</span><br><span class="line">    FrameLoader* frameLoader = DocumentLoader::frameLoader();</span><br><span class="line">    if (!frameLoader)</span><br><span class="line">        return;</span><br><span class="line">#if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)</span><br><span class="line">    if (ArchiveFactory::isArchiveMimeType(response().mimeType()))</span><br><span class="line">        return;</span><br><span class="line">#endif</span><br><span class="line">    //FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态</span><br><span class="line">    frameLoader-&gt;client().committedLoad(this, data, length);</span><br><span class="line"></span><br><span class="line">    if (isMultipartReplacingLoad())</span><br><span class="line">        frameLoader-&gt;client().didReplaceMultipartContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DocumentWriter::begin(const URL&amp; urlReference, bool dispatch, Document* ownerDocument)</span><br><span class="line">&#123;</span><br><span class="line">    // We grab a local copy of the URL because it&apos;s easy for callers to supply</span><br><span class="line">    // a URL that will be deallocated during the execution of this function.</span><br><span class="line">    // For example, see &lt;https://bugs.webkit.org/show_bug.cgi?id=66360&gt;.</span><br><span class="line">    URL url = urlReference;</span><br><span class="line"></span><br><span class="line">    // Create a new document before clearing the frame, because it may need to</span><br><span class="line">    // inherit an aliased security context.</span><br><span class="line">    //创建了 Document 对象</span><br><span class="line">    Ref&lt;Document&gt; document = createDocument(url);</span><br><span class="line">    </span><br><span class="line">    // If the new document is for a Plugin but we&apos;re supposed to be sandboxed from Plugins,</span><br><span class="line">    // then replace the document with one whose parser will ignore the incoming data (bug 39323)</span><br><span class="line">    if (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins))</span><br><span class="line">        document = SinkDocument::create(m_frame, url);</span><br><span class="line"></span><br><span class="line">    // FIXME: Do we need to consult the content security policy here about blocked plug-ins?</span><br><span class="line"></span><br><span class="line">    bool shouldReuseDefaultView = m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url);</span><br><span class="line">    if (shouldReuseDefaultView)</span><br><span class="line">        document-&gt;takeDOMWindowFrom(m_frame-&gt;document());</span><br><span class="line">    else</span><br><span class="line">        document-&gt;createDOMWindow();</span><br><span class="line"></span><br><span class="line">    // Per &lt;https://www.w3.org/TR/upgrade-insecure-requests/&gt;, we need to retain an ongoing set of upgraded</span><br><span class="line">    // requests in new navigation contexts. Although this information is present when we construct the</span><br><span class="line">    // Document object, it is discard in the subsequent &apos;clear&apos; statements below. So, we must capture it</span><br><span class="line">    // so we can restore it.</span><br><span class="line">    HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade;</span><br><span class="line">    if (auto* existingDocument = m_frame-&gt;document())</span><br><span class="line">        insecureNavigationRequestsToUpgrade = existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade();</span><br><span class="line">    </span><br><span class="line">    m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView);</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    // m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document.</span><br><span class="line">    // Bail out if document has no view.</span><br><span class="line">    if (!document-&gt;view())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!shouldReuseDefaultView)</span><br><span class="line">        m_frame-&gt;script().updatePlatformScriptObjects();</span><br><span class="line"></span><br><span class="line">    m_frame-&gt;loader().setOutgoingReferrer(url);</span><br><span class="line">    m_frame-&gt;setDocument(document.copyRef());</span><br><span class="line"></span><br><span class="line">    document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade));</span><br><span class="line"></span><br><span class="line">    if (m_decoder)</span><br><span class="line">        document-&gt;setDecoder(m_decoder.get());</span><br><span class="line">    if (ownerDocument) &#123;</span><br><span class="line">        document-&gt;setCookieURL(ownerDocument-&gt;cookieURL());</span><br><span class="line">        document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy());</span><br><span class="line">        document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_frame-&gt;loader().didBeginDocument(dispatch);</span><br><span class="line"></span><br><span class="line">    document-&gt;implicitOpen();</span><br><span class="line"></span><br><span class="line">    // We grab a reference to the parser so that we&apos;ll always send data to the</span><br><span class="line">    // original parser, even if the document acquires a new parser (e.g., via</span><br><span class="line">    // document.open).</span><br><span class="line">    m_parser = document-&gt;parser();</span><br><span class="line"></span><br><span class="line">    if (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView())</span><br><span class="line">        m_frame-&gt;view()-&gt;setContentsSize(IntSize());</span><br><span class="line"></span><br><span class="line">    m_state = StartedWritingState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, const char* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    if (!length)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。</span><br><span class="line">    String decoded = writer.createDecoderIfNeeded()-&gt;decode(data, length);</span><br><span class="line">    if (decoded.isEmpty())</span><br><span class="line">        return;</span><br><span class="line">    //解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步</span><br><span class="line">    writer.reportDataReceived();</span><br><span class="line">    append(decoded.releaseImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。</p>
<p>下面看看解码的流程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/85.png" alt="85"><br>decoder 的类图如下:<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/86.png" alt="86"></p>
<h4 id="SubResourceLoader-的加载顺序"><a href="#SubResourceLoader-的加载顺序" class="headerlink" title="SubResourceLoader 的加载顺序"></a>SubResourceLoader 的加载顺序</h4><p>SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/81.png" alt="81"></p>
<p>会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)</span><br><span class="line">&#123;</span><br><span class="line">    auto&amp; localName = token.name();</span><br><span class="line">    // FIXME: This can&apos;t use HTMLConstructionSite::createElement because we</span><br><span class="line">    // have to pass the current form element.  We should rework form association</span><br><span class="line">    // to occur after construction to allow better code sharing here.</span><br><span class="line">    // https://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token</span><br><span class="line">    Document&amp; ownerDocument = ownerDocumentForCurrentNode();</span><br><span class="line">    bool insideTemplateElement = !ownerDocument.frame();</span><br><span class="line">    //将 tagName 和节点构造创建成 HTMLImageElement</span><br><span class="line">    RefPtr&lt;Element&gt; element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);</span><br><span class="line">    if (UNLIKELY(!element)) &#123;</span><br><span class="line">        auto* window = ownerDocument.domWindow();</span><br><span class="line">        if (customElementInterface &amp;&amp; window) &#123;</span><br><span class="line">            auto* registry = window-&gt;customElementRegistry();</span><br><span class="line">            if (UNLIKELY(registry)) &#123;</span><br><span class="line">                if (auto* elementInterface = registry-&gt;findInterface(localName)) &#123;</span><br><span class="line">                    *customElementInterface = elementInterface;</span><br><span class="line">                    return nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI);</span><br><span class="line">        if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) &#123;</span><br><span class="line">            element = HTMLElement::create(qualifiedName, ownerDocument);</span><br><span class="line">            element-&gt;setIsCustomElementUpgradeCandidate();</span><br><span class="line">        &#125; else</span><br><span class="line">            element = HTMLUnknownElement::create(qualifiedName, ownerDocument);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(element);</span><br><span class="line"></span><br><span class="line">    // FIXME: This is a hack to connect images to pictures before the image has</span><br><span class="line">    // been inserted into the document. It can be removed once asynchronous image</span><br><span class="line">    // loading is working.</span><br><span class="line">    if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))</span><br><span class="line">        downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));</span><br><span class="line">    //设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载</span><br><span class="line">    setAttributes(*element, token, m_parserContentPolicy);</span><br><span class="line">    ASSERT(element-&gt;isHTMLElement());</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void HTMLImageElement::selectImageSource()</span><br><span class="line">&#123;</span><br><span class="line">    // First look for the best fit source from our &lt;picture&gt; parent if we have one.</span><br><span class="line">    ImageCandidate candidate = bestFitSourceFromPictureElement();</span><br><span class="line">    if (candidate.isEmpty()) &#123;</span><br><span class="line">        // If we don&apos;t have a &lt;picture&gt; or didn&apos;t find a source, then we use our own attributes.</span><br><span class="line">        auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();</span><br><span class="line">        candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);</span><br><span class="line">    &#125;</span><br><span class="line">    setBestFitURLAndDPRFromImageCandidate(candidate);</span><br><span class="line">    //updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源</span><br><span class="line">    m_imageLoader.updateFromElementIgnoringPreviousError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/33.png" alt="33"></p>
<p>ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/34.png" alt="34"></p>
<ul>
<li>Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。</li>
<li>CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。</li>
<li>MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap &lt;String,CachedResource&gt; m_resources;</li>
</ul>
<p>在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum RevalidationPolicy &#123; Use, Revalidate, Reload, Load &#125;;</span><br><span class="line">    RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const;</span><br></pre></td></tr></table></figure>

<p>可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);</span><br><span class="line">switch (policy) &#123;</span><br><span class="line">case Reload:</span><br><span class="line">    memoryCache.remove(*resource);</span><br><span class="line">    FALLTHROUGH;</span><br><span class="line">case Load:</span><br><span class="line">    if (resource)</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</span><br><span class="line">    resource = loadResource(type, WTFMove(request));</span><br><span class="line">    break;</span><br><span class="line">case Revalidate:</span><br><span class="line">    if (resource)</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</span><br><span class="line">    resource = revalidateResource(WTFMove(request), *resource);</span><br><span class="line">    break;</span><br><span class="line">case Use:</span><br><span class="line">    ASSERT(resource);</span><br><span class="line">    if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) &#123;</span><br><span class="line">        resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request));</span><br><span class="line">        if (resource-&gt;status() != CachedResource::Status::Cached)</span><br><span class="line">            policy = Load;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ResourceError error;</span><br><span class="line">        if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))</span><br><span class="line">            return makeUnexpected(WTFMove(error));</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</span><br><span class="line">        loadTiming.setResponseEnd(MonotonicTime::now());</span><br><span class="line"></span><br><span class="line">        memoryCache.resourceAccessed(*resource);</span><br><span class="line"></span><br><span class="line">        if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) &#123;</span><br><span class="line">            auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());</span><br><span class="line">            if (initiatorContext == InitiatorContext::Worker) &#123;</span><br><span class="line">                ASSERT(is&lt;CachedRawResource&gt;(resource.get()));</span><br><span class="line">                downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ASSERT(initiatorContext == InitiatorContext::Document);</span><br><span class="line">                m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());</span><br><span class="line">                m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (forPreload == ForPreload::No)</span><br><span class="line">            resource-&gt;setLoadPriority(request.priority());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。</p>
<p>CachedResource 加载<br>CachedResource 实现了 RFC2616 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html</a> 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/35.png" alt="35"></p>
<p>会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。</p>
<p>在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)</span><br><span class="line">&#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">    case CachedResource::MainResource:</span><br><span class="line">        return ResourceLoadPriority::VeryHigh;</span><br><span class="line">    case CachedResource::CSSStyleSheet:</span><br><span class="line">    case CachedResource::Script:</span><br><span class="line">        return ResourceLoadPriority::High;</span><br><span class="line">#if ENABLE(SVG_FONTS)</span><br><span class="line">    case CachedResource::SVGFontResource:</span><br><span class="line">#endif</span><br><span class="line">    case CachedResource::MediaResource:</span><br><span class="line">    case CachedResource::FontResource:</span><br><span class="line">    case CachedResource::RawResource:</span><br><span class="line">    case CachedResource::Icon:</span><br><span class="line">        return ResourceLoadPriority::Medium;</span><br><span class="line">    case CachedResource::ImageResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">#if ENABLE(XSLT)</span><br><span class="line">    case CachedResource::XSLStyleSheet:</span><br><span class="line">        return ResourceLoadPriority::High;</span><br><span class="line">#endif</span><br><span class="line">    case CachedResource::SVGDocumentResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">    case CachedResource::Beacon:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">#if ENABLE(LINK_PREFETCH)</span><br><span class="line">    case CachedResource::LinkPrefetch:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">    case CachedResource::LinkSubresource:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">#endif</span><br><span class="line">#if ENABLE(VIDEO_TRACK)</span><br><span class="line">    case CachedResource::TextTrackResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_NOT_REACHED();</span><br><span class="line">    return ResourceLoadPriority::Low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(resourceLoader);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    // If there&apos;s a web archive resource for this URL, we don&apos;t need to schedule the load since it will never touch the network.</span><br><span class="line">    if (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) &#123;</span><br><span class="line">        resourceLoader-&gt;startLoading();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) &#123;</span><br><span class="line">        resourceLoader-&gt;start();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);</span><br><span class="line">#else</span><br><span class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ResourceLoadPriority priority = resourceLoader-&gt;request().priority();</span><br><span class="line"></span><br><span class="line">    bool hadRequests = host-&gt;hasRequests();</span><br><span class="line">    //把优先级存放到 host 的 m_requestsPending 属性里</span><br><span class="line">    host-&gt;schedule(resourceLoader, priority);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(COCOA) || USE(CFURLCONNECTION)</span><br><span class="line">    if (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) &#123;</span><br><span class="line">        // Serve all requests at once to keep the pipeline full at the network layer.</span><br><span class="line">        // FIXME: Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms?</span><br><span class="line">        servePendingRequests(host, ResourceLoadPriority::VeryLow);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//这里就是如何根据优先级来进行安排的</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    if ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) &#123;</span><br><span class="line">        //重要资源立刻进行</span><br><span class="line">        servePendingRequests(host, priority);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &#123;</span><br><span class="line">        //重要资源立刻进行</span><br><span class="line">        servePendingRequests(host, priority);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Handle asynchronously so early low priority requests don&apos;t</span><br><span class="line">    // get scheduled before later high priority ones.</span><br><span class="line">    //不重要的就延迟进行，然后根据优先级，由高到低依次加载</span><br><span class="line">    scheduleServePendingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority)</span><br><span class="line">&#123;</span><br><span class="line">    auto priority = ResourceLoadPriority::Highest;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        auto&amp; requestsPending = host-&gt;requestsPending(priority);</span><br><span class="line">        while (!requestsPending.isEmpty()) &#123;</span><br><span class="line">            RefPtr&lt;ResourceLoader&gt; resourceLoader = requestsPending.first();</span><br><span class="line"></span><br><span class="line">            // For named hosts - which are only http(s) hosts - we should always enforce the connection limit.</span><br><span class="line">            // For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn&apos;t done parsing </span><br><span class="line">            // and we don&apos;t know all stylesheets yet.</span><br><span class="line">            Document* document = resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : 0;</span><br><span class="line">            bool shouldLimitRequests = !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded()));</span><br><span class="line">            if (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority))</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            requestsPending.removeFirst();</span><br><span class="line">            host-&gt;addLoadInProgress(resourceLoader.get());</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">            if (!IOSApplication::isWebProcess()) &#123;</span><br><span class="line">                resourceLoader-&gt;startLoading();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            //在这个函数里创建了 ResourceHandle</span><br><span class="line">            resourceLoader-&gt;start();</span><br><span class="line">        &#125;</span><br><span class="line">        if (priority == minimumPriority)</span><br><span class="line">            return;</span><br><span class="line">        --priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(m_resource);</span><br><span class="line"></span><br><span class="line">    if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())</span><br><span class="line">        return;</span><br><span class="line">    ASSERT(!m_resource-&gt;resourceToRevalidate());</span><br><span class="line">    ASSERT(!m_resource-&gt;errorOccurred());</span><br><span class="line">    ASSERT(m_state == Initialized);</span><br><span class="line">    // Reference the object in this method since the additional processing can do</span><br><span class="line">    // anything including removing the last reference to this object; one example of this is 3266216.</span><br><span class="line">    Ref&lt;SubresourceLoader&gt; protectedThis(*this);</span><br><span class="line">    </span><br><span class="line">    //ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里</span><br><span class="line">    ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);</span><br><span class="line"></span><br><span class="line">    if (!m_loadingMultipartContent) &#123;</span><br><span class="line">        if (auto* resourceData = this-&gt;resourceData())</span><br><span class="line">            m_resource-&gt;addDataBuffer(*resourceData);</span><br><span class="line">        else</span><br><span class="line">            m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 image 为例如图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/36.png" alt="36"></p>
<p>举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。</p>
<p>CacheImage 的加载过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/82.png" alt="82"></p>
<p>具体调用方法顺序如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">HTMLImageElement::create //解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象</span><br><span class="line">ImageLoader::updateFromElementIgnoringPreviousError //解析到 img 的 href 属性</span><br><span class="line">ImageLoader::updateFromElement</span><br><span class="line">CachedResourceLoader::requestImage</span><br><span class="line">CachedResourceLoader::requestResource //判断是否从缓存读取，还是网络获取</span><br><span class="line">CachedResourceLoader::loadResource //创建不同类型的 CachedResource，这里是 CachedImage</span><br><span class="line">MemoryCache::add //创建对应的 cache 项目</span><br><span class="line">CachedImage::load</span><br><span class="line">CachedResource::load</span><br><span class="line">CachedResourceLoader::load</span><br><span class="line">CachedResourceRequest::load</span><br><span class="line">ResourceLoaderScheduler::scheduleSubresourceLoad</span><br><span class="line">SubresourceLoader::create</span><br><span class="line">ResourceLoadScheduler::requestTimerFired</span><br><span class="line">ResourceLoader::start</span><br><span class="line">ResourceHandle::create</span><br><span class="line">ResourceLoader::didReceiveResponse //收到 HTTP Header 的 response</span><br><span class="line">SubresourceLoader::didiReceiveResponse</span><br><span class="line">CachedResourceRequest::didReceiveResponse //处理响应</span><br><span class="line">ResourceLoader::didReceiveResponse</span><br><span class="line">ResourceLoader::didReceiveData //收到 body 数据</span><br><span class="line">SubresourceLoader::didReceiveData</span><br><span class="line">ResourceLoader::didReceiveData</span><br><span class="line">ResourceLoader::addData</span><br><span class="line">CachedResourceRequest::didReceiveData</span><br><span class="line">ResourceLoader::didFinishLoading //数据读取完成</span><br><span class="line">SubresourceLoader::didFinishLoading</span><br><span class="line">CachedResourceRequest::didFinishLoading</span><br><span class="line">CachedResource::finish</span><br><span class="line">CachedResourceLoader::loadDone</span><br><span class="line">CachedImage::data //创建 Image 对象，进行解码</span><br></pre></td></tr></table></figure>

<p>可以用下图概括下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/51.png" alt="51"><br>一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。</p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。</p>
<h3 id="WebKit-的-Cache"><a href="#WebKit-的-Cache" class="headerlink" title="WebKit 的 Cache"></a>WebKit 的 Cache</h3><p>WebKit 主要有三种 Cache。</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">if (!m_frame.tree().parent() &amp;&amp; history().currentItem()) &#123;</span><br><span class="line">    // Check to see if we need to cache the page we are navigating away from into the back/forward cache.</span><br><span class="line">    // We are doing this here because we know for sure that a new page is about to be loaded.</span><br><span class="line">    PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</span><br><span class="line"></span><br><span class="line">    WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void PageCache::addIfCacheable(HistoryItem&amp; item, Page* page)</span><br><span class="line">&#123;</span><br><span class="line">    if (item.isInPageCache())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!page || !canCache(*page))</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), &quot;Utility pages such as SVGImage pages should never go into PageCache&quot;);</span><br><span class="line"></span><br><span class="line">    setPageCacheState(*page, Document::AboutToEnterPageCache);</span><br><span class="line"></span><br><span class="line">    // Focus the main frame, defocusing a focused subframe (if we have one). We do this here,</span><br><span class="line">    // before the page enters the page cache, while we still can dispatch DOM blur/focus events.</span><br><span class="line">    if (page-&gt;focusController().focusedFrame())</span><br><span class="line">        page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    // Fire the pagehide event in all frames.</span><br><span class="line">    firePageHideEventRecursively(page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    // Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers</span><br><span class="line">    // could have altered the page in a way that could prevent caching.</span><br><span class="line">    if (!canCache(*page)) &#123;</span><br><span class="line">        setPageCacheState(*page, Document::NotInPageCache);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroyRenderTree(page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    setPageCacheState(*page, Document::InPageCache);</span><br><span class="line"></span><br><span class="line">    // Make sure we no longer fire any JS events past this point.</span><br><span class="line">    NoEventDispatchAssertion assertNoEventDispatch;</span><br><span class="line">    //创建一个新的 CachedPage 存放到 HistoryItem 里</span><br><span class="line">    item.m_cachedPage = std::make_unique&lt;CachedPage&gt;(*page);</span><br><span class="line">    item.m_pruningReason = PruningReason::None;</span><br><span class="line">    //将 HistoryItem 添加到 m_items 列表中</span><br><span class="line">    m_items.add(&amp;item);</span><br><span class="line">    </span><br><span class="line">    //检查是否有超过回收的限制，进行资源回收</span><br><span class="line">    prune(PruningReason::ReachedMaxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/83.png" alt="83"><br>Memory Cache 有三个比较重要的属性。</p>
<ul>
<li>m_resources：类型是 HashMap，key 是 url，值是 CacheResource。</li>
<li>m_allResources：采用的是 LRU 算法，类型是 Vector&lt;LRUList,32&gt; 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。</li>
<li>m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。</p>
<h2 id="HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><a href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token" class="headerlink" title="HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token"></a>HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</h2><h3 id="解析成-HTML-Token-的算法"><a href="#解析成-HTML-Token-的算法" class="headerlink" title="解析成 HTML Token 的算法"></a>解析成 HTML Token 的算法</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/17.png" alt="17"><br>初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。</p>
<p>在 Tag open state 状态时如果碰到 / 字符那么就会创建 End tag token，同时状态变成 Tag name state。</p>
<p>在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。</p>
<p>HTMLToken 的所有类型定义在 HTMLToken.h 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">enum Type &#123;</span><br><span class="line">    Uninitialized, //默认类型</span><br><span class="line">    DOCTYPE,       //文档类型</span><br><span class="line">    StartTag,      //起始标签</span><br><span class="line">    EndTag,        //结束标签</span><br><span class="line">    Comment,       //注释</span><br><span class="line">    Character,     //元素内容</span><br><span class="line">    EndOfFile,     //文档结束</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">private:</span><br><span class="line">    Type m_type;       //那种类型</span><br><span class="line"></span><br><span class="line">    DataVector m_data; //根据类型来，不同类型内容不一样</span><br><span class="line">    UChar m_data8BitCheck;</span><br><span class="line"></span><br><span class="line">    // For StartTag and EndTag</span><br><span class="line">    bool m_selfClosing;            //是否是自封闭</span><br><span class="line">    AttributeList m_attributes;    //属性列表</span><br><span class="line">    Attribute* m_currentAttribute; //当前属性</span><br><span class="line"></span><br><span class="line">    // For DOCTYPE</span><br><span class="line">    std::unique_ptr&lt;DoctypeData&gt; m_doctypeData;</span><br><span class="line"></span><br><span class="line">    unsigned m_attributeBaseOffset &#123; 0 &#125;; // Changes across document.write() boundaries.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/28.png" alt="28"></p>
<p>HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：<a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="noopener">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">//HTML 有限状态机的状态非空集合</span><br><span class="line">enum State &#123;</span><br><span class="line">    DataState, //初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character</span><br><span class="line">    CharacterReferenceInDataState,</span><br><span class="line">    RCDATAState,</span><br><span class="line">    CharacterReferenceInRCDATAState,</span><br><span class="line">    RAWTEXTState,</span><br><span class="line">    ScriptDataState,</span><br><span class="line">    PLAINTEXTState,</span><br><span class="line">    TagOpenState, //碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里</span><br><span class="line">    EndTagOpenState, //TagOpenState 状态碰见 / 进入。HTMLToken 的 type 为 endTag</span><br><span class="line">    TagNameState, //在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag</span><br><span class="line"></span><br><span class="line">    RCDATALessThanSignState,</span><br><span class="line">    RCDATAEndTagOpenState,</span><br><span class="line">    RCDATAEndTagNameState,</span><br><span class="line"></span><br><span class="line">    RAWTEXTLessThanSignState,</span><br><span class="line">    RAWTEXTEndTagOpenState,</span><br><span class="line">    RAWTEXTEndTagNameState,</span><br><span class="line"></span><br><span class="line">    ScriptDataLessThanSignState,</span><br><span class="line">    ScriptDataEndTagOpenState,</span><br><span class="line">    ScriptDataEndTagNameState,</span><br><span class="line">    ScriptDataEscapeStartState,</span><br><span class="line">    ScriptDataEscapeStartDashState,</span><br><span class="line">    ScriptDataEscapedState,</span><br><span class="line">    ScriptDataEscapedDashState,</span><br><span class="line">    ScriptDataEscapedDashDashState,</span><br><span class="line">    ScriptDataEscapedLessThanSignState,</span><br><span class="line">    ScriptDataEscapedEndTagOpenState,</span><br><span class="line">    ScriptDataEscapedEndTagNameState,</span><br><span class="line">    ScriptDataDoubleEscapeStartState,</span><br><span class="line">    ScriptDataDoubleEscapedState,</span><br><span class="line">    ScriptDataDoubleEscapedDashState,</span><br><span class="line">    ScriptDataDoubleEscapedDashDashState,</span><br><span class="line">    ScriptDataDoubleEscapedLessThanSignState,</span><br><span class="line">    ScriptDataDoubleEscapeEndState,</span><br><span class="line"></span><br><span class="line">    BeforeAttributeNameState, //TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname</span><br><span class="line">    AttributeNameState, //BeforeAttributeNameState 碰见字母进入</span><br><span class="line">    AfterAttributeNameState,</span><br><span class="line">    BeforeAttributeValueState, //AttributeNameState 状态碰到 = 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的</span><br><span class="line">    AttributeValueDoubleQuotedState, //BeforeAttributeValueState 碰到 &quot; 符号</span><br><span class="line">    AttributeValueSingleQuotedState, //BeforeAttributeValueState 碰到 &apos; 符号</span><br><span class="line">    AttributeValueUnquotedState,</span><br><span class="line">    CharacterReferenceInAttributeValueState,</span><br><span class="line">    AfterAttributeValueQuotedState, // 再次碰到 &quot; 或 &apos; 符号。HTMLToken 记录属性的值</span><br><span class="line">    SelfClosingStartTagState,</span><br><span class="line">    BogusCommentState,</span><br><span class="line">    ContinueBogusCommentState, // Not in the HTML spec, used internally to track whether we started the bogus comment token.</span><br><span class="line">    MarkupDeclarationOpenState, //TagOpenState 后遇到! 比如&lt;!</span><br><span class="line"></span><br><span class="line">    //解析comment</span><br><span class="line">    CommentStartState, //MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT</span><br><span class="line">    CommentStartDashState,</span><br><span class="line">    CommentState, //CommentStartState 碰到字母进入这个状态</span><br><span class="line">    CommentEndDashState, //在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容</span><br><span class="line">    CommentEndState, //在 CommentEndDashState 状态碰见 - 进入</span><br><span class="line">    CommentEndBangState,</span><br><span class="line"></span><br><span class="line">    //解析 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 这种标签</span><br><span class="line">    DOCTYPEState, //匹配到 DOCTYPE，&lt;!DOCTYPE</span><br><span class="line">    BeforeDOCTYPENameState, //DOCTYPE 状态后遇到空格</span><br><span class="line">    DOCTYPENameState, //BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html</span><br><span class="line">    AfterDOCTYPENameState, //DOCTYPENameState 遇到空格 &lt;!DOCTYPE html</span><br><span class="line">    AfterDOCTYPEPublicKeywordState, //AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC</span><br><span class="line">    BeforeDOCTYPEPublicIdentifierState, //AfterDOCTYPEPublicKeywordState 状态后碰到空格</span><br><span class="line">    DOCTYPEPublicIdentifierDoubleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &quot; 进入</span><br><span class="line">    DOCTYPEPublicIdentifierSingleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &apos; 进入</span><br><span class="line">    AfterDOCTYPEPublicIdentifierState, //再次遇到 &quot; 或 &apos; 。可将 HTMLToken 的 m_publicIdentifier 确定</span><br><span class="line">    BetweenDOCTYPEPublicAndSystemIdentifiersState, </span><br><span class="line">    AfterDOCTYPESystemKeywordState,</span><br><span class="line">    BeforeDOCTYPESystemIdentifierState,</span><br><span class="line">    DOCTYPESystemIdentifierDoubleQuotedState,</span><br><span class="line">    DOCTYPESystemIdentifierSingleQuotedState,</span><br><span class="line">    AfterDOCTYPESystemIdentifierState,</span><br><span class="line">    BogusDOCTYPEState,</span><br><span class="line">    CDATASectionState,</span><br><span class="line"></span><br><span class="line">    // These CDATA states are not in the HTML5 spec, but we use them internally.</span><br><span class="line">    CDATASectionRightSquareBracketState,</span><br><span class="line">    CDATASectionDoubleRightSquareBracketState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/55.png" alt="55"></p>
<h2 id="HTML-语法解析"><a href="#HTML-语法解析" class="headerlink" title="HTML 语法解析"></a>HTML 语法解析</h2><h3 id="HTML-的语法定义"><a href="#HTML-的语法定义" class="headerlink" title="HTML 的语法定义"></a>HTML 的语法定义</h3><p>HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：<a href="https://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">https://www.w3.org/TR/html4/strict.dtd</a></p>
<h3 id="相关类关系图"><a href="#相关类关系图" class="headerlink" title="相关类关系图"></a>相关类关系图</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/09.png" alt="09"></p>
<ul>
<li>Document 和 DocumentParser 相互引用</li>
<li>HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。</li>
<li>HTMLInputStream：解码后的字符流的保存，作为缓冲区。</li>
<li>HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。</li>
<li>HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。</li>
<li>HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用</li>
<li>HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。</li>
<li>HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/10.png" alt="10"></p>
<ul>
<li><p>DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。</p>
</li>
<li><p>HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。</p>
</li>
<li><p>把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite</a> 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。</p>
</li>
<li><p>然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。</p>
</li>
</ul>
<h3 id="Element-属性设置"><a href="#Element-属性设置" class="headerlink" title="Element 属性设置"></a>Element 属性设置</h3><p>是通过 Element::parserSetAttributes 来设置的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">			c++</span><br><span class="line">void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isConnected());</span><br><span class="line">    ASSERT(!parentNode());</span><br><span class="line">    ASSERT(!m_elementData);</span><br><span class="line"></span><br><span class="line">    if (!attributeVector.isEmpty()) &#123;</span><br><span class="line">        if (document().sharedObjectPool())</span><br><span class="line">            m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);</span><br><span class="line">        else</span><br><span class="line">            m_elementData = ShareableElementData::createWithAttributes(attributeVector);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parserDidSetAttributes();</span><br><span class="line"></span><br><span class="line">    // Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.</span><br><span class="line">    for (const auto&amp; attribute : attributeVector)</span><br><span class="line">        attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。</p>
<h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/84.png" alt="84"><br>相关类流程图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/87.png" alt="87"></p>
<p>前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树</p>
<h3 id="DOM-标准规范"><a href="#DOM-标准规范" class="headerlink" title="DOM 标准规范"></a>DOM 标准规范</h3><p>Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/52.png" alt="52"><br>下面对各个 level 进行说明<br>DOM level 1</p>
<ul>
<li>Core：底层接口，接口支持 XML 等任何结构化文档。</li>
<li>HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。</li>
</ul>
<p>DOM level 2</p>
<ul>
<li>Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。</li>
<li>HTML：允许动态访问修改文档。</li>
<li>Views：文档的各种视图。</li>
<li>Events：鼠标事件等。</li>
<li>Style：可以修改 HTML 样式的一个属性。</li>
<li>Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。</li>
</ul>
<p>节点DOM level 3</p>
<ul>
<li>Core：加入了新接口 adoptNode 和 textContent。</li>
<li>Load and Save：加载 XML 转成 DOM 表示的文档结构。</li>
<li>Validation：验证文档有效性。</li>
<li>Events：加入键盘支持。</li>
<li>XPath：一种简单直观检索 DOM 节点的方式。</li>
</ul>
<p>DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore/dom/Document.idl 文件里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">interface Document : Node &#123;</span><br><span class="line">    readonly attribute DOMImplementation implementation; // FIXME: Should be [SameObject].</span><br><span class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString URL;</span><br><span class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString documentURI;</span><br><span class="line">    readonly attribute USVString origin;</span><br><span class="line">    readonly attribute DOMString compatMode;</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString characterSet;</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString charset; // Historical alias of .characterSet,</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; // Historical alias of .characterSet.</span><br><span class="line">    readonly attribute DOMString contentType;</span><br><span class="line"></span><br><span class="line">    readonly attribute DocumentType? doctype;</span><br><span class="line">    [DOMJIT=Getter] readonly attribute Element? documentElement;</span><br><span class="line"></span><br><span class="line">    HTMLCollection getElementsByTagName(DOMString qualifiedName);</span><br><span class="line">    HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);</span><br><span class="line">    HTMLCollection getElementsByClassName(DOMString classNames);</span><br><span class="line"></span><br><span class="line">    [NewObject, MayThrowException, ImplementedAs=createElementForBindings] Element createElement(DOMString localName); // FIXME: missing options parameter.</span><br><span class="line">    [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); // FIXME: missing options parameter.</span><br><span class="line">    [NewObject] DocumentFragment createDocumentFragment();</span><br><span class="line">    [NewObject] Text createTextNode(DOMString data);</span><br><span class="line">    [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data);</span><br><span class="line">    [NewObject] Comment createComment(DOMString data);</span><br><span class="line">    [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);</span><br><span class="line"></span><br><span class="line">    [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep = false);</span><br><span class="line">    [CEReactions, MayThrowException] Node adoptNode(Node node);</span><br><span class="line"></span><br><span class="line">    [NewObject, MayThrowException] Attr createAttribute(DOMString localName);</span><br><span class="line">    [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName);</span><br><span class="line"></span><br><span class="line">    [MayThrowException, NewObject] Event createEvent(DOMString type);</span><br><span class="line"></span><br><span class="line">    [NewObject] Range createRange();</span><br><span class="line"></span><br><span class="line">    // NodeFilter.SHOW_ALL = 0xFFFFFFFF.</span><br><span class="line">    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</span><br><span class="line">    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</span><br><span class="line"></span><br><span class="line">    // Extensions from HTML specification (https://html.spec.whatwg.org/#the-document-object).</span><br><span class="line">    [PutForwards=href, Unforgeable] readonly attribute Location? location;</span><br><span class="line">    [SetterMayThrowException] attribute USVString domain;</span><br><span class="line">    readonly attribute USVString referrer;</span><br><span class="line">    [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie;</span><br><span class="line">    readonly attribute DOMString lastModified;</span><br><span class="line">    readonly attribute DocumentReadyState readyState;</span><br><span class="line"></span><br><span class="line">    // DOM tree accessors.</span><br><span class="line">    [CEReactions] attribute DOMString title;</span><br><span class="line">    [CEReactions] attribute DOMString dir;</span><br><span class="line">    [CEReactions, DOMJIT=Getter, ImplementedAs=bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body;</span><br><span class="line">    readonly attribute HTMLHeadElement? head;</span><br><span class="line">    readonly attribute HTMLCollection images; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection embeds; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection plugins; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection links; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection forms; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection scripts; // Should be [SameObject].</span><br><span class="line">    NodeList getElementsByName([AtomicString] DOMString elementName);</span><br><span class="line">    readonly attribute HTMLScriptElement? currentScript; // FIXME: Should return a HTMLOrSVGScriptElement.</span><br><span class="line"></span><br><span class="line">    // dynamic markup insertion</span><br><span class="line">    // FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure</span><br><span class="line">    // that the caller document matches those semantics. It is possible we should replace it with</span><br><span class="line">    // the existing &apos;incumbent document&apos; concept.</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, ImplementedAs=openForBindings, MayThrowException] Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</span><br><span class="line">    [CallWith=ActiveWindow&amp;FirstWindow, ImplementedAs=openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features);</span><br><span class="line">    [CEReactions, ImplementedAs=closeForBindings, MayThrowException] void close();</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void write(DOMString... text);</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void writeln(DOMString... text);</span><br><span class="line"></span><br><span class="line">    // User interaction.</span><br><span class="line">    readonly attribute DOMWindow? defaultView;</span><br><span class="line">    boolean hasFocus();</span><br><span class="line">    [CEReactions] attribute DOMString designMode;</span><br><span class="line">    [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString? value = null); // FIXME: value should not be nullable.</span><br><span class="line">    boolean queryCommandEnabled(DOMString commandId);</span><br><span class="line">    boolean queryCommandIndeterm(DOMString commandId);</span><br><span class="line">    boolean queryCommandState(DOMString commandId);</span><br><span class="line">    boolean queryCommandSupported(DOMString commandId);</span><br><span class="line">    DOMString queryCommandValue(DOMString commandId);</span><br><span class="line"></span><br><span class="line">    // Special event handler IDL attributes that only apply to Document objects.</span><br><span class="line">    [LenientThis] attribute EventHandler onreadystatechange;</span><br><span class="line"></span><br><span class="line">    // Extensions from the CSSOM specification (https://drafts.csswg.org/cssom/#extensions-to-the-document-interface).</span><br><span class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</span><br><span class="line">    readonly attribute StyleSheetList styleSheets; // FIXME: Should be [SameObject].</span><br><span class="line"></span><br><span class="line">    // Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-document-interface).</span><br><span class="line">    readonly attribute Element? scrollingElement;</span><br><span class="line"></span><br><span class="line">    // Extensions from Selection API (https://www.w3.org/TR/selection-api/#extensions-to-document-interface).</span><br><span class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</span><br><span class="line">    DOMSelection? getSelection();</span><br><span class="line"></span><br><span class="line">    // XPath extensions (https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator).</span><br><span class="line">    [MayThrowException] XPathExpression createExpression(optional DOMString expression = &quot;undefined&quot;, optional XPathNSResolver? resolver); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</span><br><span class="line">    XPathNSResolver createNSResolver(Node? nodeResolver);</span><br><span class="line">    [MayThrowException] XPathResult evaluate(optional DOMString expression = &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type = 0, optional XPathResult? inResult); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</span><br><span class="line"></span><br><span class="line">    // Extensions from FullScreen API (https://fullscreen.spec.whatwg.org/#api).</span><br><span class="line">    // FIXME: Should probably be unprefixed.</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled;</span><br><span class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement;</span><br><span class="line">    [Conditional=FULLSCREEN_API] void webkitExitFullscreen();</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API] void webkitCancelFullScreen(); // Mozilla version.</span><br><span class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange;</span><br><span class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror;</span><br><span class="line"></span><br><span class="line">    // Extensions from Pointer Lock API (https://www.w3.org/TR/pointerlock/#extensions-to-the-document-interface).</span><br><span class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockchange; // FIXME: Should be enumerable.</span><br><span class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockerror; // FIXME: Should be enumerable.</span><br><span class="line">    [Conditional=POINTER_LOCK] void exitPointerLock();</span><br><span class="line"></span><br><span class="line">    // Extensions from CSS Font Loading API (https://drafts.csswg.org/css-font-loading/#font-face-source).</span><br><span class="line">    // FIXME: Should be in a separate FontFaceSource interface.</span><br><span class="line">    readonly attribute FontFaceSet fonts;</span><br><span class="line"></span><br><span class="line">    // Extensions from Page visibility API (https://www.w3.org/TR/page-visibility/#sec-document-interface).</span><br><span class="line">    readonly attribute boolean hidden;</span><br><span class="line">    readonly attribute VisibilityState visibilityState;</span><br><span class="line">    attribute EventHandler onvisibilitychange;</span><br><span class="line"></span><br><span class="line">    // FIXME: Those were dropped from the CSSOM specification.</span><br><span class="line">    readonly attribute DOMString? preferredStylesheetSet;</span><br><span class="line">    attribute DOMString? selectedStylesheetSet;</span><br><span class="line"></span><br><span class="line">    // FIXME: Those have been dropped from the DOM specification.</span><br><span class="line">    readonly attribute DOMString? xmlEncoding;</span><br><span class="line">    [SetterMayThrowException] attribute DOMString? xmlVersion;</span><br><span class="line">    attribute boolean xmlStandalone;</span><br><span class="line"></span><br><span class="line">    // FIXME: Blink has already dropped this (https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/s3ezjTuC8ig).</span><br><span class="line">    CSSStyleDeclaration getOverrideStyle(optional Element? element = null, optional DOMString pseudoElement = &quot;undefined&quot;);</span><br><span class="line"></span><br><span class="line">    // FIXME: Should be moved to GlobalEventHandlers (https://w3c.github.io/selection-api/#extensions-to-globaleventhandlers).</span><br><span class="line">    [NotEnumerable] attribute EventHandler onselectstart; // FIXME: Should be enumerable.</span><br><span class="line">    [NotEnumerable] attribute EventHandler onselectionchange; // FIXME: Should be enumerable.</span><br><span class="line"></span><br><span class="line">    // Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet.</span><br><span class="line">    Range caretRangeFromPoint(optional long x = 0, optional long y = 0);</span><br><span class="line"></span><br><span class="line">    // FIXME: This is not standard and has been dropped from Blink already.</span><br><span class="line">    RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height);</span><br><span class="line"></span><br><span class="line">    // Non standard (https://developer.apple.com/reference/webkitjs/document/1633863-webkitgetnamedflows).</span><br><span class="line">    [Conditional=CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Obsolete features from https://html.spec.whatwg.org/multipage/obsolete.html</span><br><span class="line"></span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor;</span><br><span class="line">    [CEReactions, ImplementedAs=linkColorForBindings] attribute [TreatNullAs=EmptyString] DOMString linkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;</span><br><span class="line"></span><br><span class="line">    readonly attribute HTMLCollection anchors; /* [SameObject] */</span><br><span class="line">    readonly attribute HTMLCollection applets; /* [SameObject] */</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line">    void captureEvents();</span><br><span class="line">    void releaseEvents();</span><br><span class="line"></span><br><span class="line">    [Replaceable] readonly attribute HTMLAllCollection all; /* [SameObject] */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DOM-Tree-Token-的构造算法"><a href="#DOM-Tree-Token-的构造算法" class="headerlink" title="DOM Tree Token 的构造算法"></a>DOM Tree Token 的构造算法</h3><p>这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：<a href="https://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="noopener">https://www.w3.org/TR/html5/syntax.html#html-parser</a></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/19.png" alt="19"><br>当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。</p>
<p>具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。</p>
<p>接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。</p>
<p>再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。</p>
<h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>构建 DOM 的几个关键的类<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/53.png" alt="53"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/11.png" alt="11"></p>
<ul>
<li>HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。</li>
<li>HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。</li>
<li>HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。</li>
<li>HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。</li>
</ul>
<p>构建 DOM 树的过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/54.png" alt="54"></p>
<p>举个例子：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">			Hello World</span><br><span class="line">		<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"example.png"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转成 DOM Tree 如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/69.png" alt="69"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FetchRequest fetchRequest(m_request, FetchInitiatorTypeNames::document,</span><br><span class="line">                            mainResourceLoadOptions);</span><br><span class="line">  m_mainResource =</span><br><span class="line">      RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData);</span><br></pre></td></tr></table></figure>

<p>DocumentLoader 的 commitData 会去处理 dataReceived 的数据块</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DocumentLoader::commitData(const char* bytes, size_t length) &#123;</span><br><span class="line">  ensureWriter(m_response.mimeType()); //会初始化 HTMLDocumentParser 实例化 document 对象</span><br><span class="line">  if (length)</span><br><span class="line">    m_dataReceived = true;</span><br><span class="line">  m_writer-&gt;addData(bytes, length); //给 Parser 解析，这里的bytes就是返回来的 html 文本代码</span><br><span class="line">&#125;</span><br><span class="line">//ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次</span><br><span class="line">void DocumentLoader::ensureWriter(const AtomicString&amp; mimeType, const KURL&amp; overridingURL) &#123;</span><br><span class="line">  if (m_writer)</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>DOM Tree 已经被 W3 标准化了 <a href="https://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">Document Object Model (DOM) Technical Reports</a> 在 DOM Level 3 里 IDL 的定义在 <a href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank" rel="noopener">IDL Definitions</a></p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/56.png" alt="56"></p>
<p>在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：<a href="https://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode" target="_blank" rel="noopener">https://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode</a> 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a> 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。</p>
<p>需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：<a href="https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements</a></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/37.png" alt="37"></p>
<p>DOM Node 的数据结构<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/12.png" alt="12"></p>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/75.png" alt="75"></p>
<h4 id="构建-DOM-Tree-1"><a href="#构建-DOM-Tree-1" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h4><p>从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore/html/parser/HTMLTreeBuilder.cpp 文件里。<br>constructtreefromToken</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    switch (token.type()) &#123;</span><br><span class="line">    case HTMLToken::Uninitialized:</span><br><span class="line">        ASSERT_NOT_REACHED();</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::DOCTYPE:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processDoctypeToken(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::StartTag:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processStartTag(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::EndTag:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processEndTag(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::Comment:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processComment(WTFMove(token));</span><br><span class="line">        return;</span><br><span class="line">    case HTMLToken::Character:</span><br><span class="line">        processCharacter(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::EndOfFile:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processEndOfFile(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) &#123;</span><br><span class="line">  HTMLHtmlElement* element = HTMLHtmlElement::create(*m_document);</span><br><span class="line">  attachLater(m_attachmentRoot, element);</span><br><span class="line">  m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); //push 到 HTMLStackItem 栈里</span><br><span class="line">  executeQueuedTasks();</span><br><span class="line">&#125;</span><br><span class="line">//通过 attachLater 创建 task</span><br><span class="line">void HTMLConstructionSite::attachLater(ContainerNode* parent,</span><br><span class="line">                                       Node* child,</span><br><span class="line">                                       bool selfClosing) &#123;</span><br><span class="line">  HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);</span><br><span class="line">  task.parent = parent;</span><br><span class="line">  task.child = child;</span><br><span class="line">  task.selfClosing = selfClosing;</span><br><span class="line">  //判断是否到达最深，512是最深</span><br><span class="line">  if (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp;</span><br><span class="line">      task.parent-&gt;parentNode())</span><br><span class="line">    task.parent = task.parent-&gt;parentNode();</span><br><span class="line">  queueTask(task);</span><br><span class="line">&#125;</span><br><span class="line">//executeQueued 添加子节点</span><br><span class="line">void ContainerNode::parserAppendChild(Node* newChild) &#123;</span><br><span class="line">  if (!checkParserAcceptChild(*newChild))</span><br><span class="line">    return;</span><br><span class="line">    AdoptAndAppendChild()(*this, *newChild, nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  notifyNodeInserted(*newChild, ChildrenChangeSourceParser);</span><br><span class="line">&#125;</span><br><span class="line">//添加前会先检查是否支持子元素</span><br><span class="line">void ContainerNode::appendChildCommon(Node&amp; child) &#123;</span><br><span class="line">  child.setParentOrShadowHostNode(this);</span><br><span class="line">  if (m_lastChild) &#123;</span><br><span class="line">    child.setPreviousSibling(m_lastChild);</span><br><span class="line">    m_lastChild-&gt;setNextSibling(&amp;child);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    setFirstChild(&amp;child);</span><br><span class="line">  &#125;</span><br><span class="line">  setLastChild(&amp;child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭标签会把元素 pop 出来</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_tree.openElements()-&gt;popUntilPopped(token-&gt;name());</span><br></pre></td></tr></table></figure>

<h3 id="对错误的处理"><a href="#对错误的处理" class="headerlink" title="对错误的处理"></a>对错误的处理</h3><p>parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子</p>
<h4 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a><br> 问题</h4><p>一些网站会用 <br> 替代 <br>，处理的代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stray-table"><a href="#stray-table" class="headerlink" title="stray table"></a>stray table</h4><p>stray table 是一个 table 包含了一个不在 table cell 的 table。</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>inner table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">         <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>outer table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>WebKit 的处理</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure>

<p>这样会处理成两个同级 table</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>outer table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>inner table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套-form"><a href="#嵌套-form" class="headerlink" title="嵌套 form"></a>嵌套 form</h4><p>将一个 form 放到另一个 form 里。那么第二个 form 会被忽略</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement = new HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过深的层级"><a href="#过深的层级" class="headerlink" title="过深的层级"></a>过深的层级</h4><p>同一个类型里只允许嵌套 20 个 tag。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line">unsigned i = 0;</span><br><span class="line">for (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">     curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line">return i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="html-或-body-的-end-tags-缺失"><a href="#html-或-body-的-end-tags-缺失" class="headerlink" title="html 或 body 的 end tags 缺失"></a>html 或 body 的 end tags 缺失</h4><p>这些都会在 end() 是调用</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line">        return;</span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-语法简介"><a href="#CSS-语法简介" class="headerlink" title="CSS 语法简介"></a>CSS 语法简介</h3><p>所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。</p>
<h4 id="CSS-declarations"><a href="#CSS-declarations" class="headerlink" title="CSS declarations"></a>CSS declarations</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/40.png" alt="40"><br>在这里可以找到 CSS  的不同的属性。</p>
<h4 id="CSS-declaration-blocks"><a href="#CSS-declaration-blocks" class="headerlink" title="CSS declaration blocks"></a>CSS declaration blocks</h4><p>使用大括号包起来。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/41.png" alt="41"></p>
<h4 id="CSS-selectors-and-rules"><a href="#CSS-selectors-and-rules" class="headerlink" title="CSS selectors and rules"></a>CSS selectors and rules</h4><p>在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/42.png" alt="42"></p>
<p>selector 可以分为以下类别</p>
<ul>
<li>Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。</li>
<li>Attribute selectors：属性选择器，通过属性匹配。</li>
<li>Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。</li>
<li>Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^=http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。</li>
<li>Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。</li>
<li>Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。</li>
</ul>
<p>Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种</p>
<ul>
<li>[attr]：不论值是什么选择所有 attr 属性的元素。</li>
<li>[attr=val]：按照 attr 属性的值为 val 的所有元素。</li>
<li>[attr~=val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。</li>
</ul>
<p>还有 Substring value attribute selector 这样的伪正则选择器：</p>
<ul>
<li>[attr|=val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。</li>
<li>[attr^=val]：匹配选择以 val 开头的元素。</li>
<li>[attr$=val]：匹配选择以 val 结尾的元素。</li>
<li>[attr*=val]：匹配选择包含 val 的元素。</li>
</ul>
<p>Combinators 组合器有以下几种</p>
<ul>
<li>A,B： 匹配 A B 的任意元素。</li>
<li>A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。</li>
<li>A &gt; B：B 是 A 的直接子节点。</li>
<li>A + B：B 是 A 的兄弟节点。</li>
<li>A ~ B：B 是 A 兄弟节点中的任意一个。</li>
</ul>
<h4 id="CSS-statements"><a href="#CSS-statements" class="headerlink" title="CSS statements"></a>CSS statements</h4><p>CSS rule 只是 CSS statements 的一种。<br>其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。</p>
<ul>
<li>@charset：元数据</li>
<li>@import：元数据</li>
<li>@media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。</li>
<li>@supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。</li>
<li>@document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。</li>
<li>@font-face：描述性信息</li>
</ul>
<p>比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;starming.css&apos;;</span><br></pre></td></tr></table></figure>

<p>表示向当前的 CSS 导入了 starming.css 文件。再举个例子：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 801px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        width:800px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表示页面宽度超过801像素时才会运用 @-规则里的内容。</p>
<h4 id="Shorthand"><a href="#Shorthand" class="headerlink" title="Shorthand"></a>Shorthand</h4><p>有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。<br>比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maring: 20px 10px 10px 20px;</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">margin-top: 20px;</span><br><span class="line">margin-right: 10px;</span><br><span class="line">margin-bottom: 10px;</span><br><span class="line">margin-left: 20px;</span><br></pre></td></tr></table></figure>

<p>再比如 background 属性</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: black url(starming-bg.png) 20px 20px repeat-x fixed;</span><br></pre></td></tr></table></figure>

<p>和下面的属性设置等效</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background-color: black;</span><br><span class="line">background-image: url(starming-bg.png);</span><br><span class="line">background-position: 20px 20px;</span><br><span class="line">background-repeat: repeat-x;</span><br><span class="line">background-scroll: fixed;</span><br></pre></td></tr></table></figure>

<h4 id="Value-and-unit"><a href="#Value-and-unit" class="headerlink" title="Value and unit"></a>Value and unit</h4><ul>
<li>absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1/72 of an inch) 点，picas (12 points.) 十二点活字。</li>
<li>相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1/100 和视图高度的 1/100，但是支持没有 rem 那么好。</li>
<li>无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。</li>
<li>百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。</li>
<li>颜色：有165个不同关键字可用，具体见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords</a> ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：<a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle</a></li>
<li>透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。</li>
<li>函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’);</li>
</ul>
<h4 id="验证-CSS-语法正确性"><a href="#验证-CSS-语法正确性" class="headerlink" title="验证 CSS 语法正确性"></a>验证 CSS 语法正确性</h4><p>可以通过 w3c 提供的服务 <a href="https://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener">https://jigsaw.w3.org/css-validator/</a> 来验证，w3c 还提供了 html 的验证服务 <a href="https://validator.w3.org/#validate_by_uri" target="_blank" rel="noopener">https://validator.w3.org/#validate_by_uri</a></p>
<h3 id="CSS-BNF"><a href="#CSS-BNF" class="headerlink" title="CSS BNF"></a>CSS BNF</h3><p>CSS 语法 BNF</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : &apos;.&apos; IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | &apos;*&apos;</span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/68.png" alt="68"></p>
<h3 id="CSS-主要类与关系"><a href="#CSS-主要类与关系" class="headerlink" title="CSS 主要类与关系"></a>CSS 主要类与关系</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/57.png" alt="57"><br>上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。</p>
<p>StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。</p>
<p>CSS 文档结构的类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/90.png" alt="90"></p>
<h4 id="StyleRuleBase-类的继承关系"><a href="#StyleRuleBase-类的继承关系" class="headerlink" title="StyleRuleBase 类的继承关系"></a>StyleRuleBase 类的继承关系</h4><p>RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/58.png" alt="58"><br>我们来看看这些子类类型都是对应 CSS 里的什么</p>
<ul>
<li>StyleRule：常用的都是这个类型</li>
<li>StyleRuleImport：对应的是 @import</li>
<li>StyleRuleMedia：对应的是 @media</li>
<li>StyleRuleFontFace：对应的 @font-face</li>
<li>StyleRulePage：对应的 @page</li>
<li>StyleRuleKeyFrames：对应的 @-webkit-key-frames</li>
<li>StyleRuleRegion：分区域排版</li>
</ul>
<h4 id="StyleRule-类的结构"><a href="#StyleRule-类的结构" class="headerlink" title="StyleRule 类的结构"></a>StyleRule 类的结构</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/59.png" alt="59"></p>
<h3 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h3><p>WebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/91.png" alt="91"></p>
<p>字符串转 tokens<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/13.png" alt="13"></p>
<p>将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。<br>定义 matchType</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum MatchType &#123;</span><br><span class="line">    Unknown,</span><br><span class="line">    Tag,               //比如 div</span><br><span class="line">    Id,                // #id</span><br><span class="line">    Class,             // .class</span><br><span class="line">    PseudoClass,       // :nth-child(2)</span><br><span class="line">    PseudoElement,     // ::first-line</span><br><span class="line">    PagePseudoClass,   //</span><br><span class="line">    AttributeExact,    // E[attr=&quot;value&quot;]</span><br><span class="line">    AttributeSet,      // E[attr]</span><br><span class="line">    AttributeHyphen,   // E[attr|=&quot;value&quot;]</span><br><span class="line">    AttributeList,     // E[attr~=&quot;value&quot;]</span><br><span class="line">    AttributeContain,  // E[attr*=&quot;value&quot;]</span><br><span class="line">    AttributeBegin,    // E[attr^=&quot;value&quot;]</span><br><span class="line">    AttributeEnd,      // E[attr$=&quot;value&quot;]</span><br><span class="line">    FirstAttributeSelectorMatch = AttributeExact,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义 selectors 的 Relation 类型</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum RelationType &#123;</span><br><span class="line">    SubSelector,       // No combinator</span><br><span class="line">    Descendant,        // &quot;Space&quot; combinator</span><br><span class="line">    Child,             // &gt; combinator</span><br><span class="line">    DirectAdjacent,    // + combinator</span><br><span class="line">    IndirectAdjacent,  // ~ combinator</span><br><span class="line">    // Special cases for shadow DOM related selectors.</span><br><span class="line">    ShadowPiercingDescendant,  // &gt;&gt;&gt; combinator</span><br><span class="line">    ShadowDeep,                // /deep/ combinator</span><br><span class="line">    ShadowPseudo,              // ::shadow pseudo element</span><br><span class="line">    ShadowSlot                 // ::slotted() pseudo element</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CSS 的属性是 id 来标识的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum CSSPropertyID &#123;</span><br><span class="line">    CSSPropertyColor = 15,</span><br><span class="line">    CSSPropertyWidth = 316,</span><br><span class="line">    CSSPropertyMarginLeft = 145,</span><br><span class="line">    CSSPropertyMarginRight = 146,</span><br><span class="line">    CSSPropertyMarginTop = 147,</span><br><span class="line">    CSSPropertyMarkerEnd = 148,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认样式，Blink ua全部 CSS 样式：<a href="https://yincheng.site/html/chrome-ua-css.html" target="_blank" rel="noopener">https://yincheng.site/html/chrome-ua-css.html</a> 。w3c 的默认样式是：<a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/sample.html</a></p>
<p>接着会生成 hash map，分成四个类型</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompactRuleMap m_idRules;                    //id</span><br><span class="line">CompactRuleMap m_classRules;                 //class</span><br><span class="line">CompactRuleMap m_tagRules;                   //标签</span><br><span class="line">CompactRuleMap m_shadowPseudoElementRules;   //伪类选择器</span><br></pre></td></tr></table></figure>

<p>CSS 解析完会触发  layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。</p>
<p>layout 会更新递归所有 DOM 元素</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ContainerNode::attachLayoutTree(const AttachContext&amp; context) &#123;</span><br><span class="line">  for (Node* child = firstChild(); child; child = child-&gt;nextSibling()) &#123;</span><br><span class="line">    if (child-&gt;needsAttach())</span><br><span class="line">      child-&gt;attachLayoutTree(childrenContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//id</span><br><span class="line">if (element.hasID()) </span><br><span class="line">  collectMatchingRulesForList(</span><br><span class="line">      matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()),</span><br><span class="line">      cascadeOrder, matchRequest);</span><br><span class="line">//class</span><br><span class="line">if (element.isStyledElement() &amp;&amp; element.hasClass()) &#123; </span><br><span class="line">  for (size_t i = 0; i &lt; element.classNames().size(); ++i)</span><br><span class="line">    collectMatchingRulesForList(</span><br><span class="line">        matchRequest.ruleSet-&gt;classRules(element.classNames()[i]),</span><br><span class="line">        cascadeOrder, matchRequest);</span><br><span class="line">&#125;</span><br><span class="line">//伪类</span><br><span class="line">...</span><br><span class="line">//tag 和 selector</span><br><span class="line">collectMatchingRulesForList(</span><br><span class="line">    matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()),</span><br><span class="line">    cascadeOrder, matchRequest);</span><br><span class="line">//通配符</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。</p>
<p>在 classRules 里会进行检验</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (!checkOne(context, subResult))</span><br><span class="line">  return SelectorFailsLocally;</span><br><span class="line">if (context.selector-&gt;isLastInTagHistory()) &#123; </span><br><span class="line">    return SelectorMatches;</span><br><span class="line">&#125;</span><br><span class="line">//checkOne 的实现</span><br><span class="line">switch (selector.match()) &#123; </span><br><span class="line">  case CSSSelector::Tag:</span><br><span class="line">    return matchesTagName(element, selector.tagQName());</span><br><span class="line">  case CSSSelector::Class:</span><br><span class="line">    return element.hasClass() &amp;&amp;</span><br><span class="line">           element.classNames().contains(selector.value());</span><br><span class="line">  case CSSSelector::Id:</span><br><span class="line">    return element.hasID() &amp;&amp;</span><br><span class="line">           element.idForStyleResolution() == selector.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (relation) &#123; </span><br><span class="line">  case CSSSelector::Descendant:</span><br><span class="line">    for (nextContext.element = parentElement(context); nextContext.element;</span><br><span class="line">         nextContext.element = parentElement(nextContext)) &#123; </span><br><span class="line">      MatchStatus match = matchSelector(nextContext, result);</span><br><span class="line">      if (match == SelectorMatches || match == SelectorFailsCompletely)</span><br><span class="line">        return match;</span><br><span class="line">      if (nextSelectorExceedsScope(nextContext))</span><br><span class="line">        return SelectorFailsCompletely;</span><br><span class="line">    &#125; </span><br><span class="line">    return SelectorFailsCompletely;</span><br><span class="line">      case CSSSelector::Child:</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。</p>
<h3 id="CSS-规则匹配"><a href="#CSS-规则匹配" class="headerlink" title="CSS 规则匹配"></a>CSS 规则匹配</h3><p>CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。</p>
<p>CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/92.png" alt="92"><br>匹配的流程图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/93.png" alt="93"></p>
<h3 id="设置-style"><a href="#设置-style" class="headerlink" title="设置 style"></a>设置 style</h3><p>设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style-&gt;inheritFrom(*state.parentStyle())</span><br><span class="line">matchUARules(collector);</span><br><span class="line">matchAuthorRules(*state.element(), collector);</span><br></pre></td></tr></table></figure>

<p>在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (const CSSSelector* selector = this; selector;</span><br><span class="line">     selector = selector-&gt;tagHistory()) &#123; </span><br><span class="line">  temp = total + selector-&gt;specificityForOneSelector();</span><br><span class="line">&#125;</span><br><span class="line">return total;</span><br></pre></td></tr></table></figure>

<p>每个不同类型的 selector 的优先级如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">switch (m_match) &#123;</span><br><span class="line">    case Id: </span><br><span class="line">      return 0x010000;</span><br><span class="line">    case PseudoClass:</span><br><span class="line">      return 0x000100;</span><br><span class="line">    case Class:</span><br><span class="line">    case PseudoElement:</span><br><span class="line">    case AttributeExact:</span><br><span class="line">    case AttributeSet:</span><br><span class="line">    case AttributeList:</span><br><span class="line">    case AttributeHyphen:</span><br><span class="line">    case AttributeContain:</span><br><span class="line">    case AttributeBegin:</span><br><span class="line">    case AttributeEnd:</span><br><span class="line">      return 0x000100;</span><br><span class="line">    case Tag:</span><br><span class="line">      return 0x000001;</span><br><span class="line">    case Unknown:</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 id 的优先级最大是 0x010000 = 65536，类，属性，伪类优先级是 0x000100 = 256，标签是 0x000001 = 1</p>
<p>举个优先级计算的例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*优先级为257 = 265 + 1*/</span><br><span class="line">.text h1&#123;</span><br><span class="line">    font-size: 8em;</span><br><span class="line">&#125;</span><br><span class="line">/*优先级为65537 = 65536 + 1*/</span><br><span class="line">#my-text h1&#123;</span><br><span class="line">    font-size: 16em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。</p>
<p>目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。</p>
<p>排序规则</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline bool compareRules(const MatchedRule&amp; matchedRule1,</span><br><span class="line">                                const MatchedRule&amp; matchedRule2) &#123;</span><br><span class="line">  unsigned specificity1 = matchedRule1.specificity();</span><br><span class="line">  unsigned specificity2 = matchedRule2.specificity();</span><br><span class="line">  if (specificity1 != specificity2)</span><br><span class="line">    return specificity1 &lt; specificity2;</span><br><span class="line"> </span><br><span class="line">  return matchedRule1.position() &lt; matchedRule2.position();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则和优先级完后就开始设置元素的 style 了：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">applyMatchedPropertiesAndCustomPropertyAnimations(</span><br><span class="line">        state, collector.matchedResult(), element);</span><br><span class="line"></span><br><span class="line">applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</span><br><span class="line">      state, matchResult.allRules(), false, applyInheritedOnly, needsApplyPass);</span><br><span class="line">  for (auto range : ImportantAuthorRanges(matchResult)) &#123;</span><br><span class="line">    applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</span><br><span class="line">        state, range, true, applyInheritedOnly, needsApplyPass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/14.png" alt="14"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/15.png" alt="15"></p>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。</p>
<p>W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore/page/DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-window-interface).</span><br><span class="line">[NewObject] MediaQueryList matchMedia(CSSOMString query);</span><br><span class="line">[Replaceable] readonly attribute Screen screen; // FIXME: Should be [SameObject].</span><br><span class="line"></span><br><span class="line">// Browsing context (CSSOM-View).</span><br><span class="line">void moveTo(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line">void moveBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line">void resizeTo(optional unrestricted float width = NaN, optional unrestricted float height = NaN); // Parameters should be mandatory and of type long.</span><br><span class="line">void resizeBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line"></span><br><span class="line">// Viewport (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute long innerHeight;</span><br><span class="line">[Replaceable] readonly attribute long innerWidth;</span><br><span class="line"></span><br><span class="line">// Viewport scrolling (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute double scrollX;</span><br><span class="line">[Replaceable, ImplementedAs=scrollX] readonly attribute double pageXOffset;</span><br><span class="line">[Replaceable] readonly attribute double scrollY;</span><br><span class="line">[Replaceable, ImplementedAs=scrollY] readonly attribute double pageYOffset;</span><br><span class="line">[ImplementedAs=scrollTo] void scroll(optional ScrollToOptions options);</span><br><span class="line">[ImplementedAs=scrollTo] void scroll(unrestricted double x, unrestricted double y);</span><br><span class="line">void scrollTo(optional ScrollToOptions options);</span><br><span class="line">void scrollTo(unrestricted double x, unrestricted double y);</span><br><span class="line">void scrollBy(optional ScrollToOptions option);</span><br><span class="line">void scrollBy(unrestricted double x, unrestricted double y);</span><br><span class="line"></span><br><span class="line">// Client (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute long screenX;</span><br><span class="line">[Replaceable] readonly attribute long screenY;</span><br><span class="line">[Replaceable] readonly attribute long outerWidth;</span><br><span class="line">[Replaceable] readonly attribute long outerHeight;</span><br><span class="line">[Replaceable] readonly attribute double devicePixelRatio;</span><br></pre></td></tr></table></figure>

<p>可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。</p>
<h2 id="RenderObject-Tree"><a href="#RenderObject-Tree" class="headerlink" title="RenderObject Tree"></a>RenderObject Tree</h2><p>当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。</p>
<p>整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/64.png" alt="64"><br>上图所示，WebKit 会先检查 DOM 节点是否需要新的  RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。</p>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>RenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/88.png" alt="88"></p>
<p>RenderObject 被创建时创建时相关的类如下图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/62.png" alt="62"><br>Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/89.png" alt="89"></p>
<p>RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/63.png" alt="63"></p>
<p>RenderObject 核心对象关系图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/94.png" alt="94"></p>
<p>RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。</p>
<p>RenderObject 的继承关系图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/76.png" alt="76"></p>
<p>RenderObject 的一些主要虚函数</p>
<ul>
<li>parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。</li>
<li>layout()，style()，enclosingBox() 这些计算和获取布局的函数。</li>
<li>isASubClass 类似这样判断那种子类类型的函数。</li>
<li>paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。</li>
</ul>
<p>RenderObject 用来构建 Render Tree 的相关方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RenderElement* parent() const &#123; return m_parent; &#125;</span><br><span class="line">bool isDescendantOf(const RenderObject*) const;</span><br><span class="line"></span><br><span class="line">RenderObject* previousSibling() const &#123; return m_previous; &#125;</span><br><span class="line">RenderObject* nextSibling() const &#123; return m_next; &#125;</span><br><span class="line"></span><br><span class="line">// Use RenderElement versions instead.</span><br><span class="line">virtual RenderObject* firstChildSlow() const &#123; return nullptr; &#125;</span><br><span class="line">virtual RenderObject* lastChildSlow() const &#123; return nullptr; &#125;</span><br><span class="line"></span><br><span class="line">RenderObject* nextInPreOrder() const;</span><br><span class="line">RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;</span><br><span class="line">RenderObject* nextInPreOrderAfterChildren() const;</span><br><span class="line">RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;</span><br><span class="line">RenderObject* previousInPreOrder() const;</span><br><span class="line">RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;</span><br><span class="line">WEBCORE_EXPORT RenderObject* childAt(unsigned) const;</span><br><span class="line"></span><br><span class="line">RenderObject* firstLeafChild() const;</span><br><span class="line">RenderObject* lastLeafChild() const;</span><br></pre></td></tr></table></figure>

<p>RenderObject 用来布局相关的方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool needsLayout() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()</span><br><span class="line">        || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool selfNeedsLayout() const &#123; return m_bitfields.needsLayout(); &#125;</span><br><span class="line">bool needsPositionedMovementLayout() const &#123; return m_bitfields.needsPositionedMovementLayout(); &#125;</span><br><span class="line">bool needsPositionedMovementLayoutOnly() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()</span><br><span class="line">        &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool posChildNeedsLayout() const &#123; return m_bitfields.posChildNeedsLayout(); &#125;</span><br><span class="line">bool needsSimplifiedNormalFlowLayout() const &#123; return m_bitfields.needsSimplifiedNormalFlowLayout(); &#125;</span><br><span class="line">bool normalChildNeedsLayout() const &#123; return m_bitfields.normalChildNeedsLayout(); &#125;</span><br></pre></td></tr></table></figure>

<p>RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。</p>
<p>RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。</p>
<p>RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。</p>
<p>RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。</p>
<p>RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/95.png" alt="95"><br>RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。</p>
<p>RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/96.png" alt="96"></p>
<h3 id="StyleResolver"><a href="#StyleResolver" class="headerlink" title="StyleResolver"></a>StyleResolver</h3><p>RenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/61.png" alt="61"></p>
<p>规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/60.png" alt="60"><br>创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle = 0, StyleSharingBehavior = AllowStyleSharing,  </span><br><span class="line">    RuleMatchingBehavior = MatchAllRules, RenderRegion* regionForStyling = 0);   </span><br><span class="line"> ......  </span><br><span class="line">  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle);  </span><br><span class="line">  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForPage(int pageIndex);  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement();  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForText(Text*);  </span><br><span class="line">  </span><br><span class="line">static PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* = 0);</span><br></pre></td></tr></table></figure>

<p>StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。</p>
<h3 id="styleForElement-进行-CSS-选择和匹配"><a href="#styleForElement-进行-CSS-选择和匹配" class="headerlink" title="styleForElement 进行 CSS 选择和匹配"></a>styleForElement 进行 CSS 选择和匹配</h3><p>具体代码实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//保存 element</span><br><span class="line">initElement(element);</span><br><span class="line">initForStyleResolve(element, defaultParent);  </span><br><span class="line">....  </span><br><span class="line"></span><br><span class="line">//规则匹配  </span><br><span class="line">MatchResult matchResult;  </span><br><span class="line">if (matchingBehavior == MatchOnlyUserAgentRules)  </span><br><span class="line">    matchUARules(matchResult);  </span><br><span class="line">else  </span><br><span class="line">    matchAllRules(matchResult, matchingBehavior != MatchAllRulesExcludingSMIL);  </span><br><span class="line"></span><br><span class="line">//将规则和 element 做映射</span><br><span class="line">applyMatchedProperties(matchResult, element);</span><br><span class="line"></span><br><span class="line">//matchUARules</span><br><span class="line">void StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules)  </span><br><span class="line">&#123;</span><br><span class="line">    m_matchedRules.clear();</span><br><span class="line">    result.ranges.lastUARule = result.matchedProperties.size() - 1;</span><br><span class="line">    //收集匹配规则</span><br><span class="line">    collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, false);  </span><br><span class="line">	//规则排序</span><br><span class="line">    sortAndTransferMatchedRules(result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RuleSet"><a href="#RuleSet" class="headerlink" title="RuleSet"></a>RuleSet</h3><p>matchUARules 的 RuleSet 代表 CSS 规则，比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; background : red; &#125;</span><br></pre></td></tr></table></figure>

<p>RuleSet 的成员变量</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RuleSet ... &#123;</span><br><span class="line">.....</span><br><span class="line">AtomRuleMap m_idRules;</span><br><span class="line">AtomRuleMap m_classRules;</span><br><span class="line">AtomRuleMap m_tagRules;</span><br><span class="line">AtomRuleMap m_shadowPseudoElementRules;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sortAndTransferMatchedRules 是为了保证正确的匹配顺序。</p>
<p>RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void StyledElement::rebuildPresentationAttributeStyle()  </span><br><span class="line">&#123;  </span><br><span class="line">.....  </span><br><span class="line">  </span><br><span class="line">    RefPtr&lt;StylePropertySet&gt; style;</span><br><span class="line">    if (cacheHash &amp;&amp; cacheIterator-&gt;value) &#123;  </span><br><span class="line">        style = cacheIterator-&gt;value-&gt;value;  </span><br><span class="line">        presentationAttributeCacheCleaner().didHitPresentationAttributeCache();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        style = StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode);  </span><br><span class="line">        unsigned size = attributeCount();  </span><br><span class="line">        for (unsigned i = 0; i &lt; size; ++i) &#123;  </span><br><span class="line">            const Attribute* attribute = attributeItem(i);  </span><br><span class="line">            collectStyleForPresentationAttribute(*attribute, style.get());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // ImmutableElementAttributeData doesn&apos;t store presentation attribute style, so make sure we have a MutableElementAttributeData.  </span><br><span class="line">    ElementAttributeData* attributeData = mutableAttributeData();  </span><br><span class="line">  </span><br><span class="line">    attributeData-&gt;m_presentationAttributeStyleIsDirty = false;  </span><br><span class="line">    attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? 0 : style);  </span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。</p>
<h3 id="Render-tree-和-DOM-tree-做对应"><a href="#Render-tree-和-DOM-tree-做对应" class="headerlink" title="Render tree 和 DOM tree 做对应"></a>Render tree 和 DOM tree 做对应</h3><p>其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。</p>
<p>有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/65.png" alt="65"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/73.png" alt="73"></p>
<p>上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。</p>
<h3 id="构建-Render-Tree-的流程"><a href="#构建-Render-Tree-的流程" class="headerlink" title="构建 Render Tree 的流程"></a>构建 Render Tree 的流程</h3><p>解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。</p>
<h3 id="RenderLayer-Tree"><a href="#RenderLayer-Tree" class="headerlink" title="RenderLayer Tree"></a>RenderLayer Tree</h3><p>RenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件：</p>
<ul>
<li>HTMLElement 节点对应的 RenderBlock 节点。</li>
<li>有设置 relative，absolute，transform 的 CSS position 属性的。</li>
<li>透明效果的 RenderObject 节点。</li>
<li>节点有 overflow， apha mask 或反射效果的 RenderObject 节点。</li>
<li>设置了 CSS filter 属性的节点。</li>
<li>使用 Canvas 或 WebGL 的 RenderObject 节点。</li>
<li>Video 节点对应的 RenderObject 节点。</li>
</ul>
<p>RenderObject Tree 和 RenderLayer Tree 的关系如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/66.png" alt="66"><br>接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/67.png" alt="67"></p>
<h3 id="style-计算"><a href="#style-计算" class="headerlink" title="style 计算"></a>style 计算</h3><p>构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。</p>
<p>这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。</p>
<p>我们先看看 style 计算可能会有一些什么样问题</p>
<ul>
<li>Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。</li>
<li>如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。</li>
<li>应用规则涉及到比较复杂的层级规则。</li>
</ul>
<p>下面来说下如何解决这些问题</p>
<h4 id="共享-style-数据"><a href="#共享-style-数据" class="headerlink" title="共享 style 数据"></a>共享 style 数据</h4><p>WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的</p>
<ul>
<li>element 必须有相同的鼠标状态</li>
<li>都没有 id</li>
<li>tag 名能匹配上</li>
<li>class 属性能匹配上</li>
<li>一组映射的属性是相同的</li>
<li>链接状态能匹配上</li>
<li>focus 状态能匹配上</li>
<li>任何 element 都不会被属性 selectors 影响</li>
<li>elements 不能有 inline style 属性</li>
<li>不要使用兄弟 selectors</li>
</ul>
<h4 id="Rule-tree"><a href="#Rule-tree" class="headerlink" title="Rule tree"></a>Rule tree</h4><p>WebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/70.png" alt="70"></p>
<p>通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。</p>
<h4 id="可确定样式分到各个-structs-里"><a href="#可确定样式分到各个-structs-里" class="headerlink" title="可确定样式分到各个 structs 里"></a>可确定样式分到各个 structs 里</h4><p>一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。</p>
<p>rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。</p>
<h4 id="使用-rule-tree-计算-style-contexts"><a href="#使用-rule-tree-计算-style-contexts" class="headerlink" title="使用 rule tree 计算 style contexts"></a>使用 rule tree 计算 style contexts</h4><p>当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。</p>
<p>从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree  上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。</p>
<p>如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。</p>
<p>如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。</p>
<p>看个例子</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"err"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div1"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">                          this is a <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"big"</span>&gt;</span> big error <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">                          this is also a</span><br><span class="line">                          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"big"</span>&gt;</span> very  big  error<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> error</span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"err"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div2"</span>&gt;</span>another error<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是 CSS 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div &#123;margin:5px;color:black&#125;</span><br><span class="line">.err &#123;color:red&#125;</span><br><span class="line">.big &#123;margin-top:3px&#125;</span><br><span class="line">div span &#123;margin-bottom:4px&#125;</span><br><span class="line">#div1 &#123;color:blue&#125;</span><br><span class="line">#div2 &#123;color:green&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/71.png" alt="71"></p>
<p>context tree：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/72.png" alt="72"></p>
<p>假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。</p>
<p>现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。</p>
<p>已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。</p>
<p>对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。</p>
<p>如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。</p>
<h4 id="比较容易匹配的-rules"><a href="#比较容易匹配的-rules" class="headerlink" title="比较容易匹配的 rules"></a>比较容易匹配的 rules</h4><p>下面是不同的 style rules 的来源：</p>
<ul>
<li><p>CSS rules，来自于 style sheets 或者在 style elements 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Inline style 属性</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 视觉属性</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">"blue"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。</p>
<p>如果是 class name 那么会添加到 class map 里。</p>
<p>这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。</p>
<p>下面举个例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.error &#123;color:red&#125;</span><br><span class="line">#messageDiv &#123;height:50px&#125;</span><br><span class="line">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。</p>
<p>对于下面的 HTML</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>an error occurred <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">" messageDiv"</span>&gt;</span>this is a message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure>

<p>selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。</p>
<h4 id="Style-sheet-的-cascade-排序"><a href="#Style-sheet-的-cascade-排序" class="headerlink" title="Style sheet 的 cascade 排序"></a>Style sheet 的 cascade 排序</h4><p>一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。</p>
<ul>
<li>浏览器的设置</li>
<li>用户的设置</li>
<li>网页里普通的设置</li>
<li>网页里重要的设置</li>
<li>用户重要的设置</li>
</ul>
<h4 id="CSS-specification"><a href="#CSS-specification" class="headerlink" title="CSS specification"></a>CSS specification</h4><p>selector 的 specifity 在 w3c 里有定义 <a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/cascade.html#specificity</a></p>
<p>计算方法如下</p>
<ul>
<li>style attribute 数量 =a</li>
<li>ID attribute 数量 =b</li>
<li>其它的 attribute 和 pseudo-classes 数量 =c</li>
<li>element names 和 pseudo-element 数量 =d</li>
</ul>
<p>举个例子</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> *             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span><br><span class="line"> li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span><br><span class="line"> li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line"> ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line"> ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span><br><span class="line"> h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span><br><span class="line"> ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span><br><span class="line"> li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span><br><span class="line"> #x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line"> style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">HEAD</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">STYLE</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span></span><br><span class="line">  #x97z &#123; color: red &#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">STYLE</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">P</span> <span class="hljs-attr">ID</span>=<span class="hljs-string">x97z</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: green"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。</p>
<h4 id="Rules-排序"><a href="#Rules-排序" class="headerlink" title="Rules 排序"></a>Rules 排序</h4><p>这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 = r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。</p>
<p>HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。</p>
<p>Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。</p>
<h3 id="Layout-处理过程"><a href="#Layout-处理过程" class="headerlink" title="Layout 处理过程"></a>Layout 处理过程</h3><p>完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FrameView:: layout( bool allowSubtree) // 栈 顶 </span><br><span class="line">Document:: implicitClose() </span><br><span class="line">FrameLoader:: checkCallImplicitClose() </span><br><span class="line">FrameLoader:: checkCompleted() </span><br><span class="line">FrameLoader:: finishedParsing() </span><br><span class="line">Document:: finishedParsing() </span><br><span class="line">HTMLParser:: finished() </span><br><span class="line">HTMLTokenizer:: end() </span><br><span class="line">HTMLTokenizer:: finish() </span><br><span class="line">Document:: finishParsing() </span><br><span class="line">FrameLoader:: endIfNotLoadingMainResource() </span><br><span class="line">FrameLoader:: end() </span><br><span class="line">DocumentLoader:: finishedLoading() </span><br><span class="line">FrameLoader:: finishedLoading() </span><br><span class="line">MainResourceLoader:: didFinishLoading() </span><br><span class="line">ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h)</span><br></pre></td></tr></table></figure>

<p>layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line">void FrameView::layout(bool allowSubtree)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());</span><br><span class="line"></span><br><span class="line">    LOG(Layout, &quot;FrameView %p (%dx%d) layout, main frameview %d, allowSubtree=%d&quot;, this, size().width(), size().height(), frame().isMainFrame(), allowSubtree);</span><br><span class="line">    //判断是否已在 layout 过程中，避免多次 layout</span><br><span class="line">    if (isInRenderTreeLayout()) &#123;</span><br><span class="line">        LOG(Layout, &quot;  in layout, bailing&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (layoutDisallowed()) &#123;</span><br><span class="line">        LOG(Layout, &quot;  layout is disallowed, bailing&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Protect the view from being deleted during layout (in recalcStyle).</span><br><span class="line">    Ref&lt;FrameView&gt; protectedThis(*this);</span><br><span class="line"></span><br><span class="line">    // Many of the tasks performed during layout can cause this function to be re-entered,</span><br><span class="line">    // so save the layout phase now and restore it on exit.</span><br><span class="line">    SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout);</span><br><span class="line"></span><br><span class="line">    // Every scroll that happens during layout is programmatic.</span><br><span class="line">    SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span><br><span class="line"></span><br><span class="line">    bool inChildFrameLayoutWithFrameFlattening = isInChildFrameWithFrameFlattening();</span><br><span class="line"></span><br><span class="line">    if (inChildFrameLayoutWithFrameFlattening) &#123;</span><br><span class="line">        if (!m_frameFlatteningViewSizeForMediaQuery) &#123;</span><br><span class="line">            LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; snapshotting size &quot; &lt;&lt;  ScrollView::layoutSize() &lt;&lt; &quot; for media queries&quot;);</span><br><span class="line">            m_frameFlatteningViewSizeForMediaQuery = ScrollView::layoutSize();</span><br><span class="line">        &#125;</span><br><span class="line">        startLayoutAtMainFrameViewIfNeeded(allowSubtree);</span><br><span class="line">        //获取 root。这个 root 就是 RenderView 对象</span><br><span class="line">        RenderElement* root = m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView();</span><br><span class="line">        if (!root || !root-&gt;needsLayout())</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TraceScope tracingScope(LayoutStart, LayoutEnd);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    if (updateFixedPositionLayoutRect())</span><br><span class="line">        allowSubtree = false;</span><br><span class="line">#endif</span><br><span class="line">    //也是避免多次触发，会把 layoutTimer 先停止</span><br><span class="line">    m_layoutTimer.stop();</span><br><span class="line">    m_delayedLayout = false;</span><br><span class="line">    m_setNeedsLayoutWasDeferred = false;</span><br><span class="line">    </span><br><span class="line">    //我们不应该在 painting 时进入 layout</span><br><span class="line">    ASSERT(!isPainting());</span><br><span class="line">    if (isPainting())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willLayout(frame());</span><br><span class="line">    AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());</span><br><span class="line">    </span><br><span class="line">    if (!allowSubtree &amp;&amp; m_layoutRoot)</span><br><span class="line">        convertSubtreeLayoutToFullLayout();</span><br><span class="line"></span><br><span class="line">    ASSERT(frame().view() == this);</span><br><span class="line">    ASSERT(frame().document());</span><br><span class="line"></span><br><span class="line">    Document&amp; document = *frame().document();</span><br><span class="line">    ASSERT(document.pageCacheState() == Document::NotInPageCache);</span><br><span class="line">    //对样式先进行更新</span><br><span class="line">    &#123;</span><br><span class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</span><br><span class="line"></span><br><span class="line">        if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) &#123;</span><br><span class="line">            // This is a new top-level layout. If there are any remaining tasks from the previous</span><br><span class="line">            // layout, finish them now.</span><br><span class="line">            SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</span><br><span class="line">            performPostLayoutTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_layoutPhase = InPreLayoutStyleUpdate;</span><br><span class="line"></span><br><span class="line">        // Viewport-dependent media queries may cause us to need completely different style information.</span><br><span class="line">        auto* styleResolver = document.styleScope().resolverIfExists();</span><br><span class="line">        if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) &#123;</span><br><span class="line">            LOG(Layout, &quot;  hasMediaQueriesAffectedByViewportChange, enqueueing style recalc&quot;);</span><br><span class="line">            document.styleScope().didChangeStyleSheetEnvironment();</span><br><span class="line">            // FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds.</span><br><span class="line">            InspectorInstrumentation::mediaQueryResultChanged(document);</span><br><span class="line">        &#125;</span><br><span class="line">        document.evaluateMediaQueryList();</span><br><span class="line">        // If there is any pagination to apply, it will affect the RenderView&apos;s style, so we should</span><br><span class="line">        // take care of that now.</span><br><span class="line">        applyPaginationToViewport();</span><br><span class="line">        // Always ensure our style info is up-to-date. This can happen in situations where</span><br><span class="line">        // the layout beats any sort of style recalc update that needs to occur.</span><br><span class="line">        document.updateStyleIfNeeded();</span><br><span class="line">        // If there is only one ref to this view left, then its going to be destroyed as soon as we exit,</span><br><span class="line">        // so there&apos;s no point to continuing to layout</span><br><span class="line">        if (hasOneRef())</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        // Close block here so we can set up the font cache purge preventer, which we will still</span><br><span class="line">        // want in scope even after we want m_layoutSchedulingEnabled to be restored again.</span><br><span class="line">        // The next block sets m_layoutSchedulingEnabled back to false once again.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPreLayout;</span><br><span class="line"></span><br><span class="line">    RenderLayer* layer = nullptr;</span><br><span class="line">    bool subtree = false;</span><br><span class="line">    RenderElement* root = nullptr;</span><br><span class="line"></span><br><span class="line">    ++m_nestedLayoutCount;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</span><br><span class="line"></span><br><span class="line">        autoSizeIfEnabled();</span><br><span class="line">        //重新设置 RenderView 对象，准备开始 layout</span><br><span class="line">        root = m_layoutRoot ? m_layoutRoot : document.renderView();</span><br><span class="line">        if (!root)</span><br><span class="line">            return;</span><br><span class="line">        subtree = m_layoutRoot;</span><br><span class="line"></span><br><span class="line">        if (!m_layoutRoot) &#123;</span><br><span class="line">            auto* body = document.bodyOrFrameset();</span><br><span class="line">            if (body &amp;&amp; body-&gt;renderer()) &#123;</span><br><span class="line">                if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) &#123;</span><br><span class="line">                    body-&gt;renderer()-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125; else if (is&lt;HTMLBodyElement&gt;(*body)) &#123;</span><br><span class="line">                    if (!m_firstLayout &amp;&amp; m_size.height() != layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport())</span><br><span class="line">                        body-&gt;renderer()-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#if !LOG_DISABLED</span><br><span class="line">            if (m_firstLayout &amp;&amp; !frame().ownerElement())</span><br><span class="line">                LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs\n&quot;, this, document.timeSinceDocumentCreation().value());</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_needsFullRepaint = !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing());</span><br><span class="line"></span><br><span class="line">        if (!subtree) &#123;</span><br><span class="line">            ScrollbarMode hMode;</span><br><span class="line">            ScrollbarMode vMode;    </span><br><span class="line">            calculateScrollbarModesForLayout(hMode, vMode);</span><br><span class="line"></span><br><span class="line">            if (m_firstLayout || (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())) &#123;</span><br><span class="line">                if (m_firstLayout) &#123;</span><br><span class="line">                    setScrollbarsSuppressed(true);</span><br><span class="line"></span><br><span class="line">                    m_firstLayout = false;</span><br><span class="line">                    m_firstLayoutCallbackPending = true;</span><br><span class="line">                    m_lastViewportSize = sizeForResizeEvent();</span><br><span class="line">                    m_lastZoomFactor = root-&gt;style().zoom();</span><br><span class="line"></span><br><span class="line">                    // Set the initial vMode to AlwaysOn if we&apos;re auto.</span><br><span class="line">                    if (vMode == ScrollbarAuto)</span><br><span class="line">                        setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.</span><br><span class="line">                    // Set the initial hMode to AlwaysOff if we&apos;re auto.</span><br><span class="line">                    if (hMode == ScrollbarAuto)</span><br><span class="line">                        setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.</span><br><span class="line">                    Page* page = frame().page();</span><br><span class="line">                    if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span><br><span class="line">                        scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span><br><span class="line">                    setScrollbarModes(hMode, vMode);</span><br><span class="line">                    setScrollbarsSuppressed(false, true);</span><br><span class="line">                &#125; else</span><br><span class="line">                    setScrollbarModes(hMode, vMode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LayoutSize oldSize = m_size;</span><br><span class="line">            m_size = layoutSize();</span><br><span class="line"></span><br><span class="line">            if (oldSize != m_size) &#123;</span><br><span class="line">                LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat());</span><br><span class="line">                m_needsFullRepaint = true;</span><br><span class="line">                if (!m_firstLayout) &#123;</span><br><span class="line">                    RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;</span><br><span class="line">                    auto* body = document.bodyOrFrameset();</span><br><span class="line">                    RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;</span><br><span class="line">                    if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())</span><br><span class="line">                        bodyRenderer-&gt;setChildNeedsLayout();</span><br><span class="line">                    else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())</span><br><span class="line">                        rootRenderer-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_layoutPhase = InPreLayout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layer = root-&gt;enclosingLayer();</span><br><span class="line">        SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot);</span><br><span class="line"></span><br><span class="line">        RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view());</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InPreLayout);</span><br><span class="line">        m_layoutPhase = InRenderTreeLayout;</span><br><span class="line"></span><br><span class="line">        forceLayoutParentViewIfNeeded();</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">        RenderTreeNeedsLayoutChecker checker(*root);</span><br><span class="line">#endif</span><br><span class="line">        //从 RenderView 这个根级开始进行 layout。</span><br><span class="line">        root-&gt;layout();</span><br><span class="line">        ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());</span><br><span class="line"></span><br><span class="line">#if ENABLE(TEXT_AUTOSIZING)</span><br><span class="line">        if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) &#123;</span><br><span class="line">            float minimumZoomFontSize = frame().settings().minimumZoomFontSize();</span><br><span class="line">            float textAutosizingWidth = frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0;</span><br><span class="line">            if (int overrideWidth = frame().settings().textAutosizingWindowSizeOverride().width())</span><br><span class="line">                textAutosizingWidth = overrideWidth;</span><br><span class="line"></span><br><span class="line">            LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);</span><br><span class="line">            </span><br><span class="line">            if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) &#123;</span><br><span class="line">                root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);</span><br><span class="line">                if (root-&gt;needsLayout())</span><br><span class="line">                    root-&gt;layout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</span><br><span class="line">        m_layoutRoot = nullptr;</span><br><span class="line">        // Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InViewSizeAdjust;</span><br><span class="line"></span><br><span class="line">    bool neededFullRepaint = m_needsFullRepaint;</span><br><span class="line"></span><br><span class="line">    if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) &#123;</span><br><span class="line">        adjustViewSize();</span><br><span class="line">        // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by</span><br><span class="line">        // navigating away from the current document (see webkit.org/b/173329).</span><br><span class="line">        if (hasOneRef())</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPostLayout;</span><br><span class="line"></span><br><span class="line">    m_needsFullRepaint = neededFullRepaint;</span><br><span class="line"></span><br><span class="line">    // Now update the positions of all layers.</span><br><span class="line">    if (m_needsFullRepaint)</span><br><span class="line">        root-&gt;view().repaintRootContents();</span><br><span class="line"></span><br><span class="line">    root-&gt;view().releaseProtectedRenderWidgets();</span><br><span class="line"></span><br><span class="line">    ASSERT(!root-&gt;needsLayout());</span><br><span class="line"></span><br><span class="line">    layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint));</span><br><span class="line"></span><br><span class="line">    updateCompositingLayersAfterLayout();</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPostLayerPositionsUpdatedAfterLayout;</span><br><span class="line"></span><br><span class="line">    m_layoutCount++;</span><br><span class="line"></span><br><span class="line">#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)</span><br><span class="line">    if (AXObjectCache* cache = root-&gt;document().existingAXObjectCache())</span><br><span class="line">        cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if ENABLE(DASHBOARD_SUPPORT)</span><br><span class="line">    updateAnnotatedRegions();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if ENABLE(IOS_TOUCH_EVENTS)</span><br><span class="line">    document.setTouchEventRegionsNeedUpdate();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    updateCanBlitOnScrollRecursively();</span><br><span class="line"></span><br><span class="line">    handleDeferredScrollUpdateAfterContentSizeChange();</span><br><span class="line"></span><br><span class="line">    handleDeferredScrollbarsUpdateAfterDirectionChange();</span><br><span class="line"></span><br><span class="line">    if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER))</span><br><span class="line">        updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());</span><br><span class="line"></span><br><span class="line">    frame().document()-&gt;markers().invalidateRectsForAllMarkers();</span><br><span class="line"></span><br><span class="line">    if (!m_postLayoutTasksTimer.isActive()) &#123;</span><br><span class="line">        if (!m_inSynchronousPostLayout) &#123;</span><br><span class="line">            if (inChildFrameLayoutWithFrameFlattening)</span><br><span class="line">                updateWidgetPositions();</span><br><span class="line">            else &#123;</span><br><span class="line">                SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</span><br><span class="line">                performPostLayoutTasks(); // Calls resumeScheduledEvents().</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) &#123;</span><br><span class="line">            // If we need layout or are already in a synchronous call to postLayoutTasks(), </span><br><span class="line">            // defer widget updates and event dispatch until after we return. postLayoutTasks()</span><br><span class="line">            // can make us need to update again, and we can get stuck in a nasty cycle unless</span><br><span class="line">            // we call it through the timer here.</span><br><span class="line">            m_postLayoutTasksTimer.startOneShot(0_s);</span><br><span class="line">        &#125;</span><br><span class="line">        if (needsLayout())</span><br><span class="line">            layout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InspectorInstrumentation::didLayout(cookie, *root);</span><br><span class="line">    DebugPageOverlays::didLayout(frame());</span><br><span class="line"></span><br><span class="line">    --m_nestedLayoutCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void RenderView::layoutContent(const LayoutState&amp; state)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_PARAM(state);</span><br><span class="line">    ASSERT(needsLayout());</span><br><span class="line"></span><br><span class="line">    RenderBlockFlow::layout();</span><br><span class="line">    if (hasRenderNamedFlowThreads())</span><br><span class="line">        flowThreadController().layoutRenderNamedFlowThreads();</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">    checkLayoutState(state);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(needsLayout());</span><br><span class="line">    //当不需要布局子节点同时能 simplifiedLayout 重新布局成功</span><br><span class="line">    if (!relayoutChildren &amp;&amp; simplifiedLayout())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    LayoutRepainter repainter(*this, checkForRepaintDuringLayout());</span><br><span class="line">    //重新计算逻辑宽度</span><br><span class="line">    if (recomputeLogicalWidthAndColumnWidth())</span><br><span class="line">        relayoutChildren = true;</span><br><span class="line"></span><br><span class="line">    rebuildFloatingObjectSetFromIntrudingFloats();</span><br><span class="line"></span><br><span class="line">    //先保留一份以前的高度为后面做对比用</span><br><span class="line">    LayoutUnit previousHeight = logicalHeight();</span><br><span class="line">    // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),</span><br><span class="line">    // for consistency with other render classes?</span><br><span class="line">    //然后将 logicalHeight 设置为 0，避免累加以前的。</span><br><span class="line">    setLogicalHeight(0);</span><br><span class="line"></span><br><span class="line">    bool pageLogicalHeightChanged = false;</span><br><span class="line">    checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);</span><br><span class="line"></span><br><span class="line">    const RenderStyle&amp; styleToUse = style();</span><br><span class="line">    LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);</span><br><span class="line"></span><br><span class="line">    preparePaginationBeforeBlockLayout(relayoutChildren);</span><br><span class="line">    if (!relayoutChildren)</span><br><span class="line">        relayoutChildren = namedFlowFragmentNeedsUpdate();</span><br><span class="line"></span><br><span class="line">    // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track</span><br><span class="line">    // our current maximal positive and negative margins. These values are used when we</span><br><span class="line">    // are collapsed with adjacent blocks, so for example, if you have block A and B</span><br><span class="line">    // collapsing together, then you&apos;d take the maximal positive margin from both A and B</span><br><span class="line">    // and subtract it from the maximal negative margin from both A and B to get the</span><br><span class="line">    // true collapsed margin. This algorithm is recursive, so when we finish layout()</span><br><span class="line">    // our block knows its current maximal positive/negative values.</span><br><span class="line">    //</span><br><span class="line">    // Start out by setting our margin values to our current margins. Table cells have</span><br><span class="line">    // no margins, so we don&apos;t fill in the values for table cells.</span><br><span class="line">    bool isCell = isTableCell();</span><br><span class="line">    if (!isCell) &#123;</span><br><span class="line">        initMaxMarginValues();</span><br><span class="line">        </span><br><span class="line">        setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());</span><br><span class="line">        setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());</span><br><span class="line">        setPaginationStrut(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutUnit repaintLogicalTop = 0;</span><br><span class="line">    LayoutUnit repaintLogicalBottom = 0;</span><br><span class="line">    LayoutUnit maxFloatLogicalBottom = 0;</span><br><span class="line">    if (!firstChild() &amp;&amp; !isAnonymousBlock())</span><br><span class="line">        setChildrenInline(true);</span><br><span class="line">    //Inline 和 Block 的不同布局处理</span><br><span class="line">    if (childrenInline())</span><br><span class="line">        layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span><br><span class="line">    else</span><br><span class="line">        layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);</span><br><span class="line"></span><br><span class="line">    // Expand our intrinsic height to encompass floats.</span><br><span class="line">    LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();</span><br><span class="line">    if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())</span><br><span class="line">        setLogicalHeight(lowestFloatLogicalBottom() + toAdd);</span><br><span class="line">    </span><br><span class="line">    if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) &#123;</span><br><span class="line">        ASSERT(!shouldBreakAtLineToAvoidWidow());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Calculate our new height. 计算新高</span><br><span class="line">    LayoutUnit oldHeight = logicalHeight();</span><br><span class="line">    LayoutUnit oldClientAfterEdge = clientLogicalBottom();</span><br><span class="line"></span><br><span class="line">    // Before updating the final size of the flow thread make sure a forced break is applied after the content.</span><br><span class="line">    // This ensures the size information is correctly computed for the last auto-height region receiving content.</span><br><span class="line">    if (is&lt;RenderFlowThread&gt;(*this))</span><br><span class="line">        downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);</span><br><span class="line"></span><br><span class="line">    updateLogicalHeight();</span><br><span class="line">    LayoutUnit newHeight = logicalHeight();</span><br><span class="line">    if (oldHeight != newHeight) &#123;</span><br><span class="line">        if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) &#123;</span><br><span class="line">            // One of our children&apos;s floats may have become an overhanging float for us. We need to look for it.</span><br><span class="line">            for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) &#123;</span><br><span class="line">                if (blockFlow.isFloatingOrOutOfFlowPositioned())</span><br><span class="line">                    continue;</span><br><span class="line">                if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)</span><br><span class="line">                    addOverhangingFloats(blockFlow, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点</span><br><span class="line">    bool heightChanged = (previousHeight != newHeight);</span><br><span class="line">    if (heightChanged)</span><br><span class="line">        relayoutChildren = true;</span><br><span class="line"></span><br><span class="line">    layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());</span><br><span class="line"></span><br><span class="line">    //Add overflow from children (unless we&apos;re multi-column, since in that case all our child overflow is clipped anyway).</span><br><span class="line">    computeOverflow(oldClientAfterEdge);</span><br><span class="line">    </span><br><span class="line">    statePusher.pop();</span><br><span class="line"></span><br><span class="line">    fitBorderToLinesIfNeeded();</span><br><span class="line"></span><br><span class="line">    if (view().layoutState()-&gt;m_pageLogicalHeight)</span><br><span class="line">        setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop()));</span><br><span class="line"></span><br><span class="line">    updateLayerTransform();</span><br><span class="line"></span><br><span class="line">    // Update our scroll information if we&apos;re overflow:auto/scroll/hidden now that we know if</span><br><span class="line">    // we overflow or not.</span><br><span class="line">    updateScrollInfoAfterLayout();</span><br><span class="line"></span><br><span class="line">    // FIXME: This repaint logic should be moved into a separate helper function!</span><br><span class="line">    // Repaint with our new bounds if they are different from our old bounds.</span><br><span class="line">    bool didFullRepaint = repainter.repaintAfterLayout();</span><br><span class="line">    if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) &#123;</span><br><span class="line">        // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines</span><br><span class="line">        // it had to lay out. We wouldn&apos;t need the hasOverflowClip() hack in that case either.</span><br><span class="line">        LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();</span><br><span class="line">        LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();</span><br><span class="line">        if (hasOverflowClip()) &#123;</span><br><span class="line">            // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&apos;t propagate to our block&apos;s overflow.</span><br><span class="line">            // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.</span><br><span class="line">            // layoutInlineChildren should be patched to compute the entire repaint rect.</span><br><span class="line">            repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());</span><br><span class="line">            repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LayoutRect repaintRect;</span><br><span class="line">        if (isHorizontalWritingMode())</span><br><span class="line">            repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);</span><br><span class="line">        else</span><br><span class="line">            repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);</span><br><span class="line"></span><br><span class="line">        if (hasOverflowClip()) &#123;</span><br><span class="line">            // Adjust repaint rect for scroll offset</span><br><span class="line">            repaintRect.moveBy(-scrollPosition());</span><br><span class="line"></span><br><span class="line">            // Don&apos;t allow this rect to spill out of our overflow box.</span><br><span class="line">            repaintRect.intersect(LayoutRect(LayoutPoint(), size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure the rect is still non-empty after intersecting for overflow above</span><br><span class="line">        if (!repaintRect.isEmpty()) &#123;</span><br><span class="line">            repaintRectangle(repaintRect); // We need to do a partial repaint of our content.</span><br><span class="line">            if (hasReflection())</span><br><span class="line">                repaintRectangle(reflectedRect(repaintRect));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearNeedsLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。</p>
<h3 id="Layout-Tree-创建"><a href="#Layout-Tree-创建" class="headerlink" title="Layout Tree 创建"></a>Layout Tree 创建</h3><p>Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是<a href="https://skia.org/" target="_blank" rel="noopener">Skia</a> 开源 2D 图形库做底层 Paint 引擎。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Document::finishedParsing() &#123;</span><br><span class="line">      updateStyleAndLayoutTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 Node 都会创建一个 LayoutObject，</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutObject* newLayoutObject = m_node-&gt;createLayoutObject(style);</span><br><span class="line">parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject);</span><br></pre></td></tr></table></figure>

<h3 id="Layout-值的计算"><a href="#Layout-值的计算" class="headerlink" title="Layout 值的计算"></a>Layout 值的计算</h3><p>Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)</span><br><span class="line">&#123;</span><br><span class="line">    LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();</span><br><span class="line">    LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();</span><br><span class="line"></span><br><span class="line">    // The child is a normal flow object. Compute the margins we will use for collapsing now.</span><br><span class="line">    child.computeAndSetBlockDirectionMargins(*this);</span><br><span class="line"></span><br><span class="line">    // Try to guess our correct logical top position. In most cases this guess will</span><br><span class="line">    // be correct. Only if we&apos;re wrong (when we compute the real logical top position)</span><br><span class="line">    // will we have to potentially relayout.</span><br><span class="line">    LayoutUnit estimateWithoutPagination;</span><br><span class="line">    //估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标</span><br><span class="line">    LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);</span><br><span class="line"></span><br><span class="line">    // Cache our old rect so that we can dirty the proper repaint rects if the child moves.</span><br><span class="line">    LayoutRect oldRect = child.frameRect();</span><br><span class="line">    LayoutUnit oldLogicalTop = logicalTopForChild(child);</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">    LayoutSize oldLayoutDelta = view().layoutDelta();</span><br><span class="line">#endif</span><br><span class="line">    // Position the child as though it didn&apos;t collapse with the top.</span><br><span class="line">    //先设置布局前 top 坐标</span><br><span class="line">    setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);</span><br><span class="line">    estimateRegionRangeForBoxChild(child);</span><br><span class="line"></span><br><span class="line">    RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;</span><br><span class="line">    bool markDescendantsWithFloats = false;</span><br><span class="line">    if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">        markDescendantsWithFloats = true;</span><br><span class="line">    else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))</span><br><span class="line">        // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for</span><br><span class="line">        // very large elements. If it does the comparison with oldLogicalTop might yield a</span><br><span class="line">        // false negative as adding and removing margins, borders etc from a saturated number</span><br><span class="line">        // might yield incorrect results. If this is the case always mark for layout.</span><br><span class="line">        markDescendantsWithFloats = true;</span><br><span class="line">    else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) &#123;</span><br><span class="line">        // If an element might be affected by the presence of floats, then always mark it for</span><br><span class="line">        // layout.</span><br><span class="line">        LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());</span><br><span class="line">        if (fb &gt; logicalTopEstimate)</span><br><span class="line">            markDescendantsWithFloats = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (childBlockFlow) &#123;</span><br><span class="line">        if (markDescendantsWithFloats)</span><br><span class="line">            childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</span><br><span class="line">        if (!child.isWritingModeRoot())</span><br><span class="line">            previousFloatLogicalBottom = std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child.markForPaginationRelayoutIfNeeded();</span><br><span class="line"></span><br><span class="line">    bool childHadLayout = child.everHadLayout();</span><br><span class="line">    //对子节点进行布局</span><br><span class="line">    bool childNeededLayout = child.needsLayout();</span><br><span class="line">    if (childNeededLayout)</span><br><span class="line">        child.layout();</span><br><span class="line"></span><br><span class="line">    // Cache if we are at the top of the block right now.</span><br><span class="line">    bool atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();</span><br><span class="line"></span><br><span class="line">    //保证 top 坐标和子节点布局后能够同步</span><br><span class="line">    // Now determine the correct ypos based off examination of collapsing margin</span><br><span class="line">    // values.</span><br><span class="line">    LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);</span><br><span class="line"></span><br><span class="line">    // Now check for clear.</span><br><span class="line">    LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);</span><br><span class="line">    </span><br><span class="line">    bool paginated = view().layoutState()-&gt;isPaginated();</span><br><span class="line">    if (paginated)</span><br><span class="line">        logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);</span><br><span class="line"></span><br><span class="line">    //经过上面的子节点布局完后重新计算得到新高</span><br><span class="line">    setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);</span><br><span class="line"></span><br><span class="line">    // Now we have a final top position. See if it really does end up being different from our estimate.</span><br><span class="line">    // clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&apos;t move. This happens</span><br><span class="line">    // when collapseMargins dynamically adds overhanging floats because of a child with negative margins.</span><br><span class="line">    if (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) &#123;</span><br><span class="line">        if (child.shrinkToAvoidFloats()) &#123;</span><br><span class="line">            // The child&apos;s width depends on the line width. When the child shifts to clear an item, its width can</span><br><span class="line">            // change (because it has more available line width). So mark the item as dirty.</span><br><span class="line">            child.setChildNeedsLayout(MarkOnlyThis);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (childBlockFlow) &#123;</span><br><span class="line">            if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">                childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</span><br><span class="line">            child.markForPaginationRelayoutIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (updateRegionRangeForBoxChild(child))</span><br><span class="line">        child.setNeedsLayout(MarkOnlyThis);</span><br><span class="line"></span><br><span class="line">    // In case our guess was wrong, relayout the child.</span><br><span class="line">    child.layoutIfNeeded();</span><br><span class="line"></span><br><span class="line">    // We are no longer at the top of the block if we encounter a non-empty child.  </span><br><span class="line">    // This has to be done after checking for clear, so that margins can be reset if a clear occurred.</span><br><span class="line">    if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())</span><br><span class="line">        marginInfo.setAtBeforeSideOfBlock(false);</span><br><span class="line"></span><br><span class="line">    // Now place the child in the correct left position</span><br><span class="line">    //计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。</span><br><span class="line">    determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);</span><br><span class="line"></span><br><span class="line">    // Update our height now that the child has been placed in the correct position.</span><br><span class="line">    setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));</span><br><span class="line">    if (mustSeparateMarginAfterForChild(child)) &#123;</span><br><span class="line">        setLogicalHeight(logicalHeight() + marginAfterForChild(child));</span><br><span class="line">        marginInfo.clearMargin();</span><br><span class="line">    &#125;</span><br><span class="line">    // If the child has overhanging floats that intrude into following siblings (or possibly out</span><br><span class="line">    // of this block), then the parent gets notified of the floats now.</span><br><span class="line">    if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">        maxFloatLogicalBottom = std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));</span><br><span class="line"></span><br><span class="line">    LayoutSize childOffset = child.location() - oldRect.location();</span><br><span class="line">    if (childOffset.width() || childOffset.height()) &#123;</span><br><span class="line">        view().addLayoutDelta(childOffset);</span><br><span class="line"></span><br><span class="line">        // If the child moved, we have to repaint it as well as any floating/positioned</span><br><span class="line">        // descendants. An exception is if we need a layout. In this case, we know we&apos;re going to</span><br><span class="line">        // repaint ourselves (and the child) anyway.</span><br><span class="line">        if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())</span><br><span class="line">            child.repaintDuringLayoutIfMoved(oldRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //渲染</span><br><span class="line">    if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) &#123;</span><br><span class="line">        child.repaint();</span><br><span class="line">        child.repaintOverhangingFloats(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (paginated) &#123;</span><br><span class="line">        if (RenderFlowThread* flowThread = flowThreadContainingBlock())</span><br><span class="line">            flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child);</span><br><span class="line">        // Check for an after page/column break.</span><br><span class="line">        LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);</span><br><span class="line">        if (newHeight != height())</span><br><span class="line">            setLogicalHeight(newHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(view().layoutDeltaMatches(oldLayoutDelta));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断值的类型是固定值还是百分比的方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch (length.type()) &#123;</span><br><span class="line">  case Fixed:</span><br><span class="line">    return LayoutUnit(length.value()); //返回 LayoutUnit 封装的数据 1px = 1 &lt;&lt; 6 = 64 unit</span><br><span class="line">  case Percent:</span><br><span class="line">    //maximumValue 是传进来的最大值</span><br><span class="line">    return LayoutUnit(</span><br><span class="line">        static_cast&lt;float&gt;(maximumValue * length.percent() / 100.0f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算 margin 的值</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CSS 2.1: &quot;If both &apos;margin-left&apos; and &apos;margin-right&apos; are &apos;auto&apos;, their used</span><br><span class="line">// values are equal. This horizontally centers the element with respect to</span><br><span class="line">// the edges of the containing block.&quot;</span><br><span class="line">const ComputedStyle&amp; containingBlockStyle = containingBlock-&gt;styleRef();</span><br><span class="line">if (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) &#123;</span><br><span class="line">  LayoutUnit centeredMarginBoxStart = std::max(</span><br><span class="line">      LayoutUnit(),</span><br><span class="line">      (availableWidth - childWidth) / 2); </span><br><span class="line">  marginStart = centeredMarginBoxStart;</span><br><span class="line">  marginEnd = availableWidth - childWidth - marginStart;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Box Model 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_frameRect.setWidth(width);</span><br><span class="line">m_marginBox.setStart(marginLeft);</span><br></pre></td></tr></table></figure>

<p>经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First line.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>Second one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>布局计算后带布局信息的 Render Tree 如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RenderBlock &#123;HTML&#125; at (0, 0) size 640x480 </span><br><span class="line">|—— RenderBody &#123;BODY&#125; at (0, 80) size 640x480 [bgcolor=# FFFFFF] </span><br><span class="line">| |—— RenderBlock &#123;P&#125; at (0, 0) size 640x80 </span><br><span class="line">| | |—— RenderText &#123;#text&#125; at (0, 0) size 48x24 &quot;First line.&quot; </span><br><span class="line">| | |—— RenderBR &#123;BR&#125; at (20, 20) size 0x0 </span><br><span class="line">| | |—— RenderText &#123;#text&#125; at (0, 24) size 48x24 &quot;Second one.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Box-Model-数据结构"><a href="#Box-Model-数据结构" class="headerlink" title="Box Model 数据结构"></a>Box Model 数据结构</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/16.png" alt="16"><br>所有的 elements 都有 display 属性用来确定显示类型。属性值有</p>
<ul>
<li>block：生成一个 block box</li>
<li>inline：生成一个或多个 inline boxes</li>
<li>none：不生成 box</li>
</ul>
<p>默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：<a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/sample.html</a></p>
<h4 id="定位的方案"><a href="#定位的方案" class="headerlink" title="定位的方案"></a>定位的方案</h4><p>有三种方案</p>
<ul>
<li>Normal：由 render tree 来决定的位置。</li>
<li>Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。</li>
<li>Absolute：让其在 render tree 的位置和 DOM tree 不一样</li>
</ul>
<p>定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。</p>
<p>对于 float 的处理，首先需要判断宽度是否需要 fit content</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool LayoutBox::sizesLogicalWidthToFitContent(</span><br><span class="line">    const Length&amp; logicalWidth) const &#123;</span><br><span class="line">  if (isFloating() || isInlineBlockOrInlineTable())</span><br><span class="line">    return true;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。</p>
<p>对于 float:left 的计算</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束</span><br><span class="line">while (logicalRightOffsetForPositioningFloat(</span><br><span class="line">           logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) -</span><br><span class="line">           floatLogicalLeft &lt;</span><br><span class="line">       floatLogicalWidth) &#123;</span><br><span class="line">  //下移</span><br><span class="line">  logicalTopOffset +=</span><br><span class="line">      std::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight);</span><br><span class="line">  //新的 floatLogicalLeft</span><br><span class="line">  floatLogicalLeft = logicalLeftOffsetForPositioningFloat(</span><br><span class="line">      logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值</span><br><span class="line">floatLogicalLeft = std::max(</span><br><span class="line">    logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);</span><br></pre></td></tr></table></figure>

<h4 id="Box-类型"><a href="#Box-类型" class="headerlink" title="Box 类型"></a>Box 类型</h4><p>Block box：在浏览器的 window 里有自己的矩形<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/20.png" alt="20"></p>
<p>Inline box：没有自己的 block，但是会在一个 block 里<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/21.png" alt="21"></p>
<p>Block 是按照垂直排列，Inline 是按照水平来排列<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/22.png" alt="22"></p>
<p>Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/23.png" alt="23"></p>
<p>下面举个例子看看 Inline  类型的例子，比如有如下的 html：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First line.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>Second one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段 html 的 Render Tree 如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/97.png" alt="97"></p>
<h4 id="Position-类型"><a href="#Position-类型" class="headerlink" title="Position 类型"></a>Position 类型</h4><p>Relative：相对定位，先按照正常的定位然后根据设置的值再移动。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/24.png" alt="24"></p>
<p>Float：会被移动到左边或右边侧<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/25.png" alt="25"></p>
<p>Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/26.png" alt="26"></p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">STYLE</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span></span><br><span class="line">    div &#123; </span><br><span class="line">        position: absolute; </span><br><span class="line">        left: 2in; </span><br><span class="line">        top: 2in; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">STYLE</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DIV</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DIV</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/27.png" alt="27"></p>
<p>可以看到层级是按照 z-index 来排的。</p>
<h4 id="大小的计算"><a href="#大小的计算" class="headerlink" title="大小的计算"></a>大小的计算</h4><p>border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// More IE extensions.  clientWidth and clientHeight represent the interior of</span><br><span class="line">// an object excluding border and scrollbar.</span><br><span class="line">LayoutUnit LayoutBox::clientWidth() const &#123;</span><br><span class="line">  return m_frameRect.width() - borderLeft() - borderRight() -</span><br><span class="line">         verticalScrollbarWidth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>offsetWidth  是 frameRect 的宽度</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// IE extensions. Used to calculate offsetWidth/Height.</span><br><span class="line">LayoutUnit offsetWidth() const override &#123; return m_frameRect.width(); &#125;</span><br><span class="line">LayoutUnit offsetHeight() const override &#123; return m_frameRect.height(); &#125;</span><br></pre></td></tr></table></figure>

<p>Margin 区域是用 LayoutRectOutsets </p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LayoutUnit m_top;</span><br><span class="line">LayoutUnit m_right;</span><br><span class="line">LayoutUnit m_bottom;</span><br><span class="line">LayoutUnit m_left;</span><br></pre></td></tr></table></figure>

<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置的计算，即 x 和 y 是通过下面两个函数计算得到</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据 margin 得到 y 值</span><br><span class="line">LayoutUnit logicalTopBeforeClear =</span><br><span class="line">    collapseMargins(child, layoutInfo, childIsSelfCollapsing,</span><br><span class="line">                    childDiscardMarginBefore, childDiscardMarginAfter);</span><br><span class="line">// 得到 x 值</span><br><span class="line">determineLogicalLeftPositionForChild(child);</span><br></pre></td></tr></table></figure>

<p>计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。</p>
<blockquote>
<p> <a href="https://github.com/ming1016/study/wiki" target="_blank" rel="noopener">ming1016</a></p>
</blockquote>

        </div>
        
        
        
        <div class="social-share"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-info donate">
    <span class="icon is-small">
        <i class="fab fa-alipay"></i>
    </span>
    <span>支付宝</span>
    <div class="qrcode"><img src="/images/alipay.png" alt="支付宝"></div>
</a>

                
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/wechat.jpg" alt="微信"></div>
</a>

                
                <!-- Visit https://www.paypal.com/donate/buttons/ to get your donate button -->

<a class="button is-warning donate" onclick="document.getElementById(&#39;paypal-donate-form&#39;).submit()">
    <span class="icon is-small">
        <i class="fab fa-paypal"></i>
    </span>
    <span>Paypal</span>
</a>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" id="paypal-donate-form">
    <input type="hidden" name="cmd" value="_donations">
    <input type="hidden" name="business" value="buy@policx.com">
    <input type="hidden" name="currency_code" value="USD">
</form>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2016/06/18/javascriptcore/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">深入剖析-JavaScriptCore</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2016/06/18/clang-llvm/">
                <span class="level-item">深入剖析-iOS-编译-Clang---LLVM</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        <!-- 
<script>
    var disqus_config = function () {
        this.page.url = 'https://www.policx.com/2016/06/18/webkit/';
        this.page.identifier = '2016/06/18/webkit/';
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'policx' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div> -->

<link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>
    var dsqjs = new DisqusJS({
        shortname: 'policx',
        siteName: '',
        identifier: '',
        url: '',
        title: '',
        api: 'https://disqus.skk.moe/disqus/',
        apikey: 'yKpZ790nbB7UbaNpYxRZogQQi7HmsXTlv4XxHbvM8TEk7tdrddQKwPILq4WScQBz',
        admin: '',
        adminLabel: ''
    });
</script>
    </div>
</div>
</div>
                

<!-- 粘贴的部分 -->

<!-- 修改，可选保留的栏 -->




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
    
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="张良计">
                    
                    
                    <p class="is-size-4 is-block">
                        张良计
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        heal the world
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Helsinki-Suomi</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        92
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        3
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        7
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://996.icu" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://developer.apple.com/">
                
                <i class="fab fa-apple"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Facebook" href="https://docs.python.org/zh-cn/3.7/whatsnew/3.7.html">
                
                <i class="fab fa-python"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Twitter" href="https://nodejs.org/zh-cn/">
                
                <i class="fab fa-node-js"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Dribbble" href="https://developer.android.google.cn/">
                
                <i class="fab fa-android"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
    
    
    
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/Django/" style="font-size: 12.5px;">Django</a> <a href="/tags/Hexo/" style="font-size: 12.5px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Python/" style="font-size: 17.5px;">Python</a> <a href="/tags/git/" style="font-size: 12.5px;">git</a> <a href="/tags//" style="font-size: 20px;"></a>
    </div>
</div>

    
    

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="http://t.cn/AiOmxPZU" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Markdown</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/Re0wbzP" target="_blank">
                    <span class="level-left">
                        <span class="level-item">源代码图片</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/RLs3BSV" target="_blank">
                    <span class="level-left">
                        <span class="level-item">HEXO</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/AiOmM16n" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Easy Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/EJ3xzUk" target="_blank">
                    <span class="level-left">
                        <span class="level-item">图库</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/E6aRKaM" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Swift</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/R9X5EQw" target="_blank">
                    <span class="level-left">
                        <span class="level-item">阅后即焚</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/EMFRvKO" target="_blank">
                    <span class="level-left">
                        <span class="level-item">Linux命令大全(手册)</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="http://t.cn/AiW5GvnM" target="_blank">
                    <span class="level-left">
                        <span class="level-item">张良计</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">t.cn</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
    
    <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/07/16/flutter/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/07/16/5d2da57fca83996078.png" alt="flutter">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-07-16T10:14:18.000Z">2019-07-16</time></div>
                    <a href="/2019/07/16/flutter/" class="has-link-black-ter is-size-6">flutter</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/07/15/spider/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/07/16/5d2d5059794e137401.jpg" alt="Python爬虫">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-07-15T02:06:04.000Z">2019-07-15</time></div>
                    <a href="/2019/07/15/spider/" class="has-link-black-ter is-size-6">Python爬虫</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/07/14/ddos/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/07/14/5d2ad9be1666f71074.jpeg" alt="DDoS（分布式拒绝服务）攻击是无解的吗？">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-07-14T07:26:43.000Z">2019-07-14</time></div>
                    <a href="/2019/07/14/ddos/" class="has-link-black-ter is-size-6">DDoS（分布式拒绝服务）攻击是无解的吗？</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/07/14/node/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/07/15/5d2c49fe7e01233711.jpg" alt="Node.js">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-07-13T16:06:04.000Z">2019-07-14</time></div>
                    <a href="/2019/07/14/node/" class="has-link-black-ter is-size-6">Node.js</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/07/11/Front-matter/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/og_image.png" alt="front-matter">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-07-11T15:14:18.000Z">2019-07-11</time></div>
                    <a href="/2019/07/11/Front-matter/" class="has-link-black-ter is-size-6">front-matter</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/life/">
            <span class="level-start">
                <span class="level-item">life</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">14</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/news/">
            <span class="level-start">
                <span class="level-item">news</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programing/">
            <span class="level-start">
                <span class="level-item">programing</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">15</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
        
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">七月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">8</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">六月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/05/">
                <span class="level-start">
                    <span class="level-item">五月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/09/">
                <span class="level-start">
                    <span class="level-item">九月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">六月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/05/">
                <span class="level-start">
                    <span class="level-item">五月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/04/">
                <span class="level-start">
                    <span class="level-item">四月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/03/">
                <span class="level-start">
                    <span class="level-item">三月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/02/">
                <span class="level-start">
                    <span class="level-item">二月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">7</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/09/">
                <span class="level-start">
                    <span class="level-item">九月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/08/">
                <span class="level-start">
                    <span class="level-item">八月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/06/">
                <span class="level-start">
                    <span class="level-item">六月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/03/">
                <span class="level-start">
                    <span class="level-item">三月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/02/">
                <span class="level-start">
                    <span class="level-item">二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/01/">
                <span class="level-start">
                    <span class="level-item">一月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/10/">
                <span class="level-start">
                    <span class="level-item">十月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/08/">
                <span class="level-start">
                    <span class="level-item">八月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/07/">
                <span class="level-start">
                    <span class="level-item">七月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/06/">
                <span class="level-start">
                    <span class="level-item">六月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">21</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/03/">
                <span class="level-start">
                    <span class="level-item">三月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/02/">
                <span class="level-start">
                    <span class="level-item">二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/01/">
                <span class="level-start">
                    <span class="level-item">一月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/09/">
                <span class="level-start">
                    <span class="level-item">九月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/06/">
                <span class="level-start">
                    <span class="level-item">六月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/09/">
                <span class="level-start">
                    <span class="level-item">九月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/08/">
                <span class="level-start">
                    <span class="level-item">八月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/06/">
                <span class="level-start">
                    <span class="level-item">六月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/05/">
                <span class="level-start">
                    <span class="level-item">五月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/03/">
                <span class="level-start">
                    <span class="level-item">三月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2013/07/">
                <span class="level-start">
                    <span class="level-item">七月 2013</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Django/">
                        <span class="tag">Django</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Hexo/">
                        <span class="tag">Hexo</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Linux/">
                        <span class="tag">Linux</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Markdown/">
                        <span class="tag">Markdown</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags//">
                        <span class="tag"></span>
                        <span class="tag is-grey">18</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
    </div>
    
</div>

                

<!-- 粘贴的部分 -->

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                    
                    <img src="https://api.netlify.com/api/v1/badges/463de27d-503e-4e61-9352-dbdf036876b6/deploy-status" alt="深入剖析-WebKit" height="28">
                    
                </a>
                <p class="is-size-7">
                    &copy; 2019 policx&nbsp;
                    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> 🌏 <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                    
                    <br>
                    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
                    本站总访问量-<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>-次 |
                    您是第-<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>-位访客
                    <br>
                    <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
                    <script>
                        var now = new Date();
                        function createtime() {
                            var grt = new Date("06/01/2019 00:00:00");//此处修改你的建站时间或者网站上线时间 
                            now.setTime(now.getTime() + 250);
                            days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                            hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                            if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
                            mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
                            seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                            snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
                            document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
                            document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
                        }
                        setInterval("createtime()", 250);
                    </script>
                    
                </p>
            </div>
            <div class="level-end">
                
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                    <img src="https://tool.lu/netcard/" height="80px" width="200px">
                    <script type="text/javascript" src="//rf.revolvermaps.com/0/0/2.js?i=5llb4uunz4b&amp;m=6&amp;s=130&amp;c=ff0000&amp;t=1" async="async"></script>
                </div>
                
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>