<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>江湖</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta property="og:type" content="website">
<meta property="og:title" content="江湖">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="江湖">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="江湖">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.gif" alt="江湖" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://www.2345.com/?k.cn">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-image">
        <a href="/2016/06/18/webkit/" class="image is-7by1">
            <img class="thumbnail" src="https://www.policx.com/talk/images/banner.jpg" alt="深入剖析-WebKit">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-06-18T02:00:59.000Z">2016-06-18</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 小时 读完 (大约 31433 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/06/18/webkit/">深入剖析-WebKit</a>
            
        </h1>
        <div class="content">
            <h2 id="HTML-标准"><a href="#HTML-标准" class="headerlink" title="HTML 标准"></a>HTML 标准</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>HTML DOM 树的插入状态规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode</a></li>
<li>HTML Tokenize 规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a> <a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="noopener">https://dev.w3.org/html5/spec-preview/tokenization.html</a></li>
<li>HTMLElement 堆栈规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a></li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。</p>
<p>1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。</p>
<p>1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。</p>
<p>1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。</p>
<p>2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。</p>
<p>2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。</p>
<p>2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio / video 音频视频，3D/graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。</p>
<p>完整的浏览器发展史可以在这里看：<a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>
<h2 id="WebKit-全貌"><a href="#WebKit-全貌" class="headerlink" title="WebKit 全貌"></a>WebKit 全貌</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。<br>先看看它的大模块：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/45.png" alt="45"><br>WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/46.png" alt="46"><br>整个 WebKit 架构，如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/49.png" alt="49"><br>实线部分是共享的，虚线部分会根据不同的平台有不同的实现。</p>
<p>下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/74.png" alt="74"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/01.png" alt="01"></p>
<p>解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。</p>
<p>DOM Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/02.png" alt="02"><br>从网页 URL 到构建完 DOM 树的过程如图<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/47.png" alt="47"></p>
<p>CSS Rule Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/03.png" alt="03"></p>
<p>通过上面的两个数构造的 Style Context Tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/04.png" alt="04"></p>
<p>浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/48.png" alt="48"></p>
<p>计算每个 Node 的位置，执行 Layout 过程<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/05.png" alt="05"></p>
<p>Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。</p>
<h3 id="WebKit-源代码结构说明"><a href="#WebKit-源代码结构说明" class="headerlink" title="WebKit 源代码结构说明"></a>WebKit 源代码结构说明</h3><ul>
<li>JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。</li>
<li>WebCore：浏览器渲染引擎，包含了各个核心模块。</li>
<li>WebCore/css：CSS 解释器，CSS 规则等。</li>
<li>WebCore/dom：各种 DOM 元素和 DOM Tree 结构相关的类。</li>
<li>WebCore/html：HTML 解释器和各种 HTML 元素等相关内容。</li>
<li>WebCore/rendering：Render Object 相关，还有页面渲染的样式和布局等。</li>
<li>WebCore/inspector：网页调试工具。</li>
<li>WebCore/loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。</li>
<li>WebCore/page：页面相关的操作，页面结构和交互事件等。</li>
<li>WebCore/platform：各个平台相关的代码，比如 iOS，Mac 等</li>
<li>WebCore/storage：存储相关，比如 WebStorage，Index DB 等接口的实现。</li>
<li>WebCore/workers：Worker 线程封装，提供 JS 多线程执行环境。</li>
<li>WebCore/xml：XML 相关比如 XML Parser，XPath，XSLT 等。</li>
<li>WebCore/accessibility：图形控件访问接口。</li>
<li>WebCore/bindings：DOM 元素和 JS 绑定的接口。</li>
<li>WebCore/bridge：C，JavaScript 和 Objective-C 的桥接。</li>
<li>WebCore/editing：页面编辑相关，比如 DOM 修改，拼写检查等。</li>
<li>WebCore/history：Page Cache 实现前进后退浏览记录等。</li>
<li>WebCore/mathml：数学表达式在网页中的规范代码实现。</li>
<li>WebCore/plugins：NPPlugin 的支持接口</li>
<li>WebCore/svg：矢量图形的支持。</li>
<li>WebKit：平台相关的接口，每个目录都是不同的平台接口实现。</li>
<li>WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。</li>
<li>DumpRenderTree：用于生成 RenderTree</li>
<li>TestWebKitAPI：测试 WebKit 的 API 的测试代码</li>
</ul>
<h3 id="WebKit-代码风格"><a href="#WebKit-代码风格" class="headerlink" title="WebKit 代码风格"></a>WebKit 代码风格</h3><ul>
<li>内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。</li>
<li>代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。</li>
<li>代码编写风格：可以在官网查看到：<a href="https://webkit.org/code-style-guidelines/" target="_blank" rel="noopener">https://webkit.org/code-style-guidelines/</a> 想给 WebKit 做贡献的同学们可以好好看看了。</li>
</ul>
<h3 id="WebKit-的设计模式"><a href="#WebKit-的设计模式" class="headerlink" title="WebKit 的设计模式"></a>WebKit 的设计模式</h3><p>下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。</p>
<ul>
<li>单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。</li>
<li>工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。</li>
<li>观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。</li>
<li>组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。</li>
<li>命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。</li>
</ul>
<h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/06.png" alt="06"></p>
<ul>
<li>Frame：中心类，通过它找其它类</li>
<li>FrameLoader：加载资源用的</li>
<li>Document：具体实现是 HTMLDocument</li>
<li>Page：窗口的操作</li>
<li>EventHandler：输入事件的处理，比如键盘，鼠标，触屏等</li>
</ul>
<h4 id="WebCore-Frame"><a href="#WebCore-Frame" class="headerlink" title="WebCore::Frame"></a>WebCore::Frame</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/29.png" alt="29"></p>
<ul>
<li>FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。</li>
<li>FrameLoader：frame 的加载</li>
<li>NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。</li>
<li>DOMWindow：管理 DOM 相关的事件，属性和消息。</li>
<li>FrameView：Frame 的排版。</li>
<li>Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。</li>
<li>ScriptController：管理 js 脚本。</li>
<li>Editor：管理页面比如 copy，paste和输入等编辑操作。</li>
<li>SelectionController：管理 Frame 里的选择操作。</li>
<li>AnimationControlle：动画控制。</li>
<li>EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。</li>
</ul>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/43.png" alt="43"><br>上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/44.png" alt="44"></p>
<h3 id="Frame-的主要接口"><a href="#Frame-的主要接口" class="headerlink" title="Frame 的主要接口"></a>Frame 的主要接口</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(page);</span><br><span class="line">    ASSERT(client);</span><br><span class="line">    return adoptRef(*new Frame(*page, ownerElement, *client));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。<br>初始调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webPage::setView</span><br><span class="line">webPage::setViewportSize</span><br><span class="line">webPage::mainFrame</span><br><span class="line">webPagePrivate::createMainFrame</span><br><span class="line">webFrameData::webFrameData</span><br><span class="line">Frame::create</span><br></pre></td></tr></table></figure>

<p>解析中发现 iframe 时的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FrameLoader::finishedLoading</span><br><span class="line">HTMLDocumentParser::append</span><br><span class="line">HTMLTreeBuilder::processToken</span><br><span class="line">HTMLElementBase::openURL</span><br><span class="line">SubFrameLoader::requestFrame</span><br><span class="line">FrameLoaderClient::creatFrame</span><br><span class="line">webFrameData::webFrameData</span><br><span class="line">Frame::create</span><br></pre></td></tr></table></figure>

<h4 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">void Frame::createView(const IntSize&amp; viewportSize, const Color&amp; backgroundColor, bool transparent,</span><br><span class="line">    const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,</span><br><span class="line">    bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,</span><br><span class="line">    ScrollbarMode verticalScrollbarMode, bool verticalLock)</span><br></pre></td></tr></table></figure>

<p>会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。<br>调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">FrameLoader::commitProvisionalLoad</span><br><span class="line">FrameLoader::transitionToCommitted</span><br><span class="line">FrameLoaderClient::transitionToCommittedForNewPage</span><br><span class="line">Frame::createView</span><br></pre></td></tr></table></figure>

<h4 id="setDocument"><a href="#setDocument" class="headerlink" title="setDocument"></a>setDocument</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)</span><br></pre></td></tr></table></figure>

<p>用来关联 Frame 和 Document 对象<br>Frame 初始化调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">WebFrame::webFrame</span><br><span class="line">webFramePrivate::init</span><br><span class="line">Frame::init</span><br><span class="line">FrameLoader::init</span><br><span class="line">DocumentWriter::begin</span><br><span class="line">Frame::setDocument</span><br></pre></td></tr></table></figure>

<p>js 脚本更改数据时的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c++</span><br><span class="line">DocumentLoader::receivedData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">FrameLoaderClient::committedLoad</span><br><span class="line">DocumentLoader::commitData</span><br><span class="line">DocumentWriter::setEncoding</span><br><span class="line">DocumentWriter::willSetEncoding</span><br><span class="line">FrameLoader::receivedFirstData</span><br><span class="line">DocumentWriter::begin</span><br><span class="line">FrameLoader::clear</span><br><span class="line">Frame::setDocument</span><br></pre></td></tr></table></figure>

<h2 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h2><p>全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。</p>
<h3 id="Smart-ptr-智能指针"><a href="#Smart-ptr-智能指针" class="headerlink" title="Smart ptr 智能指针"></a>Smart ptr 智能指针</h3><p>对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。</p>
<p>智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。</p>
<p>智能指针的实现方式：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPtr &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef T ValueType;</span><br><span class="line">        typedef ValueType *PtrType;</span><br><span class="line">        </span><br><span class="line">        //构造析构函数</span><br><span class="line">        SmartPtr() :m_ptr(NULL) &#123;&#125;</span><br><span class="line">        SmartPtr(PtrType ptr) :m_ptr(ptr) &#123;&#125;</span><br><span class="line">        ~SmartPtr() &#123; </span><br><span class="line">            if(m_ptr) delete m_ptr; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //拷贝构造函数</span><br><span class="line">        SmartPtr(const SmartPtr&lt;T&gt;&amp; o); //堆上分配的对象</span><br><span class="line">        template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; o);</span><br><span class="line">        </span><br><span class="line">        //拷贝赋值运算符</span><br><span class="line">        template&lt;typename U&gt; SmartPtr&amp; operator = (const SmartPtr&lt;U&gt;&amp; o);</span><br><span class="line"></span><br><span class="line">        //指针运算，是为了让智能指针在行为上更类似原生指针</span><br><span class="line">        ValueType&amp; operator*() const &#123; </span><br><span class="line">            return *m_ptr; </span><br><span class="line">        &#125;</span><br><span class="line">        PtrType operator-&gt;() const &#123;</span><br><span class="line">            return m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //逻辑运算符重载</span><br><span class="line">        //对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr)</span><br><span class="line">        bool operator!() const &#123;</span><br><span class="line">            return !m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //转成 raw ptr</span><br><span class="line">        operator PtrType() &#123;</span><br><span class="line">            return m_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    private:</span><br><span class="line">        PtrType m_ptr;</span><br><span class="line">&#125;</span><br><span class="line">//创建智能指针对象格式</span><br><span class="line">SmartPtr(new ValueType());</span><br></pre></td></tr></table></figure>

<h3 id="RefPtr"><a href="#RefPtr" class="headerlink" title="RefPtr"></a>RefPtr</h3><p>RefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF/Source/wtf/RefCounted.h 里。类模板的定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">class RefCountedBase &#123;</span><br><span class="line">public:</span><br><span class="line">    void ref() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line">        ++m_refCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool hasOneRef() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT(!m_deletionHasBegun);</span><br><span class="line">#endif</span><br><span class="line">        return m_refCount == 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned refCount() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_refCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void relaxAdoptionRequirement()</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(m_adoptionIsRequired);</span><br><span class="line">        m_adoptionIsRequired = false;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    RefCountedBase()</span><br><span class="line">        : m_refCount(1)</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        , m_deletionHasBegun(false)</span><br><span class="line">        , m_adoptionIsRequired(true)</span><br><span class="line">#endif</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~RefCountedBase()</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT(m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns whether the pointer should be freed or not.</span><br><span class="line">    bool derefBase() const</span><br><span class="line">    &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</span><br><span class="line">        ASSERT(!m_adoptionIsRequired);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        ASSERT(m_refCount);</span><br><span class="line">        unsigned tempRefCount = m_refCount - 1;</span><br><span class="line">        if (!tempRefCount) &#123;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">            m_deletionHasBegun = true;</span><br><span class="line">#endif</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        m_refCount = tempRefCount;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    bool deletionHasBegun() const</span><br><span class="line">    &#123;</span><br><span class="line">        return m_deletionHasBegun;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    friend void adopted(RefCountedBase*);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    mutable unsigned m_refCount;</span><br><span class="line">#if CHECK_REF_COUNTED_LIFECYCLE</span><br><span class="line">    mutable bool m_deletionHasBegun;</span><br><span class="line">    mutable bool m_adoptionIsRequired;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt; class RefCounted : public RefCountedBase &#123;</span><br><span class="line">    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;</span><br><span class="line">public:</span><br><span class="line">    void deref() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (derefBase())</span><br><span class="line">            delete static_cast&lt;const T*&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    RefCounted() &#123; &#125;</span><br><span class="line">    ~RefCounted()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted<class>即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。</class></p>
<h3 id="Assert-断言的实现和应用"><a href="#Assert-断言的实现和应用" class="headerlink" title="Assert 断言的实现和应用"></a>Assert 断言的实现和应用</h3><p>断言在 WTF 里是这样定义的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">#define ASSERT(assertion) do &#123; \</span><br><span class="line">    if (!(assertion)) &#123; \</span><br><span class="line">        //打印用</span><br><span class="line">        WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \</span><br><span class="line">        //重点</span><br><span class="line">        CRASH(); \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">#ifndef CRASH</span><br><span class="line">#if defined(NDEBUG) &amp;&amp; OS(DARWIN)</span><br><span class="line">// Crash with a SIGTRAP i.e EXC_BREAKPOINT.</span><br><span class="line">// We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily</span><br><span class="line">// trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.</span><br><span class="line">#define CRASH() do &#123; \</span><br><span class="line">    //直接 inline 汇编代码</span><br><span class="line">    WTFBreakpointTrap(); \</span><br><span class="line">    __builtin_unreachable(); \</span><br><span class="line">&#125; while (0)</span><br><span class="line">#else</span><br><span class="line">#define CRASH() WTFCrash()</span><br><span class="line">#endif</span><br><span class="line">#endif // !defined(CRASH)</span><br><span class="line"></span><br><span class="line">//根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏</span><br><span class="line">#if CPU(X86_64) || CPU(X86)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;int3&quot;)</span><br><span class="line">#elif CPU(ARM_THUMB2)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;bkpt #0&quot;)</span><br><span class="line">#elif CPU(ARM64)</span><br><span class="line">#define WTFBreakpointTrap()  __asm__ volatile (&quot;brk #0&quot;)</span><br><span class="line">#else</span><br><span class="line">#define WTFBreakpointTrap() WTFCrash() // Not implemented.</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">#define WTF_MAKE_FAST_ALLOCATED \</span><br><span class="line">public: \</span><br><span class="line">    void* operator new(size_t, void* p) &#123; return p; &#125; \</span><br><span class="line">    void* operator new[](size_t, void* p) &#123; return p; &#125; \</span><br><span class="line">    \</span><br><span class="line">    void* operator new(size_t size) \</span><br><span class="line">    &#123; \</span><br><span class="line">        return ::WTF::fastMalloc(size); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void operator delete(void* p) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ::WTF::fastFree(p); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void* operator new[](size_t size) \</span><br><span class="line">    &#123; \</span><br><span class="line">        return ::WTF::fastMalloc(size); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    void operator delete[](void* p) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ::WTF::fastFree(p); \</span><br><span class="line">    &#125; \</span><br><span class="line">    void* operator new(size_t, NotNullTag, void* location) \</span><br><span class="line">    &#123; \</span><br><span class="line">        ASSERT(location); \</span><br><span class="line">        return location; \</span><br><span class="line">    &#125; \</span><br><span class="line">private: \</span><br><span class="line">typedef int __thisIsHereToForceASemicolonAfterThisMacro</span><br></pre></td></tr></table></figure>

<p>这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void* fastMalloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_IS_WITHIN_LIMIT(size);</span><br><span class="line">    return bmalloc::api::malloc(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="noopener">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。</p>
<h4 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h4><p>WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">template&lt;typename T, size_t inlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, size_t minCapacity = 16, typename Malloc = FastMalloc&gt;</span><br><span class="line">class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; &#123;</span><br><span class="line">    WTF_MAKE_FAST_ALLOCATED;</span><br><span class="line">private:</span><br><span class="line">    //VectorBuffer 是内部存储数据的容器</span><br><span class="line">    typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</span><br><span class="line">    //Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里</span><br><span class="line">    typedef VectorTypeOperations&lt;T&gt; TypeOperations;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    typedef T ValueType;</span><br><span class="line">    //iterator 直接使用的原生指针</span><br><span class="line">    typedef T* iterator;</span><br><span class="line">    typedef const T* const_iterator;</span><br><span class="line">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line"></span><br><span class="line">    Vector()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Unlike in std::vector, this constructor does not initialize POD types.</span><br><span class="line">    explicit Vector(size_t size)</span><br><span class="line">        : Base(size, size)</span><br><span class="line">    &#123;</span><br><span class="line">        asanSetInitialBufferSizeTo(size);</span><br><span class="line"></span><br><span class="line">        if (begin())</span><br><span class="line">            TypeOperations::initialize(begin(), end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(size_t size, const T&amp; val)</span><br><span class="line">        : Base(size, size)</span><br><span class="line">    &#123;</span><br><span class="line">        asanSetInitialBufferSizeTo(size);</span><br><span class="line"></span><br><span class="line">        if (begin())</span><br><span class="line">            TypeOperations::uninitializedFill(begin(), end(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(std::initializer_list&lt;T&gt; initializerList)</span><br><span class="line">    &#123;</span><br><span class="line">        reserveInitialCapacity(initializerList.size());</span><br><span class="line"></span><br><span class="line">        asanSetInitialBufferSizeTo(initializerList.size());</span><br><span class="line"></span><br><span class="line">        for (const auto&amp; element : initializerList)</span><br><span class="line">            uncheckedAppend(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_size)</span><br><span class="line">            TypeOperations::destruct(begin(), end());</span><br><span class="line"></span><br><span class="line">        asanSetBufferSizeToFullCapacity(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(const Vector&amp;);</span><br><span class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span><br><span class="line">    explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    Vector&amp; operator=(const Vector&amp;);</span><br><span class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span><br><span class="line">    Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    Vector(Vector&amp;&amp;);</span><br><span class="line">    Vector&amp; operator=(Vector&amp;&amp;);</span><br><span class="line">    </span><br><span class="line">    //返回 Vector 里元素个数</span><br><span class="line">    size_t size() const &#123; return m_size; &#125;</span><br><span class="line">    static ptrdiff_t sizeMemoryOffset() &#123; return OBJECT_OFFSETOF(Vector, m_size); &#125;</span><br><span class="line">    </span><br><span class="line">    //返回的是 Vector 中的容量，容量随着元素增加和删除而变化</span><br><span class="line">    size_t capacity() const &#123; return Base::capacity(); &#125;</span><br><span class="line">    bool isEmpty() const &#123; return !size(); &#125;</span><br><span class="line">    </span><br><span class="line">    //这里提供的是数组的访问功能</span><br><span class="line">    T&amp; at(size_t i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(i &gt;= size()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; at(size_t i) const </span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(i &gt;= size()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; at(Checked&lt;size_t&gt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        RELEASE_ASSERT(i &lt; size());</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    const T&amp; at(Checked&lt;size_t&gt; i) const</span><br><span class="line">    &#123;</span><br><span class="line">        RELEASE_ASSERT(i &lt; size());</span><br><span class="line">        return Base::buffer()[i];</span><br><span class="line">    &#125;</span><br><span class="line">    //返回数组中第几个元素</span><br><span class="line">    T&amp; operator[](size_t i) &#123; return at(i); &#125;</span><br><span class="line">    const T&amp; operator[](size_t i) const &#123; return at(i); &#125;</span><br><span class="line">    T&amp; operator[](Checked&lt;size_t&gt; i) &#123; return at(i); &#125;</span><br><span class="line">    const T&amp; operator[](Checked&lt;size_t&gt; i) const &#123; return at(i); &#125;</span><br><span class="line"></span><br><span class="line">    T* data() &#123; return Base::buffer(); &#125;</span><br><span class="line">    const T* data() const &#123; return Base::buffer(); &#125;</span><br><span class="line">    static ptrdiff_t dataMemoryOffset() &#123; return Base::bufferMemoryOffset(); &#125;</span><br><span class="line">    //迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。</span><br><span class="line">    iterator begin() &#123; return data(); &#125;</span><br><span class="line">    iterator end() &#123; return begin() + m_size; &#125;</span><br><span class="line">    const_iterator begin() const &#123; return data(); &#125;</span><br><span class="line">    const_iterator end() const &#123; return begin() + m_size; &#125;</span><br><span class="line"></span><br><span class="line">    reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;</span><br><span class="line">    reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;</span><br><span class="line">    const_reverse_iterator rbegin() const &#123; return const_reverse_iterator(end()); &#125;</span><br><span class="line">    const_reverse_iterator rend() const &#123; return const_reverse_iterator(begin()); &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; first() &#123; return at(0); &#125;</span><br><span class="line">    const T&amp; first() const &#123; return at(0); &#125;</span><br><span class="line">    T&amp; last() &#123; return at(size() - 1); &#125;</span><br><span class="line">    const T&amp; last() const &#123; return at(size() - 1); &#125;</span><br><span class="line">    </span><br><span class="line">    T takeLast()</span><br><span class="line">    &#123;</span><br><span class="line">        T result = WTFMove(last());</span><br><span class="line">        removeLast();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好</span><br><span class="line">    template&lt;typename U&gt; bool contains(const U&amp;) const;</span><br><span class="line">    template&lt;typename U&gt; size_t find(const U&amp;) const;</span><br><span class="line">    template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;</span><br><span class="line">    template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;</span><br><span class="line">    </span><br><span class="line">    template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);</span><br><span class="line">    </span><br><span class="line">    //实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力</span><br><span class="line">    void shrink(size_t size);</span><br><span class="line">    void grow(size_t size);</span><br><span class="line">    void resize(size_t size);</span><br><span class="line">    void resizeToFit(size_t size);</span><br><span class="line">    void reserveCapacity(size_t newCapacity);</span><br><span class="line">    bool tryReserveCapacity(size_t newCapacity);</span><br><span class="line">    void reserveInitialCapacity(size_t initialCapacity);</span><br><span class="line">    void shrinkCapacity(size_t newCapacity);</span><br><span class="line">    void shrinkToFit() &#123; shrinkCapacity(size()); &#125;</span><br><span class="line"></span><br><span class="line">    void clear() &#123; shrinkCapacity(0); &#125;</span><br><span class="line"></span><br><span class="line">    void append(ValueType&amp;&amp; value) &#123; append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</span><br><span class="line">    template&lt;typename U&gt; void append(U&amp;&amp;);</span><br><span class="line">    template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);</span><br><span class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    void uncheckedAppend(ValueType&amp;&amp; value) &#123; uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</span><br><span class="line">    template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; void append(const U*, size_t);</span><br><span class="line">    template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);</span><br><span class="line">    template&lt;typename U&gt; bool tryAppend(const U*, size_t);</span><br><span class="line"></span><br><span class="line">    template&lt;typename U&gt; void insert(size_t position, const U*, size_t);</span><br><span class="line">    template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);</span><br><span class="line">    template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;);</span><br><span class="line"></span><br><span class="line">    void remove(size_t position);</span><br><span class="line">    void remove(size_t position, size_t length);</span><br><span class="line">    template&lt;typename U&gt; bool removeFirst(const U&amp;);</span><br><span class="line">    template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);</span><br><span class="line">    template&lt;typename U&gt; unsigned removeAll(const U&amp;);</span><br><span class="line">    template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);</span><br><span class="line"></span><br><span class="line">    void removeLast() </span><br><span class="line">    &#123;</span><br><span class="line">        if (UNLIKELY(isEmpty()))</span><br><span class="line">            OverflowHandler::overflowed();</span><br><span class="line">        shrink(size() - 1); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void fill(const T&amp;, size_t);</span><br><span class="line">    void fill(const T&amp; val) &#123; fill(val, size()); &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);</span><br><span class="line"></span><br><span class="line">    MallocPtr&lt;T&gt; releaseBuffer();</span><br><span class="line"></span><br><span class="line">    void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">#if ASAN_ENABLED</span><br><span class="line">        if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.</span><br><span class="line">            return;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // Make it possible to copy inline buffers.</span><br><span class="line">        asanSetBufferSizeToFullCapacity();</span><br><span class="line">        other.asanSetBufferSizeToFullCapacity();</span><br><span class="line"></span><br><span class="line">        Base::swap(other, m_size, other.m_size);</span><br><span class="line">        std::swap(m_size, other.m_size);</span><br><span class="line"></span><br><span class="line">        asanSetInitialBufferSizeTo(m_size);</span><br><span class="line">        other.asanSetInitialBufferSizeTo(other.m_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reverse();</span><br><span class="line"></span><br><span class="line">    void checkConsistency();</span><br><span class="line"></span><br><span class="line">    template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void expandCapacity(size_t newMinCapacity);</span><br><span class="line">    T* expandCapacity(size_t newMinCapacity, T*);</span><br><span class="line">    bool tryExpandCapacity(size_t newMinCapacity);</span><br><span class="line">    const T* tryExpandCapacity(size_t newMinCapacity, const T*);</span><br><span class="line">    template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); </span><br><span class="line">    template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);</span><br><span class="line">    template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);</span><br><span class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);</span><br><span class="line"></span><br><span class="line">    void asanSetInitialBufferSizeTo(size_t);</span><br><span class="line">    void asanSetBufferSizeToFullCapacity(size_t);</span><br><span class="line">    void asanSetBufferSizeToFullCapacity() &#123; asanSetBufferSizeToFullCapacity(size()); &#125;</span><br><span class="line"></span><br><span class="line">    void asanBufferSizeWillChangeTo(size_t);</span><br><span class="line"></span><br><span class="line">    using Base::m_size;</span><br><span class="line">    using Base::buffer;</span><br><span class="line">    using Base::capacity;</span><br><span class="line">    using Base::swap;</span><br><span class="line">    using Base::allocateBuffer;</span><br><span class="line">    using Base::deallocateBuffer;</span><br><span class="line">    using Base::tryAllocateBuffer;</span><br><span class="line">    using Base::shouldReallocateBuffer;</span><br><span class="line">    using Base::reallocateBuffer;</span><br><span class="line">    using Base::restoreInlineBufferIfNeeded;</span><br><span class="line">    using Base::releaseBuffer;</span><br><span class="line">#if ASAN_ENABLED</span><br><span class="line">    using Base::endOfBuffer;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h4><p>HashTable 实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">    template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;</span><br><span class="line">    class HashTable &#123;</span><br><span class="line">    public:</span><br><span class="line">        typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;</span><br><span class="line">        typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;</span><br><span class="line">        typedef Traits ValueTraits;</span><br><span class="line">        typedef Key KeyType;</span><br><span class="line">        typedef Value ValueType;</span><br><span class="line">        typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;</span><br><span class="line">        typedef HashTableAddResult&lt;iterator&gt; AddResult;</span><br><span class="line"></span><br><span class="line">#if DUMP_HASHTABLE_STATS_PER_TABLE</span><br><span class="line">        struct Stats &#123;</span><br><span class="line">            Stats()</span><br><span class="line">                : numAccesses(0)</span><br><span class="line">                , numRehashes(0)</span><br><span class="line">                , numRemoves(0)</span><br><span class="line">                , numReinserts(0)</span><br><span class="line">                , maxCollisions(0)</span><br><span class="line">                , numCollisions(0)</span><br><span class="line">                , collisionGraph()</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            unsigned numAccesses;</span><br><span class="line">            unsigned numRehashes;</span><br><span class="line">            unsigned numRemoves;</span><br><span class="line">            unsigned numReinserts;</span><br><span class="line"></span><br><span class="line">            unsigned maxCollisions;</span><br><span class="line">            unsigned numCollisions;</span><br><span class="line">            unsigned collisionGraph[4096];</span><br><span class="line"></span><br><span class="line">            void recordCollisionAtCount(unsigned count)</span><br><span class="line">            &#123;</span><br><span class="line">                if (count &gt; maxCollisions)</span><br><span class="line">                    maxCollisions = count;</span><br><span class="line">                numCollisions++;</span><br><span class="line">                collisionGraph[count]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            void dumpStats()</span><br><span class="line">            &#123;</span><br><span class="line">                dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);</span><br><span class="line">                dataLogF(&quot;%d accesses\n&quot;, numAccesses);</span><br><span class="line">                dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses);</span><br><span class="line">                dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);</span><br><span class="line">                for (unsigned i = 1; i &lt;= maxCollisions; i++) &#123;</span><br><span class="line">                    dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses);</span><br><span class="line">                &#125;</span><br><span class="line">                dataLogF(&quot;%d rehashes\n&quot;, numRehashes);</span><br><span class="line">                dataLogF(&quot;%d reinserts\n&quot;, numReinserts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        HashTable();</span><br><span class="line">        ~HashTable() </span><br><span class="line">        &#123;</span><br><span class="line">            invalidateIterators(); </span><br><span class="line">            if (m_table)</span><br><span class="line">                deallocateTable(m_table, m_tableSize);</span><br><span class="line">#if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION</span><br><span class="line">            m_table = (ValueType*)(uintptr_t)0xbbadbeef;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashTable(const HashTable&amp;);</span><br><span class="line">        void swap(HashTable&amp;);</span><br><span class="line">        HashTable&amp; operator=(const HashTable&amp;);</span><br><span class="line"></span><br><span class="line">        HashTable(HashTable&amp;&amp;);</span><br><span class="line">        HashTable&amp; operator=(HashTable&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        // When the hash table is empty, just return the same iterator for end as for begin.</span><br><span class="line">        // This is more efficient because we don&apos;t have to skip all the empty and deleted</span><br><span class="line">        // buckets, and iterating an empty table is a common case that&apos;s worth optimizing.</span><br><span class="line">        iterator begin() &#123; return isEmpty() ? end() : makeIterator(m_table); &#125;</span><br><span class="line">        iterator end() &#123; return makeKnownGoodIterator(m_table + m_tableSize); &#125;</span><br><span class="line">        const_iterator begin() const &#123; return isEmpty() ? end() : makeConstIterator(m_table); &#125;</span><br><span class="line">        const_iterator end() const &#123; return makeKnownGoodConstIterator(m_table + m_tableSize); &#125;</span><br><span class="line"></span><br><span class="line">        unsigned size() const &#123; return m_keyCount; &#125;</span><br><span class="line">        unsigned capacity() const &#123; return m_tableSize; &#125;</span><br><span class="line">        bool isEmpty() const &#123; return !m_keyCount; &#125;</span><br><span class="line"></span><br><span class="line">        AddResult add(const ValueType&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); &#125;</span><br><span class="line">        AddResult add(ValueType&amp;&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); &#125;</span><br><span class="line"></span><br><span class="line">        // A special version of add() that finds the object by hashing and comparing</span><br><span class="line">        // with some other type, to avoid the cost of type conversion if the object is already</span><br><span class="line">        // in the table.</span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        iterator find(const KeyType&amp; key) &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        const_iterator find(const KeyType&amp; key) const &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        bool contains(const KeyType&amp; key) const &#123; return contains&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;</span><br><span class="line"></span><br><span class="line">        void remove(const KeyType&amp;);</span><br><span class="line">        void remove(iterator);</span><br><span class="line">        void removeWithoutEntryConsistencyCheck(iterator);</span><br><span class="line">        void removeWithoutEntryConsistencyCheck(const_iterator);</span><br><span class="line">        template&lt;typename Functor&gt;</span><br><span class="line">        void removeIf(const Functor&amp;);</span><br><span class="line">        void clear();</span><br><span class="line"></span><br><span class="line">        static bool isEmptyBucket(const ValueType&amp; value) &#123; return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); &#125;</span><br><span class="line">        static bool isDeletedBucket(const ValueType&amp; value) &#123; return KeyTraits::isDeletedValue(Extractor::extract(value)); &#125;</span><br><span class="line">        static bool isEmptyOrDeletedBucket(const ValueType&amp; value) &#123; return isEmptyBucket(value) || isDeletedBucket(value); &#125;</span><br><span class="line"></span><br><span class="line">        ValueType* lookup(const Key&amp; key) &#123; return lookup&lt;IdentityTranslatorType&gt;(key); &#125;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">        void checkTableConsistency() const;</span><br><span class="line">#else</span><br><span class="line">        static void checkTableConsistency() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line">#if CHECK_HASHTABLE_CONSISTENCY</span><br><span class="line">        void internalCheckTableConsistency() const &#123; checkTableConsistency(); &#125;</span><br><span class="line">        void internalCheckTableConsistencyExceptSize() const &#123; checkTableConsistencyExceptSize(); &#125;</span><br><span class="line">#else</span><br><span class="line">        static void internalCheckTableConsistencyExceptSize() &#123; &#125;</span><br><span class="line">        static void internalCheckTableConsistency() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        static ValueType* allocateTable(unsigned size);</span><br><span class="line">        static void deallocateTable(ValueType* table, unsigned size);</span><br><span class="line"></span><br><span class="line">        typedef std::pair&lt;ValueType*, bool&gt; LookupType;</span><br><span class="line">        typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;</span><br><span class="line"></span><br><span class="line">        LookupType lookupForWriting(const Key&amp; key) &#123; return lookupForWriting&lt;IdentityTranslatorType&gt;(key); &#125;;</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);</span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);</span><br><span class="line"></span><br><span class="line">        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);</span><br><span class="line">        void removeAndInvalidate(ValueType*);</span><br><span class="line">        void remove(ValueType*);</span><br><span class="line"></span><br><span class="line">        bool shouldExpand() const &#123; return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; &#125;</span><br><span class="line">        bool mustRehashInPlace() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize * 2; &#125;</span><br><span class="line">        bool shouldShrink() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; &#125;</span><br><span class="line">        ValueType* expand(ValueType* entry = nullptr);</span><br><span class="line">        void shrink() &#123; rehash(m_tableSize / 2, nullptr); &#125;</span><br><span class="line"></span><br><span class="line">        ValueType* rehash(unsigned newTableSize, ValueType* entry);</span><br><span class="line">        ValueType* reinsert(ValueType&amp;&amp;);</span><br><span class="line"></span><br><span class="line">        static void initializeBucket(ValueType&amp; bucket);</span><br><span class="line">        static void deleteBucket(ValueType&amp; bucket) &#123; hashTraitsDeleteBucket&lt;Traits&gt;(bucket); &#125;</span><br><span class="line"></span><br><span class="line">        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)</span><br><span class="line">            &#123; return FullLookupType(LookupType(position, found), hash); &#125;</span><br><span class="line"></span><br><span class="line">        iterator makeIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize); &#125;</span><br><span class="line">        const_iterator makeConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize); &#125;</span><br><span class="line">        iterator makeKnownGoodIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</span><br><span class="line">        const_iterator makeKnownGoodConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">        void checkTableConsistencyExceptSize() const;</span><br><span class="line">#else</span><br><span class="line">        static void checkTableConsistencyExceptSize() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if CHECK_HASHTABLE_ITERATORS</span><br><span class="line">        void invalidateIterators();</span><br><span class="line">#else</span><br><span class="line">        static void invalidateIterators() &#123; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        static const unsigned m_maxLoad = 2;</span><br><span class="line">        static const unsigned m_minLoad = 6;</span><br><span class="line"></span><br><span class="line">        ValueType* m_table;</span><br><span class="line">        unsigned m_tableSize;</span><br><span class="line">        unsigned m_tableSizeMask;</span><br><span class="line">        unsigned m_keyCount;</span><br><span class="line">        unsigned m_deletedCount;</span><br><span class="line"></span><br><span class="line">#if CHECK_HASHTABLE_ITERATORS</span><br><span class="line">    public:</span><br><span class="line">        // All access to m_iterators should be guarded with m_mutex.</span><br><span class="line">        mutable const_iterator* m_iterators;</span><br><span class="line">        // Use std::unique_ptr so HashTable can still be memmove&apos;d or memcpy&apos;ed.</span><br><span class="line">        mutable std::unique_ptr&lt;Lock&gt; m_mutex;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if DUMP_HASHTABLE_STATS_PER_TABLE</span><br><span class="line">    public:</span><br><span class="line">        mutable std::unique_ptr&lt;Stats&gt; m_stats;</span><br><span class="line">#endif</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>完整具体的实现可以查看 WTF/Source/wtf/HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF/Source/wtf/MessageQueue.h 里有对消息队列的定义：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">// The queue takes ownership of messages and transfer it to the new owner</span><br><span class="line">// when messages are fetched from the queue.</span><br><span class="line">// Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.</span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">class MessageQueue &#123;</span><br><span class="line">    WTF_MAKE_NONCOPYABLE(MessageQueue);</span><br><span class="line">public:</span><br><span class="line">    MessageQueue() : m_killed(false) &#123; &#125;</span><br><span class="line">    ~MessageQueue();</span><br><span class="line"></span><br><span class="line">    void append(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    void appendAndKill(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    bool appendAndCheckEmpty(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line">    void prepend(std::unique_ptr&lt;DataType&gt;);</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;DataType&gt; waitForMessage();</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; tryGetMessage();</span><br><span class="line">    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; takeAllMessages();</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; tryGetMessageIgnoringKilled();</span><br><span class="line">    template&lt;typename Predicate&gt;</span><br><span class="line">    std::unique_ptr&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime);</span><br><span class="line"></span><br><span class="line">    template&lt;typename Predicate&gt;</span><br><span class="line">    void removeIf(Predicate&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    void kill();</span><br><span class="line">    bool killed() const;</span><br><span class="line"></span><br><span class="line">    // The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time.</span><br><span class="line">    bool isEmpty();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装</span><br><span class="line">    mutable Lock m_mutex;</span><br><span class="line">    </span><br><span class="line">    //Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程</span><br><span class="line">    Condition m_condition;</span><br><span class="line">    </span><br><span class="line">    //内部主要存储结构</span><br><span class="line">    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; m_queue;</span><br><span class="line">    bool m_killed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I/O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore/platform/network 里。如果是 iOS 就在 WebCore/platform/network/iOS 里，如果 Mac 就在 WebCore/platform/network/mac 里。</p>
<h3 id="Loader-的资源"><a href="#Loader-的资源" class="headerlink" title="Loader 的资源"></a>Loader 的资源</h3><p>网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型：</p>
<ul>
<li>HTML：页面主文件</li>
<li>JavaScript：单独的文件后者直接在 HTML 代码里</li>
<li>CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里</li>
<li>图片：各种编码图片比如 jpg 和 png</li>
<li>SVG：矢量图片</li>
<li>CSS Shader：为 CSS 带来 3D 图形特性</li>
<li>音频视频：多媒体资源以及视频字幕</li>
<li>字体：自定义的字体</li>
<li>XSL：对 XSLT 语言编写的文件支持</li>
</ul>
<p>WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/50.png" alt="50"></p>
<h3 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h3><p>加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/07.png" alt="07"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/39.png" alt="39"></p>
<ul>
<li>MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。</li>
<li>CacheResourceLoader：缓存资源读取。</li>
<li>资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。</li>
<li>DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。</li>
</ul>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/08.png" alt="08"></p>
<p>解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。</p>
<p>这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。</p>
<p>整个资源加载过程，这篇文章有详细的介绍：<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="noopener">https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/</a></p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/30.png" alt="30"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/77.png" alt="77"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/78.png" alt="78"></p>
<ul>
<li>Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。</li>
<li>SubFrameLoader：维护子 Frame。</li>
<li>DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。</li>
<li>DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。</li>
<li>HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。</li>
<li>ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。</li>
<li>SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。</li>
<li>FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。</li>
<li>PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。</li>
</ul>
<h3 id="FrameLoader-的主要接口"><a href="#FrameLoader-的主要接口" class="headerlink" title="FrameLoader 的主要接口"></a>FrameLoader 的主要接口</h3><h4 id="Frame-init"><a href="#Frame-init" class="headerlink" title="Frame::init"></a>Frame::init</h4><p>FrameLoader 自身的初始化。<br>初始化的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)</span><br><span class="line">WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)</span><br><span class="line">Frame::init()</span><br><span class="line">FrameLoader::init()</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-commitProvisionalLoad"><a href="#FrameLoader-commitProvisionalLoad" class="headerlink" title="FrameLoader::commitProvisionalLoad"></a>FrameLoader::commitProvisionalLoad</h4><p>提交 provisional 阶段时下载的数据<br>完成 Document loading 的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DocumentLoader::finishLoading</span><br><span class="line">DocumentLoader::commitIfReady</span><br><span class="line">FrameLoader::commitProvisionalLoad</span><br></pre></td></tr></table></figure>

<p>资源数据接受提交调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader::didReceiveData</span><br><span class="line">MainResourceLoader::addData</span><br><span class="line">DocumentLoader::receiveData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">DocumentLoader::commitIfReady</span><br><span class="line">DocumentLoader::commitProvisionalLoad</span><br></pre></td></tr></table></figure>

<h4 id="Frame-finishedLoading"><a href="#Frame-finishedLoading" class="headerlink" title="Frame::finishedLoading"></a>Frame::finishedLoading</h4><p>网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。<br>函数的调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader::didFinishLoading</span><br><span class="line">MainResourceLoader::didFinishLoading</span><br><span class="line">FrameLoader::finishedLoading</span><br><span class="line">FrameLoader::init()</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-finishedParsing"><a href="#FrameLoader-finishedParsing" class="headerlink" title="FrameLoader::finishedParsing"></a>FrameLoader::finishedParsing</h4><p>完成解析时调用的接口<br>调用顺序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DocumentWritter::end</span><br><span class="line">Document::finishParsing</span><br><span class="line">Document::finishedParsing</span><br><span class="line">FrameLoader::finishedParsing</span><br></pre></td></tr></table></figure>

<h4 id="FrameLoader-load-FrameLoadRequest-amp-amp-request"><a href="#FrameLoader-load-FrameLoadRequest-amp-amp-request" class="headerlink" title="FrameLoader::load(FrameLoadRequest&amp;&amp; request)"></a>FrameLoader::load(FrameLoadRequest&amp;&amp; request)</h4><p>加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">//创建 DocumentLoader</span><br><span class="line">void FrameLoader::load(FrameLoadRequest&amp;&amp; request)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_inStopAllLoaders)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!request.frameName().isEmpty()) &#123;</span><br><span class="line">        Frame* frame = findFrameForNavigation(request.frameName());</span><br><span class="line">        if (frame) &#123;</span><br><span class="line">            request.setShouldCheckNewWindowPolicy(false);</span><br><span class="line">            if (&amp;frame-&gt;loader() != this) &#123;</span><br><span class="line">                frame-&gt;loader().load(WTFMove(request));</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (request.shouldCheckNewWindowPolicy()) &#123;</span><br><span class="line">        NavigationAction action &#123; request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() &#125;;</span><br><span class="line">        policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), nullptr, request.frameName(), [this] (const ResourceRequest&amp; request, FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, bool shouldContinue) &#123;</span><br><span class="line">            continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!request.hasSubstituteData())</span><br><span class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</span><br><span class="line">    //FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。</span><br><span class="line">    Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());</span><br><span class="line">    applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);</span><br><span class="line"></span><br><span class="line">    load(loader.ptr());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//完善 request 信息</span><br><span class="line">void FrameLoader::load(DocumentLoader* newDocumentLoader)</span><br><span class="line">&#123;</span><br><span class="line">    ResourceRequest&amp; r = newDocumentLoader-&gt;request();</span><br><span class="line">    //ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。</span><br><span class="line">    addExtraFieldsToMainResourceRequest(r);</span><br><span class="line">    FrameLoadType type;</span><br><span class="line"></span><br><span class="line">    if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) &#123;</span><br><span class="line">        r.setCachePolicy(ReloadIgnoringCacheData);</span><br><span class="line">        type = FrameLoadType::Same;</span><br><span class="line">    &#125; else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType == FrameLoadType::Reload)</span><br><span class="line">        type = FrameLoadType::Reload;</span><br><span class="line">    else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid())</span><br><span class="line">        type = FrameLoadType::RedirectWithLockedBackForwardList;</span><br><span class="line">    else</span><br><span class="line">        type = FrameLoadType::Standard;</span><br><span class="line"></span><br><span class="line">    if (m_documentLoader)</span><br><span class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</span><br><span class="line">    </span><br><span class="line">    if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</span><br><span class="line">        history().saveDocumentAndScrollState();</span><br><span class="line">        ASSERT(type == FrameLoadType::Standard);</span><br><span class="line">        type = FrameLoadType::Reload;</span><br><span class="line">    &#125;</span><br><span class="line">    loadWithDocumentLoader(newDocumentLoader, type, 0, AllowNavigationToInvalidURL::Yes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//校验检查</span><br><span class="line">void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</span><br><span class="line">&#123;</span><br><span class="line">    // Retain because dispatchBeforeLoadEvent may release the last reference to it.</span><br><span class="line">    Ref&lt;Frame&gt; protect(m_frame);</span><br><span class="line"></span><br><span class="line">    ASSERT(m_client.hasWebView());</span><br><span class="line">    ASSERT(m_frame.view());</span><br><span class="line"></span><br><span class="line">    if (!isNavigationAllowed())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (m_frame.document())</span><br><span class="line">        m_previousURL = m_frame.document()-&gt;url();</span><br><span class="line"></span><br><span class="line">    const URL&amp; newURL = loader-&gt;request().url();</span><br><span class="line">    // Log main frame navigation types.</span><br><span class="line">    if (m_frame.isMainFrame()) &#123;</span><br><span class="line">        if (auto* page = m_frame.page())</span><br><span class="line">            page-&gt;mainFrameLoadStarted(newURL, type);</span><br><span class="line">static_cast&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    policyChecker().setLoadType(type);</span><br><span class="line">    bool isFormSubmission = formState;</span><br><span class="line"></span><br><span class="line">    const String&amp; httpMethod = loader-&gt;request().httpMethod();</span><br><span class="line"></span><br><span class="line">    if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) &#123;</span><br><span class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</span><br><span class="line">        NavigationAction action &#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;;</span><br><span class="line"></span><br><span class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</span><br><span class="line">        oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());</span><br><span class="line">        policyChecker().stopCheck();</span><br><span class="line">        policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, oldDocumentLoader.get(), formState, [this] (const ResourceRequest&amp; request, FormState*, bool shouldContinue) &#123;</span><br><span class="line">            continueFragmentScrollAfterNavigationPolicy(request, shouldContinue);</span><br><span class="line">        &#125;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Frame* parent = m_frame.tree().parent())</span><br><span class="line">        loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());</span><br><span class="line"></span><br><span class="line">    policyChecker().stopCheck();</span><br><span class="line">    </span><br><span class="line">    //把 DocumentLoader 赋给 m_policyDocumentLoader</span><br><span class="line">    setPolicyDocumentLoader(loader);</span><br><span class="line">    </span><br><span class="line">    //将请求信息记在 loader.m_triggeringAction 中</span><br><span class="line">    if (loader-&gt;triggeringAction().isEmpty())</span><br><span class="line">        loader-&gt;setTriggeringAction(&#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;);</span><br><span class="line"></span><br><span class="line">    if (Element* ownerElement = m_frame.ownerElement()) &#123;</span><br><span class="line">        if (!m_stateMachine.committedFirstRealDocumentLoad()</span><br><span class="line">            &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) &#123;</span><br><span class="line">            continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false, allowNavigationToInvalidURL);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求</span><br><span class="line">    policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, loader, formState, [this, allowNavigationToInvalidURL] (const ResourceRequest&amp; request, FormState* formState, bool shouldContinue) &#123;</span><br><span class="line">        //shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。</span><br><span class="line">        continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, bool shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</span><br><span class="line">&#123;</span><br><span class="line">    // If we loaded an alternate page to replace an unreachableURL, we&apos;ll get in here with a</span><br><span class="line">    // nil policyDataSource because loading the alternate page will have passed</span><br><span class="line">    // through this method already, nested; otherwise, policyDataSource should still be set.</span><br><span class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</span><br><span class="line"></span><br><span class="line">    bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;</span><br><span class="line"></span><br><span class="line">    bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();</span><br><span class="line"></span><br><span class="line">    // Three reasons we can&apos;t continue:</span><br><span class="line">    //    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this </span><br><span class="line">    //       is the user responding Cancel to the form repost nag sheet.</span><br><span class="line">    //    2) User responded Cancel to an alert popped up by the before unload event handler.</span><br><span class="line">    //    3) The request&apos;s URL is invalid and navigation to invalid URLs is disallowed.</span><br><span class="line">    bool canContinue = shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;</span><br><span class="line"></span><br><span class="line">    if (!canContinue) &#123;</span><br><span class="line">        // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we </span><br><span class="line">        // need to report that the client redirect was cancelled.</span><br><span class="line">        // FIXME: The client should be told about ignored non-quick redirects, too.</span><br><span class="line">        if (m_quickRedirectComing)</span><br><span class="line">            clientRedirectCancelledOrFinished(false);</span><br><span class="line"></span><br><span class="line">        setPolicyDocumentLoader(nullptr);</span><br><span class="line"></span><br><span class="line">        // If the navigation request came from the back/forward menu, and we punt on it, we have the </span><br><span class="line">        // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,</span><br><span class="line">        // we only do this when punting a navigation for the target frame or top-level frame.  </span><br><span class="line">        if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) &#123;</span><br><span class="line">            if (Page* page = m_frame.page()) &#123;</span><br><span class="line">                if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem()) &#123;</span><br><span class="line">                    page-&gt;backForward().setCurrentItem(resetItem);</span><br><span class="line">                    m_frame.loader().client().updateGlobalHistoryItemForPage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FrameLoadType type = policyChecker().loadType();</span><br><span class="line">    // A new navigation is in progress, so don&apos;t clear the history&apos;s provisional item.</span><br><span class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</span><br><span class="line">    </span><br><span class="line">    // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</span><br><span class="line">    // might detach the current FrameLoader, in which case we should bail on this newly defunct load. </span><br><span class="line">    if (!m_frame.page())</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //把 DocumentLoader 赋值给 m_provisionalDocumentLoader</span><br><span class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</span><br><span class="line">    m_loadType = type;</span><br><span class="line">    //设置 FrameLoader 状态为 Provisional</span><br><span class="line">    setState(FrameStateProvisional);</span><br><span class="line"></span><br><span class="line">    setPolicyDocumentLoader(nullptr);</span><br><span class="line"></span><br><span class="line">    if (isBackForwardLoadType(type)) &#123;</span><br><span class="line">        auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();</span><br><span class="line">        if (history().provisionalItem()-&gt;isInPageCache()) &#123;</span><br><span class="line">            diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</span><br><span class="line">            loadProvisionalItemFromCachedPage();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!formState) &#123;</span><br><span class="line">        continueLoadAfterWillSubmitForm();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_client.dispatchWillSubmitForm(*formState, [this] (PolicyAction action) &#123;</span><br><span class="line">        policyChecker().continueLoadAfterWillSubmitForm(action);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。</p>
<h3 id="WebKit-网络处理"><a href="#WebKit-网络处理" class="headerlink" title="WebKit 网络处理"></a>WebKit 网络处理</h3><p>WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore/platform/network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。</p>
<h3 id="ResourceHandle-的相关类"><a href="#ResourceHandle-的相关类" class="headerlink" title="ResourceHandle 的相关类"></a>ResourceHandle 的相关类</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/31.png" alt="31"></p>
<ul>
<li>ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。</li>
<li>MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存</li>
<li>SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。</li>
<li>ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。</li>
</ul>
<h3 id="ResourceHandleClient"><a href="#ResourceHandleClient" class="headerlink" title="ResourceHandleClient"></a>ResourceHandleClient</h3><p>ResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class ResourceHandleClient &#123;</span><br><span class="line">public:</span><br><span class="line">    WEBCORE_EXPORT ResourceHandleClient();</span><br><span class="line">    WEBCORE_EXPORT virtual ~ResourceHandleClient();</span><br><span class="line"></span><br><span class="line">    WEBCORE_EXPORT virtual ResourceRequest willSendRequest(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);</span><br><span class="line">    virtual void didSendData(ResourceHandle*, unsigned long long /*bytesSent*/, unsigned long long /*totalBytesToBeSent*/) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    //收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功</span><br><span class="line">    virtual void didReceiveResponse(ResourceHandle*, ResourceResponse&amp;&amp;) &#123; &#125;</span><br><span class="line">    //收到服务器端包含请求数据的响应包</span><br><span class="line">    virtual void didReceiveData(ResourceHandle*, const char*, unsigned, int /*encodedDataLength*/) &#123; &#125;</span><br><span class="line">    WEBCORE_EXPORT virtual void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength);</span><br><span class="line">    //接受过程结束</span><br><span class="line">    virtual void didFinishLoading(ResourceHandle*) &#123; &#125;</span><br><span class="line">    //接受失败</span><br><span class="line">    virtual void didFail(ResourceHandle*, const ResourceError&amp;) &#123; &#125;</span><br><span class="line">    virtual void wasBlocked(ResourceHandle*) &#123; &#125;</span><br><span class="line">    virtual void cannotShowURL(ResourceHandle*) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool usesAsyncCallbacks() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">    virtual bool loadingSynchronousXHR() &#123; return false; &#125;</span><br><span class="line"></span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);</span><br><span class="line"></span><br><span class="line">    // Client will call ResourceHandle::continueDidReceiveResponse() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;);</span><br><span class="line"></span><br><span class="line">#if USE(PROTECTION_SPACE_AUTH_CALLBACK)</span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready.</span><br><span class="line">    WEBCORE_EXPORT virtual void canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp;);</span><br><span class="line">#endif</span><br><span class="line">    // Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.</span><br><span class="line">#if USE(CFURLCONNECTION)</span><br><span class="line">    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, CFCachedURLResponseRef);</span><br><span class="line">#elif PLATFORM(COCOA)</span><br><span class="line">    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse *);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE(SOUP)</span><br><span class="line">    virtual char* getOrCreateReadBuffer(size_t /*requestedLength*/, size_t&amp; /*actualLength*/) &#123; return 0; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    virtual bool shouldUseCredentialStorage(ResourceHandle*) &#123; return false; &#125;</span><br><span class="line">    virtual void didReceiveAuthenticationChallenge(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;</span><br><span class="line">#if USE(PROTECTION_SPACE_AUTH_CALLBACK)</span><br><span class="line">    virtual bool canAuthenticateAgainstProtectionSpace(ResourceHandle*, const ProtectionSpace&amp;) &#123; return false; &#125;</span><br><span class="line">#endif</span><br><span class="line">    virtual void receivedCancellation(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS) || USE(CFURLCONNECTION)</span><br><span class="line">    virtual RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) &#123; return nullptr; &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE(CFURLCONNECTION)</span><br><span class="line">    virtual CFCachedURLResponseRef willCacheResponse(ResourceHandle*, CFCachedURLResponseRef response) &#123; return response; &#125;</span><br><span class="line">#if PLATFORM(WIN)</span><br><span class="line">    virtual bool shouldCacheResponse(ResourceHandle*, CFCachedURLResponseRef) &#123; return true; &#125;</span><br><span class="line">#endif // PLATFORM(WIN)</span><br><span class="line"></span><br><span class="line">#elif PLATFORM(COCOA)</span><br><span class="line">    virtual NSCachedURLResponse *willCacheResponse(ResourceHandle*, NSCachedURLResponse *response) &#123; return response; &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与 ResourceHandleClient 相关的类如下<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/80.png" alt="80"></p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/98.png" alt="98"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/32.png" alt="32"></p>
<h4 id="MainResourceLoader-的加载顺序"><a href="#MainResourceLoader-的加载顺序" class="headerlink" title="MainResourceLoader 的加载顺序"></a>MainResourceLoader 的加载顺序</h4><p>MainResourceLoader 加载的是 html 文本资源。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/79.png" alt="79"></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">MainResourceLoader::load</span><br><span class="line">MainResourceLoader::loadNow</span><br><span class="line">MainResourceLoader::willSendRequest</span><br><span class="line">ResourceLoader::willSendRequest //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。</span><br><span class="line">PolicyChecker::checkNavigationPolicy //检查 NavigationPolicy 可以过滤一些重复的请求</span><br><span class="line">ResourceHandle::create 开始发网络请求</span><br><span class="line">MainResourceLoader::didReceiveResponse //主资源收到第一个 HTTP 的响应回调，处理 HTTP header</span><br><span class="line">PolicyChecker:: checkContentPolicy //进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求</span><br><span class="line">MainResourceLoader::continueAfterContentPolicy //看看 ContentPolicy 检查后是否有错误</span><br><span class="line">ResourceLoader::didReceiveResponse //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span><br><span class="line">MainResourceLoader::didReceiveData //主资源开始接受 body 数据</span><br><span class="line">ResourceLoader::didReceiveData //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span><br><span class="line">MainResourceLoader::addData</span><br><span class="line">DocumentLoader::receivedData</span><br><span class="line">DocumentLoader::commitLoad</span><br><span class="line">FrameLoader::commitProvisionalLoad //从 provisional 状态到 Committed 状态</span><br><span class="line">FrameLoaderClientQt::committedLoad</span><br><span class="line">DocumentLoader::commitData</span><br><span class="line">DocumentWriter::setEncoding</span><br><span class="line">DocumentWriter::addData</span><br><span class="line">DocumentParser::appendByte</span><br><span class="line">DecodedDataDocumentParser::appendBytes //编码处理</span><br><span class="line">HTMLDocumentParser::append //解析 HTML</span><br><span class="line">MainResourceLoader::didFinishLoading</span><br><span class="line">FrameLoader::finishedLoading</span><br><span class="line">DocumentLoader::finishedLoading</span><br><span class="line">FrameLoader::finishedLoadingDocument</span><br><span class="line">DocumentWriter::end</span><br><span class="line">Document::finishParsing</span><br><span class="line">HTMLDocumentParser::finish</span><br></pre></td></tr></table></figure>

<p>在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。</p>
<p>在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void ResourceLoader::addDataOrBuffer(const char* data, unsigned length, SharedBuffer* buffer, DataPayloadType dataPayloadType)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_options.dataBufferingPolicy == DoNotBufferData)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!m_resourceData || dataPayloadType == DataPayloadWholeResource) &#123;</span><br><span class="line">        if (buffer)</span><br><span class="line">            m_resourceData = buffer;</span><br><span class="line">        else</span><br><span class="line">            m_resourceData = SharedBuffer::create(data, length);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (buffer)</span><br><span class="line">        m_resourceData-&gt;append(*buffer);</span><br><span class="line">    else</span><br><span class="line">        m_resourceData-&gt;append(data, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DocumentLoader::commitLoad(const char* data, int length)</span><br><span class="line">&#123;</span><br><span class="line">    // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource</span><br><span class="line">    // by starting a new load, so retain temporarily.</span><br><span class="line">    RefPtr&lt;Frame&gt; protectedFrame(m_frame);</span><br><span class="line">    Ref&lt;DocumentLoader&gt; protectedThis(*this);</span><br><span class="line"></span><br><span class="line">    commitIfReady();</span><br><span class="line">    FrameLoader* frameLoader = DocumentLoader::frameLoader();</span><br><span class="line">    if (!frameLoader)</span><br><span class="line">        return;</span><br><span class="line">#if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)</span><br><span class="line">    if (ArchiveFactory::isArchiveMimeType(response().mimeType()))</span><br><span class="line">        return;</span><br><span class="line">#endif</span><br><span class="line">    //FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态</span><br><span class="line">    frameLoader-&gt;client().committedLoad(this, data, length);</span><br><span class="line"></span><br><span class="line">    if (isMultipartReplacingLoad())</span><br><span class="line">        frameLoader-&gt;client().didReplaceMultipartContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DocumentWriter::begin(const URL&amp; urlReference, bool dispatch, Document* ownerDocument)</span><br><span class="line">&#123;</span><br><span class="line">    // We grab a local copy of the URL because it&apos;s easy for callers to supply</span><br><span class="line">    // a URL that will be deallocated during the execution of this function.</span><br><span class="line">    // For example, see &lt;https://bugs.webkit.org/show_bug.cgi?id=66360&gt;.</span><br><span class="line">    URL url = urlReference;</span><br><span class="line"></span><br><span class="line">    // Create a new document before clearing the frame, because it may need to</span><br><span class="line">    // inherit an aliased security context.</span><br><span class="line">    //创建了 Document 对象</span><br><span class="line">    Ref&lt;Document&gt; document = createDocument(url);</span><br><span class="line">    </span><br><span class="line">    // If the new document is for a Plugin but we&apos;re supposed to be sandboxed from Plugins,</span><br><span class="line">    // then replace the document with one whose parser will ignore the incoming data (bug 39323)</span><br><span class="line">    if (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins))</span><br><span class="line">        document = SinkDocument::create(m_frame, url);</span><br><span class="line"></span><br><span class="line">    // FIXME: Do we need to consult the content security policy here about blocked plug-ins?</span><br><span class="line"></span><br><span class="line">    bool shouldReuseDefaultView = m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url);</span><br><span class="line">    if (shouldReuseDefaultView)</span><br><span class="line">        document-&gt;takeDOMWindowFrom(m_frame-&gt;document());</span><br><span class="line">    else</span><br><span class="line">        document-&gt;createDOMWindow();</span><br><span class="line"></span><br><span class="line">    // Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, we need to retain an ongoing set of upgraded</span><br><span class="line">    // requests in new navigation contexts. Although this information is present when we construct the</span><br><span class="line">    // Document object, it is discard in the subsequent &apos;clear&apos; statements below. So, we must capture it</span><br><span class="line">    // so we can restore it.</span><br><span class="line">    HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade;</span><br><span class="line">    if (auto* existingDocument = m_frame-&gt;document())</span><br><span class="line">        insecureNavigationRequestsToUpgrade = existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade();</span><br><span class="line">    </span><br><span class="line">    m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView);</span><br><span class="line">    clear();</span><br><span class="line"></span><br><span class="line">    // m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document.</span><br><span class="line">    // Bail out if document has no view.</span><br><span class="line">    if (!document-&gt;view())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!shouldReuseDefaultView)</span><br><span class="line">        m_frame-&gt;script().updatePlatformScriptObjects();</span><br><span class="line"></span><br><span class="line">    m_frame-&gt;loader().setOutgoingReferrer(url);</span><br><span class="line">    m_frame-&gt;setDocument(document.copyRef());</span><br><span class="line"></span><br><span class="line">    document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade));</span><br><span class="line"></span><br><span class="line">    if (m_decoder)</span><br><span class="line">        document-&gt;setDecoder(m_decoder.get());</span><br><span class="line">    if (ownerDocument) &#123;</span><br><span class="line">        document-&gt;setCookieURL(ownerDocument-&gt;cookieURL());</span><br><span class="line">        document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy());</span><br><span class="line">        document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_frame-&gt;loader().didBeginDocument(dispatch);</span><br><span class="line"></span><br><span class="line">    document-&gt;implicitOpen();</span><br><span class="line"></span><br><span class="line">    // We grab a reference to the parser so that we&apos;ll always send data to the</span><br><span class="line">    // original parser, even if the document acquires a new parser (e.g., via</span><br><span class="line">    // document.open).</span><br><span class="line">    m_parser = document-&gt;parser();</span><br><span class="line"></span><br><span class="line">    if (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView())</span><br><span class="line">        m_frame-&gt;view()-&gt;setContentsSize(IntSize());</span><br><span class="line"></span><br><span class="line">    m_state = StartedWritingState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, const char* data, size_t length)</span><br><span class="line">&#123;</span><br><span class="line">    if (!length)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。</span><br><span class="line">    String decoded = writer.createDecoderIfNeeded()-&gt;decode(data, length);</span><br><span class="line">    if (decoded.isEmpty())</span><br><span class="line">        return;</span><br><span class="line">    //解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步</span><br><span class="line">    writer.reportDataReceived();</span><br><span class="line">    append(decoded.releaseImpl());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。</p>
<p>下面看看解码的流程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/85.png" alt="85"><br>decoder 的类图如下:<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/86.png" alt="86"></p>
<h4 id="SubResourceLoader-的加载顺序"><a href="#SubResourceLoader-的加载顺序" class="headerlink" title="SubResourceLoader 的加载顺序"></a>SubResourceLoader 的加载顺序</h4><p>SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/81.png" alt="81"></p>
<p>会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)</span><br><span class="line">&#123;</span><br><span class="line">    auto&amp; localName = token.name();</span><br><span class="line">    // FIXME: This can&apos;t use HTMLConstructionSite::createElement because we</span><br><span class="line">    // have to pass the current form element.  We should rework form association</span><br><span class="line">    // to occur after construction to allow better code sharing here.</span><br><span class="line">    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token</span><br><span class="line">    Document&amp; ownerDocument = ownerDocumentForCurrentNode();</span><br><span class="line">    bool insideTemplateElement = !ownerDocument.frame();</span><br><span class="line">    //将 tagName 和节点构造创建成 HTMLImageElement</span><br><span class="line">    RefPtr&lt;Element&gt; element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);</span><br><span class="line">    if (UNLIKELY(!element)) &#123;</span><br><span class="line">        auto* window = ownerDocument.domWindow();</span><br><span class="line">        if (customElementInterface &amp;&amp; window) &#123;</span><br><span class="line">            auto* registry = window-&gt;customElementRegistry();</span><br><span class="line">            if (UNLIKELY(registry)) &#123;</span><br><span class="line">                if (auto* elementInterface = registry-&gt;findInterface(localName)) &#123;</span><br><span class="line">                    *customElementInterface = elementInterface;</span><br><span class="line">                    return nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI);</span><br><span class="line">        if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) &#123;</span><br><span class="line">            element = HTMLElement::create(qualifiedName, ownerDocument);</span><br><span class="line">            element-&gt;setIsCustomElementUpgradeCandidate();</span><br><span class="line">        &#125; else</span><br><span class="line">            element = HTMLUnknownElement::create(qualifiedName, ownerDocument);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(element);</span><br><span class="line"></span><br><span class="line">    // FIXME: This is a hack to connect images to pictures before the image has</span><br><span class="line">    // been inserted into the document. It can be removed once asynchronous image</span><br><span class="line">    // loading is working.</span><br><span class="line">    if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))</span><br><span class="line">        downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));</span><br><span class="line">    //设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载</span><br><span class="line">    setAttributes(*element, token, m_parserContentPolicy);</span><br><span class="line">    ASSERT(element-&gt;isHTMLElement());</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void HTMLImageElement::selectImageSource()</span><br><span class="line">&#123;</span><br><span class="line">    // First look for the best fit source from our &lt;picture&gt; parent if we have one.</span><br><span class="line">    ImageCandidate candidate = bestFitSourceFromPictureElement();</span><br><span class="line">    if (candidate.isEmpty()) &#123;</span><br><span class="line">        // If we don&apos;t have a &lt;picture&gt; or didn&apos;t find a source, then we use our own attributes.</span><br><span class="line">        auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();</span><br><span class="line">        candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);</span><br><span class="line">    &#125;</span><br><span class="line">    setBestFitURLAndDPRFromImageCandidate(candidate);</span><br><span class="line">    //updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源</span><br><span class="line">    m_imageLoader.updateFromElementIgnoringPreviousError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/33.png" alt="33"></p>
<p>ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/34.png" alt="34"></p>
<ul>
<li>Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。</li>
<li>CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。</li>
<li>MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap &lt;String,CachedResource&gt; m_resources;</li>
</ul>
<p>在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum RevalidationPolicy &#123; Use, Revalidate, Reload, Load &#125;;</span><br><span class="line">    RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const;</span><br></pre></td></tr></table></figure>

<p>可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);</span><br><span class="line">switch (policy) &#123;</span><br><span class="line">case Reload:</span><br><span class="line">    memoryCache.remove(*resource);</span><br><span class="line">    FALLTHROUGH;</span><br><span class="line">case Load:</span><br><span class="line">    if (resource)</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</span><br><span class="line">    resource = loadResource(type, WTFMove(request));</span><br><span class="line">    break;</span><br><span class="line">case Revalidate:</span><br><span class="line">    if (resource)</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</span><br><span class="line">    resource = revalidateResource(WTFMove(request), *resource);</span><br><span class="line">    break;</span><br><span class="line">case Use:</span><br><span class="line">    ASSERT(resource);</span><br><span class="line">    if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) &#123;</span><br><span class="line">        resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request));</span><br><span class="line">        if (resource-&gt;status() != CachedResource::Status::Cached)</span><br><span class="line">            policy = Load;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ResourceError error;</span><br><span class="line">        if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))</span><br><span class="line">            return makeUnexpected(WTFMove(error));</span><br><span class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</span><br><span class="line">        loadTiming.setResponseEnd(MonotonicTime::now());</span><br><span class="line"></span><br><span class="line">        memoryCache.resourceAccessed(*resource);</span><br><span class="line"></span><br><span class="line">        if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) &#123;</span><br><span class="line">            auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());</span><br><span class="line">            if (initiatorContext == InitiatorContext::Worker) &#123;</span><br><span class="line">                ASSERT(is&lt;CachedRawResource&gt;(resource.get()));</span><br><span class="line">                downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ASSERT(initiatorContext == InitiatorContext::Document);</span><br><span class="line">                m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());</span><br><span class="line">                m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (forPreload == ForPreload::No)</span><br><span class="line">            resource-&gt;setLoadPriority(request.priority());</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。</p>
<p>CachedResource 加载<br>CachedResource 实现了 RFC2616 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" target="_blank" rel="noopener">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html</a> 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/35.png" alt="35"></p>
<p>会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。</p>
<p>在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)</span><br><span class="line">&#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">    case CachedResource::MainResource:</span><br><span class="line">        return ResourceLoadPriority::VeryHigh;</span><br><span class="line">    case CachedResource::CSSStyleSheet:</span><br><span class="line">    case CachedResource::Script:</span><br><span class="line">        return ResourceLoadPriority::High;</span><br><span class="line">#if ENABLE(SVG_FONTS)</span><br><span class="line">    case CachedResource::SVGFontResource:</span><br><span class="line">#endif</span><br><span class="line">    case CachedResource::MediaResource:</span><br><span class="line">    case CachedResource::FontResource:</span><br><span class="line">    case CachedResource::RawResource:</span><br><span class="line">    case CachedResource::Icon:</span><br><span class="line">        return ResourceLoadPriority::Medium;</span><br><span class="line">    case CachedResource::ImageResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">#if ENABLE(XSLT)</span><br><span class="line">    case CachedResource::XSLStyleSheet:</span><br><span class="line">        return ResourceLoadPriority::High;</span><br><span class="line">#endif</span><br><span class="line">    case CachedResource::SVGDocumentResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">    case CachedResource::Beacon:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">#if ENABLE(LINK_PREFETCH)</span><br><span class="line">    case CachedResource::LinkPrefetch:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">    case CachedResource::LinkSubresource:</span><br><span class="line">        return ResourceLoadPriority::VeryLow;</span><br><span class="line">#endif</span><br><span class="line">#if ENABLE(VIDEO_TRACK)</span><br><span class="line">    case CachedResource::TextTrackResource:</span><br><span class="line">        return ResourceLoadPriority::Low;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_NOT_REACHED();</span><br><span class="line">    return ResourceLoadPriority::Low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(resourceLoader);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    // If there&apos;s a web archive resource for this URL, we don&apos;t need to schedule the load since it will never touch the network.</span><br><span class="line">    if (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) &#123;</span><br><span class="line">        resourceLoader-&gt;startLoading();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) &#123;</span><br><span class="line">        resourceLoader-&gt;start();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);</span><br><span class="line">#else</span><br><span class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ResourceLoadPriority priority = resourceLoader-&gt;request().priority();</span><br><span class="line"></span><br><span class="line">    bool hadRequests = host-&gt;hasRequests();</span><br><span class="line">    //把优先级存放到 host 的 m_requestsPending 属性里</span><br><span class="line">    host-&gt;schedule(resourceLoader, priority);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(COCOA) || USE(CFURLCONNECTION)</span><br><span class="line">    if (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) &#123;</span><br><span class="line">        // Serve all requests at once to keep the pipeline full at the network layer.</span><br><span class="line">        // FIXME: Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms?</span><br><span class="line">        servePendingRequests(host, ResourceLoadPriority::VeryLow);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//这里就是如何根据优先级来进行安排的</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    if ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) &#123;</span><br><span class="line">        //重要资源立刻进行</span><br><span class="line">        servePendingRequests(host, priority);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &#123;</span><br><span class="line">        //重要资源立刻进行</span><br><span class="line">        servePendingRequests(host, priority);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // Handle asynchronously so early low priority requests don&apos;t</span><br><span class="line">    // get scheduled before later high priority ones.</span><br><span class="line">    //不重要的就延迟进行，然后根据优先级，由高到低依次加载</span><br><span class="line">    scheduleServePendingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority)</span><br><span class="line">&#123;</span><br><span class="line">    auto priority = ResourceLoadPriority::Highest;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        auto&amp; requestsPending = host-&gt;requestsPending(priority);</span><br><span class="line">        while (!requestsPending.isEmpty()) &#123;</span><br><span class="line">            RefPtr&lt;ResourceLoader&gt; resourceLoader = requestsPending.first();</span><br><span class="line"></span><br><span class="line">            // For named hosts - which are only http(s) hosts - we should always enforce the connection limit.</span><br><span class="line">            // For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn&apos;t done parsing </span><br><span class="line">            // and we don&apos;t know all stylesheets yet.</span><br><span class="line">            Document* document = resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : 0;</span><br><span class="line">            bool shouldLimitRequests = !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded()));</span><br><span class="line">            if (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority))</span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            requestsPending.removeFirst();</span><br><span class="line">            host-&gt;addLoadInProgress(resourceLoader.get());</span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">            if (!IOSApplication::isWebProcess()) &#123;</span><br><span class="line">                resourceLoader-&gt;startLoading();</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            //在这个函数里创建了 ResourceHandle</span><br><span class="line">            resourceLoader-&gt;start();</span><br><span class="line">        &#125;</span><br><span class="line">        if (priority == minimumPriority)</span><br><span class="line">            return;</span><br><span class="line">        --priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(m_resource);</span><br><span class="line"></span><br><span class="line">    if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())</span><br><span class="line">        return;</span><br><span class="line">    ASSERT(!m_resource-&gt;resourceToRevalidate());</span><br><span class="line">    ASSERT(!m_resource-&gt;errorOccurred());</span><br><span class="line">    ASSERT(m_state == Initialized);</span><br><span class="line">    // Reference the object in this method since the additional processing can do</span><br><span class="line">    // anything including removing the last reference to this object; one example of this is 3266216.</span><br><span class="line">    Ref&lt;SubresourceLoader&gt; protectedThis(*this);</span><br><span class="line">    </span><br><span class="line">    //ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里</span><br><span class="line">    ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);</span><br><span class="line"></span><br><span class="line">    if (!m_loadingMultipartContent) &#123;</span><br><span class="line">        if (auto* resourceData = this-&gt;resourceData())</span><br><span class="line">            m_resource-&gt;addDataBuffer(*resourceData);</span><br><span class="line">        else</span><br><span class="line">            m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 image 为例如图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/36.png" alt="36"></p>
<p>举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。</p>
<p>CacheImage 的加载过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/82.png" alt="82"></p>
<p>具体调用方法顺序如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">HTMLImageElement::create //解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象</span><br><span class="line">ImageLoader::updateFromElementIgnoringPreviousError //解析到 img 的 href 属性</span><br><span class="line">ImageLoader::updateFromElement</span><br><span class="line">CachedResourceLoader::requestImage</span><br><span class="line">CachedResourceLoader::requestResource //判断是否从缓存读取，还是网络获取</span><br><span class="line">CachedResourceLoader::loadResource //创建不同类型的 CachedResource，这里是 CachedImage</span><br><span class="line">MemoryCache::add //创建对应的 cache 项目</span><br><span class="line">CachedImage::load</span><br><span class="line">CachedResource::load</span><br><span class="line">CachedResourceLoader::load</span><br><span class="line">CachedResourceRequest::load</span><br><span class="line">ResourceLoaderScheduler::scheduleSubresourceLoad</span><br><span class="line">SubresourceLoader::create</span><br><span class="line">ResourceLoadScheduler::requestTimerFired</span><br><span class="line">ResourceLoader::start</span><br><span class="line">ResourceHandle::create</span><br><span class="line">ResourceLoader::didReceiveResponse //收到 HTTP Header 的 response</span><br><span class="line">SubresourceLoader::didiReceiveResponse</span><br><span class="line">CachedResourceRequest::didReceiveResponse //处理响应</span><br><span class="line">ResourceLoader::didReceiveResponse</span><br><span class="line">ResourceLoader::didReceiveData //收到 body 数据</span><br><span class="line">SubresourceLoader::didReceiveData</span><br><span class="line">ResourceLoader::didReceiveData</span><br><span class="line">ResourceLoader::addData</span><br><span class="line">CachedResourceRequest::didReceiveData</span><br><span class="line">ResourceLoader::didFinishLoading //数据读取完成</span><br><span class="line">SubresourceLoader::didFinishLoading</span><br><span class="line">CachedResourceRequest::didFinishLoading</span><br><span class="line">CachedResource::finish</span><br><span class="line">CachedResourceLoader::loadDone</span><br><span class="line">CachedImage::data //创建 Image 对象，进行解码</span><br></pre></td></tr></table></figure>

<p>可以用下图概括下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/51.png" alt="51"><br>一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。</p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。</p>
<h3 id="WebKit-的-Cache"><a href="#WebKit-的-Cache" class="headerlink" title="WebKit 的 Cache"></a>WebKit 的 Cache</h3><p>WebKit 主要有三种 Cache。</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">if (!m_frame.tree().parent() &amp;&amp; history().currentItem()) &#123;</span><br><span class="line">    // Check to see if we need to cache the page we are navigating away from into the back/forward cache.</span><br><span class="line">    // We are doing this here because we know for sure that a new page is about to be loaded.</span><br><span class="line">    PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</span><br><span class="line"></span><br><span class="line">    WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">void PageCache::addIfCacheable(HistoryItem&amp; item, Page* page)</span><br><span class="line">&#123;</span><br><span class="line">    if (item.isInPageCache())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    if (!page || !canCache(*page))</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), &quot;Utility pages such as SVGImage pages should never go into PageCache&quot;);</span><br><span class="line"></span><br><span class="line">    setPageCacheState(*page, Document::AboutToEnterPageCache);</span><br><span class="line"></span><br><span class="line">    // Focus the main frame, defocusing a focused subframe (if we have one). We do this here,</span><br><span class="line">    // before the page enters the page cache, while we still can dispatch DOM blur/focus events.</span><br><span class="line">    if (page-&gt;focusController().focusedFrame())</span><br><span class="line">        page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    // Fire the pagehide event in all frames.</span><br><span class="line">    firePageHideEventRecursively(page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    // Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers</span><br><span class="line">    // could have altered the page in a way that could prevent caching.</span><br><span class="line">    if (!canCache(*page)) &#123;</span><br><span class="line">        setPageCacheState(*page, Document::NotInPageCache);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroyRenderTree(page-&gt;mainFrame());</span><br><span class="line"></span><br><span class="line">    setPageCacheState(*page, Document::InPageCache);</span><br><span class="line"></span><br><span class="line">    // Make sure we no longer fire any JS events past this point.</span><br><span class="line">    NoEventDispatchAssertion assertNoEventDispatch;</span><br><span class="line">    //创建一个新的 CachedPage 存放到 HistoryItem 里</span><br><span class="line">    item.m_cachedPage = std::make_unique&lt;CachedPage&gt;(*page);</span><br><span class="line">    item.m_pruningReason = PruningReason::None;</span><br><span class="line">    //将 HistoryItem 添加到 m_items 列表中</span><br><span class="line">    m_items.add(&amp;item);</span><br><span class="line">    </span><br><span class="line">    //检查是否有超过回收的限制，进行资源回收</span><br><span class="line">    prune(PruningReason::ReachedMaxSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/83.png" alt="83"><br>Memory Cache 有三个比较重要的属性。</p>
<ul>
<li>m_resources：类型是 HashMap，key 是 url，值是 CacheResource。</li>
<li>m_allResources：采用的是 LRU 算法，类型是 Vector&lt;LRUList,32&gt; 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。</li>
<li>m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。</p>
<h2 id="HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><a href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token" class="headerlink" title="HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token"></a>HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</h2><h3 id="解析成-HTML-Token-的算法"><a href="#解析成-HTML-Token-的算法" class="headerlink" title="解析成 HTML Token 的算法"></a>解析成 HTML Token 的算法</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/17.png" alt="17"><br>初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。</p>
<p>在 Tag open state 状态时如果碰到 / 字符那么就会创建 End tag token，同时状态变成 Tag name state。</p>
<p>在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。</p>
<p>HTMLToken 的所有类型定义在 HTMLToken.h 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">enum Type &#123;</span><br><span class="line">    Uninitialized, //默认类型</span><br><span class="line">    DOCTYPE,       //文档类型</span><br><span class="line">    StartTag,      //起始标签</span><br><span class="line">    EndTag,        //结束标签</span><br><span class="line">    Comment,       //注释</span><br><span class="line">    Character,     //元素内容</span><br><span class="line">    EndOfFile,     //文档结束</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">private:</span><br><span class="line">    Type m_type;       //那种类型</span><br><span class="line"></span><br><span class="line">    DataVector m_data; //根据类型来，不同类型内容不一样</span><br><span class="line">    UChar m_data8BitCheck;</span><br><span class="line"></span><br><span class="line">    // For StartTag and EndTag</span><br><span class="line">    bool m_selfClosing;            //是否是自封闭</span><br><span class="line">    AttributeList m_attributes;    //属性列表</span><br><span class="line">    Attribute* m_currentAttribute; //当前属性</span><br><span class="line"></span><br><span class="line">    // For DOCTYPE</span><br><span class="line">    std::unique_ptr&lt;DoctypeData&gt; m_doctypeData;</span><br><span class="line"></span><br><span class="line">    unsigned m_attributeBaseOffset &#123; 0 &#125;; // Changes across document.write() boundaries.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/28.png" alt="28"></p>
<p>HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：<a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="noopener">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">	c++</span><br><span class="line">//HTML 有限状态机的状态非空集合</span><br><span class="line">enum State &#123;</span><br><span class="line">    DataState, //初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character</span><br><span class="line">    CharacterReferenceInDataState,</span><br><span class="line">    RCDATAState,</span><br><span class="line">    CharacterReferenceInRCDATAState,</span><br><span class="line">    RAWTEXTState,</span><br><span class="line">    ScriptDataState,</span><br><span class="line">    PLAINTEXTState,</span><br><span class="line">    TagOpenState, //碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里</span><br><span class="line">    EndTagOpenState, //TagOpenState 状态碰见 / 进入。HTMLToken 的 type 为 endTag</span><br><span class="line">    TagNameState, //在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag</span><br><span class="line"></span><br><span class="line">    RCDATALessThanSignState,</span><br><span class="line">    RCDATAEndTagOpenState,</span><br><span class="line">    RCDATAEndTagNameState,</span><br><span class="line"></span><br><span class="line">    RAWTEXTLessThanSignState,</span><br><span class="line">    RAWTEXTEndTagOpenState,</span><br><span class="line">    RAWTEXTEndTagNameState,</span><br><span class="line"></span><br><span class="line">    ScriptDataLessThanSignState,</span><br><span class="line">    ScriptDataEndTagOpenState,</span><br><span class="line">    ScriptDataEndTagNameState,</span><br><span class="line">    ScriptDataEscapeStartState,</span><br><span class="line">    ScriptDataEscapeStartDashState,</span><br><span class="line">    ScriptDataEscapedState,</span><br><span class="line">    ScriptDataEscapedDashState,</span><br><span class="line">    ScriptDataEscapedDashDashState,</span><br><span class="line">    ScriptDataEscapedLessThanSignState,</span><br><span class="line">    ScriptDataEscapedEndTagOpenState,</span><br><span class="line">    ScriptDataEscapedEndTagNameState,</span><br><span class="line">    ScriptDataDoubleEscapeStartState,</span><br><span class="line">    ScriptDataDoubleEscapedState,</span><br><span class="line">    ScriptDataDoubleEscapedDashState,</span><br><span class="line">    ScriptDataDoubleEscapedDashDashState,</span><br><span class="line">    ScriptDataDoubleEscapedLessThanSignState,</span><br><span class="line">    ScriptDataDoubleEscapeEndState,</span><br><span class="line"></span><br><span class="line">    BeforeAttributeNameState, //TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname</span><br><span class="line">    AttributeNameState, //BeforeAttributeNameState 碰见字母进入</span><br><span class="line">    AfterAttributeNameState,</span><br><span class="line">    BeforeAttributeValueState, //AttributeNameState 状态碰到 = 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的</span><br><span class="line">    AttributeValueDoubleQuotedState, //BeforeAttributeValueState 碰到 &quot; 符号</span><br><span class="line">    AttributeValueSingleQuotedState, //BeforeAttributeValueState 碰到 &apos; 符号</span><br><span class="line">    AttributeValueUnquotedState,</span><br><span class="line">    CharacterReferenceInAttributeValueState,</span><br><span class="line">    AfterAttributeValueQuotedState, // 再次碰到 &quot; 或 &apos; 符号。HTMLToken 记录属性的值</span><br><span class="line">    SelfClosingStartTagState,</span><br><span class="line">    BogusCommentState,</span><br><span class="line">    ContinueBogusCommentState, // Not in the HTML spec, used internally to track whether we started the bogus comment token.</span><br><span class="line">    MarkupDeclarationOpenState, //TagOpenState 后遇到! 比如&lt;!</span><br><span class="line"></span><br><span class="line">    //解析comment</span><br><span class="line">    CommentStartState, //MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT</span><br><span class="line">    CommentStartDashState,</span><br><span class="line">    CommentState, //CommentStartState 碰到字母进入这个状态</span><br><span class="line">    CommentEndDashState, //在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容</span><br><span class="line">    CommentEndState, //在 CommentEndDashState 状态碰见 - 进入</span><br><span class="line">    CommentEndBangState,</span><br><span class="line"></span><br><span class="line">    //解析 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 这种标签</span><br><span class="line">    DOCTYPEState, //匹配到 DOCTYPE，&lt;!DOCTYPE</span><br><span class="line">    BeforeDOCTYPENameState, //DOCTYPE 状态后遇到空格</span><br><span class="line">    DOCTYPENameState, //BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html</span><br><span class="line">    AfterDOCTYPENameState, //DOCTYPENameState 遇到空格 &lt;!DOCTYPE html</span><br><span class="line">    AfterDOCTYPEPublicKeywordState, //AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC</span><br><span class="line">    BeforeDOCTYPEPublicIdentifierState, //AfterDOCTYPEPublicKeywordState 状态后碰到空格</span><br><span class="line">    DOCTYPEPublicIdentifierDoubleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &quot; 进入</span><br><span class="line">    DOCTYPEPublicIdentifierSingleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &apos; 进入</span><br><span class="line">    AfterDOCTYPEPublicIdentifierState, //再次遇到 &quot; 或 &apos; 。可将 HTMLToken 的 m_publicIdentifier 确定</span><br><span class="line">    BetweenDOCTYPEPublicAndSystemIdentifiersState, </span><br><span class="line">    AfterDOCTYPESystemKeywordState,</span><br><span class="line">    BeforeDOCTYPESystemIdentifierState,</span><br><span class="line">    DOCTYPESystemIdentifierDoubleQuotedState,</span><br><span class="line">    DOCTYPESystemIdentifierSingleQuotedState,</span><br><span class="line">    AfterDOCTYPESystemIdentifierState,</span><br><span class="line">    BogusDOCTYPEState,</span><br><span class="line">    CDATASectionState,</span><br><span class="line"></span><br><span class="line">    // These CDATA states are not in the HTML5 spec, but we use them internally.</span><br><span class="line">    CDATASectionRightSquareBracketState,</span><br><span class="line">    CDATASectionDoubleRightSquareBracketState,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/55.png" alt="55"></p>
<h2 id="HTML-语法解析"><a href="#HTML-语法解析" class="headerlink" title="HTML 语法解析"></a>HTML 语法解析</h2><h3 id="HTML-的语法定义"><a href="#HTML-的语法定义" class="headerlink" title="HTML 的语法定义"></a>HTML 的语法定义</h3><p>HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：<a href="https://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">https://www.w3.org/TR/html4/strict.dtd</a></p>
<h3 id="相关类关系图"><a href="#相关类关系图" class="headerlink" title="相关类关系图"></a>相关类关系图</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/09.png" alt="09"></p>
<ul>
<li>Document 和 DocumentParser 相互引用</li>
<li>HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。</li>
<li>HTMLInputStream：解码后的字符流的保存，作为缓冲区。</li>
<li>HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。</li>
<li>HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。</li>
<li>HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用</li>
<li>HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。</li>
<li>HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/10.png" alt="10"></p>
<ul>
<li><p>DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。</p>
</li>
<li><p>HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。</p>
</li>
<li><p>把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite</a> 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。</p>
</li>
<li><p>然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。</p>
</li>
</ul>
<h3 id="Element-属性设置"><a href="#Element-属性设置" class="headerlink" title="Element 属性设置"></a>Element 属性设置</h3><p>是通过 Element::parserSetAttributes 来设置的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">			c++</span><br><span class="line">void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isConnected());</span><br><span class="line">    ASSERT(!parentNode());</span><br><span class="line">    ASSERT(!m_elementData);</span><br><span class="line"></span><br><span class="line">    if (!attributeVector.isEmpty()) &#123;</span><br><span class="line">        if (document().sharedObjectPool())</span><br><span class="line">            m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);</span><br><span class="line">        else</span><br><span class="line">            m_elementData = ShareableElementData::createWithAttributes(attributeVector);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parserDidSetAttributes();</span><br><span class="line"></span><br><span class="line">    // Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.</span><br><span class="line">    for (const auto&amp; attribute : attributeVector)</span><br><span class="line">        attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。</p>
<h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/84.png" alt="84"><br>相关类流程图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/87.png" alt="87"></p>
<p>前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树</p>
<h3 id="DOM-标准规范"><a href="#DOM-标准规范" class="headerlink" title="DOM 标准规范"></a>DOM 标准规范</h3><p>Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/52.png" alt="52"><br>下面对各个 level 进行说明<br>DOM level 1</p>
<ul>
<li>Core：底层接口，接口支持 XML 等任何结构化文档。</li>
<li>HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。</li>
</ul>
<p>DOM level 2</p>
<ul>
<li>Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。</li>
<li>HTML：允许动态访问修改文档。</li>
<li>Views：文档的各种视图。</li>
<li>Events：鼠标事件等。</li>
<li>Style：可以修改 HTML 样式的一个属性。</li>
<li>Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。</li>
</ul>
<p>节点DOM level 3</p>
<ul>
<li>Core：加入了新接口 adoptNode 和 textContent。</li>
<li>Load and Save：加载 XML 转成 DOM 表示的文档结构。</li>
<li>Validation：验证文档有效性。</li>
<li>Events：加入键盘支持。</li>
<li>XPath：一种简单直观检索 DOM 节点的方式。</li>
</ul>
<p>DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore/dom/Document.idl 文件里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">interface Document : Node &#123;</span><br><span class="line">    readonly attribute DOMImplementation implementation; // FIXME: Should be [SameObject].</span><br><span class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString URL;</span><br><span class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString documentURI;</span><br><span class="line">    readonly attribute USVString origin;</span><br><span class="line">    readonly attribute DOMString compatMode;</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString characterSet;</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString charset; // Historical alias of .characterSet,</span><br><span class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; // Historical alias of .characterSet.</span><br><span class="line">    readonly attribute DOMString contentType;</span><br><span class="line"></span><br><span class="line">    readonly attribute DocumentType? doctype;</span><br><span class="line">    [DOMJIT=Getter] readonly attribute Element? documentElement;</span><br><span class="line"></span><br><span class="line">    HTMLCollection getElementsByTagName(DOMString qualifiedName);</span><br><span class="line">    HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);</span><br><span class="line">    HTMLCollection getElementsByClassName(DOMString classNames);</span><br><span class="line"></span><br><span class="line">    [NewObject, MayThrowException, ImplementedAs=createElementForBindings] Element createElement(DOMString localName); // FIXME: missing options parameter.</span><br><span class="line">    [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); // FIXME: missing options parameter.</span><br><span class="line">    [NewObject] DocumentFragment createDocumentFragment();</span><br><span class="line">    [NewObject] Text createTextNode(DOMString data);</span><br><span class="line">    [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data);</span><br><span class="line">    [NewObject] Comment createComment(DOMString data);</span><br><span class="line">    [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);</span><br><span class="line"></span><br><span class="line">    [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep = false);</span><br><span class="line">    [CEReactions, MayThrowException] Node adoptNode(Node node);</span><br><span class="line"></span><br><span class="line">    [NewObject, MayThrowException] Attr createAttribute(DOMString localName);</span><br><span class="line">    [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName);</span><br><span class="line"></span><br><span class="line">    [MayThrowException, NewObject] Event createEvent(DOMString type);</span><br><span class="line"></span><br><span class="line">    [NewObject] Range createRange();</span><br><span class="line"></span><br><span class="line">    // NodeFilter.SHOW_ALL = 0xFFFFFFFF.</span><br><span class="line">    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</span><br><span class="line">    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</span><br><span class="line"></span><br><span class="line">    // Extensions from HTML specification (https://html.spec.whatwg.org/#the-document-object).</span><br><span class="line">    [PutForwards=href, Unforgeable] readonly attribute Location? location;</span><br><span class="line">    [SetterMayThrowException] attribute USVString domain;</span><br><span class="line">    readonly attribute USVString referrer;</span><br><span class="line">    [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie;</span><br><span class="line">    readonly attribute DOMString lastModified;</span><br><span class="line">    readonly attribute DocumentReadyState readyState;</span><br><span class="line"></span><br><span class="line">    // DOM tree accessors.</span><br><span class="line">    [CEReactions] attribute DOMString title;</span><br><span class="line">    [CEReactions] attribute DOMString dir;</span><br><span class="line">    [CEReactions, DOMJIT=Getter, ImplementedAs=bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body;</span><br><span class="line">    readonly attribute HTMLHeadElement? head;</span><br><span class="line">    readonly attribute HTMLCollection images; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection embeds; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection plugins; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection links; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection forms; // Should be [SameObject].</span><br><span class="line">    readonly attribute HTMLCollection scripts; // Should be [SameObject].</span><br><span class="line">    NodeList getElementsByName([AtomicString] DOMString elementName);</span><br><span class="line">    readonly attribute HTMLScriptElement? currentScript; // FIXME: Should return a HTMLOrSVGScriptElement.</span><br><span class="line"></span><br><span class="line">    // dynamic markup insertion</span><br><span class="line">    // FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure</span><br><span class="line">    // that the caller document matches those semantics. It is possible we should replace it with</span><br><span class="line">    // the existing &apos;incumbent document&apos; concept.</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, ImplementedAs=openForBindings, MayThrowException] Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</span><br><span class="line">    [CallWith=ActiveWindow&amp;FirstWindow, ImplementedAs=openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features);</span><br><span class="line">    [CEReactions, ImplementedAs=closeForBindings, MayThrowException] void close();</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void write(DOMString... text);</span><br><span class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void writeln(DOMString... text);</span><br><span class="line"></span><br><span class="line">    // User interaction.</span><br><span class="line">    readonly attribute DOMWindow? defaultView;</span><br><span class="line">    boolean hasFocus();</span><br><span class="line">    [CEReactions] attribute DOMString designMode;</span><br><span class="line">    [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString? value = null); // FIXME: value should not be nullable.</span><br><span class="line">    boolean queryCommandEnabled(DOMString commandId);</span><br><span class="line">    boolean queryCommandIndeterm(DOMString commandId);</span><br><span class="line">    boolean queryCommandState(DOMString commandId);</span><br><span class="line">    boolean queryCommandSupported(DOMString commandId);</span><br><span class="line">    DOMString queryCommandValue(DOMString commandId);</span><br><span class="line"></span><br><span class="line">    // Special event handler IDL attributes that only apply to Document objects.</span><br><span class="line">    [LenientThis] attribute EventHandler onreadystatechange;</span><br><span class="line"></span><br><span class="line">    // Extensions from the CSSOM specification (https://drafts.csswg.org/cssom/#extensions-to-the-document-interface).</span><br><span class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</span><br><span class="line">    readonly attribute StyleSheetList styleSheets; // FIXME: Should be [SameObject].</span><br><span class="line"></span><br><span class="line">    // Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-document-interface).</span><br><span class="line">    readonly attribute Element? scrollingElement;</span><br><span class="line"></span><br><span class="line">    // Extensions from Selection API (https://www.w3.org/TR/selection-api/#extensions-to-document-interface).</span><br><span class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</span><br><span class="line">    DOMSelection? getSelection();</span><br><span class="line"></span><br><span class="line">    // XPath extensions (https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator).</span><br><span class="line">    [MayThrowException] XPathExpression createExpression(optional DOMString expression = &quot;undefined&quot;, optional XPathNSResolver? resolver); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</span><br><span class="line">    XPathNSResolver createNSResolver(Node? nodeResolver);</span><br><span class="line">    [MayThrowException] XPathResult evaluate(optional DOMString expression = &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type = 0, optional XPathResult? inResult); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</span><br><span class="line"></span><br><span class="line">    // Extensions from FullScreen API (https://fullscreen.spec.whatwg.org/#api).</span><br><span class="line">    // FIXME: Should probably be unprefixed.</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled;</span><br><span class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement;</span><br><span class="line">    [Conditional=FULLSCREEN_API] void webkitExitFullscreen();</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; // Mozilla version.</span><br><span class="line">    [Conditional=FULLSCREEN_API] void webkitCancelFullScreen(); // Mozilla version.</span><br><span class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange;</span><br><span class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror;</span><br><span class="line"></span><br><span class="line">    // Extensions from Pointer Lock API (https://www.w3.org/TR/pointerlock/#extensions-to-the-document-interface).</span><br><span class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockchange; // FIXME: Should be enumerable.</span><br><span class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockerror; // FIXME: Should be enumerable.</span><br><span class="line">    [Conditional=POINTER_LOCK] void exitPointerLock();</span><br><span class="line"></span><br><span class="line">    // Extensions from CSS Font Loading API (https://drafts.csswg.org/css-font-loading/#font-face-source).</span><br><span class="line">    // FIXME: Should be in a separate FontFaceSource interface.</span><br><span class="line">    readonly attribute FontFaceSet fonts;</span><br><span class="line"></span><br><span class="line">    // Extensions from Page visibility API (https://www.w3.org/TR/page-visibility/#sec-document-interface).</span><br><span class="line">    readonly attribute boolean hidden;</span><br><span class="line">    readonly attribute VisibilityState visibilityState;</span><br><span class="line">    attribute EventHandler onvisibilitychange;</span><br><span class="line"></span><br><span class="line">    // FIXME: Those were dropped from the CSSOM specification.</span><br><span class="line">    readonly attribute DOMString? preferredStylesheetSet;</span><br><span class="line">    attribute DOMString? selectedStylesheetSet;</span><br><span class="line"></span><br><span class="line">    // FIXME: Those have been dropped from the DOM specification.</span><br><span class="line">    readonly attribute DOMString? xmlEncoding;</span><br><span class="line">    [SetterMayThrowException] attribute DOMString? xmlVersion;</span><br><span class="line">    attribute boolean xmlStandalone;</span><br><span class="line"></span><br><span class="line">    // FIXME: Blink has already dropped this (https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/s3ezjTuC8ig).</span><br><span class="line">    CSSStyleDeclaration getOverrideStyle(optional Element? element = null, optional DOMString pseudoElement = &quot;undefined&quot;);</span><br><span class="line"></span><br><span class="line">    // FIXME: Should be moved to GlobalEventHandlers (http://w3c.github.io/selection-api/#extensions-to-globaleventhandlers).</span><br><span class="line">    [NotEnumerable] attribute EventHandler onselectstart; // FIXME: Should be enumerable.</span><br><span class="line">    [NotEnumerable] attribute EventHandler onselectionchange; // FIXME: Should be enumerable.</span><br><span class="line"></span><br><span class="line">    // Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet.</span><br><span class="line">    Range caretRangeFromPoint(optional long x = 0, optional long y = 0);</span><br><span class="line"></span><br><span class="line">    // FIXME: This is not standard and has been dropped from Blink already.</span><br><span class="line">    RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height);</span><br><span class="line"></span><br><span class="line">    // Non standard (https://developer.apple.com/reference/webkitjs/document/1633863-webkitgetnamedflows).</span><br><span class="line">    [Conditional=CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // Obsolete features from https://html.spec.whatwg.org/multipage/obsolete.html</span><br><span class="line"></span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor;</span><br><span class="line">    [CEReactions, ImplementedAs=linkColorForBindings] attribute [TreatNullAs=EmptyString] DOMString linkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor;</span><br><span class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;</span><br><span class="line"></span><br><span class="line">    readonly attribute HTMLCollection anchors; /* [SameObject] */</span><br><span class="line">    readonly attribute HTMLCollection applets; /* [SameObject] */</span><br><span class="line"></span><br><span class="line">    void clear();</span><br><span class="line">    void captureEvents();</span><br><span class="line">    void releaseEvents();</span><br><span class="line"></span><br><span class="line">    [Replaceable] readonly attribute HTMLAllCollection all; /* [SameObject] */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DOM-Tree-Token-的构造算法"><a href="#DOM-Tree-Token-的构造算法" class="headerlink" title="DOM Tree Token 的构造算法"></a>DOM Tree Token 的构造算法</h3><p>这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：<a href="https://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="noopener">https://www.w3.org/TR/html5/syntax.html#html-parser</a></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/19.png" alt="19"><br>当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。</p>
<p>具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。</p>
<p>接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。</p>
<p>再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。</p>
<h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>构建 DOM 的几个关键的类<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/53.png" alt="53"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/11.png" alt="11"></p>
<ul>
<li>HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。</li>
<li>HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。</li>
<li>HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。</li>
<li>HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。</li>
</ul>
<p>构建 DOM 树的过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/54.png" alt="54"></p>
<p>举个例子：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">			Hello World</span><br><span class="line">		<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"example.png"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转成 DOM Tree 如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/69.png" alt="69"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FetchRequest fetchRequest(m_request, FetchInitiatorTypeNames::document,</span><br><span class="line">                            mainResourceLoadOptions);</span><br><span class="line">  m_mainResource =</span><br><span class="line">      RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData);</span><br></pre></td></tr></table></figure>

<p>DocumentLoader 的 commitData 会去处理 dataReceived 的数据块</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DocumentLoader::commitData(const char* bytes, size_t length) &#123;</span><br><span class="line">  ensureWriter(m_response.mimeType()); //会初始化 HTMLDocumentParser 实例化 document 对象</span><br><span class="line">  if (length)</span><br><span class="line">    m_dataReceived = true;</span><br><span class="line">  m_writer-&gt;addData(bytes, length); //给 Parser 解析，这里的bytes就是返回来的 html 文本代码</span><br><span class="line">&#125;</span><br><span class="line">//ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次</span><br><span class="line">void DocumentLoader::ensureWriter(const AtomicString&amp; mimeType, const KURL&amp; overridingURL) &#123;</span><br><span class="line">  if (m_writer)</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>DOM Tree 已经被 W3 标准化了 <a href="https://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">Document Object Model (DOM) Technical Reports</a> 在 DOM Level 3 里 IDL 的定义在 <a href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank" rel="noopener">IDL Definitions</a></p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/56.png" alt="56"></p>
<p>在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode" target="_blank" rel="noopener">http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode</a> 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a> 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。</p>
<p>需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：<a href="https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements</a></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/37.png" alt="37"></p>
<p>DOM Node 的数据结构<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/12.png" alt="12"></p>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/75.png" alt="75"></p>
<h4 id="构建-DOM-Tree-1"><a href="#构建-DOM-Tree-1" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h4><p>从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore/html/parser/HTMLTreeBuilder.cpp 文件里。<br>constructtreefromToken</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)</span><br><span class="line">&#123;</span><br><span class="line">    switch (token.type()) &#123;</span><br><span class="line">    case HTMLToken::Uninitialized:</span><br><span class="line">        ASSERT_NOT_REACHED();</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::DOCTYPE:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processDoctypeToken(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::StartTag:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processStartTag(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::EndTag:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processEndTag(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::Comment:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processComment(WTFMove(token));</span><br><span class="line">        return;</span><br><span class="line">    case HTMLToken::Character:</span><br><span class="line">        processCharacter(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    case HTMLToken::EndOfFile:</span><br><span class="line">        m_shouldSkipLeadingNewline = false;</span><br><span class="line">        processEndOfFile(WTFMove(token));</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) &#123;</span><br><span class="line">  HTMLHtmlElement* element = HTMLHtmlElement::create(*m_document);</span><br><span class="line">  attachLater(m_attachmentRoot, element);</span><br><span class="line">  m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); //push 到 HTMLStackItem 栈里</span><br><span class="line">  executeQueuedTasks();</span><br><span class="line">&#125;</span><br><span class="line">//通过 attachLater 创建 task</span><br><span class="line">void HTMLConstructionSite::attachLater(ContainerNode* parent,</span><br><span class="line">                                       Node* child,</span><br><span class="line">                                       bool selfClosing) &#123;</span><br><span class="line">  HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);</span><br><span class="line">  task.parent = parent;</span><br><span class="line">  task.child = child;</span><br><span class="line">  task.selfClosing = selfClosing;</span><br><span class="line">  //判断是否到达最深，512是最深</span><br><span class="line">  if (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp;</span><br><span class="line">      task.parent-&gt;parentNode())</span><br><span class="line">    task.parent = task.parent-&gt;parentNode();</span><br><span class="line">  queueTask(task);</span><br><span class="line">&#125;</span><br><span class="line">//executeQueued 添加子节点</span><br><span class="line">void ContainerNode::parserAppendChild(Node* newChild) &#123;</span><br><span class="line">  if (!checkParserAcceptChild(*newChild))</span><br><span class="line">    return;</span><br><span class="line">    AdoptAndAppendChild()(*this, *newChild, nullptr);</span><br><span class="line">  &#125;</span><br><span class="line">  notifyNodeInserted(*newChild, ChildrenChangeSourceParser);</span><br><span class="line">&#125;</span><br><span class="line">//添加前会先检查是否支持子元素</span><br><span class="line">void ContainerNode::appendChildCommon(Node&amp; child) &#123;</span><br><span class="line">  child.setParentOrShadowHostNode(this);</span><br><span class="line">  if (m_lastChild) &#123;</span><br><span class="line">    child.setPreviousSibling(m_lastChild);</span><br><span class="line">    m_lastChild-&gt;setNextSibling(&amp;child);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    setFirstChild(&amp;child);</span><br><span class="line">  &#125;</span><br><span class="line">  setLastChild(&amp;child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭标签会把元素 pop 出来</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_tree.openElements()-&gt;popUntilPopped(token-&gt;name());</span><br></pre></td></tr></table></figure>

<h3 id="对错误的处理"><a href="#对错误的处理" class="headerlink" title="对错误的处理"></a>对错误的处理</h3><p>parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子</p>
<h4 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a><br> 问题</h4><p>一些网站会用 <br> 替代 <br>，处理的代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="stray-table"><a href="#stray-table" class="headerlink" title="stray table"></a>stray table</h4><p>stray table 是一个 table 包含了一个不在 table cell 的 table。</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">		<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>inner table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">         <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>outer table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>WebKit 的处理</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure>

<p>这样会处理成两个同级 table</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>outer table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">	<span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>inner table<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"> <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套-form"><a href="#嵌套-form" class="headerlink" title="嵌套 form"></a>嵌套 form</h4><p>将一个 form 放到另一个 form 里。那么第二个 form 会被忽略</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement = new HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过深的层级"><a href="#过深的层级" class="headerlink" title="过深的层级"></a>过深的层级</h4><p>同一个类型里只允许嵌套 20 个 tag。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line">unsigned i = 0;</span><br><span class="line">for (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">     curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line">return i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="html-或-body-的-end-tags-缺失"><a href="#html-或-body-的-end-tags-缺失" class="headerlink" title="html 或 body 的 end tags 缺失"></a>html 或 body 的 end tags 缺失</h4><p>这些都会在 end() 是调用</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line">        return;</span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-语法简介"><a href="#CSS-语法简介" class="headerlink" title="CSS 语法简介"></a>CSS 语法简介</h3><p>所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。</p>
<h4 id="CSS-declarations"><a href="#CSS-declarations" class="headerlink" title="CSS declarations"></a>CSS declarations</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/40.png" alt="40"><br>在这里可以找到 CSS  的不同的属性。</p>
<h4 id="CSS-declaration-blocks"><a href="#CSS-declaration-blocks" class="headerlink" title="CSS declaration blocks"></a>CSS declaration blocks</h4><p>使用大括号包起来。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/41.png" alt="41"></p>
<h4 id="CSS-selectors-and-rules"><a href="#CSS-selectors-and-rules" class="headerlink" title="CSS selectors and rules"></a>CSS selectors and rules</h4><p>在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/42.png" alt="42"></p>
<p>selector 可以分为以下类别</p>
<ul>
<li>Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。</li>
<li>Attribute selectors：属性选择器，通过属性匹配。</li>
<li>Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。</li>
<li>Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^=http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。</li>
<li>Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。</li>
<li>Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。</li>
</ul>
<p>Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种</p>
<ul>
<li>[attr]：不论值是什么选择所有 attr 属性的元素。</li>
<li>[attr=val]：按照 attr 属性的值为 val 的所有元素。</li>
<li>[attr~=val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。</li>
</ul>
<p>还有 Substring value attribute selector 这样的伪正则选择器：</p>
<ul>
<li>[attr|=val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。</li>
<li>[attr^=val]：匹配选择以 val 开头的元素。</li>
<li>[attr$=val]：匹配选择以 val 结尾的元素。</li>
<li>[attr*=val]：匹配选择包含 val 的元素。</li>
</ul>
<p>Combinators 组合器有以下几种</p>
<ul>
<li>A,B： 匹配 A B 的任意元素。</li>
<li>A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。</li>
<li>A &gt; B：B 是 A 的直接子节点。</li>
<li>A + B：B 是 A 的兄弟节点。</li>
<li>A ~ B：B 是 A 兄弟节点中的任意一个。</li>
</ul>
<h4 id="CSS-statements"><a href="#CSS-statements" class="headerlink" title="CSS statements"></a>CSS statements</h4><p>CSS rule 只是 CSS statements 的一种。<br>其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。</p>
<ul>
<li>@charset：元数据</li>
<li>@import：元数据</li>
<li>@media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。</li>
<li>@supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。</li>
<li>@document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。</li>
<li>@font-face：描述性信息</li>
</ul>
<p>比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;starming.css&apos;;</span><br></pre></td></tr></table></figure>

<p>表示向当前的 CSS 导入了 starming.css 文件。再举个例子：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@media (min-width: 801px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        width:800px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个表示页面宽度超过801像素时才会运用 @-规则里的内容。</p>
<h4 id="Shorthand"><a href="#Shorthand" class="headerlink" title="Shorthand"></a>Shorthand</h4><p>有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。<br>比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maring: 20px 10px 10px 20px;</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">margin-top: 20px;</span><br><span class="line">margin-right: 10px;</span><br><span class="line">margin-bottom: 10px;</span><br><span class="line">margin-left: 20px;</span><br></pre></td></tr></table></figure>

<p>再比如 background 属性</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: black url(starming-bg.png) 20px 20px repeat-x fixed;</span><br></pre></td></tr></table></figure>

<p>和下面的属性设置等效</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background-color: black;</span><br><span class="line">background-image: url(starming-bg.png);</span><br><span class="line">background-position: 20px 20px;</span><br><span class="line">background-repeat: repeat-x;</span><br><span class="line">background-scroll: fixed;</span><br></pre></td></tr></table></figure>

<h4 id="Value-and-unit"><a href="#Value-and-unit" class="headerlink" title="Value and unit"></a>Value and unit</h4><ul>
<li>absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1/72 of an inch) 点，picas (12 points.) 十二点活字。</li>
<li>相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1/100 和视图高度的 1/100，但是支持没有 rem 那么好。</li>
<li>无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。</li>
<li>百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。</li>
<li>颜色：有165个不同关键字可用，具体见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords</a> ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：<a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle</a></li>
<li>透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。</li>
<li>函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’);</li>
</ul>
<h4 id="验证-CSS-语法正确性"><a href="#验证-CSS-语法正确性" class="headerlink" title="验证 CSS 语法正确性"></a>验证 CSS 语法正确性</h4><p>可以通过 w3c 提供的服务 <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="noopener">http://jigsaw.w3.org/css-validator/</a> 来验证，w3c 还提供了 html 的验证服务 <a href="https://validator.w3.org/#validate_by_uri" target="_blank" rel="noopener">https://validator.w3.org/#validate_by_uri</a></p>
<h3 id="CSS-BNF"><a href="#CSS-BNF" class="headerlink" title="CSS BNF"></a>CSS BNF</h3><p>CSS 语法 BNF</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : &apos;.&apos; IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | &apos;*&apos;</span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>

<p>WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/68.png" alt="68"></p>
<h3 id="CSS-主要类与关系"><a href="#CSS-主要类与关系" class="headerlink" title="CSS 主要类与关系"></a>CSS 主要类与关系</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/57.png" alt="57"><br>上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。</p>
<p>StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。</p>
<p>CSS 文档结构的类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/90.png" alt="90"></p>
<h4 id="StyleRuleBase-类的继承关系"><a href="#StyleRuleBase-类的继承关系" class="headerlink" title="StyleRuleBase 类的继承关系"></a>StyleRuleBase 类的继承关系</h4><p>RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/58.png" alt="58"><br>我们来看看这些子类类型都是对应 CSS 里的什么</p>
<ul>
<li>StyleRule：常用的都是这个类型</li>
<li>StyleRuleImport：对应的是 @import</li>
<li>StyleRuleMedia：对应的是 @media</li>
<li>StyleRuleFontFace：对应的 @font-face</li>
<li>StyleRulePage：对应的 @page</li>
<li>StyleRuleKeyFrames：对应的 @-webkit-key-frames</li>
<li>StyleRuleRegion：分区域排版</li>
</ul>
<h4 id="StyleRule-类的结构"><a href="#StyleRule-类的结构" class="headerlink" title="StyleRule 类的结构"></a>StyleRule 类的结构</h4><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/59.png" alt="59"></p>
<h3 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h3><p>WebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/91.png" alt="91"></p>
<p>字符串转 tokens<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/13.png" alt="13"></p>
<p>将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。<br>定义 matchType</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum MatchType &#123;</span><br><span class="line">    Unknown,</span><br><span class="line">    Tag,               //比如 div</span><br><span class="line">    Id,                // #id</span><br><span class="line">    Class,             // .class</span><br><span class="line">    PseudoClass,       // :nth-child(2)</span><br><span class="line">    PseudoElement,     // ::first-line</span><br><span class="line">    PagePseudoClass,   //</span><br><span class="line">    AttributeExact,    // E[attr=&quot;value&quot;]</span><br><span class="line">    AttributeSet,      // E[attr]</span><br><span class="line">    AttributeHyphen,   // E[attr|=&quot;value&quot;]</span><br><span class="line">    AttributeList,     // E[attr~=&quot;value&quot;]</span><br><span class="line">    AttributeContain,  // E[attr*=&quot;value&quot;]</span><br><span class="line">    AttributeBegin,    // E[attr^=&quot;value&quot;]</span><br><span class="line">    AttributeEnd,      // E[attr$=&quot;value&quot;]</span><br><span class="line">    FirstAttributeSelectorMatch = AttributeExact,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义 selectors 的 Relation 类型</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum RelationType &#123;</span><br><span class="line">    SubSelector,       // No combinator</span><br><span class="line">    Descendant,        // &quot;Space&quot; combinator</span><br><span class="line">    Child,             // &gt; combinator</span><br><span class="line">    DirectAdjacent,    // + combinator</span><br><span class="line">    IndirectAdjacent,  // ~ combinator</span><br><span class="line">    // Special cases for shadow DOM related selectors.</span><br><span class="line">    ShadowPiercingDescendant,  // &gt;&gt;&gt; combinator</span><br><span class="line">    ShadowDeep,                // /deep/ combinator</span><br><span class="line">    ShadowPseudo,              // ::shadow pseudo element</span><br><span class="line">    ShadowSlot                 // ::slotted() pseudo element</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CSS 的属性是 id 来标识的</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum CSSPropertyID &#123;</span><br><span class="line">    CSSPropertyColor = 15,</span><br><span class="line">    CSSPropertyWidth = 316,</span><br><span class="line">    CSSPropertyMarginLeft = 145,</span><br><span class="line">    CSSPropertyMarginRight = 146,</span><br><span class="line">    CSSPropertyMarginTop = 147,</span><br><span class="line">    CSSPropertyMarkerEnd = 148,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认样式，Blink ua全部 CSS 样式：<a href="http://yincheng.site/html/chrome-ua-css.html" target="_blank" rel="noopener">http://yincheng.site/html/chrome-ua-css.html</a> 。w3c 的默认样式是：<a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/sample.html</a></p>
<p>接着会生成 hash map，分成四个类型</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompactRuleMap m_idRules;                    //id</span><br><span class="line">CompactRuleMap m_classRules;                 //class</span><br><span class="line">CompactRuleMap m_tagRules;                   //标签</span><br><span class="line">CompactRuleMap m_shadowPseudoElementRules;   //伪类选择器</span><br></pre></td></tr></table></figure>

<p>CSS 解析完会触发  layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。</p>
<p>layout 会更新递归所有 DOM 元素</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void ContainerNode::attachLayoutTree(const AttachContext&amp; context) &#123;</span><br><span class="line">  for (Node* child = firstChild(); child; child = child-&gt;nextSibling()) &#123;</span><br><span class="line">    if (child-&gt;needsAttach())</span><br><span class="line">      child-&gt;attachLayoutTree(childrenContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//id</span><br><span class="line">if (element.hasID()) </span><br><span class="line">  collectMatchingRulesForList(</span><br><span class="line">      matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()),</span><br><span class="line">      cascadeOrder, matchRequest);</span><br><span class="line">//class</span><br><span class="line">if (element.isStyledElement() &amp;&amp; element.hasClass()) &#123; </span><br><span class="line">  for (size_t i = 0; i &lt; element.classNames().size(); ++i)</span><br><span class="line">    collectMatchingRulesForList(</span><br><span class="line">        matchRequest.ruleSet-&gt;classRules(element.classNames()[i]),</span><br><span class="line">        cascadeOrder, matchRequest);</span><br><span class="line">&#125;</span><br><span class="line">//伪类</span><br><span class="line">...</span><br><span class="line">//tag 和 selector</span><br><span class="line">collectMatchingRulesForList(</span><br><span class="line">    matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()),</span><br><span class="line">    cascadeOrder, matchRequest);</span><br><span class="line">//通配符</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。</p>
<p>在 classRules 里会进行检验</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if (!checkOne(context, subResult))</span><br><span class="line">  return SelectorFailsLocally;</span><br><span class="line">if (context.selector-&gt;isLastInTagHistory()) &#123; </span><br><span class="line">    return SelectorMatches;</span><br><span class="line">&#125;</span><br><span class="line">//checkOne 的实现</span><br><span class="line">switch (selector.match()) &#123; </span><br><span class="line">  case CSSSelector::Tag:</span><br><span class="line">    return matchesTagName(element, selector.tagQName());</span><br><span class="line">  case CSSSelector::Class:</span><br><span class="line">    return element.hasClass() &amp;&amp;</span><br><span class="line">           element.classNames().contains(selector.value());</span><br><span class="line">  case CSSSelector::Id:</span><br><span class="line">    return element.hasID() &amp;&amp;</span><br><span class="line">           element.idForStyleResolution() == selector.value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">switch (relation) &#123; </span><br><span class="line">  case CSSSelector::Descendant:</span><br><span class="line">    for (nextContext.element = parentElement(context); nextContext.element;</span><br><span class="line">         nextContext.element = parentElement(nextContext)) &#123; </span><br><span class="line">      MatchStatus match = matchSelector(nextContext, result);</span><br><span class="line">      if (match == SelectorMatches || match == SelectorFailsCompletely)</span><br><span class="line">        return match;</span><br><span class="line">      if (nextSelectorExceedsScope(nextContext))</span><br><span class="line">        return SelectorFailsCompletely;</span><br><span class="line">    &#125; </span><br><span class="line">    return SelectorFailsCompletely;</span><br><span class="line">      case CSSSelector::Child:</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。</p>
<h3 id="CSS-规则匹配"><a href="#CSS-规则匹配" class="headerlink" title="CSS 规则匹配"></a>CSS 规则匹配</h3><p>CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。</p>
<p>CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/92.png" alt="92"><br>匹配的流程图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/93.png" alt="93"></p>
<h3 id="设置-style"><a href="#设置-style" class="headerlink" title="设置 style"></a>设置 style</h3><p>设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">style-&gt;inheritFrom(*state.parentStyle())</span><br><span class="line">matchUARules(collector);</span><br><span class="line">matchAuthorRules(*state.element(), collector);</span><br></pre></td></tr></table></figure>

<p>在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (const CSSSelector* selector = this; selector;</span><br><span class="line">     selector = selector-&gt;tagHistory()) &#123; </span><br><span class="line">  temp = total + selector-&gt;specificityForOneSelector();</span><br><span class="line">&#125;</span><br><span class="line">return total;</span><br></pre></td></tr></table></figure>

<p>每个不同类型的 selector 的优先级如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">switch (m_match) &#123;</span><br><span class="line">    case Id: </span><br><span class="line">      return 0x010000;</span><br><span class="line">    case PseudoClass:</span><br><span class="line">      return 0x000100;</span><br><span class="line">    case Class:</span><br><span class="line">    case PseudoElement:</span><br><span class="line">    case AttributeExact:</span><br><span class="line">    case AttributeSet:</span><br><span class="line">    case AttributeList:</span><br><span class="line">    case AttributeHyphen:</span><br><span class="line">    case AttributeContain:</span><br><span class="line">    case AttributeBegin:</span><br><span class="line">    case AttributeEnd:</span><br><span class="line">      return 0x000100;</span><br><span class="line">    case Tag:</span><br><span class="line">      return 0x000001;</span><br><span class="line">    case Unknown:</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 id 的优先级最大是 0x010000 = 65536，类，属性，伪类优先级是 0x000100 = 256，标签是 0x000001 = 1</p>
<p>举个优先级计算的例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*优先级为257 = 265 + 1*/</span><br><span class="line">.text h1&#123;</span><br><span class="line">    font-size: 8em;</span><br><span class="line">&#125;</span><br><span class="line">/*优先级为65537 = 65536 + 1*/</span><br><span class="line">#my-text h1&#123;</span><br><span class="line">    font-size: 16em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。</p>
<p>目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。</p>
<p>排序规则</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline bool compareRules(const MatchedRule&amp; matchedRule1,</span><br><span class="line">                                const MatchedRule&amp; matchedRule2) &#123;</span><br><span class="line">  unsigned specificity1 = matchedRule1.specificity();</span><br><span class="line">  unsigned specificity2 = matchedRule2.specificity();</span><br><span class="line">  if (specificity1 != specificity2)</span><br><span class="line">    return specificity1 &lt; specificity2;</span><br><span class="line"> </span><br><span class="line">  return matchedRule1.position() &lt; matchedRule2.position();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规则和优先级完后就开始设置元素的 style 了：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">applyMatchedPropertiesAndCustomPropertyAnimations(</span><br><span class="line">        state, collector.matchedResult(), element);</span><br><span class="line"></span><br><span class="line">applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</span><br><span class="line">      state, matchResult.allRules(), false, applyInheritedOnly, needsApplyPass);</span><br><span class="line">  for (auto range : ImportantAuthorRanges(matchResult)) &#123;</span><br><span class="line">    applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</span><br><span class="line">        state, range, true, applyInheritedOnly, needsApplyPass);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/14.png" alt="14"></p>
<p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/15.png" alt="15"></p>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。</p>
<p>W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore/page/DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-window-interface).</span><br><span class="line">[NewObject] MediaQueryList matchMedia(CSSOMString query);</span><br><span class="line">[Replaceable] readonly attribute Screen screen; // FIXME: Should be [SameObject].</span><br><span class="line"></span><br><span class="line">// Browsing context (CSSOM-View).</span><br><span class="line">void moveTo(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line">void moveBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line">void resizeTo(optional unrestricted float width = NaN, optional unrestricted float height = NaN); // Parameters should be mandatory and of type long.</span><br><span class="line">void resizeBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</span><br><span class="line"></span><br><span class="line">// Viewport (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute long innerHeight;</span><br><span class="line">[Replaceable] readonly attribute long innerWidth;</span><br><span class="line"></span><br><span class="line">// Viewport scrolling (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute double scrollX;</span><br><span class="line">[Replaceable, ImplementedAs=scrollX] readonly attribute double pageXOffset;</span><br><span class="line">[Replaceable] readonly attribute double scrollY;</span><br><span class="line">[Replaceable, ImplementedAs=scrollY] readonly attribute double pageYOffset;</span><br><span class="line">[ImplementedAs=scrollTo] void scroll(optional ScrollToOptions options);</span><br><span class="line">[ImplementedAs=scrollTo] void scroll(unrestricted double x, unrestricted double y);</span><br><span class="line">void scrollTo(optional ScrollToOptions options);</span><br><span class="line">void scrollTo(unrestricted double x, unrestricted double y);</span><br><span class="line">void scrollBy(optional ScrollToOptions option);</span><br><span class="line">void scrollBy(unrestricted double x, unrestricted double y);</span><br><span class="line"></span><br><span class="line">// Client (CSSOM-View).</span><br><span class="line">[Replaceable] readonly attribute long screenX;</span><br><span class="line">[Replaceable] readonly attribute long screenY;</span><br><span class="line">[Replaceable] readonly attribute long outerWidth;</span><br><span class="line">[Replaceable] readonly attribute long outerHeight;</span><br><span class="line">[Replaceable] readonly attribute double devicePixelRatio;</span><br></pre></td></tr></table></figure>

<p>可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。</p>
<h2 id="RenderObject-Tree"><a href="#RenderObject-Tree" class="headerlink" title="RenderObject Tree"></a>RenderObject Tree</h2><p>当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。</p>
<p>整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/64.png" alt="64"><br>上图所示，WebKit 会先检查 DOM 节点是否需要新的  RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。</p>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>RenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/88.png" alt="88"></p>
<p>RenderObject 被创建时创建时相关的类如下图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/62.png" alt="62"><br>Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/89.png" alt="89"></p>
<p>RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/63.png" alt="63"></p>
<p>RenderObject 核心对象关系图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/94.png" alt="94"></p>
<p>RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。</p>
<p>RenderObject 的继承关系图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/76.png" alt="76"></p>
<p>RenderObject 的一些主要虚函数</p>
<ul>
<li>parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。</li>
<li>layout()，style()，enclosingBox() 这些计算和获取布局的函数。</li>
<li>isASubClass 类似这样判断那种子类类型的函数。</li>
<li>paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。</li>
</ul>
<p>RenderObject 用来构建 Render Tree 的相关方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RenderElement* parent() const &#123; return m_parent; &#125;</span><br><span class="line">bool isDescendantOf(const RenderObject*) const;</span><br><span class="line"></span><br><span class="line">RenderObject* previousSibling() const &#123; return m_previous; &#125;</span><br><span class="line">RenderObject* nextSibling() const &#123; return m_next; &#125;</span><br><span class="line"></span><br><span class="line">// Use RenderElement versions instead.</span><br><span class="line">virtual RenderObject* firstChildSlow() const &#123; return nullptr; &#125;</span><br><span class="line">virtual RenderObject* lastChildSlow() const &#123; return nullptr; &#125;</span><br><span class="line"></span><br><span class="line">RenderObject* nextInPreOrder() const;</span><br><span class="line">RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;</span><br><span class="line">RenderObject* nextInPreOrderAfterChildren() const;</span><br><span class="line">RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;</span><br><span class="line">RenderObject* previousInPreOrder() const;</span><br><span class="line">RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;</span><br><span class="line">WEBCORE_EXPORT RenderObject* childAt(unsigned) const;</span><br><span class="line"></span><br><span class="line">RenderObject* firstLeafChild() const;</span><br><span class="line">RenderObject* lastLeafChild() const;</span><br></pre></td></tr></table></figure>

<p>RenderObject 用来布局相关的方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool needsLayout() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()</span><br><span class="line">        || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool selfNeedsLayout() const &#123; return m_bitfields.needsLayout(); &#125;</span><br><span class="line">bool needsPositionedMovementLayout() const &#123; return m_bitfields.needsPositionedMovementLayout(); &#125;</span><br><span class="line">bool needsPositionedMovementLayoutOnly() const</span><br><span class="line">&#123;</span><br><span class="line">    return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()</span><br><span class="line">        &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool posChildNeedsLayout() const &#123; return m_bitfields.posChildNeedsLayout(); &#125;</span><br><span class="line">bool needsSimplifiedNormalFlowLayout() const &#123; return m_bitfields.needsSimplifiedNormalFlowLayout(); &#125;</span><br><span class="line">bool normalChildNeedsLayout() const &#123; return m_bitfields.normalChildNeedsLayout(); &#125;</span><br></pre></td></tr></table></figure>

<p>RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。</p>
<p>RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。</p>
<p>RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。</p>
<p>RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。</p>
<p>RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/95.png" alt="95"><br>RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。</p>
<p>RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/96.png" alt="96"></p>
<h3 id="StyleResolver"><a href="#StyleResolver" class="headerlink" title="StyleResolver"></a>StyleResolver</h3><p>RenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/61.png" alt="61"></p>
<p>规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/60.png" alt="60"><br>创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle = 0, StyleSharingBehavior = AllowStyleSharing,  </span><br><span class="line">    RuleMatchingBehavior = MatchAllRules, RenderRegion* regionForStyling = 0);   </span><br><span class="line"> ......  </span><br><span class="line">  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle);  </span><br><span class="line">  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForPage(int pageIndex);  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement();  </span><br><span class="line">PassRefPtr&lt;RenderStyle&gt; styleForText(Text*);  </span><br><span class="line">  </span><br><span class="line">static PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* = 0);</span><br></pre></td></tr></table></figure>

<p>StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。</p>
<h3 id="styleForElement-进行-CSS-选择和匹配"><a href="#styleForElement-进行-CSS-选择和匹配" class="headerlink" title="styleForElement 进行 CSS 选择和匹配"></a>styleForElement 进行 CSS 选择和匹配</h3><p>具体代码实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//保存 element</span><br><span class="line">initElement(element);</span><br><span class="line">initForStyleResolve(element, defaultParent);  </span><br><span class="line">....  </span><br><span class="line"></span><br><span class="line">//规则匹配  </span><br><span class="line">MatchResult matchResult;  </span><br><span class="line">if (matchingBehavior == MatchOnlyUserAgentRules)  </span><br><span class="line">    matchUARules(matchResult);  </span><br><span class="line">else  </span><br><span class="line">    matchAllRules(matchResult, matchingBehavior != MatchAllRulesExcludingSMIL);  </span><br><span class="line"></span><br><span class="line">//将规则和 element 做映射</span><br><span class="line">applyMatchedProperties(matchResult, element);</span><br><span class="line"></span><br><span class="line">//matchUARules</span><br><span class="line">void StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules)  </span><br><span class="line">&#123;</span><br><span class="line">    m_matchedRules.clear();</span><br><span class="line">    result.ranges.lastUARule = result.matchedProperties.size() - 1;</span><br><span class="line">    //收集匹配规则</span><br><span class="line">    collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, false);  </span><br><span class="line">	//规则排序</span><br><span class="line">    sortAndTransferMatchedRules(result);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RuleSet"><a href="#RuleSet" class="headerlink" title="RuleSet"></a>RuleSet</h3><p>matchUARules 的 RuleSet 代表 CSS 规则，比如</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123; background : red; &#125;</span><br></pre></td></tr></table></figure>

<p>RuleSet 的成员变量</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RuleSet ... &#123;</span><br><span class="line">.....</span><br><span class="line">AtomRuleMap m_idRules;</span><br><span class="line">AtomRuleMap m_classRules;</span><br><span class="line">AtomRuleMap m_tagRules;</span><br><span class="line">AtomRuleMap m_shadowPseudoElementRules;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sortAndTransferMatchedRules 是为了保证正确的匹配顺序。</p>
<p>RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void StyledElement::rebuildPresentationAttributeStyle()  </span><br><span class="line">&#123;  </span><br><span class="line">.....  </span><br><span class="line">  </span><br><span class="line">    RefPtr&lt;StylePropertySet&gt; style;</span><br><span class="line">    if (cacheHash &amp;&amp; cacheIterator-&gt;value) &#123;  </span><br><span class="line">        style = cacheIterator-&gt;value-&gt;value;  </span><br><span class="line">        presentationAttributeCacheCleaner().didHitPresentationAttributeCache();  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        style = StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode);  </span><br><span class="line">        unsigned size = attributeCount();  </span><br><span class="line">        for (unsigned i = 0; i &lt; size; ++i) &#123;  </span><br><span class="line">            const Attribute* attribute = attributeItem(i);  </span><br><span class="line">            collectStyleForPresentationAttribute(*attribute, style.get());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // ImmutableElementAttributeData doesn&apos;t store presentation attribute style, so make sure we have a MutableElementAttributeData.  </span><br><span class="line">    ElementAttributeData* attributeData = mutableAttributeData();  </span><br><span class="line">  </span><br><span class="line">    attributeData-&gt;m_presentationAttributeStyleIsDirty = false;  </span><br><span class="line">    attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? 0 : style);  </span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。</p>
<h3 id="Render-tree-和-DOM-tree-做对应"><a href="#Render-tree-和-DOM-tree-做对应" class="headerlink" title="Render tree 和 DOM tree 做对应"></a>Render tree 和 DOM tree 做对应</h3><p>其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。</p>
<p>有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/65.png" alt="65"><br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/73.png" alt="73"></p>
<p>上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。</p>
<h3 id="构建-Render-Tree-的流程"><a href="#构建-Render-Tree-的流程" class="headerlink" title="构建 Render Tree 的流程"></a>构建 Render Tree 的流程</h3><p>解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。</p>
<h3 id="RenderLayer-Tree"><a href="#RenderLayer-Tree" class="headerlink" title="RenderLayer Tree"></a>RenderLayer Tree</h3><p>RenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件：</p>
<ul>
<li>HTMLElement 节点对应的 RenderBlock 节点。</li>
<li>有设置 relative，absolute，transform 的 CSS position 属性的。</li>
<li>透明效果的 RenderObject 节点。</li>
<li>节点有 overflow， apha mask 或反射效果的 RenderObject 节点。</li>
<li>设置了 CSS filter 属性的节点。</li>
<li>使用 Canvas 或 WebGL 的 RenderObject 节点。</li>
<li>Video 节点对应的 RenderObject 节点。</li>
</ul>
<p>RenderObject Tree 和 RenderLayer Tree 的关系如下图：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/66.png" alt="66"><br>接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/67.png" alt="67"></p>
<h3 id="style-计算"><a href="#style-计算" class="headerlink" title="style 计算"></a>style 计算</h3><p>构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。</p>
<p>这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。</p>
<p>我们先看看 style 计算可能会有一些什么样问题</p>
<ul>
<li>Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。</li>
<li>如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。</li>
<li>应用规则涉及到比较复杂的层级规则。</li>
</ul>
<p>下面来说下如何解决这些问题</p>
<h4 id="共享-style-数据"><a href="#共享-style-数据" class="headerlink" title="共享 style 数据"></a>共享 style 数据</h4><p>WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的</p>
<ul>
<li>element 必须有相同的鼠标状态</li>
<li>都没有 id</li>
<li>tag 名能匹配上</li>
<li>class 属性能匹配上</li>
<li>一组映射的属性是相同的</li>
<li>链接状态能匹配上</li>
<li>focus 状态能匹配上</li>
<li>任何 element 都不会被属性 selectors 影响</li>
<li>elements 不能有 inline style 属性</li>
<li>不要使用兄弟 selectors</li>
</ul>
<h4 id="Rule-tree"><a href="#Rule-tree" class="headerlink" title="Rule tree"></a>Rule tree</h4><p>WebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/70.png" alt="70"></p>
<p>通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。</p>
<h4 id="可确定样式分到各个-structs-里"><a href="#可确定样式分到各个-structs-里" class="headerlink" title="可确定样式分到各个 structs 里"></a>可确定样式分到各个 structs 里</h4><p>一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。</p>
<p>rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。</p>
<h4 id="使用-rule-tree-计算-style-contexts"><a href="#使用-rule-tree-计算-style-contexts" class="headerlink" title="使用 rule tree 计算 style contexts"></a>使用 rule tree 计算 style contexts</h4><p>当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。</p>
<p>从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree  上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。</p>
<p>如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。</p>
<p>如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。</p>
<p>看个例子</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"err"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div1"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">                          this is a <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"big"</span>&gt;</span> big error <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">                          this is also a</span><br><span class="line">                          <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"big"</span>&gt;</span> very  big  error<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> error</span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"err"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"div2"</span>&gt;</span>another error<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是 CSS 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div &#123;margin:5px;color:black&#125;</span><br><span class="line">.err &#123;color:red&#125;</span><br><span class="line">.big &#123;margin-top:3px&#125;</span><br><span class="line">div span &#123;margin-bottom:4px&#125;</span><br><span class="line">#div1 &#123;color:blue&#125;</span><br><span class="line">#div2 &#123;color:green&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/71.png" alt="71"></p>
<p>context tree：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/72.png" alt="72"></p>
<p>假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。</p>
<p>现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。</p>
<p>已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。</p>
<p>对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。</p>
<p>如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。</p>
<h4 id="比较容易匹配的-rules"><a href="#比较容易匹配的-rules" class="headerlink" title="比较容易匹配的 rules"></a>比较容易匹配的 rules</h4><p>下面是不同的 style rules 的来源：</p>
<ul>
<li><p>CSS rules，来自于 style sheets 或者在 style elements 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Inline style 属性</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTML 视觉属性</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">"blue"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。</p>
<p>如果是 class name 那么会添加到 class map 里。</p>
<p>这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。</p>
<p>下面举个例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.error &#123;color:red&#125;</span><br><span class="line">#messageDiv &#123;height:50px&#125;</span><br><span class="line">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。</p>
<p>对于下面的 HTML</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>an error occurred <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">" messageDiv"</span>&gt;</span>this is a message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure>

<p>selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。</p>
<h4 id="Style-sheet-的-cascade-排序"><a href="#Style-sheet-的-cascade-排序" class="headerlink" title="Style sheet 的 cascade 排序"></a>Style sheet 的 cascade 排序</h4><p>一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。</p>
<ul>
<li>浏览器的设置</li>
<li>用户的设置</li>
<li>网页里普通的设置</li>
<li>网页里重要的设置</li>
<li>用户重要的设置</li>
</ul>
<h4 id="CSS-specification"><a href="#CSS-specification" class="headerlink" title="CSS specification"></a>CSS specification</h4><p>selector 的 specifity 在 w3c 里有定义 <a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="noopener">https://www.w3.org/TR/CSS2/cascade.html#specificity</a></p>
<p>计算方法如下</p>
<ul>
<li>style attribute 数量 =a</li>
<li>ID attribute 数量 =b</li>
<li>其它的 attribute 和 pseudo-classes 数量 =c</li>
<li>element names 和 pseudo-element 数量 =d</li>
</ul>
<p>举个例子</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> *             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span><br><span class="line"> li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span><br><span class="line"> li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line"> ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line"> ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span><br><span class="line"> h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span><br><span class="line"> ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span><br><span class="line"> li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span><br><span class="line"> #x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line"> style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">HEAD</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">STYLE</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span></span><br><span class="line">  #x97z &#123; color: red &#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">STYLE</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">P</span> <span class="hljs-attr">ID</span>=<span class="hljs-string">x97z</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: green"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。</p>
<h4 id="Rules-排序"><a href="#Rules-排序" class="headerlink" title="Rules 排序"></a>Rules 排序</h4><p>这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 = r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。</p>
<p>HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。</p>
<p>Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。</p>
<h3 id="Layout-处理过程"><a href="#Layout-处理过程" class="headerlink" title="Layout 处理过程"></a>Layout 处理过程</h3><p>完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FrameView:: layout( bool allowSubtree) // 栈 顶 </span><br><span class="line">Document:: implicitClose() </span><br><span class="line">FrameLoader:: checkCallImplicitClose() </span><br><span class="line">FrameLoader:: checkCompleted() </span><br><span class="line">FrameLoader:: finishedParsing() </span><br><span class="line">Document:: finishedParsing() </span><br><span class="line">HTMLParser:: finished() </span><br><span class="line">HTMLTokenizer:: end() </span><br><span class="line">HTMLTokenizer:: finish() </span><br><span class="line">Document:: finishParsing() </span><br><span class="line">FrameLoader:: endIfNotLoadingMainResource() </span><br><span class="line">FrameLoader:: end() </span><br><span class="line">DocumentLoader:: finishedLoading() </span><br><span class="line">FrameLoader:: finishedLoading() </span><br><span class="line">MainResourceLoader:: didFinishLoading() </span><br><span class="line">ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h)</span><br></pre></td></tr></table></figure>

<p>layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line">void FrameView::layout(bool allowSubtree)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());</span><br><span class="line"></span><br><span class="line">    LOG(Layout, &quot;FrameView %p (%dx%d) layout, main frameview %d, allowSubtree=%d&quot;, this, size().width(), size().height(), frame().isMainFrame(), allowSubtree);</span><br><span class="line">    //判断是否已在 layout 过程中，避免多次 layout</span><br><span class="line">    if (isInRenderTreeLayout()) &#123;</span><br><span class="line">        LOG(Layout, &quot;  in layout, bailing&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (layoutDisallowed()) &#123;</span><br><span class="line">        LOG(Layout, &quot;  layout is disallowed, bailing&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Protect the view from being deleted during layout (in recalcStyle).</span><br><span class="line">    Ref&lt;FrameView&gt; protectedThis(*this);</span><br><span class="line"></span><br><span class="line">    // Many of the tasks performed during layout can cause this function to be re-entered,</span><br><span class="line">    // so save the layout phase now and restore it on exit.</span><br><span class="line">    SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout);</span><br><span class="line"></span><br><span class="line">    // Every scroll that happens during layout is programmatic.</span><br><span class="line">    SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</span><br><span class="line"></span><br><span class="line">    bool inChildFrameLayoutWithFrameFlattening = isInChildFrameWithFrameFlattening();</span><br><span class="line"></span><br><span class="line">    if (inChildFrameLayoutWithFrameFlattening) &#123;</span><br><span class="line">        if (!m_frameFlatteningViewSizeForMediaQuery) &#123;</span><br><span class="line">            LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; snapshotting size &quot; &lt;&lt;  ScrollView::layoutSize() &lt;&lt; &quot; for media queries&quot;);</span><br><span class="line">            m_frameFlatteningViewSizeForMediaQuery = ScrollView::layoutSize();</span><br><span class="line">        &#125;</span><br><span class="line">        startLayoutAtMainFrameViewIfNeeded(allowSubtree);</span><br><span class="line">        //获取 root。这个 root 就是 RenderView 对象</span><br><span class="line">        RenderElement* root = m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView();</span><br><span class="line">        if (!root || !root-&gt;needsLayout())</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TraceScope tracingScope(LayoutStart, LayoutEnd);</span><br><span class="line"></span><br><span class="line">#if PLATFORM(IOS)</span><br><span class="line">    if (updateFixedPositionLayoutRect())</span><br><span class="line">        allowSubtree = false;</span><br><span class="line">#endif</span><br><span class="line">    //也是避免多次触发，会把 layoutTimer 先停止</span><br><span class="line">    m_layoutTimer.stop();</span><br><span class="line">    m_delayedLayout = false;</span><br><span class="line">    m_setNeedsLayoutWasDeferred = false;</span><br><span class="line">    </span><br><span class="line">    //我们不应该在 painting 时进入 layout</span><br><span class="line">    ASSERT(!isPainting());</span><br><span class="line">    if (isPainting())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willLayout(frame());</span><br><span class="line">    AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());</span><br><span class="line">    </span><br><span class="line">    if (!allowSubtree &amp;&amp; m_layoutRoot)</span><br><span class="line">        convertSubtreeLayoutToFullLayout();</span><br><span class="line"></span><br><span class="line">    ASSERT(frame().view() == this);</span><br><span class="line">    ASSERT(frame().document());</span><br><span class="line"></span><br><span class="line">    Document&amp; document = *frame().document();</span><br><span class="line">    ASSERT(document.pageCacheState() == Document::NotInPageCache);</span><br><span class="line">    //对样式先进行更新</span><br><span class="line">    &#123;</span><br><span class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</span><br><span class="line"></span><br><span class="line">        if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) &#123;</span><br><span class="line">            // This is a new top-level layout. If there are any remaining tasks from the previous</span><br><span class="line">            // layout, finish them now.</span><br><span class="line">            SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</span><br><span class="line">            performPostLayoutTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_layoutPhase = InPreLayoutStyleUpdate;</span><br><span class="line"></span><br><span class="line">        // Viewport-dependent media queries may cause us to need completely different style information.</span><br><span class="line">        auto* styleResolver = document.styleScope().resolverIfExists();</span><br><span class="line">        if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) &#123;</span><br><span class="line">            LOG(Layout, &quot;  hasMediaQueriesAffectedByViewportChange, enqueueing style recalc&quot;);</span><br><span class="line">            document.styleScope().didChangeStyleSheetEnvironment();</span><br><span class="line">            // FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds.</span><br><span class="line">            InspectorInstrumentation::mediaQueryResultChanged(document);</span><br><span class="line">        &#125;</span><br><span class="line">        document.evaluateMediaQueryList();</span><br><span class="line">        // If there is any pagination to apply, it will affect the RenderView&apos;s style, so we should</span><br><span class="line">        // take care of that now.</span><br><span class="line">        applyPaginationToViewport();</span><br><span class="line">        // Always ensure our style info is up-to-date. This can happen in situations where</span><br><span class="line">        // the layout beats any sort of style recalc update that needs to occur.</span><br><span class="line">        document.updateStyleIfNeeded();</span><br><span class="line">        // If there is only one ref to this view left, then its going to be destroyed as soon as we exit,</span><br><span class="line">        // so there&apos;s no point to continuing to layout</span><br><span class="line">        if (hasOneRef())</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        // Close block here so we can set up the font cache purge preventer, which we will still</span><br><span class="line">        // want in scope even after we want m_layoutSchedulingEnabled to be restored again.</span><br><span class="line">        // The next block sets m_layoutSchedulingEnabled back to false once again.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPreLayout;</span><br><span class="line"></span><br><span class="line">    RenderLayer* layer = nullptr;</span><br><span class="line">    bool subtree = false;</span><br><span class="line">    RenderElement* root = nullptr;</span><br><span class="line"></span><br><span class="line">    ++m_nestedLayoutCount;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</span><br><span class="line"></span><br><span class="line">        autoSizeIfEnabled();</span><br><span class="line">        //重新设置 RenderView 对象，准备开始 layout</span><br><span class="line">        root = m_layoutRoot ? m_layoutRoot : document.renderView();</span><br><span class="line">        if (!root)</span><br><span class="line">            return;</span><br><span class="line">        subtree = m_layoutRoot;</span><br><span class="line"></span><br><span class="line">        if (!m_layoutRoot) &#123;</span><br><span class="line">            auto* body = document.bodyOrFrameset();</span><br><span class="line">            if (body &amp;&amp; body-&gt;renderer()) &#123;</span><br><span class="line">                if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) &#123;</span><br><span class="line">                    body-&gt;renderer()-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125; else if (is&lt;HTMLBodyElement&gt;(*body)) &#123;</span><br><span class="line">                    if (!m_firstLayout &amp;&amp; m_size.height() != layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport())</span><br><span class="line">                        body-&gt;renderer()-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">#if !LOG_DISABLED</span><br><span class="line">            if (m_firstLayout &amp;&amp; !frame().ownerElement())</span><br><span class="line">                LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs\n&quot;, this, document.timeSinceDocumentCreation().value());</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_needsFullRepaint = !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing());</span><br><span class="line"></span><br><span class="line">        if (!subtree) &#123;</span><br><span class="line">            ScrollbarMode hMode;</span><br><span class="line">            ScrollbarMode vMode;    </span><br><span class="line">            calculateScrollbarModesForLayout(hMode, vMode);</span><br><span class="line"></span><br><span class="line">            if (m_firstLayout || (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())) &#123;</span><br><span class="line">                if (m_firstLayout) &#123;</span><br><span class="line">                    setScrollbarsSuppressed(true);</span><br><span class="line"></span><br><span class="line">                    m_firstLayout = false;</span><br><span class="line">                    m_firstLayoutCallbackPending = true;</span><br><span class="line">                    m_lastViewportSize = sizeForResizeEvent();</span><br><span class="line">                    m_lastZoomFactor = root-&gt;style().zoom();</span><br><span class="line"></span><br><span class="line">                    // Set the initial vMode to AlwaysOn if we&apos;re auto.</span><br><span class="line">                    if (vMode == ScrollbarAuto)</span><br><span class="line">                        setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.</span><br><span class="line">                    // Set the initial hMode to AlwaysOff if we&apos;re auto.</span><br><span class="line">                    if (hMode == ScrollbarAuto)</span><br><span class="line">                        setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.</span><br><span class="line">                    Page* page = frame().page();</span><br><span class="line">                    if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</span><br><span class="line">                        scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</span><br><span class="line">                    setScrollbarModes(hMode, vMode);</span><br><span class="line">                    setScrollbarsSuppressed(false, true);</span><br><span class="line">                &#125; else</span><br><span class="line">                    setScrollbarModes(hMode, vMode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LayoutSize oldSize = m_size;</span><br><span class="line">            m_size = layoutSize();</span><br><span class="line"></span><br><span class="line">            if (oldSize != m_size) &#123;</span><br><span class="line">                LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat());</span><br><span class="line">                m_needsFullRepaint = true;</span><br><span class="line">                if (!m_firstLayout) &#123;</span><br><span class="line">                    RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;</span><br><span class="line">                    auto* body = document.bodyOrFrameset();</span><br><span class="line">                    RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;</span><br><span class="line">                    if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())</span><br><span class="line">                        bodyRenderer-&gt;setChildNeedsLayout();</span><br><span class="line">                    else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())</span><br><span class="line">                        rootRenderer-&gt;setChildNeedsLayout();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_layoutPhase = InPreLayout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layer = root-&gt;enclosingLayer();</span><br><span class="line">        SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot);</span><br><span class="line"></span><br><span class="line">        RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view());</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InPreLayout);</span><br><span class="line">        m_layoutPhase = InRenderTreeLayout;</span><br><span class="line"></span><br><span class="line">        forceLayoutParentViewIfNeeded();</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">        RenderTreeNeedsLayoutChecker checker(*root);</span><br><span class="line">#endif</span><br><span class="line">        //从 RenderView 这个根级开始进行 layout。</span><br><span class="line">        root-&gt;layout();</span><br><span class="line">        ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());</span><br><span class="line"></span><br><span class="line">#if ENABLE(TEXT_AUTOSIZING)</span><br><span class="line">        if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) &#123;</span><br><span class="line">            float minimumZoomFontSize = frame().settings().minimumZoomFontSize();</span><br><span class="line">            float textAutosizingWidth = frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0;</span><br><span class="line">            if (int overrideWidth = frame().settings().textAutosizingWindowSizeOverride().width())</span><br><span class="line">                textAutosizingWidth = overrideWidth;</span><br><span class="line"></span><br><span class="line">            LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);</span><br><span class="line">            </span><br><span class="line">            if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) &#123;</span><br><span class="line">                root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);</span><br><span class="line">                if (root-&gt;needsLayout())</span><br><span class="line">                    root-&gt;layout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</span><br><span class="line">        m_layoutRoot = nullptr;</span><br><span class="line">        // Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InViewSizeAdjust;</span><br><span class="line"></span><br><span class="line">    bool neededFullRepaint = m_needsFullRepaint;</span><br><span class="line"></span><br><span class="line">    if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) &#123;</span><br><span class="line">        adjustViewSize();</span><br><span class="line">        // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by</span><br><span class="line">        // navigating away from the current document (see webkit.org/b/173329).</span><br><span class="line">        if (hasOneRef())</span><br><span class="line">            return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPostLayout;</span><br><span class="line"></span><br><span class="line">    m_needsFullRepaint = neededFullRepaint;</span><br><span class="line"></span><br><span class="line">    // Now update the positions of all layers.</span><br><span class="line">    if (m_needsFullRepaint)</span><br><span class="line">        root-&gt;view().repaintRootContents();</span><br><span class="line"></span><br><span class="line">    root-&gt;view().releaseProtectedRenderWidgets();</span><br><span class="line"></span><br><span class="line">    ASSERT(!root-&gt;needsLayout());</span><br><span class="line"></span><br><span class="line">    layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint));</span><br><span class="line"></span><br><span class="line">    updateCompositingLayersAfterLayout();</span><br><span class="line"></span><br><span class="line">    m_layoutPhase = InPostLayerPositionsUpdatedAfterLayout;</span><br><span class="line"></span><br><span class="line">    m_layoutCount++;</span><br><span class="line"></span><br><span class="line">#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)</span><br><span class="line">    if (AXObjectCache* cache = root-&gt;document().existingAXObjectCache())</span><br><span class="line">        cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if ENABLE(DASHBOARD_SUPPORT)</span><br><span class="line">    updateAnnotatedRegions();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if ENABLE(IOS_TOUCH_EVENTS)</span><br><span class="line">    document.setTouchEventRegionsNeedUpdate();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    updateCanBlitOnScrollRecursively();</span><br><span class="line"></span><br><span class="line">    handleDeferredScrollUpdateAfterContentSizeChange();</span><br><span class="line"></span><br><span class="line">    handleDeferredScrollbarsUpdateAfterDirectionChange();</span><br><span class="line"></span><br><span class="line">    if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER))</span><br><span class="line">        updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());</span><br><span class="line"></span><br><span class="line">    frame().document()-&gt;markers().invalidateRectsForAllMarkers();</span><br><span class="line"></span><br><span class="line">    if (!m_postLayoutTasksTimer.isActive()) &#123;</span><br><span class="line">        if (!m_inSynchronousPostLayout) &#123;</span><br><span class="line">            if (inChildFrameLayoutWithFrameFlattening)</span><br><span class="line">                updateWidgetPositions();</span><br><span class="line">            else &#123;</span><br><span class="line">                SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</span><br><span class="line">                performPostLayoutTasks(); // Calls resumeScheduledEvents().</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) &#123;</span><br><span class="line">            // If we need layout or are already in a synchronous call to postLayoutTasks(), </span><br><span class="line">            // defer widget updates and event dispatch until after we return. postLayoutTasks()</span><br><span class="line">            // can make us need to update again, and we can get stuck in a nasty cycle unless</span><br><span class="line">            // we call it through the timer here.</span><br><span class="line">            m_postLayoutTasksTimer.startOneShot(0_s);</span><br><span class="line">        &#125;</span><br><span class="line">        if (needsLayout())</span><br><span class="line">            layout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InspectorInstrumentation::didLayout(cookie, *root);</span><br><span class="line">    DebugPageOverlays::didLayout(frame());</span><br><span class="line"></span><br><span class="line">    --m_nestedLayoutCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void RenderView::layoutContent(const LayoutState&amp; state)</span><br><span class="line">&#123;</span><br><span class="line">    UNUSED_PARAM(state);</span><br><span class="line">    ASSERT(needsLayout());</span><br><span class="line"></span><br><span class="line">    RenderBlockFlow::layout();</span><br><span class="line">    if (hasRenderNamedFlowThreads())</span><br><span class="line">        flowThreadController().layoutRenderNamedFlowThreads();</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">    checkLayoutState(state);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(needsLayout());</span><br><span class="line">    //当不需要布局子节点同时能 simplifiedLayout 重新布局成功</span><br><span class="line">    if (!relayoutChildren &amp;&amp; simplifiedLayout())</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    LayoutRepainter repainter(*this, checkForRepaintDuringLayout());</span><br><span class="line">    //重新计算逻辑宽度</span><br><span class="line">    if (recomputeLogicalWidthAndColumnWidth())</span><br><span class="line">        relayoutChildren = true;</span><br><span class="line"></span><br><span class="line">    rebuildFloatingObjectSetFromIntrudingFloats();</span><br><span class="line"></span><br><span class="line">    //先保留一份以前的高度为后面做对比用</span><br><span class="line">    LayoutUnit previousHeight = logicalHeight();</span><br><span class="line">    // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),</span><br><span class="line">    // for consistency with other render classes?</span><br><span class="line">    //然后将 logicalHeight 设置为 0，避免累加以前的。</span><br><span class="line">    setLogicalHeight(0);</span><br><span class="line"></span><br><span class="line">    bool pageLogicalHeightChanged = false;</span><br><span class="line">    checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);</span><br><span class="line"></span><br><span class="line">    const RenderStyle&amp; styleToUse = style();</span><br><span class="line">    LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);</span><br><span class="line"></span><br><span class="line">    preparePaginationBeforeBlockLayout(relayoutChildren);</span><br><span class="line">    if (!relayoutChildren)</span><br><span class="line">        relayoutChildren = namedFlowFragmentNeedsUpdate();</span><br><span class="line"></span><br><span class="line">    // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track</span><br><span class="line">    // our current maximal positive and negative margins. These values are used when we</span><br><span class="line">    // are collapsed with adjacent blocks, so for example, if you have block A and B</span><br><span class="line">    // collapsing together, then you&apos;d take the maximal positive margin from both A and B</span><br><span class="line">    // and subtract it from the maximal negative margin from both A and B to get the</span><br><span class="line">    // true collapsed margin. This algorithm is recursive, so when we finish layout()</span><br><span class="line">    // our block knows its current maximal positive/negative values.</span><br><span class="line">    //</span><br><span class="line">    // Start out by setting our margin values to our current margins. Table cells have</span><br><span class="line">    // no margins, so we don&apos;t fill in the values for table cells.</span><br><span class="line">    bool isCell = isTableCell();</span><br><span class="line">    if (!isCell) &#123;</span><br><span class="line">        initMaxMarginValues();</span><br><span class="line">        </span><br><span class="line">        setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());</span><br><span class="line">        setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());</span><br><span class="line">        setPaginationStrut(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LayoutUnit repaintLogicalTop = 0;</span><br><span class="line">    LayoutUnit repaintLogicalBottom = 0;</span><br><span class="line">    LayoutUnit maxFloatLogicalBottom = 0;</span><br><span class="line">    if (!firstChild() &amp;&amp; !isAnonymousBlock())</span><br><span class="line">        setChildrenInline(true);</span><br><span class="line">    //Inline 和 Block 的不同布局处理</span><br><span class="line">    if (childrenInline())</span><br><span class="line">        layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span><br><span class="line">    else</span><br><span class="line">        layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);</span><br><span class="line"></span><br><span class="line">    // Expand our intrinsic height to encompass floats.</span><br><span class="line">    LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();</span><br><span class="line">    if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())</span><br><span class="line">        setLogicalHeight(lowestFloatLogicalBottom() + toAdd);</span><br><span class="line">    </span><br><span class="line">    if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) &#123;</span><br><span class="line">        ASSERT(!shouldBreakAtLineToAvoidWidow());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Calculate our new height. 计算新高</span><br><span class="line">    LayoutUnit oldHeight = logicalHeight();</span><br><span class="line">    LayoutUnit oldClientAfterEdge = clientLogicalBottom();</span><br><span class="line"></span><br><span class="line">    // Before updating the final size of the flow thread make sure a forced break is applied after the content.</span><br><span class="line">    // This ensures the size information is correctly computed for the last auto-height region receiving content.</span><br><span class="line">    if (is&lt;RenderFlowThread&gt;(*this))</span><br><span class="line">        downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);</span><br><span class="line"></span><br><span class="line">    updateLogicalHeight();</span><br><span class="line">    LayoutUnit newHeight = logicalHeight();</span><br><span class="line">    if (oldHeight != newHeight) &#123;</span><br><span class="line">        if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) &#123;</span><br><span class="line">            // One of our children&apos;s floats may have become an overhanging float for us. We need to look for it.</span><br><span class="line">            for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) &#123;</span><br><span class="line">                if (blockFlow.isFloatingOrOutOfFlowPositioned())</span><br><span class="line">                    continue;</span><br><span class="line">                if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)</span><br><span class="line">                    addOverhangingFloats(blockFlow, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点</span><br><span class="line">    bool heightChanged = (previousHeight != newHeight);</span><br><span class="line">    if (heightChanged)</span><br><span class="line">        relayoutChildren = true;</span><br><span class="line"></span><br><span class="line">    layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());</span><br><span class="line"></span><br><span class="line">    //Add overflow from children (unless we&apos;re multi-column, since in that case all our child overflow is clipped anyway).</span><br><span class="line">    computeOverflow(oldClientAfterEdge);</span><br><span class="line">    </span><br><span class="line">    statePusher.pop();</span><br><span class="line"></span><br><span class="line">    fitBorderToLinesIfNeeded();</span><br><span class="line"></span><br><span class="line">    if (view().layoutState()-&gt;m_pageLogicalHeight)</span><br><span class="line">        setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop()));</span><br><span class="line"></span><br><span class="line">    updateLayerTransform();</span><br><span class="line"></span><br><span class="line">    // Update our scroll information if we&apos;re overflow:auto/scroll/hidden now that we know if</span><br><span class="line">    // we overflow or not.</span><br><span class="line">    updateScrollInfoAfterLayout();</span><br><span class="line"></span><br><span class="line">    // FIXME: This repaint logic should be moved into a separate helper function!</span><br><span class="line">    // Repaint with our new bounds if they are different from our old bounds.</span><br><span class="line">    bool didFullRepaint = repainter.repaintAfterLayout();</span><br><span class="line">    if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) &#123;</span><br><span class="line">        // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines</span><br><span class="line">        // it had to lay out. We wouldn&apos;t need the hasOverflowClip() hack in that case either.</span><br><span class="line">        LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();</span><br><span class="line">        LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();</span><br><span class="line">        if (hasOverflowClip()) &#123;</span><br><span class="line">            // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&apos;t propagate to our block&apos;s overflow.</span><br><span class="line">            // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.</span><br><span class="line">            // layoutInlineChildren should be patched to compute the entire repaint rect.</span><br><span class="line">            repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());</span><br><span class="line">            repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LayoutRect repaintRect;</span><br><span class="line">        if (isHorizontalWritingMode())</span><br><span class="line">            repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);</span><br><span class="line">        else</span><br><span class="line">            repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);</span><br><span class="line"></span><br><span class="line">        if (hasOverflowClip()) &#123;</span><br><span class="line">            // Adjust repaint rect for scroll offset</span><br><span class="line">            repaintRect.moveBy(-scrollPosition());</span><br><span class="line"></span><br><span class="line">            // Don&apos;t allow this rect to spill out of our overflow box.</span><br><span class="line">            repaintRect.intersect(LayoutRect(LayoutPoint(), size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure the rect is still non-empty after intersecting for overflow above</span><br><span class="line">        if (!repaintRect.isEmpty()) &#123;</span><br><span class="line">            repaintRectangle(repaintRect); // We need to do a partial repaint of our content.</span><br><span class="line">            if (hasReflection())</span><br><span class="line">                repaintRectangle(reflectedRect(repaintRect));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearNeedsLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。</p>
<h3 id="Layout-Tree-创建"><a href="#Layout-Tree-创建" class="headerlink" title="Layout Tree 创建"></a>Layout Tree 创建</h3><p>Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是<a href="https://skia.org/" target="_blank" rel="noopener">Skia</a> 开源 2D 图形库做底层 Paint 引擎。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Document::finishedParsing() &#123;</span><br><span class="line">      updateStyleAndLayoutTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 Node 都会创建一个 LayoutObject，</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LayoutObject* newLayoutObject = m_node-&gt;createLayoutObject(style);</span><br><span class="line">parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject);</span><br></pre></td></tr></table></figure>

<h3 id="Layout-值的计算"><a href="#Layout-值的计算" class="headerlink" title="Layout 值的计算"></a>Layout 值的计算</h3><p>Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)</span><br><span class="line">&#123;</span><br><span class="line">    LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();</span><br><span class="line">    LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();</span><br><span class="line"></span><br><span class="line">    // The child is a normal flow object. Compute the margins we will use for collapsing now.</span><br><span class="line">    child.computeAndSetBlockDirectionMargins(*this);</span><br><span class="line"></span><br><span class="line">    // Try to guess our correct logical top position. In most cases this guess will</span><br><span class="line">    // be correct. Only if we&apos;re wrong (when we compute the real logical top position)</span><br><span class="line">    // will we have to potentially relayout.</span><br><span class="line">    LayoutUnit estimateWithoutPagination;</span><br><span class="line">    //估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标</span><br><span class="line">    LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);</span><br><span class="line"></span><br><span class="line">    // Cache our old rect so that we can dirty the proper repaint rects if the child moves.</span><br><span class="line">    LayoutRect oldRect = child.frameRect();</span><br><span class="line">    LayoutUnit oldLogicalTop = logicalTopForChild(child);</span><br><span class="line"></span><br><span class="line">#if !ASSERT_DISABLED</span><br><span class="line">    LayoutSize oldLayoutDelta = view().layoutDelta();</span><br><span class="line">#endif</span><br><span class="line">    // Position the child as though it didn&apos;t collapse with the top.</span><br><span class="line">    //先设置布局前 top 坐标</span><br><span class="line">    setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);</span><br><span class="line">    estimateRegionRangeForBoxChild(child);</span><br><span class="line"></span><br><span class="line">    RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;</span><br><span class="line">    bool markDescendantsWithFloats = false;</span><br><span class="line">    if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">        markDescendantsWithFloats = true;</span><br><span class="line">    else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))</span><br><span class="line">        // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for</span><br><span class="line">        // very large elements. If it does the comparison with oldLogicalTop might yield a</span><br><span class="line">        // false negative as adding and removing margins, borders etc from a saturated number</span><br><span class="line">        // might yield incorrect results. If this is the case always mark for layout.</span><br><span class="line">        markDescendantsWithFloats = true;</span><br><span class="line">    else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) &#123;</span><br><span class="line">        // If an element might be affected by the presence of floats, then always mark it for</span><br><span class="line">        // layout.</span><br><span class="line">        LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());</span><br><span class="line">        if (fb &gt; logicalTopEstimate)</span><br><span class="line">            markDescendantsWithFloats = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (childBlockFlow) &#123;</span><br><span class="line">        if (markDescendantsWithFloats)</span><br><span class="line">            childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</span><br><span class="line">        if (!child.isWritingModeRoot())</span><br><span class="line">            previousFloatLogicalBottom = std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    child.markForPaginationRelayoutIfNeeded();</span><br><span class="line"></span><br><span class="line">    bool childHadLayout = child.everHadLayout();</span><br><span class="line">    //对子节点进行布局</span><br><span class="line">    bool childNeededLayout = child.needsLayout();</span><br><span class="line">    if (childNeededLayout)</span><br><span class="line">        child.layout();</span><br><span class="line"></span><br><span class="line">    // Cache if we are at the top of the block right now.</span><br><span class="line">    bool atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();</span><br><span class="line"></span><br><span class="line">    //保证 top 坐标和子节点布局后能够同步</span><br><span class="line">    // Now determine the correct ypos based off examination of collapsing margin</span><br><span class="line">    // values.</span><br><span class="line">    LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);</span><br><span class="line"></span><br><span class="line">    // Now check for clear.</span><br><span class="line">    LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);</span><br><span class="line">    </span><br><span class="line">    bool paginated = view().layoutState()-&gt;isPaginated();</span><br><span class="line">    if (paginated)</span><br><span class="line">        logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);</span><br><span class="line"></span><br><span class="line">    //经过上面的子节点布局完后重新计算得到新高</span><br><span class="line">    setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);</span><br><span class="line"></span><br><span class="line">    // Now we have a final top position. See if it really does end up being different from our estimate.</span><br><span class="line">    // clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&apos;t move. This happens</span><br><span class="line">    // when collapseMargins dynamically adds overhanging floats because of a child with negative margins.</span><br><span class="line">    if (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) &#123;</span><br><span class="line">        if (child.shrinkToAvoidFloats()) &#123;</span><br><span class="line">            // The child&apos;s width depends on the line width. When the child shifts to clear an item, its width can</span><br><span class="line">            // change (because it has more available line width). So mark the item as dirty.</span><br><span class="line">            child.setChildNeedsLayout(MarkOnlyThis);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (childBlockFlow) &#123;</span><br><span class="line">            if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">                childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</span><br><span class="line">            child.markForPaginationRelayoutIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (updateRegionRangeForBoxChild(child))</span><br><span class="line">        child.setNeedsLayout(MarkOnlyThis);</span><br><span class="line"></span><br><span class="line">    // In case our guess was wrong, relayout the child.</span><br><span class="line">    child.layoutIfNeeded();</span><br><span class="line"></span><br><span class="line">    // We are no longer at the top of the block if we encounter a non-empty child.  </span><br><span class="line">    // This has to be done after checking for clear, so that margins can be reset if a clear occurred.</span><br><span class="line">    if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())</span><br><span class="line">        marginInfo.setAtBeforeSideOfBlock(false);</span><br><span class="line"></span><br><span class="line">    // Now place the child in the correct left position</span><br><span class="line">    //计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。</span><br><span class="line">    determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);</span><br><span class="line"></span><br><span class="line">    // Update our height now that the child has been placed in the correct position.</span><br><span class="line">    setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));</span><br><span class="line">    if (mustSeparateMarginAfterForChild(child)) &#123;</span><br><span class="line">        setLogicalHeight(logicalHeight() + marginAfterForChild(child));</span><br><span class="line">        marginInfo.clearMargin();</span><br><span class="line">    &#125;</span><br><span class="line">    // If the child has overhanging floats that intrude into following siblings (or possibly out</span><br><span class="line">    // of this block), then the parent gets notified of the floats now.</span><br><span class="line">    if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</span><br><span class="line">        maxFloatLogicalBottom = std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));</span><br><span class="line"></span><br><span class="line">    LayoutSize childOffset = child.location() - oldRect.location();</span><br><span class="line">    if (childOffset.width() || childOffset.height()) &#123;</span><br><span class="line">        view().addLayoutDelta(childOffset);</span><br><span class="line"></span><br><span class="line">        // If the child moved, we have to repaint it as well as any floating/positioned</span><br><span class="line">        // descendants. An exception is if we need a layout. In this case, we know we&apos;re going to</span><br><span class="line">        // repaint ourselves (and the child) anyway.</span><br><span class="line">        if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())</span><br><span class="line">            child.repaintDuringLayoutIfMoved(oldRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //渲染</span><br><span class="line">    if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) &#123;</span><br><span class="line">        child.repaint();</span><br><span class="line">        child.repaintOverhangingFloats(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (paginated) &#123;</span><br><span class="line">        if (RenderFlowThread* flowThread = flowThreadContainingBlock())</span><br><span class="line">            flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child);</span><br><span class="line">        // Check for an after page/column break.</span><br><span class="line">        LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);</span><br><span class="line">        if (newHeight != height())</span><br><span class="line">            setLogicalHeight(newHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(view().layoutDeltaMatches(oldLayoutDelta));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断值的类型是固定值还是百分比的方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch (length.type()) &#123;</span><br><span class="line">  case Fixed:</span><br><span class="line">    return LayoutUnit(length.value()); //返回 LayoutUnit 封装的数据 1px = 1 &lt;&lt; 6 = 64 unit</span><br><span class="line">  case Percent:</span><br><span class="line">    //maximumValue 是传进来的最大值</span><br><span class="line">    return LayoutUnit(</span><br><span class="line">        static_cast&lt;float&gt;(maximumValue * length.percent() / 100.0f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算 margin 的值</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CSS 2.1: &quot;If both &apos;margin-left&apos; and &apos;margin-right&apos; are &apos;auto&apos;, their used</span><br><span class="line">// values are equal. This horizontally centers the element with respect to</span><br><span class="line">// the edges of the containing block.&quot;</span><br><span class="line">const ComputedStyle&amp; containingBlockStyle = containingBlock-&gt;styleRef();</span><br><span class="line">if (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) &#123;</span><br><span class="line">  LayoutUnit centeredMarginBoxStart = std::max(</span><br><span class="line">      LayoutUnit(),</span><br><span class="line">      (availableWidth - childWidth) / 2); </span><br><span class="line">  marginStart = centeredMarginBoxStart;</span><br><span class="line">  marginEnd = availableWidth - childWidth - marginStart;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Box Model 里</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_frameRect.setWidth(width);</span><br><span class="line">m_marginBox.setStart(marginLeft);</span><br></pre></td></tr></table></figure>

<p>经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First line.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>Second one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>布局计算后带布局信息的 Render Tree 如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RenderBlock &#123;HTML&#125; at (0, 0) size 640x480 </span><br><span class="line">|—— RenderBody &#123;BODY&#125; at (0, 80) size 640x480 [bgcolor=# FFFFFF] </span><br><span class="line">| |—— RenderBlock &#123;P&#125; at (0, 0) size 640x80 </span><br><span class="line">| | |—— RenderText &#123;#text&#125; at (0, 0) size 48x24 &quot;First line.&quot; </span><br><span class="line">| | |—— RenderBR &#123;BR&#125; at (20, 20) size 0x0 </span><br><span class="line">| | |—— RenderText &#123;#text&#125; at (0, 24) size 48x24 &quot;Second one.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Box-Model-数据结构"><a href="#Box-Model-数据结构" class="headerlink" title="Box Model 数据结构"></a>Box Model 数据结构</h3><p><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/16.png" alt="16"><br>所有的 elements 都有 display 属性用来确定显示类型。属性值有</p>
<ul>
<li>block：生成一个 block box</li>
<li>inline：生成一个或多个 inline boxes</li>
<li>none：不生成 box</li>
</ul>
<p>默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/sample.html</a></p>
<h4 id="定位的方案"><a href="#定位的方案" class="headerlink" title="定位的方案"></a>定位的方案</h4><p>有三种方案</p>
<ul>
<li>Normal：由 render tree 来决定的位置。</li>
<li>Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。</li>
<li>Absolute：让其在 render tree 的位置和 DOM tree 不一样</li>
</ul>
<p>定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。</p>
<p>对于 float 的处理，首先需要判断宽度是否需要 fit content</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool LayoutBox::sizesLogicalWidthToFitContent(</span><br><span class="line">    const Length&amp; logicalWidth) const &#123;</span><br><span class="line">  if (isFloating() || isInlineBlockOrInlineTable())</span><br><span class="line">    return true;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。</p>
<p>对于 float:left 的计算</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束</span><br><span class="line">while (logicalRightOffsetForPositioningFloat(</span><br><span class="line">           logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) -</span><br><span class="line">           floatLogicalLeft &lt;</span><br><span class="line">       floatLogicalWidth) &#123;</span><br><span class="line">  //下移</span><br><span class="line">  logicalTopOffset +=</span><br><span class="line">      std::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight);</span><br><span class="line">  //新的 floatLogicalLeft</span><br><span class="line">  floatLogicalLeft = logicalLeftOffsetForPositioningFloat(</span><br><span class="line">      logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值</span><br><span class="line">floatLogicalLeft = std::max(</span><br><span class="line">    logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);</span><br></pre></td></tr></table></figure>

<h4 id="Box-类型"><a href="#Box-类型" class="headerlink" title="Box 类型"></a>Box 类型</h4><p>Block box：在浏览器的 window 里有自己的矩形<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/20.png" alt="20"></p>
<p>Inline box：没有自己的 block，但是会在一个 block 里<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/21.png" alt="21"></p>
<p>Block 是按照垂直排列，Inline 是按照水平来排列<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/22.png" alt="22"></p>
<p>Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/23.png" alt="23"></p>
<p>下面举个例子看看 Inline  类型的例子，比如有如下的 html：</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First line.<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>Second one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段 html 的 Render Tree 如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/97.png" alt="97"></p>
<h4 id="Position-类型"><a href="#Position-类型" class="headerlink" title="Position 类型"></a>Position 类型</h4><p>Relative：相对定位，先按照正常的定位然后根据设置的值再移动。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/24.png" alt="24"></p>
<p>Float：会被移动到左边或右边侧<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/25.png" alt="25"></p>
<p>Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/26.png" alt="26"></p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。</p>
<figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">STYLE</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span></span><br><span class="line">    div &#123; </span><br><span class="line">        position: absolute; </span><br><span class="line">        left: 2in; </span><br><span class="line">        top: 2in; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">STYLE</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">P</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DIV</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">DIV</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://ming1016.github.io/uploads/deeply-analyse-webkit/27.png" alt="27"></p>
<p>可以看到层级是按照 z-index 来排的。</p>
<h4 id="大小的计算"><a href="#大小的计算" class="headerlink" title="大小的计算"></a>大小的计算</h4><p>border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// More IE extensions.  clientWidth and clientHeight represent the interior of</span><br><span class="line">// an object excluding border and scrollbar.</span><br><span class="line">LayoutUnit LayoutBox::clientWidth() const &#123;</span><br><span class="line">  return m_frameRect.width() - borderLeft() - borderRight() -</span><br><span class="line">         verticalScrollbarWidth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>offsetWidth  是 frameRect 的宽度</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// IE extensions. Used to calculate offsetWidth/Height.</span><br><span class="line">LayoutUnit offsetWidth() const override &#123; return m_frameRect.width(); &#125;</span><br><span class="line">LayoutUnit offsetHeight() const override &#123; return m_frameRect.height(); &#125;</span><br></pre></td></tr></table></figure>

<p>Margin 区域是用 LayoutRectOutsets </p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LayoutUnit m_top;</span><br><span class="line">LayoutUnit m_right;</span><br><span class="line">LayoutUnit m_bottom;</span><br><span class="line">LayoutUnit m_left;</span><br></pre></td></tr></table></figure>

<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置的计算，即 x 和 y 是通过下面两个函数计算得到</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 根据 margin 得到 y 值</span><br><span class="line">LayoutUnit logicalTopBeforeClear =</span><br><span class="line">    collapseMargins(child, layoutInfo, childIsSelfCollapsing,</span><br><span class="line">                    childDiscardMarginBefore, childDiscardMarginAfter);</span><br><span class="line">// 得到 x 值</span><br><span class="line">determineLogicalLeftPositionForChild(child);</span><br></pre></td></tr></table></figure>

<p>计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。</p>
<blockquote>
<p> <a href="https://github.com/ming1016/study/wiki" target="_blank" rel="noopener">ming1016</a></p>
</blockquote>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2016/06/18/clang-llvm/" class="image is-7by1">
            <img class="thumbnail" src="https://www.policx.com/talk/images/banner.jpg" alt="深入剖析-iOS-编译-Clang---LLVM">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-06-18T01:58:47.000Z">2016-06-18</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 小时 读完 (大约 22521 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/06/18/clang-llvm/">深入剖析-iOS-编译-Clang---LLVM</a>
            
        </h1>
        <div class="content">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="noopener">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="noopener">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="noopener">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="noopener">《linkers and loaders》</a> 这本书就知道了。</p>
<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#define DEFINEEight 8</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int eight = DEFINEEight;</span><br><span class="line">        int six = 6;</span><br><span class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</span><br><span class="line">        int rank = eight + six;</span><br><span class="line">        NSLog(@“%@ rank %d”, site, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在命令行输入</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -ccc-print-phases main.m</span><br></pre></td></tr></table></figure>

<p>可以看到编译源文件需要的几个不同的阶段</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: input, “main.m”, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line">6: bind-arch, “x86_64”, &#123;5&#125;, image</span><br></pre></td></tr></table></figure>

<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<p>查看操作内部命令，可以使用 -### 命令</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -### main.m -o main</span><br></pre></td></tr></table></figure>

<p>想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure>

<p>执行完后可以看到文件</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3</span><br><span class="line"># 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3</span><br><span class="line"># 2 “main.m” 2</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int eight = 8;</span><br><span class="line">        int six = 6;</span><br><span class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</span><br><span class="line">        int rank = eight + six;</span><br><span class="line">        NSLog(@“%@ rank %d”, site, rank);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。</p>
<ul>
<li>“#define”</li>
<li>“#include”</li>
<li>“#indef”</li>
<li>注释</li>
<li>“#pragma”</li>
</ul>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure>

<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure>

<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>

<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass — LLVM 5 documentation</a> 。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>

<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -c main.m -o main.bc</span><br></pre></td></tr></table></figure>

<p>生成汇编</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure>

<p>生成目标文件</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure>

<p>生成可执行文件，这样就能够执行看到输出结果</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang main.o -o main</span><br><span class="line">执行</span><br><span class="line">./main</span><br><span class="line">输出</span><br><span class="line">starming rank 14</span><br></pre></td></tr></table></figure>

<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h1 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h1><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</span><br></pre></td></tr></table></figure>

<p>接下来对会更新工作路径，同时设置 PATH</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</span><br><span class="line">    export LANG=en_US.US-ASCII</span><br><span class="line">    export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”</span><br></pre></td></tr></table></figure>

<p>接下来就是实际的编译命令</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</span><br></pre></td></tr></table></figure>

<p>clang 命令参数</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-x 编译语言比如objective-c</span><br><span class="line">-arch 编译的架构，比如arm7</span><br><span class="line">-f 以-f开头的。</span><br><span class="line">-W 以-W开头的，可以通过这些定制编译警告</span><br><span class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span><br><span class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</span><br><span class="line">-I 把编译信息写入指定的辅助文件</span><br><span class="line">-F 需要的Framework</span><br><span class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</span><br><span class="line">-o 编译结果</span><br></pre></td></tr></table></figure>

<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Create product structure</span><br><span class="line">Process product packaging</span><br><span class="line">Run custom shell script ‘Check Pods Manifest.lock’</span><br><span class="line">Compile … 各个项目中的.m文件</span><br><span class="line">Link /Users/… 路径</span><br><span class="line">Copy … 静态文件</span><br><span class="line">Compile asset catalogs</span><br><span class="line">Compile Storyboard file …</span><br><span class="line">Process info.plist</span><br><span class="line">Link Storyboards</span><br><span class="line">Run custom shell script ‘Embed Pods Frameworks’</span><br><span class="line">Run custom shell script ‘Copy Pods Resources’</span><br><span class="line">…</span><br><span class="line">Touch GCDFetchFeed.app</span><br><span class="line">Sign GCDFetchFeed.app</span><br></pre></td></tr></table></figure>

<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</span><br></pre></td></tr></table></figure>

<p>然后根据这个 ID 找到 main 工程的定义。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Begin PBXProject section */</span><br><span class="line">        3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</span><br><span class="line">            isa = PBXProject;</span><br><span class="line">            …</span><br><span class="line">/* End PBXProject section */</span><br></pre></td></tr></table></figure>

<p>在 targets 里会指向各个 taget 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">targets = (</span><br><span class="line">    3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</span><br><span class="line">    3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</span><br><span class="line">    3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</span><br><span class="line">    isa = PBXNativeTarget;</span><br><span class="line">    buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” </span><br><span class="line">    buildPhases = (</span><br><span class="line">        9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</span><br><span class="line">        3EE311341C4E1F0800103FA3 /* Sources */,</span><br><span class="line">        3EE311351C4E1F0800103FA3 /* Frameworks */,</span><br><span class="line">        3EE311361C4E1F0800103FA3 /* Resources */,</span><br><span class="line">        C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </span><br><span class="line">        DD33A716222617FAB49F1472 /* Copy Pods Resources </span><br><span class="line">    );</span><br><span class="line">    buildRules = (</span><br><span class="line">    );</span><br><span class="line">    dependencies = (</span><br><span class="line">    );</span><br><span class="line">    name = GCDFetchFeed;</span><br><span class="line">    productName = GCDFetchFeed;</span><br><span class="line">    productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</span><br><span class="line">    productType = “com.apple.product-type.application”;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h1 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h1><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="noopener">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&v=VqCkCDFLSsc" target="_blank" rel="noopener">The Clang AST - a Tutorial - YouTube</a><br>CMU关于llvm的教案 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="noopener">TokensKind.def</a> 里有 Clang 定义的所有 Token。Token 可以分为以下几类</p>
<ul>
<li>关键字：语法中的关键字，if else while for 等。</li>
<li>标识符：变量名</li>
<li>字面量：值，数字，字符串</li>
<li>特殊符号：加减乘除等符号</li>
</ul>
<p>通过下面的命令可以输出所有 token 和所在文件具体位置</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -E -Xclang -dump-tokens main.m</span><br><span class="line">``` </span><br><span class="line">结果如下</span><br></pre></td></tr></table></figure>

<p>annot_module_include ‘#import &lt;Fo’        Loc=<a href="main.m:2:1" target="_blank" rel="noopener">main.m:2:1</a><br>int ‘int’     [StartOfLine]    Loc=<a href="main.m:5:1" target="_blank" rel="noopener">main.m:5:1</a><br>identifier ‘main’     [LeadingSpace]    Loc=<a href="main.m:5:5" target="_blank" rel="noopener">main.m:5:5</a><br>l_paren ‘(‘        Loc=<a href="main.m:5:9" target="_blank" rel="noopener">main.m:5:9</a><br>r_paren ‘)’        Loc=<a href="main.m:5:10" target="_blank" rel="noopener">main.m:5:10</a><br>l_brace ‘{‘     [LeadingSpace]    Loc=<a href="main.m:5:12" target="_blank" rel="noopener">main.m:5:12</a><br>at ‘@‘     [StartOfLine] [LeadingSpace]    Loc=<a href="main.m:6:5" target="_blank" rel="noopener">main.m:6:5</a><br>identifier ‘autoreleasepool’        Loc=<a href="main.m:6:6" target="_blank" rel="noopener">main.m:6:6</a><br>l_brace ‘{‘     [LeadingSpace]    Loc=<a href="main.m:6:22" target="_blank" rel="noopener">main.m:6:22</a><br>identifier ‘NSString’     [StartOfLine] [LeadingSpace]    Loc=<a href="main.m:7:9" target="_blank" rel="noopener">main.m:7:9</a><br>star ‘*’     [LeadingSpace]    Loc=<a href="main.m:7:18" target="_blank" rel="noopener">main.m:7:18</a><br>identifier ‘a’        Loc=<a href="main.m:7:19" target="_blank" rel="noopener">main.m:7:19</a><br>equal ‘=‘     [LeadingSpace]    Loc=<a href="main.m:7:21" target="_blank" rel="noopener">main.m:7:21</a><br>at ‘@‘     [LeadingSpace]    Loc=<a href="main.m:7:23" target="_blank" rel="noopener">main.m:7:23</a><br>string_literal ‘”aaa”’        Loc=<a href="main.m:7:24" target="_blank" rel="noopener">main.m:7:24</a><br>semi ‘;’        Loc=<a href="main.m:7:29" target="_blank" rel="noopener">main.m:7:29</a><br>identifier ‘NSLog’     [StartOfLine] [LeadingSpace]    Loc=<a href="main.m:8:9" target="_blank" rel="noopener">main.m:8:9</a><br>l_paren ‘(‘        Loc=<a href="main.m:8:14" target="_blank" rel="noopener">main.m:8:14</a><br>at ‘@‘        Loc=<a href="main.m:8:15" target="_blank" rel="noopener">main.m:8:15</a><br>string_literal ‘”hi %@“’        Loc=<a href="main.m:8:16" target="_blank" rel="noopener">main.m:8:16</a><br>comma ‘,’        Loc=<a href="main.m:8:23" target="_blank" rel="noopener">main.m:8:23</a><br>identifier ‘a’        Loc=<a href="main.m:8:24" target="_blank" rel="noopener">main.m:8:24</a><br>r_paren ‘)’        Loc=<a href="main.m:8:25" target="_blank" rel="noopener">main.m:8:25</a><br>semi ‘;’        Loc=<a href="main.m:8:26" target="_blank" rel="noopener">main.m:8:26</a><br>r_brace ‘}’     [StartOfLine] [LeadingSpace]    Loc=<a href="main.m:9:5" target="_blank" rel="noopener">main.m:9:5</a><br>return ‘return’     [StartOfLine] [LeadingSpace]    Loc=<a href="main.m:10:5" target="_blank" rel="noopener">main.m:10:5</a><br>numeric_constant ‘0’     [LeadingSpace]    Loc=<a href="main.m:10:12" target="_blank" rel="noopener">main.m:10:12</a><br>semi ‘;’        Loc=<a href="main.m:10:13" target="_blank" rel="noopener">main.m:10:13</a><br>r_brace ‘}’     [StartOfLine]    Loc=<a href="main.m:11:1" target="_blank" rel="noopener">main.m:11:1</a><br>eof ‘’        Loc=<a href="main.m:11:2" target="_blank" rel="noopener">main.m:11:2</a></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=&lt;main.m:11:1&gt; 这个样的具体位置。</span><br><span class="line"></span><br><span class="line">接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。</span><br><span class="line"></span><br><span class="line">打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。</span><br><span class="line"></span><br><span class="line">打印语法树的命令</span><br></pre></td></tr></table></figure>

<p>clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br></pre></td></tr></table></figure>

<p>TranslationUnitDecl 0x7fa80f018ad0 &lt;<invalid sloc>&gt; <invalid sloc><br>|-TypedefDecl 0x7fa80f018fc8 &lt;<invalid sloc>&gt; <invalid sloc> implicit <strong>int128_t ‘</strong>int128’<br>| <code>-BuiltinType 0x7fa80f018d20 ‘__int128’
|-TypedefDecl 0x7fa80f019028 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t ‘unsigned __int128’
|</code>-BuiltinType 0x7fa80f018d40 ‘unsigned <strong>int128’<br>|-TypedefDecl 0x7fa80f0190b8 &lt;<invalid sloc>&gt; <invalid sloc> implicit SEL ‘SEL *’<br>| <code>-PointerType 0x7fa80f019080 ‘SEL *’
|</code>-BuiltinType 0x7fa80f018f30 ‘SEL’<br>|-TypedefDecl 0x7fa80f019198 &lt;<invalid sloc>&gt; <invalid sloc> implicit id ‘id’<br>| <code>-ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported
|</code>-ObjCObjectType 0x7fa80f019110 ‘id’ imported<br>|-TypedefDecl 0x7fa80f019278 &lt;<invalid sloc>&gt; <invalid sloc> implicit Class ‘Class’<br>| <code>-ObjCObjectPointerType 0x7fa80f019220 ‘Class’
|</code>-ObjCObjectType 0x7fa80f0191f0 ‘Class’<br>|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;<invalid sloc>&gt; <invalid sloc> implicit Protocol<br>|-TypedefDecl 0x7fa80f019618 &lt;<invalid sloc>&gt; <invalid sloc> implicit __NSConstantString ‘struct __NSConstantString_tag’<br>| <code>-RecordType 0x7fa80f019430 ‘struct __NSConstantString_tag’
|</code>-Record 0x7fa80f019390 ‘</invalid></invalid></invalid></invalid></invalid></invalid></invalid></invalid></invalid></invalid></strong>NSConstantString_tag’<br>|-TypedefDecl 0x7fa80f0196a8 &lt;<invalid sloc>&gt; <invalid sloc> implicit <strong>builtin_ms_va_list ‘char *’<br>| <code>-PointerType 0x7fa80f019670 ‘char *’
|</code>-BuiltinType 0x7fa80f018b60 ‘char’<br>|-TypedefDecl 0x7fa80f047978 &lt;<invalid sloc>&gt; <invalid sloc> implicit __builtin_va_list ‘struct __va_list_tag [1]’<br>| <code>-ConstantArrayType 0x7fa80f047920 ‘struct __va_list_tag [1]’ 1 
|</code>-RecordType 0x7fa80f0197a0 ‘struct __va_list_tag’<br>|     `-Record 0x7fa80f0196f8 ‘</invalid></invalid></strong>va_list_tag’<br>|-ImportDecl 0x7fa80f0486b0 <a href="main.m:2:1" target="_blank" rel="noopener">main.m:2:1</a> col:1 implicit Foundation<br>|-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main ‘int ()’<br>| <code>-CompoundStmt 0x7fa80f393998 &lt;col:12, line:11:1&gt;
|   |-ObjCAutoreleasePoolStmt 0x7fa80f393950 &lt;line:6:5, line:9:5&gt;
|   |</code>-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt;<br>|   |   |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt;<br>|   |   | <code>-VarDecl 0x7fa80f3a3580 &lt;col:9, col:24&gt; col:19 used a ‘NSString *’ cinit
|   |   |</code>-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; ‘NSString <em>’<br>|   |   |     <code>-StringLiteral 0x7fa80f3a3618 &lt;col:24&gt; ‘char [4]’ lvalue “aaa”
|   |</code>-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; ‘void’<br>|   |     |-ImplicitCastExpr 0x7fa80f3938a8 <a href="col:9" target="_blank" rel="noopener">col:9</a> ‘void (</em>)(id, …)’ <functiontopointerdecay><br>|   |     | <code>-DeclRefExpr 0x7fa80f3a3b50 &lt;col:9&gt; ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’
|   |     |-ImplicitCastExpr 0x7fa80f3938f8 &lt;col:15, col:16&gt; ‘id’:’id’ &lt;BitCast&gt;
|   |     |</code>-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; ‘NSString *’<br>|   |     |   <code>-StringLiteral 0x7fa80f3a3bb8 &lt;col:16&gt; ‘char [6]’ lvalue “hi %@“
|   |</code>-ImplicitCastExpr 0x7fa80f393910 <a href="col:24" target="_blank" rel="noopener">col:24</a> ‘NSString *’ <lvaluetorvalue><br>|   |       <code>-DeclRefExpr 0x7fa80f393820 &lt;col:24&gt; ‘NSString *’ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString *’
|</code>-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt;<br>|     <code>-IntegerLiteral 0x7fa80f393960 &lt;col:12&gt; ‘int’ 0</code>-<undeserialized declarations></undeserialized></lvaluetorvalue></functiontopointerdecay></invalid></invalid></invalid></invalid></invalid></invalid></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</span><br><span class="line"></span><br><span class="line">clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</span><br><span class="line"></span><br><span class="line">可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</span><br></pre></td></tr></table></figure>

<p>debug.ConfigDumper              Dump config table<br>debug.DumpCFG                   Display Control-Flow Graphs<br>debug.DumpCallGraph             Display Call Graph<br>debug.DumpCalls                 Print calls as they are traversed by the engine<br>debug.DumpDominators            Print the dominance tree for a given CFG<br>debug.DumpLiveVars              Print results of live variable analysis<br>debug.DumpTraversal             Print branch conditions as they are traversed by the engine<br>debug.ExprInspection            Check the analyzer’s understanding of expressions<br>debug.Stats                     Emit warnings with analyzer statistics<br>debug.TaintTest                 Mark tainted symbols as such.<br>debug.ViewCFG                   View Control-Flow Graphs using GraphViz<br>debug.ViewCallGraph             View Call Graph using GraphViz<br>debug.ViewExplodedGraph         View Exploded Graphs using GraphViz</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</span><br><span class="line"></span><br><span class="line">clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</span><br><span class="line"></span><br><span class="line">编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</span><br><span class="line"></span><br><span class="line">clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</span><br><span class="line"></span><br><span class="line">整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 [MemRegion.h](https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html)和 [RegionStore.cpp](https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html) 。</span><br><span class="line"></span><br><span class="line">下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。</span><br></pre></td></tr></table></figure>

<p>int main()<br>{<br>    int a;<br>    int b = 10;<br>    a = b;<br>    return a;<br>}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应的 AST 以及 CFG</span><br></pre></td></tr></table></figure>

<p>#————————AST—————————</p>
<h1 id="clang-cc1-ast-dump"><a href="#clang-cc1-ast-dump" class="headerlink" title="clang -cc1 -ast-dump"></a>clang -cc1 -ast-dump</h1><p>TranslationUnitDecl 0xc75b450 &lt;<invalid sloc>&gt; <invalid sloc><br>|-TypedefDecl 0xc75b740 &lt;<invalid sloc>&gt; <invalid sloc> implicit __builtin_va_list ‘char *’<br><code>-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’</code>-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;<br>    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;<br>    | <code>-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’
    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;
    |</code>-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit<br>    |   `-IntegerLiteral 0xc75b8c0 <a href="col:10" target="_blank" rel="noopener">col:10</a> ‘int’ 10</invalid></invalid></invalid></invalid></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br>    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘<br>    | |-DeclRefExpr 0xc75b8e8 <a href="col:2" target="_blank" rel="noopener">col:2</a> ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’<br>    | <code>-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt;
    |</code>-DeclRefExpr 0xc75b900 <a href="col:6" target="_blank" rel="noopener">col:6</a> ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</p>
<pre><code>`-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;
  `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt;
    `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</code></pre><p>#————————CFG—————————</p>
<h1 id="clang-cc1-analyze-analyzer-checker-debug-DumpCFG"><a href="#clang-cc1-analyze-analyzer-checker-debug-DumpCFG" class="headerlink" title="clang -cc1 -analyze -analyzer-checker=debug.DumpCFG"></a>clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</h1><p>int main()<br> [B2 (ENTRY)]<br>   Succs (1): B1</p>
<p> [B1]<br>   1: int a;<br>   2: 10<br>   3: int b = 10;<br>   4: b<br>   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)<br>   6: a<br>   7: [B1.6] = [B1.5]<br>   8: a<br>   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)<br>  10: return [B1.9];<br>   Preds (1): B2<br>   Succs (1): B0</p>
<p> [B0 (EXIT)]<br>   Preds (1): B1</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</span><br><span class="line"></span><br><span class="line">在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</span><br><span class="line"></span><br><span class="line">官方 AST 相关文档</span><br><span class="line">* http://clang.llvm.org/docs/Tooling.html</span><br><span class="line">* http://clang.llvm.org/docs/IntroductionToTheClangAST.html</span><br><span class="line">* http://clang.llvm.org/docs/RAVFrontendAction.html</span><br><span class="line">* http://clang.llvm.org/docs/LibTooling.html</span><br><span class="line">* http://clang.llvm.org/docs/LibASTMatchers.html</span><br><span class="line"></span><br><span class="line">静态检查的一些库以及使用方法</span><br><span class="line">* [FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub](https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0)</span><br><span class="line"></span><br><span class="line"># CodeGen 生成 IR 代码</span><br><span class="line">将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</span><br><span class="line"></span><br><span class="line">这个过程中还会跟 runtime 桥接。</span><br><span class="line">* 各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</span><br><span class="line">* Non-Fragile ABI 合成 OBJC_IVAR_$_ 偏移值常量。</span><br><span class="line">* ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</span><br><span class="line">* strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</span><br><span class="line">* @synthesize 的处理。</span><br><span class="line">* 生成 block_layout 数据结构</span><br><span class="line">* __block 和 __weak</span><br><span class="line">* _block_invoke</span><br><span class="line">* ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</span><br><span class="line"></span><br><span class="line">不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。</span><br><span class="line"></span><br><span class="line">## IR 结构</span><br><span class="line">下面是刚才生成的 main.ll 中间代码文件。</span><br></pre></td></tr></table></figure>

<p>; ModuleID = ‘main.c’<br>source_filename = “main.c”<br>target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”<br>target triple = “x86_64-apple-macosx10.12.0”</p>
<p>@.str = private unnamed_addr constant [16 x i8] c”Please input a:\00”, align 1<br>@.str.1 = private unnamed_addr constant [3 x i8] c”%d\00”, align 1<br>@.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\00”, align 1<br>@.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\00”, align 1</p>
<p>; Function Attrs: nounwind ssp uwtable<br>define i32 @main() #0 {<br>  %1 = alloca i32, align 4<br>  %2 = alloca i32, align 4<br>  %3 = bitcast i32* %1 to i8*<br>  call void @llvm.lifetime.start(i64 4, i8* %3) #3<br>  %4 = bitcast i32* %2 to i8*<br>  call void @llvm.lifetime.start(i64 4, i8* %4) #3<br>  %5 = tail call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0))<br>  %6 = call i32 (i8<em>, …) @scanf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1)<br>  %7 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0))<br>  %8 = call i32 (i8<em>, …) @scanf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2)<br>  %9 = load i32, i32* %1, align 4, !tbaa !2<br>  %10 = load i32, i32* %2, align 4, !tbaa !2<br>  %11 = add nsw i32 %10, %9<br>  %12 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11)<br>  call void @llvm.lifetime.end(i64 4, i8* %4) #3<br>  call void @llvm.lifetime.end(i64 4, i8* %3) #3<br>  ret i32 0<br>}</p>
<p>; Function Attrs: argmemonly nounwind<br>declare void @llvm.lifetime.start(i64, i8* nocapture) #1</p>
<p>; Function Attrs: nounwind<br>declare i32 @printf(i8* nocapture readonly, …) #2</p>
<p>; Function Attrs: nounwind<br>declare i32 @scanf(i8* nocapture readonly, …) #2</p>
<p>; Function Attrs: argmemonly nounwind<br>declare void @llvm.lifetime.end(i64, i8* nocapture) #1</p>
<p>attributes #0 = { nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” }<br>attributes #1 = { argmemonly nounwind }<br>attributes #2 = { nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” }<br>attributes #3 = { nounwind }</p>
<p>!llvm.module.flags = !{!0}<br>!llvm.ident = !{!1}</p>
<p>!0 = !{i32 1, !”PIC Level”, i32 2}<br>!1 = !{!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”}<br>!2 = !{!3, !3, i64 0}<br>!3 = !{!”int”, !4, i64 0}<br>!4 = !{!”omnipotent char”, !5, i64 0}<br>!5 = !{!”Simple C/C++ TBAA”}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。</span><br><span class="line"></span><br><span class="line">一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。</span><br><span class="line">‘</span><br><span class="line"></span><br><span class="line">通过下面的 IR 结构图能够更好的理解 IR 的整体结构。</span><br><span class="line"></span><br><span class="line">![](https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm08.png?raw=true)</span><br><span class="line"></span><br><span class="line">图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。</span><br><span class="line"></span><br><span class="line">IR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。</span><br><span class="line"></span><br><span class="line">## LLVM IR 优化</span><br><span class="line">使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。</span><br><span class="line"></span><br><span class="line">可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上</span><br></pre></td></tr></table></figure>

<p>int i = 0;<br>while (i &lt; 10) {<br>    i++;<br>    printf(“%d”,i);<br>}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对应的 IR 代码是</span><br></pre></td></tr></table></figure>

<p>  %call4 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1)<br>  %call4.1 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2)<br>  %call4.2 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3)<br>  %call4.3 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4)<br>  %call4.4 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5)<br>  %call4.5 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6)<br>  %call4.6 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7)<br>  %call4.7 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8)<br>  %call4.8 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9)<br>  %call4.9 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10)</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？</span><br><span class="line"></span><br><span class="line">我们改成100后，再次生成 IR 可以看到 IR 变成了这样：</span><br></pre></td></tr></table></figure>

<p>  br label %while.body</p>
<p>while.body:                                       ; preds = %while.body, %entry<br>  %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ]<br>  %inc = add nuw nsw i32 %i.010, 1<br>  %call4 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc)<br>  %exitcond = icmp eq i32 %inc, 100<br>  br i1 %exitcond, label %while.end, label %while.body</p>
<p>while.end:                                        ; preds = %while.body<br>  %2 = load i32, i32* %a, align 4, !tbaa !2<br>  %3 = load i32, i32* %b, align 4, !tbaa !2<br>  %add = add nsw i32 %3, %2<br>  %call5 = call i32 (i8<em>, …) @printf(i8</em> getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add)<br>  call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3<br>  call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3<br>  ret i32 0<br>}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：</span><br><span class="line"></span><br><span class="line">* @ - 代表全局变量</span><br><span class="line">* % - 代表局部变量</span><br><span class="line">* alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。</span><br><span class="line">* i32：- i 是几这个整数就会占几位，i32就是32位4字节</span><br><span class="line">* align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。</span><br><span class="line">* Load - 读出，store 写入</span><br><span class="line">* icmp - 两个整数值比较，返回布尔值</span><br><span class="line">* br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto</span><br><span class="line">* indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的</span><br><span class="line">* label - 代码标签</span><br></pre></td></tr></table></figure>

<p>br label %while.body</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如上面表述，br  会选择跳向 while.body 定义的这个标签。这个标签里可以看到</span><br></pre></td></tr></table></figure>

<p>%exitcond = icmp eq i32 %inc, 100<br>  br i1 %exitcond, label %while.end, label %while.body</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## SSA</span><br><span class="line">LLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。</span><br><span class="line"></span><br><span class="line">那么看看加法这个操作的相关的 IR 代码</span><br></pre></td></tr></table></figure>

<p>%2 = load i32, i32* %a, align 4, !tbaa !2<br>%3 = load i32, i32* %b, align 4, !tbaa !2<br>%add = add nsw i32 %3, %2</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加法对应的指令是</span><br></pre></td></tr></table></figure>

<p>BinaryOperator::CreateAdd(Value *V1, Value *V2, const Twine &amp;Name)</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码</span><br></pre></td></tr></table></figure>

<p>class Value {<br>  void addUse(Use &amp;U) { U.addToList(&amp;UseList); }</p>
<p>  // …<br>};</p>
<p>class Use {<br>  Value <em>Val;<br>  Use *Next;<br>  PointerIntPair&lt;Use *</em>, 2, PrevPtrTag&gt; Prev;</p>
<p>  // …<br>};</p>
<p>void Use::set(Value <em>V) {<br>  if (Val) removeFromList();<br>  Val = V;<br>  if (V) V-&gt;addUse(</em>this);<br>}</p>
<p>Value *Use::operator=(Value *RHS) {<br>  set(RHS);<br>  return RHS;<br>}</p>
<p>class User : public Value {<br>  template &lt;int Idx, typename U&gt; static Use &amp;OpFrom(const U <em>that) {<br>    return Idx &lt; 0<br>      ? OperandTraits<u>::op_end(const_cast&lt;U</u></em>&gt;(that))[Idx]<br>      : OperandTraits<u>::op_begin(const_cast&lt;U*&gt;(that))[Idx];<br>  }<br>  template <int idx> Use &amp;Op() {<br>    return OpFrom<idx>(this);<br>  }<br>  template <int idx> const Use &amp;Op() const {<br>    return OpFrom<idx>(this);<br>  }</idx></int></idx></int></u></p>
<p>  // …<br>};</p>
<p>class Instruction : public User,<br>                    public ilist_node_with_parent&lt;Instruction, BasicBlock&gt; {<br>  // …<br>};</p>
<p>class BinaryOperator : public Instruction {<br>  /// Construct a binary instruction, given the opcode and the two<br>  /// operands.  Optionally (if InstBefore is specified) insert the instruction<br>  /// into a BasicBlock right before the specified instruction.  The specified<br>  /// Instruction is allowed to be a dereferenced end iterator.<br>  ///<br>  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,<br>                                const Twine &amp;Name = Twine(),<br>                                Instruction *InsertBefore = nullptr);</p>
<p>  // …<br>};</p>
<p>BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,<br>                               Type *Ty, const Twine &amp;Name,<br>                               Instruction *InsertBefore)<br>  : Instruction(Ty, iType,<br>                OperandTraits<binaryoperator>::op_begin(this),<br>                OperandTraits<binaryoperator>::operands(this),<br>                InsertBefore) {<br>  Op&lt;0&gt;() = S1;<br>  Op&lt;1&gt;() = S2;<br>  init(iType);<br>  setName(Name);<br>}</binaryoperator></binaryoperator></p>
<p>BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,<br>                                       const Twine &amp;Name,<br>                                       Instruction *InsertBefore) {<br>  assert(S1-&gt;getType() == S2-&gt;getType() &amp;&amp;<br>         “Cannot create binary operator with two operands of differing type!”);<br>  return new BinaryOperator(Op, S1, S2, S1-&gt;getType(), Name, InsertBefore);<br>}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。</span><br><span class="line"></span><br><span class="line">LLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。</span><br><span class="line"></span><br><span class="line">这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。</span><br><span class="line"></span><br><span class="line">当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。</span><br><span class="line"></span><br><span class="line">这里可以进行 lli 解释执行 LLVM IR。</span><br><span class="line"></span><br><span class="line">llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。</span><br><span class="line"></span><br><span class="line">调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。</span><br><span class="line"></span><br><span class="line">llvm-mc 还可以直接生成 object 文件。</span><br><span class="line"></span><br><span class="line"># Clang CFE</span><br><span class="line">动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。</span><br><span class="line"></span><br><span class="line">* LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</span><br><span class="line">* The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</span><br><span class="line">* The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</span><br><span class="line">* Precompiled Headers - Clang 支持预编译 headers 的两个实现。</span><br><span class="line">* The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</span><br><span class="line">* The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</span><br><span class="line">* The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</span><br><span class="line">* The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</span><br><span class="line"></span><br><span class="line">## libclang</span><br><span class="line">libclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下</span><br><span class="line"></span><br><span class="line">先写个 libclang 的程序来解析源码</span><br></pre></td></tr></table></figure>

<p>int main(int argc, char *argv[]) {<br>    CXIndex Index = clang_createIndex(0, 0);<br>    CXTranslationUnit TU = clang_parseTranslationUnit(Index, 0,<br>                                                      argv, argc, 0, 0, CXTranslationUnit_None); for (unsigned I = 0, N = clang_getNumDiagnostics(TU); I != N; ++I) {<br>        CXDiagnostic Diag = clang_getDiagnostic(TU, I);<br>        CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions());<br>        fprintf(stderr, “%s\n”, clang_getCString(String));<br>        clang_disposeString(String);<br>    }<br>    clang_disposeTranslationUnit(TU);<br>    clang_disposeIndex(Index);<br>    return 0;<br>}</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再写个有问题的 c 程序</span><br></pre></td></tr></table></figure>

<p>struct List { /<em>*/ };int sum(union List *L) { /</em> … */ }</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">运行了语法检查后会出现提示信息</span><br><span class="line">```bash</span><br><span class="line">list.c:2:9: error: use of &apos;List&apos; with tag type that does not match</span><br><span class="line">      previous declaration</span><br><span class="line">int sum(union List *Node) &#123;</span><br><span class="line">^~~~~</span><br><span class="line">struct</span><br><span class="line">list.c:1:8: note: previous use is here</span><br><span class="line">struct List &#123;</span><br><span class="line">^</span><br></pre></td></tr></table></figure>

<p>下面我们看看诊断过程，显示几个核心诊断方法诊断出问题</p>
<ul>
<li>enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag);</li>
<li>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticSpelling(CXDiagnostic Diag);</li>
</ul>
<p>接着进行高亮显示，最后提供两个提示修复的方法</p>
<ul>
<li>unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);* CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,CXSourceRange *ReplacementRange);</li>
</ul>
<p>我们先遍历语法树的节点。源 c 程序如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct List &#123;</span><br><span class="line">    int Data;</span><br><span class="line">    struct List *Next;</span><br><span class="line">&#125;;</span><br><span class="line">int sum(struct List *Node) &#123;</span><br><span class="line">    int result = 0;</span><br><span class="line">    for (; Node; Node = Node-&gt;Next)</span><br><span class="line">        result = result + Node-&gt;Data;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。</p>
<p>CXCursor 会统一 AST 的节点，规范包含的信息</p>
<ul>
<li>代码所在位置和长度</li>
<li>名字和符号解析</li>
<li>类型</li>
<li>子节点</li>
</ul>
<p>举个 CXCursor 分析例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct List &#123;</span><br><span class="line">    int Data;</span><br><span class="line">    struct List *Next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CXCursor 的处理过程如下</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Top-level cursor C</span><br><span class="line">clang_getCursorKind(C) == CXCursor_StructDecl</span><br><span class="line">clang_getCursorSpelling(C) == &quot;List&quot; //获取名字字符串</span><br><span class="line">clang_getCursorLocation(C) //位置</span><br><span class="line">clang_getCursorExtent(C) //长度</span><br><span class="line">clang_visitChildren(C, ...); //访问子节点</span><br><span class="line"></span><br><span class="line">//Reference cursor R</span><br><span class="line">clang_getCursorKind(R) == CXCursor_TypeRef </span><br><span class="line">clang_getCursorSpelling(R) == &quot;List&quot;</span><br><span class="line">clang_getCursorLocation(R)</span><br><span class="line">clang_getCursorExtent(R)</span><br><span class="line">clang_getCursorReferenced(R) == C //指向C</span><br></pre></td></tr></table></figure>

<h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><p>动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。</p>
<p>Driver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。</p>
<p>相关源代码在这里：clang/tools/driver/driver.cpp</p>
<p>整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个  driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc_, const char **argv_) &#123;</span><br><span class="line">  llvm::sys::PrintStackTraceOnErrorSignal(argv_[0]);</span><br><span class="line">  llvm::PrettyStackTraceProgram X(argc_, argv_);</span><br><span class="line">  llvm::llvm_shutdown_obj Y; // Call llvm_shutdown() on exit.</span><br><span class="line"></span><br><span class="line">  if (llvm::sys::Process::FixupStandardFileDescriptors())</span><br><span class="line">    return 1;</span><br><span class="line"></span><br><span class="line">  SmallVector&lt;const char *, 256&gt; argv;</span><br><span class="line">  llvm::SpecificBumpPtrAllocator&lt;char&gt; ArgAllocator;</span><br><span class="line">  std::error_code EC = llvm::sys::Process::GetArgumentVector(</span><br><span class="line">      argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator);</span><br><span class="line">  if (EC) &#123;</span><br><span class="line">    llvm::errs() &lt;&lt; &quot;error: couldn&apos;t get arguments: &quot; &lt;&lt; EC.message() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  llvm::InitializeAllTargets();</span><br><span class="line">  std::string ProgName = argv[0];</span><br><span class="line">  std::pair&lt;std::string, std::string&gt; TargetAndMode =</span><br><span class="line">      ToolChain::getTargetAndModeFromProgramName(ProgName);</span><br><span class="line"></span><br><span class="line">  llvm::BumpPtrAllocator A;</span><br><span class="line">  llvm::StringSaver Saver(A);</span><br><span class="line">    </span><br><span class="line">    //省略</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  // If we have multiple failing commands, we return the result of the first</span><br><span class="line">  // failing command.</span><br><span class="line">  return Res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Driver-的工作流程图"><a href="#Driver-的工作流程图" class="headerlink" title="Driver 的工作流程图"></a>Driver 的工作流程图</h2><p>在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags);</span><br><span class="line">  SetInstallDir(argv, TheDriver, CanonicalPrefixes);</span><br><span class="line"></span><br><span class="line">  insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv,</span><br><span class="line">                          SavedStrings);</span><br><span class="line"></span><br><span class="line">  SetBackdoorDriverOutputsFromEnvVars(TheDriver);</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv));</span><br><span class="line">  int Res = 0;</span><br><span class="line">  SmallVector&lt;std::pair&lt;int, const Command *&gt;, 4&gt; FailingCommands;</span><br><span class="line">  if (C.get())</span><br><span class="line">    Res = TheDriver.ExecuteCompilation(*C, FailingCommands);</span><br><span class="line"></span><br><span class="line">  // Force a crash to test the diagnostics.</span><br><span class="line">  if (::getenv(&quot;FORCE_CLANG_DIAGNOSTICS_CRASH&quot;)) &#123;</span><br><span class="line">    Diags.Report(diag::err_drv_force_crash) &lt;&lt; &quot;FORCE_CLANG_DIAGNOSTICS_CRASH&quot;;</span><br><span class="line"></span><br><span class="line">    // Pretend that every command failed.</span><br><span class="line">    FailingCommands.clear();</span><br><span class="line">    for (const auto &amp;J : C-&gt;getJobs())</span><br><span class="line">      if (const Command *C = dyn_cast&lt;Command&gt;(&amp;J))</span><br><span class="line">        FailingCommands.push_back(std::make_pair(-1, C));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const auto &amp;P : FailingCommands) &#123;</span><br><span class="line">    int CommandRes = P.first;</span><br><span class="line">    const Command *FailingCommand = P.second;</span><br><span class="line">    if (!Res)</span><br><span class="line">      Res = CommandRes;</span><br><span class="line"></span><br><span class="line">    // If result status is &lt; 0, then the driver command signalled an error.</span><br><span class="line">    // If result status is 70, then the driver command reported a fatal error.</span><br><span class="line">    // On Windows, abort will return an exit code of 3.  In these cases,</span><br><span class="line">    // generate additional diagnostic information if possible.</span><br><span class="line">    bool DiagnoseCrash = CommandRes &lt; 0 || CommandRes == 70;</span><br><span class="line">#ifdef LLVM_ON_WIN32</span><br><span class="line">    DiagnoseCrash |= CommandRes == 3;</span><br><span class="line">#endif</span><br><span class="line">    if (DiagnoseCrash) &#123;</span><br><span class="line">      TheDriver.generateCompilationDiagnostics(*C, *FailingCommand);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;clang/Driver/Compilation.h&quot;</span><br></pre></td></tr></table></figure>

<p>根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class Compilation &#123;</span><br><span class="line">    /// The original (untranslated) input argument list.</span><br><span class="line">  llvm::opt::InputArgList *Args;</span><br><span class="line"></span><br><span class="line">  /// The driver translated arguments. Note that toolchains may perform their</span><br><span class="line">  /// own argument translation.</span><br><span class="line">  llvm::opt::DerivedArgList *TranslatedArgs;</span><br><span class="line">  /// The driver we were created by.</span><br><span class="line">  const Driver &amp;TheDriver;</span><br><span class="line"></span><br><span class="line">  /// The default tool chain.</span><br><span class="line">  const ToolChain &amp;DefaultToolChain;</span><br><span class="line"> ...</span><br><span class="line">  /// The list of actions.  This is maintained and modified by consumers, via</span><br><span class="line">  /// getActions().</span><br><span class="line">  ActionList Actions;</span><br><span class="line"></span><br><span class="line">  /// The root list of jobs.</span><br><span class="line">  JobList Jobs;</span><br><span class="line">    ...</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">  const Driver &amp;getDriver() const &#123; return TheDriver; &#125;</span><br><span class="line"></span><br><span class="line">  const ToolChain &amp;getDefaultToolChain() const &#123; return DefaultToolChain; &#125;</span><br><span class="line">    ...</span><br><span class="line">  ActionList &amp;getActions() &#123; return Actions; &#125;</span><br><span class="line">  const ActionList &amp;getActions() const &#123; return Actions; &#125;</span><br><span class="line">    ...</span><br><span class="line">  JobList &amp;getJobs() &#123; return Jobs; &#125;</span><br><span class="line">  const JobList &amp;getJobs() const &#123; return Jobs; &#125;</span><br><span class="line"></span><br><span class="line">  void addCommand(std::unique_ptr&lt;Command&gt; C) &#123; Jobs.addJob(std::move(C)); &#125;</span><br><span class="line">    ...</span><br><span class="line">  /// ExecuteCommand - Execute an actual command.</span><br><span class="line">  ///</span><br><span class="line">  /// \param FailingCommand - For non-zero results, this will be set to the</span><br><span class="line">  /// Command which failed, if any.</span><br><span class="line">  /// \return The result code of the subprocess.</span><br><span class="line">  int ExecuteCommand(const Command &amp;C, const Command *&amp;FailingCommand) const;</span><br><span class="line"></span><br><span class="line">  /// ExecuteJob - Execute a single job.</span><br><span class="line">  ///</span><br><span class="line">  /// \param FailingCommands - For non-zero results, this will be a vector of</span><br><span class="line">  /// failing commands and their associated result code.</span><br><span class="line">  void ExecuteJobs(</span><br><span class="line">      const JobList &amp;Jobs,</span><br><span class="line">      SmallVectorImpl&lt;std::pair&lt;int, const Command *&gt;&gt; &amp;FailingCommands) const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下：</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm04.png?raw=true" alt></p>
<h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>看完完整的 Driver 流程后，我们就先从 Parse 开始说起。</p>
<p>Parse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。</p>
<p>下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm05.png?raw=true" alt></p>
<p>这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。</p>
<p>Driver 层会解析我们传入的 -I Option 参数。</p>
<p>-x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x c++ main.cpp</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm06.png?raw=true" alt></p>
<p>通过报错信息可以看出一些链接错误</p>
<p>因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -x c++ -lc++ main.cpp</span><br></pre></td></tr></table></figure>

<p>那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。</p>
<p>只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。</p>
<p>这点可以通过  driver.cpp 源码来看，在 main()  函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (MarkEOLs &amp;&amp; argv.size() &gt; 1 &amp;&amp; StringRef(argv[1]).startswith(&quot;-cc1&quot;))</span><br><span class="line">    MarkEOLs = false;</span><br><span class="line">  llvm::cl::ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs);</span><br><span class="line"></span><br><span class="line">  // 处理 -cc1 集成工具</span><br><span class="line">  auto FirstArg = std::find_if(argv.begin() + 1, argv.end(),</span><br><span class="line">                               [](const char *A) &#123; return A != nullptr; &#125;);</span><br><span class="line">  if (FirstArg != argv.end() &amp;&amp; StringRef(*FirstArg).startswith(&quot;-cc1&quot;)) &#123;</span><br><span class="line">    // 如果 -cc1 来自 response file, 移除 EOL sentinels</span><br><span class="line">    if (MarkEOLs) &#123;</span><br><span class="line">      auto newEnd = std::remove(argv.begin(), argv.end(), nullptr);</span><br><span class="line">      argv.resize(newEnd - argv.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    return ExecuteCC1Tool(argv, argv[1] + 4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int ExecuteCC1Tool(ArrayRef&lt;const char *&gt; argv, StringRef Tool) &#123;</span><br><span class="line">  void *GetExecutablePathVP = (void *)(intptr_t) GetExecutablePath;</span><br><span class="line">  if (Tool == &quot;&quot;)</span><br><span class="line">    return cc1_main(argv.slice(2), argv[0], GetExecutablePathVP);</span><br><span class="line">  if (Tool == &quot;as&quot;)</span><br><span class="line">    return cc1as_main(argv.slice(2), argv[0], GetExecutablePathVP);</span><br><span class="line"></span><br><span class="line">  // 拒绝未知工具</span><br><span class="line">  llvm::errs() &lt;&lt; &quot;error: unknown integrated tool &apos;&quot; &lt;&lt; Tool &lt;&lt; &quot;&apos;\n&quot;;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。</p>
<p>下面看看有哪些解析 Args 的方法</p>
<ul>
<li>ParseAnalyzerArgs - 解析出静态分析器 option</li>
<li>ParseMigratorArgs - 解析 Migrator option</li>
<li>ParseDependencyOutputArgs - 解析依赖输出 option</li>
<li>ParseCommentArgs - 解析注释 option</li>
<li>ParseFileSystemArgs - 解析文件系统 option</li>
<li>ParseFrontendArgs - 解析前端 option</li>
<li>ParseTargetArgs - 解析目标  option</li>
<li>ParseCodeGenArgs - 解析 CodeGen 相关的 option</li>
<li>ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option</li>
<li>parseSanitizerKinds - 解析 Sanitizer Kinds</li>
<li>ParsePreprocessorArgs - 解析预处理的 option</li>
<li>ParsePreprocessorOutputArgs - 解析预处理输出的 option</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Pipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。</p>
<p>这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。</p>
<p>在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。</p>
<p>使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/// BuildActions - Construct the list of actions to perform for the</span><br><span class="line">  /// given arguments, which are only done for a single architecture.</span><br><span class="line">  ///</span><br><span class="line">  /// \param C - The compilation that is being built.</span><br><span class="line">  /// \param Args - The input arguments.</span><br><span class="line">  /// \param Actions - The list to store the resulting actions onto.</span><br><span class="line">  void BuildActions(Compilation &amp;C, llvm::opt::DerivedArgList &amp;Args,</span><br><span class="line">                    const InputList &amp;Inputs, ActionList &amp;Actions) const;</span><br><span class="line"></span><br><span class="line">  /// BuildUniversalActions - Construct the list of actions to perform</span><br><span class="line">  /// for the given arguments, which may require a universal build.</span><br><span class="line">  ///</span><br><span class="line">  /// \param C - The compilation that is being built.</span><br><span class="line">  /// \param TC - The default host tool chain.</span><br><span class="line">  void BuildUniversalActions(Compilation &amp;C, const ToolChain &amp;TC,</span><br><span class="line">                             const InputList &amp;BAInputs) const;</span><br></pre></td></tr></table></figure>

<p>上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args,</span><br><span class="line">                          const InputList &amp;Inputs, ActionList &amp;Actions) const &#123;</span><br><span class="line">  llvm::PrettyStackTraceString CrashInfo(&quot;Building compilation actions&quot;);</span><br><span class="line"></span><br><span class="line">  if (!SuppressMissingInputWarning &amp;&amp; Inputs.empty()) &#123;</span><br><span class="line">    Diag(clang::diag::err_drv_no_input_files);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Arg *FinalPhaseArg;</span><br><span class="line">  phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg);</span><br></pre></td></tr></table></figure>

<p>接着跟 getFinalPhase 这个方法。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// -&#123;E,EP,P,M,MM&#125; only run the preprocessor.</span><br><span class="line">  if (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||</span><br><span class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) &#123;</span><br><span class="line">    FinalPhase = phases::Preprocess;</span><br><span class="line"></span><br><span class="line">    // -&#123;fsyntax-only,-analyze,emit-ast&#125; only run up to the compiler.</span><br><span class="line">  &#125; else if ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT__analyze,</span><br><span class="line">                                        options::OPT__analyze_auto)) ||</span><br><span class="line">             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) &#123;</span><br><span class="line">    FinalPhase = phases::Compile;</span><br><span class="line"></span><br><span class="line">    // -S only runs up to the backend.</span><br><span class="line">  &#125; else if ((PhaseArg = DAL.getLastArg(options::OPT_S))) &#123;</span><br><span class="line">    FinalPhase = phases::Backend;</span><br><span class="line"></span><br><span class="line">    // -c compilation only runs up to the assembler.</span><br><span class="line">  &#125; else if ((PhaseArg = DAL.getLastArg(options::OPT_c))) &#123;</span><br><span class="line">    FinalPhase = phases::Assemble;</span><br><span class="line"></span><br><span class="line">    // Otherwise do everything.</span><br><span class="line">  &#125; else</span><br><span class="line">    FinalPhase = phases::Link;</span><br></pre></td></tr></table></figure>

<p>看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。</p>
<p>下面列下一些编译器的前端 Action，大家可以一个个用着玩。</p>
<ul>
<li>InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only</li>
<li>PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly</li>
<li>PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E</li>
<li>RewriteIncludesAction - 预处理</li>
<li>DumpTokensAction - 打印token，option 是 -dump-tokens</li>
<li>DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens</li>
<li>RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros</li>
<li>HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html</li>
<li>DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts</li>
<li>ASTDeclListAction - 打印 AST 节点，option 是 -ast-list</li>
<li>ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump</li>
<li>ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view</li>
<li>AnalysisAction - 运行静态分析引擎，option 是 -analyze</li>
<li>EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm</li>
<li>EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc</li>
<li>MigrateSourceAction - 代码迁移，option 是 -migrate</li>
</ul>
<h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>Bind 主要是与工具链 ToolChain 交互<br>根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。</p>
<p>通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</p>
<p>可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。</p>
<h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><p>Translate 就是把相关的参数对应到不同平台上不同的工具。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>从创建 Jobs 的方法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// BuildJobsForAction - Construct the jobs to perform for the action \p A and</span><br><span class="line">  /// return an InputInfo for the result of running \p A.  Will only construct</span><br><span class="line">  /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.</span><br><span class="line">  InputInfo</span><br><span class="line">  BuildJobsForAction(Compilation &amp;C, const Action *A, const ToolChain *TC,</span><br><span class="line">                     StringRef BoundArch, bool AtTopLevel, bool MultipleArchs,</span><br><span class="line">                     const char *LinkingOutput,</span><br><span class="line">                     std::map&lt;std::pair&lt;const Action *, std::string&gt;, InputInfo&gt;</span><br><span class="line">                         &amp;CachedResults,</span><br><span class="line">                     Action::OffloadKind TargetDeviceOffloadKind) const;</span><br></pre></td></tr></table></figure>

<p>可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。</p>
<h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Set up response file names for each command, if necessary</span><br><span class="line"> for (auto &amp;Job : C.getJobs())</span><br><span class="line">   setUpResponseFiles(C, Job);</span><br><span class="line"></span><br><span class="line"> C.ExecuteJobs(C.getJobs(), FailingCommands);</span><br></pre></td></tr></table></figure>

<p>能够看到 Jobs 准备好了后就要开始 Excute 他们。</p>
<p>Execute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm07.png?raw=true" alt></p>
<h1 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h1><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h2 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h2><p>可以查看 NSLog 的用法</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;</span><br><span class="line"></span><br><span class="line">// Marks APIs which format strings by taking a format string and optional varargs as arguments</span><br><span class="line">#if !defined(NS_FORMAT_FUNCTION)</span><br><span class="line">    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</span><br><span class="line">    #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span><br><span class="line">    #else</span><br><span class="line">    #define NS_FORMAT_FUNCTION(F,A)</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h2><p>在编译过程中能够提示开发者该方法或者属性已经被弃用</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));</span><br><span class="line">- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</span><br></pre></td></tr></table></figure>

<h2 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” <strong>VA_ARGS</strong>))) 指明使用版本范围</h2><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));</span><br></pre></td></tr></table></figure>

<h2 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h2><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h2 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h2><p>没有被使用也不报警告</p>
<h2 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h2><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h2 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h2><p>OC 的方法不能在 Swift 中使用。</p>
<h2 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h2><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define onExit \</span><br><span class="line">    rac_keywordify \</span><br><span class="line">    __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</span><br><span class="line"></span><br><span class="line">static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) &#123;</span><br><span class="line">    (*block)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (property != NULL) &#123;</span><br><span class="line">        rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</span><br><span class="line">        if (attributes != NULL) &#123;</span><br><span class="line">            @onExit &#123;</span><br><span class="line">                free(attributes);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type;</span><br><span class="line">            BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”);</span><br><span class="line">            BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0;</span><br><span class="line">            BOOL isWeak = attributes-&gt;weak;</span><br><span class="line"></span><br><span class="line">            shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h2 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h2><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((overloadable)) void printArgument(int number)&#123;</span><br><span class="line">    NSLog(@“Add Int %i”, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((overloadable)) void printArgument(NSString *number)&#123;</span><br><span class="line">    NSLog(@“Add NSString %@“, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((overloadable)) void printArgument(NSNumber *number)&#123;</span><br><span class="line">    NSLog(@“Add NSNumber %@“, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h2><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h2 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h2><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h2 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h2><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h2 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h2><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h2 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h2><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h1 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h1><p>先看看这个</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored “-Wdeprecated-declarations”</span><br><span class="line">        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>

<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h1 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h1><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="noopener">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang</p>
<figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pip install clang</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#!/usr/bin/python</span></span><br><span class="line"><span class="hljs-comment"># vim: set fileencoding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> clang.cindex</span><br><span class="line"><span class="hljs-keyword">import</span> asciitree</span><br><span class="line"><span class="hljs-keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">node_children</span><span class="hljs-params">(node)</span>:</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> node.get_children() <span class="hljs-keyword">if</span> c.location.file == sys.argv[<span class="hljs-number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_node</span><span class="hljs-params">(node)</span>:</span></span><br><span class="line">    text = node.spelling <span class="hljs-keyword">or</span> node.displayname</span><br><span class="line">    kind = str(node.kind)[str(node.kind).index(‘.’)+<span class="hljs-number">1</span>:]</span><br><span class="line">    <span class="hljs-keyword">return</span> ‘&#123;&#125; &#123;&#125;’.format(kind, text)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> len(sys.argv) != <span class="hljs-number">2</span>:</span><br><span class="line">    print(“Usage: dump_ast.py [header file name]”)</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)</span><br><span class="line">index = clang.cindex.Index.create()</span><br><span class="line">translation_unit = index.parse(sys.argv[<span class="hljs-number">1</span>], [‘-x’, ‘objective-c’])</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</span><br><span class="line">                          <span class="hljs-keyword">lambda</span> n: list(n.get_children()),</span><br><span class="line">                          <span class="hljs-keyword">lambda</span> n: “%s (%s)” % (n.spelling <span class="hljs-keyword">or</span> n.displayname, str(n.kind).split(“.”)[<span class="hljs-number">1</span>]))</span><br></pre></td></tr></table></figure>

<p>基于语法树的分析还可以针对字符串做加密。</p>
<h1 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h1><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="noopener">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Observer</span><br><span class="line">+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span><br><span class="line">virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) &#123;</span><br><span class="line">  if (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</span><br><span class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</span><br><span class="line">    Selector Sel = E-&gt;getSelector();</span><br><span class="line">    string TypeName = ReceiverType.getAsString();</span><br><span class="line">    string SelName = Sel.getAsString();</span><br><span class="line">    if (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) &#123;</span><br><span class="line">      Expr *Receiver = E-&gt;getArg(0)-&gt;IgnoreParenCasts();</span><br><span class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(1)-&gt;IgnoreParenCasts());</span><br><span class="line">      Selector Sel = SelExpr-&gt;getSelector();</span><br><span class="line">      if (const ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</span><br><span class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</span><br><span class="line">        if (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</span><br><span class="line">          errs() &lt;&lt; “Warning: class “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\n”;</span><br><span class="line">          SourceLocation Loc = E-&gt;getExprLoc();</span><br><span class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</span><br><span class="line">          errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\n”;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Clang-Plugin"><a href="#Clang-Plugin" class="headerlink" title="Clang Plugin"></a>Clang Plugin</h1><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="noopener">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="noopener">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="noopener">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="noopener">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="noopener">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="noopener">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=2651112856&idx=1&sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="noopener">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>官方 clang 的插件： <a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">External Clang Examples</a></li>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="noopener">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="noopener">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="noopener">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h1 id="LLVM-Backend"><a href="#LLVM-Backend" class="headerlink" title="LLVM Backend"></a>LLVM Backend</h1><p>首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置：</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm09.png?raw=true" alt></p>
<p>接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm10.png?raw=true" alt></p>
<h2 id="CodeGen-阶段"><a href="#CodeGen-阶段" class="headerlink" title="CodeGen 阶段"></a>CodeGen 阶段</h2><ul>
<li>Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph）</li>
<li>Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列</li>
<li>SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的</li>
<li>Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上<br>Prolog / Epilog 生成</li>
<li>确定所需堆栈大小：Machine Code </li>
<li>晚期优化：最后一次优化机会</li>
<li>Code Emission：输出代码，可以选择汇编或者二进制机器码。</li>
</ul>
<h2 id="SelectionDAG"><a href="#SelectionDAG" class="headerlink" title="SelectionDAG"></a>SelectionDAG</h2><ul>
<li>构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点</li>
<li>优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出</li>
<li>Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到</li>
<li>指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG</li>
<li>SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr）</li>
</ul>
<p>下图是 llc -view-isel-dags 状态下的 DAG 图：</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm11.png?raw=true" alt></p>
<p>查看 DAG 不同状态的说明如下：</p>
<ul>
<li>-view-dag-combine1-dags：可以显示没有被优化的 DAG</li>
<li>-view-legalize-dags：合法化之前的 DAG</li>
<li>-view-dag-cmobine2-dags：第二次优化前</li>
<li>-view-isel-dags：显示指令选择前的 DAG</li>
<li>-view-sched-dags：在 Scheduler 之前 ISel 之后</li>
<li>-view-sunit-dags：可以显示 Scheduler 的依赖图</li>
</ul>
<h2 id="Register-Allocation-寄存器分配"><a href="#Register-Allocation-寄存器分配" class="headerlink" title="Register Allocation 寄存器分配"></a>Register Allocation 寄存器分配</h2><h3 id="寄存器在-LLVM-中的表达"><a href="#寄存器在-LLVM-中的表达" class="headerlink" title="寄存器在 LLVM 中的表达"></a>寄存器在 LLVM 中的表达</h3><p>物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc</p>
<h3 id="虚拟寄存器到物理寄存器的映射"><a href="#虚拟寄存器到物理寄存器的映射" class="headerlink" title="虚拟寄存器到物理寄存器的映射"></a>虚拟寄存器到物理寄存器的映射</h3><p>直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度</p>
<h3 id="LLVM-自带的寄存器分配算法"><a href="#LLVM-自带的寄存器分配算法" class="headerlink" title="LLVM 自带的寄存器分配算法"></a>LLVM 自带的寄存器分配算法</h3><p>llc -regalloc=Greedy add.bc -o ln.s</p>
<ul>
<li>Fast - debug 默认，尽可能保存寄存器。</li>
<li>Basic - 增量分配</li>
<li>Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化</li>
<li>PBQP - 将寄存器分配描述成分区布尔二次规划</li>
</ul>
<h2 id="Code-Emission"><a href="#Code-Emission" class="headerlink" title="Code Emission"></a>Code Emission</h2><p>下图详细表达了整个 Code Emission 的过程<br><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm12.png?raw=true" alt></p>
<h1 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h1><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">print</span>(“hi!”)</span><br></pre></td></tr></table></figure>

<p>生成程序</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swiftc toy.swift</span><br><span class="line">./toy</span><br></pre></td></tr></table></figure>

<p>生成检查 AST</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -dump-ast toy.swift</span><br></pre></td></tr></table></figure>

<p>可以还原之前函数名</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</span><br></pre></td></tr></table></figure>

<p>llvm ir 和汇编的生成</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swiftc -emit-ir toy.swift</span><br><span class="line">swiftc -emit-assembly toy.swift</span><br></pre></td></tr></table></figure>

<p>生成可执行的脚本</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk macosx swiftc toy.swift -o toy</span><br></pre></td></tr></table></figure>

<h1 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h1><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h2 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h2><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 __TEXT 代码段和 __DATA 数据段两种。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h1 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h1><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</span><br><span class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</span><br></pre></td></tr></table></figure>

<h1 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h1><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h2 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h2><p>再通过一个例子来分析下：<br>这次用 xcrun 来</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -v</span><br></pre></td></tr></table></figure>

<p>先创建一个test.c的文件</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.c</span><br></pre></td></tr></table></figure>

<p>编辑里面的内容</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vi test.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hi there!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，没有起名默认为 a.out</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang test.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>

<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -S -o - test.c | open -f</span><br></pre></td></tr></table></figure>

<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.section    __TEXT,__text,regular,pure_instructions</span><br><span class="line">.macosx_version_min 10, 12</span><br><span class="line">.globl    _main</span><br><span class="line">.align    4, 0x90</span><br></pre></td></tr></table></figure>

<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_main:                                  ## @main</span><br><span class="line">    .cfi_startproc</span><br><span class="line">## BB#0:</span><br><span class="line">    pushq    %rbp</span><br><span class="line">Ltmp0:</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">Ltmp1:</span><br><span class="line">    .cfi_offset %rbp, -16</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">Ltmp2:</span><br><span class="line">    .cfi_def_cfa_register %rbp</span><br><span class="line">    subq    $32, %rsp</span><br></pre></td></tr></table></figure>

<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leaq    L_.str(%rip), %rax</span><br><span class="line">movl    $0, -4(%rbp)</span><br><span class="line">movl    %edi, -8(%rbp)</span><br><span class="line">movq    %rsi, -16(%rbp)</span><br><span class="line">movq    %rax, %rdi</span><br><span class="line">movb    $0, %al</span><br><span class="line">callq    _printf</span><br></pre></td></tr></table></figure>

<p>leap 会将 L_.str 这个指针加载到 rax 寄存器里。可以看看 L_.str 的定义</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L_.str:                                 ## @.str</span><br><span class="line">    .asciz    &quot;hi there\n&quot;</span><br></pre></td></tr></table></figure>

<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xorl    %ecx, %ecx</span><br><span class="line">movl    %eax, -20(%rbp)         ## 4-byte Spill</span><br><span class="line">movl    %ecx, %eax</span><br><span class="line">addq    $32, %rsp</span><br><span class="line">popq    %rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br></pre></td></tr></table></figure>

<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    .section    __TEXT,__cstring,cstring_literals</span><br><span class="line">L_.str:                                 ## @.str</span><br><span class="line">    .asciz    &quot;hi there\n&quot;</span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>

<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun size -x -l -m a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</span><br><span class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</span><br><span class="line">    Section __text: 0x34 (addr 0x100000f50 offset 3920)</span><br><span class="line">    Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</span><br><span class="line">    Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</span><br><span class="line">    Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</span><br><span class="line">    Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</span><br><span class="line">    total 0xa6</span><br><span class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</span><br><span class="line">    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</span><br><span class="line">    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</span><br><span class="line">    total 0x18</span><br><span class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</span><br><span class="line">total 0x100003000</span><br></pre></td></tr></table></figure>

<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li>__stubs 和 __stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="noopener">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun otool -s __TEXT __text a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.out:</span><br><span class="line">Contents of (__TEXT,__text) section</span><br><span class="line">0000000100000f50    55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </span><br><span class="line">0000000100000f60    45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </span><br><span class="line">0000000100000f70    b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </span><br><span class="line">0000000100000f80    c4 20 5d c3</span><br></pre></td></tr></table></figure>

<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s __TEXT __text 有个缩写 -t</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun otool -v -t a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a.out:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_main:</span><br><span class="line">0000000100000f50    pushq    %rbp</span><br><span class="line">0000000100000f51    movq    %rsp, %rbp</span><br><span class="line">0000000100000f54    subq    $0x20, %rsp</span><br><span class="line">0000000100000f58    leaq    0x47(%rip), %rax</span><br><span class="line">0000000100000f5f    movl    $0x0, -0x4(%rbp)</span><br><span class="line">0000000100000f66    movl    %edi, -0x8(%rbp)</span><br><span class="line">0000000100000f69    movq    %rsi, -0x10(%rbp)</span><br><span class="line">0000000100000f6d    movq    %rax, %rdi</span><br><span class="line">0000000100000f70    movb    $0x0, %al</span><br><span class="line">0000000100000f72    callq    0x100000f84</span><br><span class="line">0000000100000f77    xorl    %ecx, %ecx</span><br><span class="line">0000000100000f79    movl    %eax, -0x14(%rbp)</span><br><span class="line">0000000100000f7c    movl    %ecx, %eax</span><br><span class="line">0000000100000f7e    addq    $0x20, %rsp</span><br><span class="line">0000000100000f82    popq    %rbp</span><br><span class="line">0000000100000f83    retq</span><br></pre></td></tr></table></figure>

<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -v -h a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</span><br></pre></td></tr></table></figure>

<p>mach_header 结构体</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">  uint32_t      magic;</span><br><span class="line">  cpu_type_t    cputype;</span><br><span class="line">  cpu_subtype_t cpusubtype;</span><br><span class="line">  uint32_t      filetype;</span><br><span class="line">  uint32_t      ncmds;</span><br><span class="line">  uint32_t      sizeofcmds;</span><br><span class="line">  uint32_t      flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -v -l a.out | open -f</span><br></pre></td></tr></table></figure>

<p>加载命令结构体</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123;</span><br><span class="line">  uint32_t  cmd;</span><br><span class="line">  uint32_t  cmdsize;</span><br><span class="line">  char      segname[16];</span><br><span class="line">  uint32_t  vmaddr;</span><br><span class="line">  uint32_t  vmsize;</span><br><span class="line">  uint32_t  fileoff;</span><br><span class="line">  uint32_t  filesize;</span><br><span class="line">  vm_prot_t maxprot;</span><br><span class="line">  vm_prot_t initprot;</span><br><span class="line">  uint32_t  nsects;</span><br><span class="line">  uint32_t  flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 __TEXT __text 的section的内容</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Section</span><br><span class="line">  sectname __text</span><br><span class="line">   segname __TEXT</span><br><span class="line">      addr 0x0000000100000f50</span><br><span class="line">      size 0x0000000000000034</span><br><span class="line">    offset 3920</span><br><span class="line">     align 2^4 (16)</span><br><span class="line">    reloff 0</span><br><span class="line">    nreloc 0</span><br><span class="line">      type S_REGULAR</span><br><span class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</span><br><span class="line"> reserved1 0</span><br><span class="line"> reserved2 0</span><br></pre></td></tr></table></figure>

<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Foo : NSObject</span><br><span class="line"></span><br><span class="line">- (void)say;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>Foo.m</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import “Foo.h”</span><br><span class="line"></span><br><span class="line">@implementation Foo</span><br><span class="line"></span><br><span class="line">- (void)say</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@“hi there again!\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>SayHi.m</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import “Foo.h”</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Foo *foo = [[Foo alloc] init];</span><br><span class="line">        [foo say];</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先编译多个文件</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -c Foo.m</span><br><span class="line">xcrun clang -c SayHi.m</span><br></pre></td></tr></table></figure>

<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</span><br></pre></td></tr></table></figure>

<h2 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h2><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="noopener">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="noopener">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="noopener">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="noopener">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h1 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h1><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm -nm SayHi.o</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                 (undefined) external _OBJC_CLASS_$_Foo</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush</span><br><span class="line">                 (undefined) external _objc_msgSend</span><br><span class="line">0000000000000000 (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure>

<ul>
<li><em>OBJC_CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm -nm Foo.o</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</span><br><span class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line">                 (undefined) external __objc_empty_cache</span><br><span class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</span><br><span class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</span><br><span class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</span><br><span class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</span><br><span class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</span><br><span class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</span><br></pre></td></tr></table></figure>

<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm -nm a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                 (undefined) external _NSLog (from Foundation)</span><br><span class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</span><br><span class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</span><br><span class="line">                 (undefined) external __objc_empty_cache (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</span><br><span class="line">                 (undefined) external _objc_msgSend (from libobjc)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000e90 (__TEXT,__text) external _main</span><br><span class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</span><br><span class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</span><br><span class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</span><br></pre></td></tr></table></figure>

<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun otool -L a.out</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.out:</span><br><span class="line">    /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</span><br><span class="line">    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</span><br><span class="line">    /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</span><br><span class="line">    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure>

<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</span><br></pre></td></tr></table></figure>

<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dyld: loaded: /Users/didi/Downloads/./a.out</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</span><br><span class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0  +[someclass load]</span><br><span class="line">1  call_class_loads()</span><br><span class="line">2  ::call_load_methods</span><br><span class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</span><br><span class="line">11 _dyld_start</span><br></pre></td></tr></table></figure>

<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="noopener">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="noopener">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="noopener">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h1 id="LLVM-工具链"><a href="#LLVM-工具链" class="headerlink" title="LLVM 工具链"></a>LLVM 工具链</h1><h2 id="获取-LLVM"><a href="#获取-LLVM" class="headerlink" title="获取 LLVM"></a>获取 LLVM</h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#先下载 LLVM</span></span><br><span class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在 LLVM 的 tools 目录下下载 Clang</span></span><br><span class="line"><span class="hljs-built_in">cd</span> llvm/tools</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ../projects</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#在 Clang 的 tools 下安装 extra 工具</span></span><br><span class="line"><span class="hljs-built_in">cd</span> ../tools/clang/tools</span><br><span class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</span><br></pre></td></tr></table></figure>

<h2 id="编译-LLVM"><a href="#编译-LLVM" class="headerlink" title="编译 LLVM"></a>编译 LLVM</h2><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line">brew install cmake</span><br><span class="line">mkdir build</span><br><span class="line"><span class="hljs-built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=<span class="hljs-string">"AArch64;X86"</span> -G <span class="hljs-string">"Unix Makefiles"</span> ..</span><br><span class="line">make j8</span><br><span class="line"><span class="hljs-comment">#安装</span></span><br><span class="line">make install</span><br><span class="line"><span class="hljs-comment">#如果找不到标准库，Xcode 需要安装 xcode-select --install</span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm01.png?raw=true" alt></p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</span></span><br><span class="line">mkdir xcodeBuild</span><br><span class="line"><span class="hljs-built_in">cd</span> xcodeBuild</span><br><span class="line">cmake -GXcode /path/to/llvm/<span class="hljs-built_in">source</span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm02.png?raw=true" alt></p>
<p>在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。</p>
<p><img src="https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm03.png?raw=true" alt></p>
<h2 id="LLVM-源码工程目录介绍"><a href="#LLVM-源码工程目录介绍" class="headerlink" title="LLVM 源码工程目录介绍"></a>LLVM 源码工程目录介绍</h2><ul>
<li>llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。</li>
<li>llvm/include/ - 导出的头文件。</li>
<li>llvm/lib/ - 主要源文件都在这里。</li>
<li>llvm/project/ - 创建自己基于 LLVM 的项目的目录。</li>
<li>llvm/test/ - 基于 LLVM 的回归测试，健全检察。</li>
<li>llvm/suite/ - 正确性，性能和基准测试套件。</li>
<li>llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。</li>
<li>llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。</li>
</ul>
<h2 id="lib-目录介绍"><a href="#lib-目录介绍" class="headerlink" title="lib 目录介绍"></a>lib 目录介绍</h2><ul>
<li>llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。</li>
<li>llvm/lib/AsmParser/ - 汇编语言解析器。</li>
<li>llvm/lib/Bitcode/ - 读取和写入字节码</li>
<li>llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。</li>
<li>llvm/lib/Transforms/ - IR-to-IR 程序的变换。</li>
<li>llvm/lib/Target/ - 对像 X86 这样机器的描述。</li>
<li>llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。</li>
<li>llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。</li>
</ul>
<h2 id="工具链命令介绍"><a href="#工具链命令介绍" class="headerlink" title="工具链命令介绍"></a>工具链命令介绍</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>llvm-as - 汇编器，将 .ll 汇编成字节码。</li>
<li>llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。</li>
<li>opt - 字节码优化器。</li>
<li>llc - 静态编译器，将字节码编译成汇编代码。</li>
<li>lli - 直接执行 LLVM 字节码。</li>
<li>llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。</li>
<li>llvm-ar - 字节码文件打包器。</li>
<li>llvm-lib - LLVM lib.exe 兼容库工具。</li>
<li>llvm-nm - 列出字节码和符号表。</li>
<li>llvm-config - 打印 LLVM 编译选项。</li>
<li>llvm-diff - 对两个进行比较。</li>
<li>llvm-cov - 输出 coverage infomation。</li>
<li>llvm-profdata - Profile 数据工具。</li>
<li>llvm-stress - 生成随机 .ll 文件。</li>
<li>llvm-symbolizer - 地址对应源码位置，定位错误。</li>
<li>llvm-dwarfdump - 打印 DWARF。</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li>bugpoint - 自动测试案例工具</li>
<li>llvm-extract - 从一个 LLVM 的模块里提取一个函数。</li>
<li>llvm-bcanalyzer - LLVM 字节码分析器。</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li>FileCheck - 灵活的模式匹配文件验证器。</li>
<li>tblgen - C++ 代码生成器。</li>
<li>lit - LLVM 集成测试器。</li>
<li>llvm-build - LLVM 构建工程时需要的工具。</li>
<li>llvm-readobj - LLVM Object 结构查看器。</li>
</ul>
<h1 id="Swift-编译"><a href="#Swift-编译" class="headerlink" title="Swift 编译"></a>Swift 编译</h1><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="noopener">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="noopener">Swift.org - Contributing</a></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</span><br><span class="line">brew install cmake ninja</span><br><span class="line">mkdir swiftsource</span><br><span class="line">cd swiftsource</span><br><span class="line"></span><br><span class="line">#clone 下 swift 源码</span><br><span class="line">git clone https://github.com/apple/swift.git</span><br><span class="line"></span><br><span class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</span><br><span class="line">./swift/utils/update-checkout —clone</span><br><span class="line"></span><br><span class="line">#查看文件夹</span><br><span class="line">du -h -d 1</span><br><span class="line"></span><br><span class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</span><br><span class="line">./swift/utils/build-script -x -R</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">./swift/utils/update-checkout</span><br><span class="line">./swift/utils/build-script -x -R</span><br><span class="line"></span><br><span class="line">#切到指定tag和分支</span><br><span class="line">#tag</span><br><span class="line">./swift/utils/update-checkout —tag swift-3.0-RELEASE</span><br><span class="line">#特定分支</span><br><span class="line">./swift/utils/update-checkout —scheme swift-3.0-branch</span><br></pre></td></tr></table></figure>

<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="noopener">Swift.org - Source Code</a></p>
<h1 id="其它编译工具"><a href="#其它编译工具" class="headerlink" title="其它编译工具"></a>其它编译工具</h1><h2 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h2><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="noopener">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><a href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language" class="headerlink" title="C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language"></a>C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</h2><p>在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：<a href="http://c-smile.sourceforge.net/" target="_blank" rel="noopener">http://c-smile.sourceforge.net/</a></p>
<h1 id="资料网址"><a href="#资料网址" class="headerlink" title="资料网址"></a>资料网址</h1><ul>
<li><a href="http://llvm.org" target="_blank" rel="noopener">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="noopener">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="noopener">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="noopener">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="noopener">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
<li><a href="http://llvm.org/devmtg/" target="_blank" rel="noopener">LLVM Developers’ Metting</a></li>
<li><a href="https://github.com/ming1016/study/wiki" target="_blank" rel="noopener">ming1016</a></li>
</ul>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-image">
        <a href="/2016/06/18/ios-han/" class="image is-7by1">
            <img class="thumbnail" src="https://www.policx.com/talk/images/banner.jpg" alt="iOS函数响应式编程以及ReactiveCocoa的使用">
        </a>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2016-06-18T01:55:45.000Z">2016-06-18</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    32 分钟 读完 (大约 4739 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2016/06/18/ios-han/">iOS函数响应式编程以及ReactiveCocoa的使用</a>
            
        </h1>
        <div class="content">
            <p>打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅</p>
<h1 id="声明式编程泛型Declarative-programming"><a href="#声明式编程泛型Declarative-programming" class="headerlink" title="声明式编程泛型Declarative programming"></a>声明式编程泛型Declarative programming</h1><p>函数反应式编程是声明式编程的子编程范式之一</p>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>需要满足两个条件</p>
<ul>
<li>一个或者多个函数作为输入。</li>
<li>有且仅有一个函数输出。</li>
</ul>
<p>Objective-c里使用block作为函数</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,number);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray * mappedArray = [array rx_mapWithBlock:^id(id each)&#123;</span><br><span class="line">    return @(pow([each integerValue],2));</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="过滤filter"><a href="#过滤filter" class="headerlink" title="过滤filter"></a>过滤filter</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *filteredArray = [array rx_filterWithBlock:^BOOL(id each)&#123;</span><br><span class="line">    return ([each integerValue] % 2 == 0);</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="折叠fold"><a href="#折叠fold" class="headerlink" title="折叠fold"></a>折叠fold</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[array rx_mapWithBlock:^id (id each)&#123;</span><br><span class="line">        return [each stringValue];</span><br><span class="line">    &#125;] rx_foldInitialValue:@&quot;&quot; block:^id (id memo , id each)&#123;</span><br><span class="line">        return [memo stringByAppendingString:each];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>用函数生成另一个函数</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func filterGenerator(lastnameCondition: String) -&gt; (Staff) -&gt; (Bool) &#123; </span><br><span class="line">    return &#123;staff in </span><br><span class="line">        return staff.lastname == lastnameCondition</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let filterWang = filterGenerator(&quot;Wang&quot;) </span><br><span class="line">let filterHu = filterGenerator(&quot;Hu&quot;)</span><br><span class="line"></span><br><span class="line">staffs.filter(filterHu)</span><br></pre></td></tr></table></figure>

<h1 id="RAC中使用高阶函数"><a href="#RAC中使用高阶函数" class="headerlink" title="RAC中使用高阶函数"></a>RAC中使用高阶函数</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[ @1, @2, @3 ];</span><br><span class="line">RACSequence * stream = [array rac_sequence];</span><br><span class="line">//RACSequence是一个RACStream的子类。</span><br><span class="line">[stream map:^id (id value)&#123;</span><br><span class="line">    return @(pow([value integerValue], 2));</span><br><span class="line">&#125;];</span><br><span class="line">//RACSequence有一个方法返回数组:array</span><br><span class="line">NSLog(@&quot;%@&quot;,[stream array]);</span><br><span class="line"></span><br><span class="line">//避免污染变量的作用域</span><br><span class="line">NSLog(@&quot;%@&quot;,[[[array rac_sequence] map:^id (id value)&#123;</span><br><span class="line">                    return @(pow([value integerValue], 2));</span><br><span class="line">                &#125;] array]);</span><br></pre></td></tr></table></figure>

<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;, [[[array rac_sequence] filter:^BOOL (id value)&#123;</span><br><span class="line">                        return [value integerValue] % 2 == 0;</span><br><span class="line">                    &#125;] array]);</span><br></pre></td></tr></table></figure>

<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,[[[array rac_sequence] map:^id (id value)&#123;</span><br><span class="line">                    return [value stringValue];</span><br><span class="line">                &#125;] foldLeftWithStart:@&quot;&quot; reduce:^id (id accumulator, id value)&#123;</span><br><span class="line">                    return [accumulator stringByAppendingString:value];</span><br><span class="line">            &#125;]);</span><br></pre></td></tr></table></figure>

<h2 id="绑定键值"><a href="#绑定键值" class="headerlink" title="绑定键值"></a>绑定键值</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * validEmailSignal = [self.textField.rac_textSignal map:^id (NSString *value)&#123;</span><br><span class="line">    return @([value rangeOfString:@&quot;@&quot;].location != NSNotFound);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RAC(self.button, enabled) = validEmailSignal;</span><br><span class="line"></span><br><span class="line">RAC(self.textField, textColor) = [validEmailSignal map: ^id (id value)&#123;</span><br><span class="line">    if([value boolValue])&#123;</span><br><span class="line">        return [UIColor greenColor];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/ming1016/study/blob/master/pic/CombinePipeline.png?raw=true" alt="绑定键值图示"></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>比较好的一个完整的RAC实践的例子：<a href="https://github.com/ashfurrow/FunctionalReactivePixels" target="_blank" rel="noopener">https://github.com/ashfurrow/FunctionalReactivePixels</a></p>
<h3 id="网络请求生成对应model"><a href="#网络请求生成对应model" class="headerlink" title="网络请求生成对应model"></a>网络请求生成对应model</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)importPhotos&#123;</span><br><span class="line">    RACReplaySubject * subject = [RACReplaySubject subject];</span><br><span class="line">    NSURLRequest * request = [self popularURLRequest];</span><br><span class="line">    [NSURLConnection sendAsynchronousRequest:request</span><br><span class="line">                                    queue:[NSOperationQueue mainQueue]</span><br><span class="line">                        completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError)&#123;</span><br><span class="line">                            if (data) &#123;</span><br><span class="line">                                id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line"></span><br><span class="line">                                [subject sendNext:[[[results[@&quot;photos&quot;] rac_sequence] map:^id(NSDictionary *photoDictionary)&#123;</span><br><span class="line">                                    FRPPhotoModel * model = [FRPPhotoModel new];</span><br><span class="line"></span><br><span class="line">                                    [self configurePhotoModel:model withDictionary:photoDictionary];</span><br><span class="line">                                    [self downloadThumbnailForPhotoModel:model];</span><br><span class="line"></span><br><span class="line">                                    return model;</span><br><span class="line">                                &#125;] array]];</span><br><span class="line"></span><br><span class="line">                                [subject sendCompleted];</span><br><span class="line">                            &#125;</span><br><span class="line">                            else&#123;</span><br><span class="line">                                [subject sendError:connectionError];</span><br><span class="line">                            &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return subject;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤相同大小的图片，取出他们的url，返回第一个"><a href="#过滤相同大小的图片，取出他们的url，返回第一个" class="headerlink" title="过滤相同大小的图片，取出他们的url，返回第一个"></a>过滤相同大小的图片，取出他们的url，返回第一个</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)urlForImageSize:(NSInteger)size inDictionary:(NSArray *)array&#123;</span><br><span class="line">    return [[[[[array rac_sequence] filter:^ BOOL (NSDictionary * value)&#123;</span><br><span class="line">        return [value[@&quot;size&quot;] integerValue] == size;</span><br><span class="line">    &#125;] map:^id (id value)&#123;</span><br><span class="line">        return value[@&quot;url&quot;];</span><br><span class="line">    &#125;] array] firstObject];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"><a href="#观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径" class="headerlink" title="观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径"></a>观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPhotoModel:(FRPPhotoModel *)photoModel&#123;</span><br><span class="line">    self.subscription = [[[RACObserver(photoModel, thumbnailData)</span><br><span class="line">        filter:^ BOOL (id value)&#123;</span><br><span class="line">            return value != nil;</span><br><span class="line">        &#125;] map:^id (id value)&#123;</span><br><span class="line">            return [UIImage imageWithData:value];</span><br><span class="line">        &#125;] setKeyPath:@keypath(self.imageView, image) onObject:self.imageView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UITableViewCell复用时需要取消cell上各个组件的订阅"><a href="#UITableViewCell复用时需要取消cell上各个组件的订阅" class="headerlink" title="UITableViewCell复用时需要取消cell上各个组件的订阅"></a>UITableViewCell复用时需要取消cell上各个组件的订阅</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)perpareForReuse &#123;</span><br><span class="line">    [super prepareForReuse];</span><br><span class="line">    [self.subscription dispose], self.subscription = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delegate的使用"><a href="#Delegate的使用" class="headerlink" title="Delegate的使用"></a>Delegate的使用</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器：</span><br><span class="line">@property (nonatomic, strong) id collectionViewDelegate;</span><br><span class="line"></span><br><span class="line">//同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。</span><br><span class="line">RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc]</span><br><span class="line">                                    initWithProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)];</span><br><span class="line"></span><br><span class="line">[[viewControllerDelegate rac_signalForSelector:@selector(userDidScroll:toPhotoAtIndex:)     fromProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)]</span><br><span class="line">        subscribeNext:^(RACTuple *value)&#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.collectionView</span><br><span class="line">                scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:[value.second integerValue] inSection:0]</span><br><span class="line">                atScrollPosition:UICollectionViewScrollPositionCenteredVertically</span><br><span class="line">                animated:NO];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">self.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UICollectionViewDelegate)];</span><br><span class="line"></span><br><span class="line">[[self.collectionViewDelegate rac_signalForSelector:@selector(collectionView:didSelectItemAtIndexPath:)]</span><br><span class="line">        subscribeNext:^(RACTuple *arguments) &#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:self.photosArray currentPhotoIndex:[(NSIndexPath *)arguments.second item]];</span><br><span class="line">            viewController.delegate = (id&lt;FRPFullSizePhotoViewControllerDelegate&gt;)viewControllerDelegate;</span><br><span class="line"></span><br><span class="line">            [self.navigationController pushViewController:viewController animated:YES];</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"><a href="#处理异常，完成执行刷新操作，异常打印日志，执行对应方法" class="headerlink" title="处理异常，完成执行刷新操作，异常打印日志，执行对应方法"></a>处理异常，完成执行刷新操作，异常打印日志，执行对应方法</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RAC(self, photosArray) = [[[[FRPPhotoImporter importPhotos]</span><br><span class="line">        doCompleted:^&#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            [self.collectionView reloadData];</span><br><span class="line">        &#125;] logError] catchTo:[RACSignal empty]];</span><br></pre></td></tr></table></figure>

<h3 id="网络请求处理数据，获取数据返回主线程"><a href="#网络请求处理数据，获取数据返回主线程" class="headerlink" title="网络请求处理数据，获取数据返回主线程"></a>网络请求处理数据，获取数据返回主线程</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)importPhotos &#123;</span><br><span class="line">    NSURLRequest *request = [self popularURLRequest];</span><br><span class="line"></span><br><span class="line">    return [[[[[[NSURLConnection rac_sendAsynchronousRequest:request]</span><br><span class="line">                reduceEach:^id(NSURLResponse *response , NSData *data)&#123;</span><br><span class="line">                    //注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。</span><br><span class="line">                    return data;</span><br><span class="line">                &#125;]</span><br><span class="line">                deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">                map:^id (NSData *data) &#123;</span><br><span class="line">                    id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line">                    return [[[results[@&quot;photo&quot;] rac_sequence]</span><br><span class="line">                        map:^id (NSDictionary *photoDictionary) &#123;</span><br><span class="line">                            FRPPhotoModel *model = [FRPPhotoModel new];</span><br><span class="line">                            [self configurePhotoModel:model withDictionary:photoDictionary];</span><br><span class="line">                            [self downloadThumbnailForPhotoModel:model];</span><br><span class="line">                            return model;</span><br><span class="line">                        &#125;] array];</span><br><span class="line">                &#125;] publish] autoconnect];</span><br><span class="line">    //信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"><a href="#信号的信号Signal-of-signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext-块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。" class="headerlink" title="信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。"></a>信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) &#123;</span><br><span class="line">    return [self signInSignal];</span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">    //x</span><br><span class="line">    NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"><a href="#不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）" class="headerlink" title="不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）"></a>不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)requestAccessToTwitterSignal</span><br><span class="line">&#123;</span><br><span class="line">    // 定义一个错误，如果用户拒绝访问则发送</span><br><span class="line">    NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil];</span><br><span class="line"></span><br><span class="line">    // 创建并返回信号</span><br><span class="line">    @weakify(self)</span><br><span class="line">    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">        // 请求访问twitter</span><br><span class="line">        @strongify(self)</span><br><span class="line">        [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType</span><br><span class="line">                                                   options:nil</span><br><span class="line">                                                completion:^(BOOL granted, NSError *error) &#123;</span><br><span class="line">                                                    // 处理响应</span><br><span class="line">                                                    if (!granted)</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        [subscriber sendError:accessError];</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    else</span><br><span class="line">                                                    &#123;</span><br><span class="line">                                                        [subscriber sendNext:nil];</span><br><span class="line">                                                        [subscriber sendCompleted];</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。</span><br><span class="line">[[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">      then:^RACSignal *&#123;</span><br><span class="line">          @strongify(self)</span><br><span class="line">          return self.searchText.rac_textSignal;</span><br><span class="line">      &#125;]</span><br><span class="line">     filter:^BOOL(NSString *text) &#123;</span><br><span class="line">         @strongify(self)</span><br><span class="line">         return [self isValidSearchText:text];</span><br><span class="line">     &#125;]</span><br><span class="line">    throttle:0.5]</span><br><span class="line">   flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">       @strongify(self)</span><br><span class="line">       //flattenMap来将每个next事件映射到一个新的被订阅的信号</span><br><span class="line">       return [self signalForSearchWithText:text];</span><br><span class="line">   &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line"> subscribeNext:^(NSDictionary *jsonSearchResult) &#123;</span><br><span class="line">     NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;];</span><br><span class="line">     NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;</span><br><span class="line">         return [RWTweet tweetWithStatus:tweet];</span><br><span class="line">     &#125;];</span><br><span class="line">     [self.resultsViewController displayTweets:tweets];</span><br><span class="line"> &#125; error:^(NSError *error) &#123;</span><br><span class="line">     NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line"> &#125;];</span><br><span class="line"> - (RACSignal *)signalForSearchWithText:(NSString *)text &#123; </span><br><span class="line">    // 1 - define the errors </span><br><span class="line">    NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain </span><br><span class="line">                                                   code:RWTwitterInstantErrorNoTwitterAccounts </span><br><span class="line">                                               userInfo:nil]; </span><br><span class="line">    NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain </span><br><span class="line">                                                        code:RWTwitterInstantErrorInvalidResponse </span><br><span class="line">                                                        userInfo:nil]; </span><br><span class="line">    @weakify(self) </span><br><span class="line">    return [RACSignal createSignal:^RACDisposable *(id subscriber) &#123; </span><br><span class="line">        @strongify(self); </span><br><span class="line">        SLRequest *request = [self requestforTwitterSearchWithText:text]; </span><br><span class="line">        NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType];         if (twitterAccounts.count == 0) &#123; </span><br><span class="line">            [subscriber sendError:noAccountsError]; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            [request setAccount:[twitterAccounts lastObject]]; </span><br><span class="line">        [request performRequestWithHandler: ^(NSData *responseData, </span><br><span class="line">                NSHTTPURLResponse *urlResponse, NSError *error) &#123; </span><br><span class="line">            if (urlResponse.statusCode == 200) &#123; </span><br><span class="line">                NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData </span><br><span class="line">                                                options:NSJSONReadingAllowFragments </span><br><span class="line">                                                  error:nil]; </span><br><span class="line">                [subscriber sendNext:timelineData]; </span><br><span class="line">                [subscriber sendCompleted]; </span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                [subscriber sendError:invalidResponseError]; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;]; </span><br><span class="line">    &#125; </span><br><span class="line">    return nil; </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/ming1016/study/blob/master/pic/CompletePipeline.png?raw=true" alt="不同信号顺序链接"></p>
<h3 id="异步加载图片"><a href="#异步加载图片" class="headerlink" title="异步加载图片"></a>异步加载图片</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl &#123;</span><br><span class="line"></span><br><span class="line">    RACScheduler *scheduler = [RACScheduler</span><br><span class="line">                               schedulerWithPriority:RACSchedulerPriorityBackground];</span><br><span class="line"></span><br><span class="line">    return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];</span><br><span class="line">        UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">        [subscriber sendNext:image];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] subscribeOn:scheduler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cell.twitterAvatarView.image = nil;</span><br><span class="line">[[[self signalForLoadingImage:tweet.profileImageUrl]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(UIImage *image) &#123;</span><br><span class="line">   cell.twitterAvatarView.image = image;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"><a href="#观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用" class="headerlink" title="观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用"></a>观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[[RACSignal merge: @[RACObserve(self.viewModel,  tweets), </span><br><span class="line">                     RACObserve(self.viewModel,  allTweetsLoaded)]]</span><br><span class="line">    bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]]</span><br><span class="line">    subscribeNext: ^(id value) &#123;</span><br><span class="line">        @strongify(self);</span><br><span class="line">        [self.tableView reloadData];</span><br><span class="line">    &#125;];</span><br><span class="line">//bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData</span><br></pre></td></tr></table></figure>

<h3 id="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"><a href="#封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。" class="headerlink" title="封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。"></a>封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[tableView rac_signalForSelector:@selector(layoutSubviews)]subscribeNext:^(id x) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    [self doSomethingBeforeTableViewLayoutSubviews];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"><a href="#使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等" class="headerlink" title="使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等"></a>使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等</h3><p>Demo的github地址：<a href="https://github.com/olegam/RACCommandExample" target="_blank" rel="noopener">https://github.com/olegam/RACCommandExample</a></p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (void)bindWithViewModel &#123;     </span><br><span class="line">  RAC(self.viewModel, email) =self.emailTextField.rac_textSignal;   </span><br><span class="line">  self.subscribeButton.rac_command = self.viewModel.subscribeCommand;     </span><br><span class="line">  RAC(self.statusLabel, text) =RACObserve(self.viewModel, statusMessage);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface SubscribeViewModel :NSObject    </span><br><span class="line">  @property(nonatomic, strong)RACCommand *subscribeCommand;  // writeto this property  </span><br><span class="line">  @property(nonatomic, strong) NSString *email;  // read from this property  </span><br><span class="line">  @property(nonatomic, strong) NSString *statusMessage;    </span><br><span class="line">@end  </span><br><span class="line"></span><br><span class="line">#import &quot;SubscribeViewModel.h&quot;  </span><br><span class="line">#import &quot;AFHTTPRequestOperationManager+RACSupport.h&quot;  </span><br><span class="line">#import&quot;NSString+EmailAdditions.h&quot;  </span><br><span class="line"></span><br><span class="line">static NSString *const kSubscribeURL =@&quot;http://reactivetest.apiary.io/subscribers&quot;;  </span><br><span class="line"></span><br><span class="line">@interface SubscribeViewModel ()  </span><br><span class="line">@property(nonatomic, strong) RACSignal*emailValidSignal;  </span><br><span class="line">@end  </span><br><span class="line"></span><br><span class="line">@implementation SubscribeViewModel  </span><br><span class="line"></span><br><span class="line">- (id)init &#123;  </span><br><span class="line">       self= [super init];  </span><br><span class="line">       if(self) &#123;  </span><br><span class="line">            [self mapSubscribeCommandStateToStatusMessage];  </span><br><span class="line">       &#125;  </span><br><span class="line">       returnself;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">-(void)mapSubscribeCommandStateToStatusMessage &#123;  </span><br><span class="line">       RACSignal *startedMessageSource = [self.subscribeCommand.executionSignals map:^id(RACSignal *subscribeSignal) &#123;  </span><br><span class="line">              return NSLocalizedString(@&quot;Sending request...&quot;, nil);  </span><br><span class="line">       &#125;];  </span><br><span class="line"></span><br><span class="line">       RACSignal *completedMessageSource = [self.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) &#123;  </span><br><span class="line">              return[[[subscribeSignal materialize] filter:^BOOL(RACEvent *event) &#123;  </span><br><span class="line">                     return event.eventType == RACEventTypeCompleted;  </span><br><span class="line">              &#125;] map:^id(id value) &#123;  </span><br><span class="line">                     return NSLocalizedString(@&quot;Thanks&quot;, nil);  </span><br><span class="line">              &#125;];  </span><br><span class="line">       &#125;];  </span><br><span class="line"></span><br><span class="line">       RACSignal*failedMessageSource = [[self.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^id(NSError *error) &#123;  </span><br><span class="line">              return NSLocalizedString(@&quot;Error :(&quot;, nil);  </span><br><span class="line">       &#125;];  </span><br><span class="line"></span><br><span class="line">       RAC(self,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (RACCommand *)subscribeCommand &#123;  </span><br><span class="line">       if(!_subscribeCommand) &#123;  </span><br><span class="line">              @weakify(self);  </span><br><span class="line">              _subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal signalBlock:^RACSignal *(id input) &#123;  </span><br><span class="line">                     @strongify(self);  </span><br><span class="line">                     return [SubscribeViewModel postEmail:self.email];  </span><br><span class="line">              &#125;];  </span><br><span class="line">       &#125;  </span><br><span class="line">       return _subscribeCommand;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">+ (RACSignal *)postEmail:(NSString *)email&#123;  </span><br><span class="line">       AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager];  </span><br><span class="line">       manager.requestSerializer= [AFJSONRequestSerializer new];  </span><br><span class="line">       NSDictionary*body = @&#123;@&quot;email&quot;: email ?: @&quot;&quot;&#125;;  </span><br><span class="line">       return [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (RACSignal *)emailValidSignal &#123;  </span><br><span class="line">       if(!_emailValidSignal) &#123;  </span><br><span class="line">              _emailValidSignal= [RACObserve(self, email) map:^id(NSString *email) &#123;  </span><br><span class="line">                     return@([email isValidEmail]);  </span><br><span class="line">              &#125;];  </span><br><span class="line">       &#125;  </span><br><span class="line">       return _emailValidSignal;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="替换Delegate，直接使用RACSubject"><a href="#替换Delegate，直接使用RACSubject" class="headerlink" title="替换Delegate，直接使用RACSubject"></a>替换Delegate，直接使用RACSubject</h3><h1 id="RAC内存管理"><a href="#RAC内存管理" class="headerlink" title="RAC内存管理"></a>RAC内存管理</h1><p>RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。</p>
<h1 id="RAC需要注意的内存问题"><a href="#RAC需要注意的内存问题" class="headerlink" title="RAC需要注意的内存问题"></a>RAC需要注意的内存问题</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //1</span><br><span class="line">        MTModel *model = [[MTModel alloc] init]; // MTModel有一个名为的title的属性</span><br><span class="line">        [subscriber sendNext:model];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    self.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) &#123; //2</span><br><span class="line">        return RACObserve(model, title);</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.flattenMapSignal subscribeNext:^(id x) &#123; //3</span><br><span class="line">        NSLog(@&quot;subscribeNext - %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \</span><br><span class="line">    (&#123; \</span><br><span class="line">        _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">        _Pragma(&quot;clang diagnostic ignored \&quot;-Wreceiver-is-weak\&quot;&quot;) \</span><br><span class="line">        __weak id target_ = (TARGET); \</span><br><span class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \</span><br><span class="line">        _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>对subject进行map这样的操作，这时就需要sendCompleted</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    RACSubject *subject = [RACSubject subject]; </span><br><span class="line">    [subject.rac_willDeallocSignal subscribeCompleted:^&#123; </span><br><span class="line">        NSLog(@&quot;subject dealloc&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [[subject map:^id(NSNumber *value) &#123; </span><br><span class="line">        return @([value integerValue] * 3);</span><br><span class="line">    &#125;] subscribeNext:^(id x) &#123; </span><br><span class="line">        NSLog(@&quot;next = %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    [subject sendNext:@1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACStreamBindBlock (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line">    /*</span><br><span class="line">     * -bind: should:</span><br><span class="line">     * </span><br><span class="line">     * 1. Subscribe to the original signal of values.</span><br><span class="line">     * 2. Any time the original signal sends a value, transform it using the binding block.</span><br><span class="line">     * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they&apos;re received.</span><br><span class="line">     * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</span><br><span class="line">     * 5. When _all_ signals complete, send completed to the subscriber.</span><br><span class="line">     * </span><br><span class="line">     * If any signal sends an error at any point, send that to the subscriber.</span><br><span class="line">     */</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        RACStreamBindBlock bindingBlock = block();</span><br><span class="line">        NSMutableArray *signals = [NSMutableArray arrayWithObject:self];</span><br><span class="line">        // 此处省略了80行代码</span><br><span class="line">        // ...</span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。</p>
<p>下面看看sendCompleted如何修复的内存泄漏</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) &#123;</span><br><span class="line">    BOOL removeDisposable = NO;</span><br><span class="line">    @synchronized (signals) &#123;</span><br><span class="line">        [signals removeObject:signal]; //1</span><br><span class="line">        if (signals.count == 0) &#123;</span><br><span class="line">            [subscriber sendCompleted]; //2</span><br><span class="line">            [compoundDisposable dispose]; //3</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeDisposable = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; //4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。</p>
<p>还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    [subscriber sendCompleted]; // 保证源信号发送完成</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *replaySignal = [signal replay]; // 这里返回的其实是一个RACReplaySubject</span><br><span class="line"></span><br><span class="line">[[replaySignal map:^id(NSNumber *value) &#123;</span><br><span class="line">    return @([value integerValue] * 3);</span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscribeNext - %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h1 id="热信号冷信号"><a href="#热信号冷信号" class="headerlink" title="热信号冷信号"></a>热信号冷信号</h1><ul>
<li>热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。</li>
<li>热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。</li>
</ul>
<h1 id="RAC的API手册"><a href="#RAC的API手册" class="headerlink" title="RAC的API手册"></a>RAC的API手册</h1><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><h3 id="RACSiganl-信号类。"><a href="#RACSiganl-信号类。" class="headerlink" title="RACSiganl 信号类。"></a>RACSiganl 信号类。</h3><ul>
<li>RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；</li>
<li>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。</li>
</ul>
<h3 id="RACSubscriber-订阅者"><a href="#RACSubscriber-订阅者" class="headerlink" title="RACSubscriber 订阅者"></a>RACSubscriber 订阅者</h3><h3 id="RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"><a href="#RACDisposable-用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。" class="headerlink" title="RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。"></a>RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</h3><ul>
<li>RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来；</li>
<li>RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察；</li>
<li>RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象</li>
<li>RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。</li>
</ul>
<h3 id="RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送"><a href="#RACSubject-信号提供者，自己可以充当信号，又能发送信号。订阅后发送" class="headerlink" title="RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送"></a>RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送</h3><ul>
<li>RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能；</li>
<li>RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li>RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅</li>
</ul>
<h3 id="RACTuple-元组类-类似NSArray-用来包装值"><a href="#RACTuple-元组类-类似NSArray-用来包装值" class="headerlink" title="RACTuple 元组类,类似NSArray,用来包装值."></a>RACTuple 元组类,类似NSArray,用来包装值.</h3><h3 id="RACSequence-RAC中的集合类"><a href="#RACSequence-RAC中的集合类" class="headerlink" title="RACSequence RAC中的集合类"></a>RACSequence RAC中的集合类</h3><h3 id="RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"><a href="#RACCommand-RAC中用于处理事件的类，可以把事件如何处理-事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。" class="headerlink" title="RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。"></a>RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</h3><h3 id="RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"><a href="#RACMulticastConnection-用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。" class="headerlink" title="RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。"></a>RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</h3><h3 id="RACScheduler-RAC中的队列，用GCD封装的。"><a href="#RACScheduler-RAC中的队列，用GCD封装的。" class="headerlink" title="RACScheduler RAC中的队列，用GCD封装的。"></a>RACScheduler RAC中的队列，用GCD封装的。</h3><ul>
<li>RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li>RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务；</li>
<li>RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务；</li>
<li>RACSubscriptionScheduler ：一个只用来调度订阅的调度器。</li>
</ul>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><ul>
<li>rac_signalForSelector : 代替代理</li>
<li>rac_valuesAndChangesForKeyPath: KVO</li>
<li>rac_signalForControlEvents:监听事件</li>
<li>rac_addObserverForName 代替通知</li>
<li>rac_textSignal：监听文本框文字改变</li>
<li>rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
</ul>
<h2 id="常见宏"><a href="#常见宏" class="headerlink" title="常见宏"></a>常见宏</h2><ul>
<li>RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定</li>
<li>RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。</li>
<li>@weakify(Obj)和@strongify(Obj)</li>
<li>RACTuplePack ：把数据包装成RACTuple（元组类）</li>
<li>RACTupleUnpack：把RACTuple（元组类）解包成对应的数据</li>
<li>RACChannelTo 用于双向绑定的一个终端</li>
</ul>
<h2 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a>常用操作方法</h2><ul>
<li>flattenMap map 用于把源信号内容映射成新的内容。</li>
<li>concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号</li>
<li>then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</li>
<li>merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用</li>
<li>zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</li>
<li>combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</li>
<li>reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</li>
<li>filter:过滤信号，使用它可以获取满足条件的信号.</li>
<li>ignore:忽略完某些值的信号.</li>
<li>distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</li>
<li>take:从开始一共取N次的信号</li>
<li>takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号.</li>
<li>takeUntil:(RACSignal *):获取信号直到某个信号执行完成</li>
<li>skip:(NSUInteger):跳过几个信号,不接受。</li>
<li>switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</li>
<li>doNext: 执行Next之前，会先执行这个Block</li>
<li>doCompleted: 执行sendCompleted之前，会先执行这个Block</li>
<li>timeout：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li>interval 定时：每隔一段时间发出信号</li>
<li>delay 延迟发送next。</li>
<li>retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</li>
<li>replay重放：当一个信号被多次订阅,反复播放内容</li>
<li>throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<h2 id="UI-Category（常用汇总）"><a href="#UI-Category（常用汇总）" class="headerlink" title="UI - Category（常用汇总）"></a>UI - Category（常用汇总）</h2><h3 id="rac-prepareForReuseSignal：-需要复用时用"><a href="#rac-prepareForReuseSignal：-需要复用时用" class="headerlink" title="rac_prepareForReuseSignal： 需要复用时用"></a>rac_prepareForReuseSignal： 需要复用时用</h3><ul>
<li>相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView</li>
</ul>
<h3 id="rac-buttonClickedSignal：点击事件触发信号"><a href="#rac-buttonClickedSignal：点击事件触发信号" class="headerlink" title="rac_buttonClickedSignal：点击事件触发信号"></a>rac_buttonClickedSignal：点击事件触发信号</h3><ul>
<li>相关UI：UIActionSheet、UIAlertView</li>
</ul>
<h3 id="rac-command：button类、刷新类相关命令替换"><a href="#rac-command：button类、刷新类相关命令替换" class="headerlink" title="rac_command：button类、刷新类相关命令替换"></a>rac_command：button类、刷新类相关命令替换</h3><ul>
<li>相关UI：UIBarButtonItem、UIButton、UIRefreshControl</li>
</ul>
<h3 id="rac-signalForControlEvents-control-event-触发"><a href="#rac-signalForControlEvents-control-event-触发" class="headerlink" title="rac_signalForControlEvents: control event 触发"></a>rac_signalForControlEvents: control event 触发</h3><ul>
<li>相关UI：UIControl</li>
</ul>
<h3 id="rac-gestureSignal-UIGestureRecognizer-事件处理信号"><a href="#rac-gestureSignal-UIGestureRecognizer-事件处理信号" class="headerlink" title="rac_gestureSignal UIGestureRecognizer 事件处理信号"></a>rac_gestureSignal UIGestureRecognizer 事件处理信号</h3><ul>
<li>相关UI：UIGestureRecognizer</li>
</ul>
<h3 id="rac-imageSelectedSignal-选择图片的信号"><a href="#rac-imageSelectedSignal-选择图片的信号" class="headerlink" title="rac_imageSelectedSignal 选择图片的信号"></a>rac_imageSelectedSignal 选择图片的信号</h3><ul>
<li>相关UI：UIImagePickerController</li>
</ul>
<h3 id="rac-textSignal"><a href="#rac-textSignal" class="headerlink" title="rac_textSignal"></a>rac_textSignal</h3><ul>
<li>相关UI：UITextField、UITextView</li>
</ul>
<h3 id="可实现双向绑定的相关API"><a href="#可实现双向绑定的相关API" class="headerlink" title="可实现双向绑定的相关API"></a>可实现双向绑定的相关API</h3><ul>
<li>rac_channelForControlEvents: key: nilValue:</li>
<li>相关UI：UIControl类</li>
<li>rac_newDateChannelWithNilValue:</li>
<li>相关UI：UIDatePicker</li>
<li>rac_newSelectedSegmentIndexChannelWithNilValue:</li>
<li>相关UI：UISegmentedControl</li>
<li>rac_newValueChannelWithNilValue:</li>
<li>相关UI：UISlider、UIStepper</li>
<li>rac_newOnChannel</li>
<li>相关UI：UISwitch</li>
<li>rac_newTextChannel</li>
<li>相关UI：UITextField</li>
</ul>
<h2 id="Foundation-Category-（常用汇总）"><a href="#Foundation-Category-（常用汇总）" class="headerlink" title="Foundation - Category （常用汇总）"></a>Foundation - Category （常用汇总）</h2><h3 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h3><ul>
<li>rac_readContentsOfURL: options: scheduler: 比oc多出线程设置</li>
</ul>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><ul>
<li>rac_sequence</li>
<li>rac_keySequence key 集合</li>
<li>rac_valueSequence value 集合</li>
</ul>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><ul>
<li>rac_sequence 信号集合</li>
</ul>
<h3 id="NSFileHandle"><a href="#NSFileHandle" class="headerlink" title="NSFileHandle"></a>NSFileHandle</h3><ul>
<li>rac_readInBackground 后台线程读取</li>
</ul>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><ul>
<li>rac_setArgument: atIndex: 设置参数</li>
<li>rac_argumentAtIndex 取某个参数</li>
<li>rac_returnValue 所关联方法的返回值</li>
</ul>
<h3 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h3><ul>
<li>rac_addObserverForName: object:注册通知</li>
</ul>
<h3 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h3><ul>
<li>rac_willDeallocSignal 对象销毁时发动的信号</li>
<li>rac_description debug用</li>
<li>rac_observeKeyPath: options: observer: block:监听某个事件</li>
<li>rac_liftSelector: withSignals: 全部信号都next在执行</li>
<li>rac_signalForSelector: 代替某个方法</li>
<li>rac_signalForSelector:(SEL)selector fromProtocol:代替代理</li>
</ul>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><ul>
<li>rac_keyPathComponents 获取一个路径所有的部分</li>
<li>rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分</li>
<li>rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分</li>
<li>rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用</li>
<li>rac_sequence</li>
</ul>
<h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><ul>
<li>rac_sendAsynchronousRequest 发起异步请求</li>
</ul>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><ul>
<li>rac_channelTerminalForKey 用于双向绑定，此乃一</li>
</ul>
<h3 id="NSEnumerator"><a href="#NSEnumerator" class="headerlink" title="NSEnumerator"></a>NSEnumerator</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSIndexSet"><a href="#NSIndexSet" class="headerlink" title="NSIndexSet"></a>NSIndexSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSOrderedSet"><a href="#NSOrderedSet" class="headerlink" title="NSOrderedSet"></a>NSOrderedSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><ul>
<li>rac_sequence</li>
</ul>
<h1 id="RAC图片版的API手册"><a href="#RAC图片版的API手册" class="headerlink" title="RAC图片版的API手册"></a>RAC图片版的API手册</h1><h2 id="ReactiveCocoa-Objective-C"><a href="#ReactiveCocoa-Objective-C" class="headerlink" title="ReactiveCocoa Objective-C"></a>ReactiveCocoa Objective-C</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaOC.png?raw=true" alt="ReactiveCocoaObjective-C"></p>
<h2 id="ReactiveCocoa-Swift"><a href="#ReactiveCocoa-Swift" class="headerlink" title="ReactiveCocoa Swift"></a>ReactiveCocoa Swift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/ReactiveCocoaSwift.png?raw=true" alt="ReactiveCocoaSwift"></p>
<h2 id="RXSwift"><a href="#RXSwift" class="headerlink" title="RXSwift"></a>RXSwift</h2><p><img src="https://github.com/ming1016/study/blob/master/pic/RXSwift.png?raw=true" alt="RXSwift"></p>
<h1 id="本文参考整理自"><a href="#本文参考整理自" class="headerlink" title="本文参考整理自"></a>本文参考整理自</h1><ul>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 <a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="noopener">https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a></li>
<li>ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 <a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="noopener">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a></li>
<li>iOS的函数响应型编程 <a href="https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details" target="_blank" rel="noopener">https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details</a></li>
<li>ReactiveCocoa Essentials: Understanding and Using RACCommand <a href="http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/" target="_blank" rel="noopener">http://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/</a></li>
<li>iOS ReactiveCocoa 最全常用API整理（可做为手册查询）<a href="http://www.cocoachina.com/ios/20160729/17236.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20160729/17236.html</a></li>
<li>ReactiveCocoa和RXSwift速查表 <a href="http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/" target="_blank" rel="noopener">http://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/</a></li>
<li>ReactiveCocoa中潜在的内存泄漏及解决方案<a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0</a></li>
<li><a href="https://github.com/ming1016/study/wiki" target="_blank" rel="noopener">ming1016</a></li>
</ul>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/page/12/">上一页</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/14/">下一页</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/">1</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/12/">12</a></li>
            
            <li><a class="pagination-link is-current" href="/page/13/">13</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/14/">14</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/27/">27</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="https://gitee.com/policx/im/raw/master/images/HQZ3sQ.png" alt="policx">
                    
                    
                    <p class="is-size-4 is-block">
                        policx
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        heal the world
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>中国</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        81
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        1
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        4
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://www.2345.com/?k.cn" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://www.2345.com/?k.cn">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Email" href="mailto:heal@policx.com">
                
                Email
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        

<div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            链接
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://github.com/ppoffice" target="_blank">
                    <span class="level-left">
                        <span class="level-item">PPOffice</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                分类
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/news/">
            <span class="level-start">
                <span class="level-item">news</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            标签云
        </h3>
        <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags//" style="font-size: 20px;"></a>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/06/05/2019/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://www.policx.com/talk/images/2019.png" alt="WWDC 2019">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-05T03:06:39.000Z">2019-06-05</time></div>
                    <a href="/2019/06/05/2019/" class="has-link-black-ter is-size-6">WWDC 2019</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/news/">news</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/09/17/git-del/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="http://pic.baike.soso.com/ugc/baikepic2/12333/20160916155205-650847467.jpg/300" alt="git如何删除已经提交的文件夹">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-09-17T08:02:32.000Z">2018-09-17</time></div>
                    <a href="/2018/09/17/git-del/" class="has-link-black-ter is-size-6">git如何删除已经提交的文件夹</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/19/python-excel/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/06/22/5d0e4f2f57e4e99534.jpg" alt="Python利用openpyxl来操作Excel">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-19T08:39:16.000Z">2018-06-19</time></div>
                    <a href="/2018/06/19/python-excel/" class="has-link-black-ter is-size-6">Python利用openpyxl来操作Excel</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/17/python-writer/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/06/22/5d0e4f2f57e4e99534.jpg" alt="python操作excel的包(openpyxl、xlsxwriter)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-17T10:28:27.000Z">2018-06-17</time></div>
                    <a href="/2018/06/17/python-writer/" class="has-link-black-ter is-size-6">python操作excel的包(openpyxl、xlsxwriter)</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/05/2018/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://www.policx.com/talk/images/2018.jpg" alt="WWDC 2018">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-04T16:59:59.000Z">2018-06-05</time></div>
                    <a href="/2018/06/05/2018/" class="has-link-black-ter is-size-6">WWDC 2018</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/news/">news</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">六月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/09/">
                <span class="level-start">
                    <span class="level-item">九月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">六月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/05/">
                <span class="level-start">
                    <span class="level-item">五月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/04/">
                <span class="level-start">
                    <span class="level-item">四月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/03/">
                <span class="level-start">
                    <span class="level-item">三月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/02/">
                <span class="level-start">
                    <span class="level-item">二月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">7</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/09/">
                <span class="level-start">
                    <span class="level-item">九月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/08/">
                <span class="level-start">
                    <span class="level-item">八月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/06/">
                <span class="level-start">
                    <span class="level-item">六月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/03/">
                <span class="level-start">
                    <span class="level-item">三月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/02/">
                <span class="level-start">
                    <span class="level-item">二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/01/">
                <span class="level-start">
                    <span class="level-item">一月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/10/">
                <span class="level-start">
                    <span class="level-item">十月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/08/">
                <span class="level-start">
                    <span class="level-item">八月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/07/">
                <span class="level-start">
                    <span class="level-item">七月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/06/">
                <span class="level-start">
                    <span class="level-item">六月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">21</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/03/">
                <span class="level-start">
                    <span class="level-item">三月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/02/">
                <span class="level-start">
                    <span class="level-item">二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/01/">
                <span class="level-start">
                    <span class="level-item">一月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/09/">
                <span class="level-start">
                    <span class="level-item">九月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/06/">
                <span class="level-start">
                    <span class="level-item">六月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/09/">
                <span class="level-start">
                    <span class="level-item">九月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/08/">
                <span class="level-start">
                    <span class="level-item">八月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/06/">
                <span class="level-start">
                    <span class="level-item">六月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/05/">
                <span class="level-start">
                    <span class="level-item">五月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/03/">
                <span class="level-start">
                    <span class="level-item">三月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2013/07/">
                <span class="level-start">
                    <span class="level-item">七月 2013</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2012/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2012</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Markdown/">
                        <span class="tag">Markdown</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags//">
                        <span class="tag"></span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            最新文章
        </h3>
        
        <article class="media">
            
            <a href="/2019/06/05/2019/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://www.policx.com/talk/images/2019.png" alt="WWDC 2019">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-05T03:06:39.000Z">2019-06-05</time></div>
                    <a href="/2019/06/05/2019/" class="has-link-black-ter is-size-6">WWDC 2019</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/news/">news</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/09/17/git-del/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="http://pic.baike.soso.com/ugc/baikepic2/12333/20160916155205-650847467.jpg/300" alt="git如何删除已经提交的文件夹">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-09-17T08:02:32.000Z">2018-09-17</time></div>
                    <a href="/2018/09/17/git-del/" class="has-link-black-ter is-size-6">git如何删除已经提交的文件夹</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/19/python-excel/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/06/22/5d0e4f2f57e4e99534.jpg" alt="Python利用openpyxl来操作Excel">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-19T08:39:16.000Z">2018-06-19</time></div>
                    <a href="/2018/06/19/python-excel/" class="has-link-black-ter is-size-6">Python利用openpyxl来操作Excel</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/17/python-writer/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://i.loli.net/2019/06/22/5d0e4f2f57e4e99534.jpg" alt="python操作excel的包(openpyxl、xlsxwriter)">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-17T10:28:27.000Z">2018-06-17</time></div>
                    <a href="/2018/06/17/python-writer/" class="has-link-black-ter is-size-6">python操作excel的包(openpyxl、xlsxwriter)</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2018/06/05/2018/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="https://www.policx.com/talk/images/2018.jpg" alt="WWDC 2018">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2018-06-04T16:59:59.000Z">2018-06-05</time></div>
                    <a href="/2018/06/05/2018/" class="has-link-black-ter is-size-6">WWDC 2018</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/news/">news</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            归档
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">六月 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/09/">
                <span class="level-start">
                    <span class="level-item">九月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">六月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/05/">
                <span class="level-start">
                    <span class="level-item">五月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/04/">
                <span class="level-start">
                    <span class="level-item">四月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/03/">
                <span class="level-start">
                    <span class="level-item">三月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/02/">
                <span class="level-start">
                    <span class="level-item">二月 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">7</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/09/">
                <span class="level-start">
                    <span class="level-item">九月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/08/">
                <span class="level-start">
                    <span class="level-item">八月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/06/">
                <span class="level-start">
                    <span class="level-item">六月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/03/">
                <span class="level-start">
                    <span class="level-item">三月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/02/">
                <span class="level-start">
                    <span class="level-item">二月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2017/01/">
                <span class="level-start">
                    <span class="level-item">一月 2017</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/10/">
                <span class="level-start">
                    <span class="level-item">十月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/08/">
                <span class="level-start">
                    <span class="level-item">八月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/07/">
                <span class="level-start">
                    <span class="level-item">七月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/06/">
                <span class="level-start">
                    <span class="level-item">六月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">21</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/03/">
                <span class="level-start">
                    <span class="level-item">三月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/02/">
                <span class="level-start">
                    <span class="level-item">二月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2016/01/">
                <span class="level-start">
                    <span class="level-item">一月 2016</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/09/">
                <span class="level-start">
                    <span class="level-item">九月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2015/06/">
                <span class="level-start">
                    <span class="level-item">六月 2015</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/11/">
                <span class="level-start">
                    <span class="level-item">十一月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/09/">
                <span class="level-start">
                    <span class="level-item">九月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/08/">
                <span class="level-start">
                    <span class="level-item">八月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/06/">
                <span class="level-start">
                    <span class="level-item">六月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/05/">
                <span class="level-start">
                    <span class="level-item">五月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2014/03/">
                <span class="level-start">
                    <span class="level-item">三月 2014</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2013/07/">
                <span class="level-start">
                    <span class="level-item">七月 2013</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2012/12/">
                <span class="level-start">
                    <span class="level-item">十二月 2012</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                标签
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Markdown/">
                        <span class="tag">Markdown</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/Python/">
                        <span class="tag">Python</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">git</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags//">
                        <span class="tag"></span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                    
                                <img src="/images/logo.gif" alt="江湖" height="28">
                                
                </a>
                <p class="is-size-7">
                    &copy;
                    2019
                        policx&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                            
                                <br>
                                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                                </span>
                                
                </p>
            </div>
            <div class="level-end">
                
                    <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                        
                            
                                <p class="control">
                                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://www.2345.com/?k.cn">
                                        
                                                    <i class="fab fa-creative-commons"></i>
                                                    
                                    </a>
                                </p>
                                
                                <p class="control">
                                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://www.2345.com/?k.cn">
                                        
                                                    <i class="fab fa-creative-commons-by"></i>
                                                    
                                    </a>
                                </p>
                                
                                <p class="control">
                                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://www.2345.com/?k.cn">
                                        
                                                    <i class="fab fa-github"></i>
                                                    
                                    </a>
                                </p>
                                
                    </div>
                    
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>