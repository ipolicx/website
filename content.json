{"pages":[{"title":"留言板","text":"在一切变好之前，我们总要经历一些不开心的日子，这段日子也许很长，也许只是一觉醒来，所以耐心点，给好运一点时间。","link":"/message/index.html"},{"title":"关于","text":"一个对着手机微笑的女孩，我也会猜测她微笑，是恋人的密语，还是朋友的问候，或许是看一段笑话，总之，很美。我想坐过去，但她的目光投过来，我又低下了头，像个犯错的孩子。","link":"/about/index.html"},{"title":"","text":"","link":"/404.html"}],"posts":[{"title":"17年会","text":"一路同行共精彩！","link":"/notes/17/"},{"title":"hexo-theme-icarus","text":"Hexo-theme-icarus 是一个优秀的 Hexo 主题，开发者 Ruipeng Zhang 同时还维护了 hexo-theme-hueman 和 hexo-theme-minos 两个项目。 icarus 是一个三栏结构的自适应主题，预置了大量第三方插件，可以方便使用者快速建站。整体风格简约，适合各种类型的站点，无论是技术文章，还是摄影佳作，都可以完美承载。 效果图 安装在命令行中cd至博客根目录，加载主题： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 基础配置首先，要在博客根目录下的 _config.yml 文件中做两件事情： 设置语言: language: zh-CN 设置主题为 icarus: theme: icarus icarus 为我们预置了多达 12 种语言，默认是英文。一开始我没有设置语言，电脑上打开使用的是英文，但是手机上看就是一种类似葡萄牙语的文字。没有深究原因，所以还是按照博客的受众以及平时的喜好设置一下语言，zh-CN是简体中文。 icarus 的文件结构先来看看 icarus 主题的文件结构吧，让我们准备好尖叫声！ 123456789101112131415├─includes├─languages├─layout│ ├─comment│ ├─common│ ├─donate│ ├─plugin│ ├─search│ ├─share│ └─widget├─sripts└─source ├─css ├─images └─js 仔细观察渲染文件 layout 目录，就可以发现 icarus 的强大了，评论、捐赠、搜索、分享以及诸多第三方插件，都已经集成好啦！再说一遍，集成好啦！icarus 的简中翻译相对中规中矩，大家可以根据自己的文案风格修改 languages 目录下的 zh-CN.yml 文件。 _config.yml 文件配置首次在博客根目录执行 hexo clean 或者 hexo g 都会触发 icarus 自动生成一个 _config.yml 文件，我们逐一说明。 logologo 会展示在顶部导航栏的最左侧以及底部的footer区域，大家可以替换 source/images/ 下的 logo 文件，使用 svg 或者 png 格式的都可以。研究源码发现，这个地方给没有 logo 的同学保留了一套文字方案： /layout/common/navbar.ejs12345&lt;% if (has_config('logo.text') &amp;&amp; get_config('logo.text')) { %&gt; &lt;%= get_config('logo.text') %&gt;&lt;% } else { %&gt; &lt;img src=\"&lt;%- url_for(get_config('logo')) %&gt;\" alt=\"&lt;%= get_config('title') %&gt;\" height=\"28\"&gt;&lt;% } %&gt; 也就是说，只要给 logo 添加 text 属性，就会优先展示预设文字作为 logo： 12logo: text: your name 这对于不会画 logo 的同学来说无疑是个大好消息了： 评论系统icarus 预置了 Changyan Disqus Facebook Gitment Gitalk Isso LiveRe 和 Valine 八大主流评论插件。 这里以我使用的 Valine 为例。首先在 LeanCloud 注册一个免费的开发账号，新建一个新应用，并把 appid 和 appkey 配置在对应部分： 1234567comment: type: valine app_id: # (required) LeanCloud application id app_key: # (required) LeanCloud application key notify: # (optional) receive email notification verify: # (optional) show verification code placeholder: # (optional) comment box placeholder text 其余的三项选填，这样就完成了 Valine 的基本配置了。此外，Valine 同步 Gravatar 头像，只要在评论的时候留下邮箱，就会展示你独一无二的头像咯！ 效果如下： 如果有的文章不希望别人评论，但是我们又希望把整个站点的评论关闭的话，就需要对指定文章进行评论关闭操作了。操作也很简单，只需要在文章 markdown 文件的 front-matter 区域设置 comments comment 为 false 即可： 注意：是 comment 没有 s 1234---title: article titlecomment: false--- 打赏作为程序员的收入来源之一，打赏是必不可少的啦。icarus 提供了 支付宝 微信 PayPal 和 Patreon 四种方式： 1234567891011121314151617donate: - type: alipay qrcode: /images/alipay.JPG - type: wechat qrcode: /images/wechat.JPG - # type: paypal # Paypal business ID or email address # business: '' # Currency code # currency_code: USD - # type: patreon # URL to the Patreon page # url: '' 支付宝 和 微信 只需要提供二维码就可以了，可以使用本地静态资源或者图床链接。效果如下，大家懂的： widget我觉得这是 icarus 比较精髓的部分了，所有的 widget 都是一个卡片，\b可以自由摆放在任何位置： 包括文章在内，个人资料、链接、分类、最新文章、归档、标签和标签云都是一个卡片，可以在 _config.yml 中设置各个卡片的具体属性，同时也可以设置卡片出现在网站的左侧还是右侧： 123456widgets: - # Widget name type: tagcloud # Where should the widget be placed, left or right position: left 其他设置（置顶/阅读量统计）还有一些其他的设置就不在这里赘述了，具体可以参考 官方文档 进行了解。 除此之外，我根据实际需求，在 icarus 主题内添加了 置顶文章 和 阅读量统计 的两个小功能，大家如果有兴趣，可以前往我的博客和我交流喔:-O 原文链接👇","link":"/blog/hexo-theme-icarus/"},{"title":"启程","text":"故事的开始 歌曲：启程作词\\作曲：卢庚戌演唱：水木年华编曲：卢梁博录音师：郝宇混音师：颜仲坤和声编配：缪杰和声：缪杰 哈达吉他：李延亮班卓琴：李延亮贝斯：韩阳鼓：刁磊 向过去的悲伤说再见吧还是好好珍惜现在吧你寻求的幸福 其实不在远处它就是你现在 一直走的路就在启程的时刻让我为你唱首歌孤独时候要记得想起我等到相遇的时刻我们再唱这首歌就像我们从未曾离别过不管怎样的时刻请你记住这首歌记住我们的坚持从未变过未来怎样的时刻请你记住这首歌记住我们的梦想从未变过记住我们的梦想从未变过记住我们的梦想从未变过","link":"/notes/2011启程/"},{"title":"2012","text":"2012 一切都还好。 世界未末日作词：方文山 作曲：周杰伦演唱：周杰伦 这街道在下陷 我们就快失去了家园你我却都没有埋怨 将眼泪停格瞬间街景摧毁 我内心却不轻易撤退满天风雪 我们会微笑去面对我牵着你的手 一路穿梭在城市路口就算故事到了尽头 我们也绝不退缩快转风景 被一再提醒失去森林落叶声音 停不住我们的关心就算是世界要崩溃 亲爱的我也绝不会落泪不放弃爱过的那种感觉珍惜着有你记忆的一切就算是世界要倾斜亲爱的我也绝不说离别尽管末日威胁再强烈 有爱就不累我牵着你的手 一路穿梭在城市路口就算故事到了尽头 我们也绝不退缩快转风景 被一再提醒失去森林落叶声音 停不住我们的关心就算是世界要崩溃亲爱的我也绝不会落泪不放弃爱过的那种感觉珍惜着有你记忆的一切就算是世界要倾斜亲爱的我也绝不说离别尽管末日威胁再强烈 有爱就不累","link":"/notes/2012/"},{"title":"16年会","text":"新的一年，新的开始。","link":"/notes/16/"},{"title":"融贝二周年","text":"融贝二周年","link":"/notes/2year/"},{"title":"王者荣耀","text":"🤔","link":"/notes/AppleSupport/"},{"title":"搬家","text":"三年，再见。","link":"/notes/banjia/"},{"title":"Website","text":"收藏 https://www.gotapi.com/ 语言：英语 简介：HTML,CSS,XPATH,XSL,JAVASCRIPT等API的查询网站。 https://www.w3schools.com/ 语言：英语 简介：W3C制定的标准诸如XML,HTML,XSL等等的在线学习教程。 https://www.xml.org.cn/ 语言：中文 简介：可以说是XML的中国官方网吧。W3C标准的翻译组织与XML系列技术交流社区. https://www.connectionstrings.com/ 语言：英语 简介：这里几乎收集了所有的数据库连接字符(connectionstring)了。 https://www.itpub.net/ 语言：中文 简介：我个人认为是国内最专业的综合性行业性技术类社区. https://www.netvtm.com/ 语言：中文 简介：内容多翻译于w3schools.com，少有原创。不过还是应该鼓励精品翻译。 https://www.regexlib.com 语言：英语 简介：正则表达式库。搜索正则表达式用。 https://www.rexv.org/ 语言：英语 简介：用Ajax开发的在线正则表达式验证器. https://www.koders.com/ 语言：英语 简介：代码搜索引擎，可以搜索几十种语言的代码。 https://www.123aspx.com/Rotor/ 语言：英语 简介：.Net Frameworks的源代码。 语言：中文 简介：孟宪会的资料站，虽资料大多比较简单，却解决了开发中的大部分问题？！ https://www.dofactory.com/Patterns/Patterns.aspx 语言：英语 简介：23种设计模式的实现参考。特点是UML+精练的示例代码+简洁的解说风格。 https://www.open-open.com/ 语言：中文 简介：Java开源大全,如果你用.NET，照着它的名字前加N找找应该都有吧 ？！：） https://www.riacn.com/ 语言：中文 简介：我认为是国内少有的RIA专业技术站于交流社区. https://www.cnpaf.net/ 语言：中文 简介：中国协议分析网，很全面的协议资料网。 https://www.pinvoke.net/ 语言：英语 简介：通过.net调用win32等非受控API的资料大全。 https://bbs.51js.com/ 语言：中文 简介：无忧脚本,专业的脚本技术社区。 https://www.c-sharpcorner.com/ 语言：英语 简介：C# Corner,学习c#的好地方. https://blog.csdn.net/group/experts/ 语言：中文 简介：CSDN专家群,汇集CSDN专家的电子报. https://www.codeproject.com/ 语言：英语 简介：有很多可学习的示例代码，特点是丰富，深入浅出． https://www.gotdotnet.com/ 语言：英语 简介：微软开发维护的关于.net framework交流社区. https://www.sourceforge.net/ 语言：英语 简介：全球最大的开源软体站点 https://www.asp.net/QuickStart/ 语言：英语 简介：Microsoft .NET Framework SDK QuickStart Tutorials https://www.matrix.org.cn/ 语言：中文 简介：与 Java 共舞,Java优秀的专业社区,文章质量很高.做.Net的朋友也可以从其借鉴很多知识. JAVA学习模板——学习流程 https://www.7zcn.com/javastep/StudyJavaInfo.html SUN中国技术社区 https://developers.sun.com.cn/ 综合网站 ­ 数动在线https://www.shudoo.com/（电脑报） ­https://www.csdn.net/ ­ 比特网IT知识库https://know.chinabyte.com/index.php/%E9%A6%96%E9%A1%B5 ­ 至顶网https://www.zdnet.com.cn/ ­ 计世网https://www.ccw.com.cn/ ­ 中国IT实验室https://www.chinaitlab.com/ ­ 天极网https://www.yesky.com/ ­ 赛迪网https://www.ccidnet.com/ ­ 全球流量查询https://www.alexa.com/ ­ Java网站 ­ Java软件社区https://www.javaeye.com/ ­ java世纪网https://www.java2000.net/ ­ JAVABUGShttps://bugs.sun.com/JAVA漏洞 ­ https://www.mldnjava.cn/java.htm ­ HEY JAVA技术社区https://www.heyjava.com/ ­ ACCP教程网https://www.accptech.com/index.html 论坛网站 ­ 美河论坛https://www.eimhe.com/bbs/ ­ 魔https://bbs.mldn.cn/ ­ https://bbs.chinajavaworld.com/index.jspa 技术网站 ­ apache的ANThttps://ant.apache.org/bindownload.cgi ­ IBM https://www.ibm.com/developerworks/­ IDE­ Eclipse官网https://www.eclipse.org/downloads­ MyEclipse官网https://www.myeclipseide.com/ 软件测试 软件测试网https://www.51testing.com/ 1 程序员论坛：https://www.gxcxy.com 2 J2me社区 https://www.j2meforums.com/forum/ 3 csdn https://www.csdn.net/ 4 Vc知识库 https://www.vckbase.com/ 5 codeproject https://www.codeproject.com/ 6 程序员联合开发网 https://www.pudn.com/ 7 看雪学院 https://www.pediy.com 8 蓝色理想 https://www.blueidea.com/ 9 博客园 https://www.cnblogs.com/ 10 Nuix应用开发社区 https://chinaunix.net/ 11 javaeye https://www.javaeye.com 12 It人网 https://www.iteer.net/ 13 中国人才热线 https://www.cjol.com/ 14 天涯论坛 https://www.tianya.cn/ 15 风云的blog https://blog.codingnow.com/ 16 新浪科技频道 https://tech.sina.com.cn/ 17 phpchina https://www.phpchina.com/html/index.html 18 游戏开发资源网 https://www.gameres.com/ 19 网络游戏第一门户 https://www.17173.com/ 20 我爱研发网 https://www.52rd.com/ 21 Msdn中文网 https://www.microsoft.com/china/MSDN/DeveloperCenter/default.mspx 22 大富翁编程网站 https://www.delphibbs.com/ 23 Delphi盒子 https://www.2ccc.com/ 24 C++buillder研究 https://www.ccrun.com/ 25 It论坛 https://bbs.itren.cn/ 26 Java开源大全 https://www.open-open.com/ 27 codegurn https://www.codeguru.com/ 28 编程爱好者 https://www.programfan.com/ 29 Java中文站 https://www.java-cn.com/ 30 reactos https://www.reactos.org/zh/index.htm 31 开源力量 https://www.opensourceforce.org/ 32 电脑编程技巧与维护 https://www.comprg.com.cn/ 33 中国电子网 https://21ic.com/ 34 编程中国 https://www.bc-cn.net/ 35 嵌入式开发论坛 https://www.cevx.com/bbs/ 36 电脑爱好者 https://www.cfan.com.cn/ 37 sybase中国 https://www.sybase.com.cn/gvswse/site/china/index.jsp 38 pbdr https://www.pbdr.com/ 39 apache https://www.apache.org 40 rootkit https://www.rootkit.com/index.php 41 驱动开发网 https://www.driverdevelop.com/first.html 42 安全焦点 https://www.xfocus.net/ 43 cnbeta网友媒体与言论平台 https://www.cnbeta.com/ 44 fyter的博客 https://www.fyter.cn/Default.aspx 45 asp.net控件 https://www.devexpress.com/ 46 operamask https://www.operamasks.org/ 47 中国源码网 https://www.yuanma.org/ 48 sawin软件研发之窗 https://www.sawin.cn/ 49 电脑教育与WEB教育在线 https://210.40.7.188/ 50 中国dos联盟 https://www.cn-dos.net/ 51 中国bios联盟 https://www.biosren.com/index.php 52 bioscentral https://bioscentral.com/ 53 eda专业论坛 https://www.edacn.net/bbs/ 54 诺基亚论坛 https://forum.nokia.com.cn/sch/index.html 55 计算机科学论坛 https://www.ieee.org.cn/index.asp 56 ibm developerworks 中国 https://www.ibm.com/developerworks/cn/ 57 w3 https://www.w3.org/ 58 网页设计师 https://www.w3cn.org/ 59 中国万维网联盟 https://www.w3china.org/index.htm 60 豆瓣 https://www.douban.com/ 61 程序员门户站：https://www.gxcxy.com 62 软件商务网 https://www.bizsofts.com/ 63 sun https://www.sun.com/ 64 google code https://code.google.com/ 65 google 开发人员主页 https://code.google.com/intl/zh-CN/ 66 the official microsoft asp.net https://www.asp.net/ 67 microsoft IIS https://www.iis.net/default.aspx?tabid=1 68 荣耀 https://www.royaloo.com/index.html 69 侯捷网站 https://jjhou.csdn.net/ 70 java大本营 https://www.javadby.com/ 71 比特网 https://www.chinabyte.com/ 72 51cto https://www.51cto.com/ 73 infoq https://www.infoq.com/ 74 博客堂 https://blog.joycode.com/ 75 嵌入式开发网 https://www.embed.com.cn/ 76 嵌入式开线 https://www.mcuol.com/ 77 中嵌网 https://www.chinaeda.cn/ 78 酷勤网 https://www.kuqin.com/ 79 红联linux门户 https://www.linuxdiyf.com/ 80 itpub技术门户 https://www.itpub.net/ 81 程式设计俱乐部 https://www.programmer-club.com/index.asp 82 uml软件工程组织 https://www.uml.org.cn/index.asp 83 delphi园地 https://www.delphifans.com/ 84 theserverside https://www.theserverside.com/ 85 中国donet俱乐部 https://www.chinaaspx.com/ 86 编程王 https://www.kingofcoders.com/ 87 it168 https://www.it168.com/ 88 open source software in c# https://csharp-source.net/ 89 中国IT实验室 https://www.chinaitlab.com/ 90 落伍者站长论坛 https://www.im286.com/ 91 中国站长站 https://www.chinaz.com/ 92 asp.net源码下载专业站 https://www.51aspx.com/ 93 it职业工程师 https://www.51myit.com/ 94 太平洋电脑网 https://www.pconline.com.cn/ 95 乘风原创程序 https://study.qqcf.com/ 96 网易学院 https://tech.163.com/school/ 97 程序设计／程序开发类教程 https://www.pcvz.com/Program/Programs/Index.html 98 算法源码吧 https://www.sfcode.cn/ 99 codegurn https://www.codeguru.cn/ 100 得益网 https://www.netyi.net/ 101 中国eclipse社区 https://www.eclipseworld.org/bbs/ 102 项目管理者联盟 https://www.mypm.net/ 103 栖息谷 https://www.21manager.com/ 104 J2me开发网 https://www.j2medev.com/bbs/index.asp 105 卓越亚马逊 https://www.amazon.cn/ WEB技术： WEB前端开发 https://www.css88.com/ Ext JS官方网 https://www.extjs.com/ Ext JS中文资料 https://www.extjs.org.cn/ 1 J2me开发网 https://www.j2medev.com/bbs/index.asp2 J2me社区 https://www.j2meforums.com/forum/3 csdn https://www.csdn.net/4 Vc知识库 https://www.vckbase.com/5 codeproject https://www.codeproject.com/6 程序员联合开发网 https://www.pudn.com/7 看雪学院 https://www.pediy.com/8 蓝色理想 https://www.blueidea.com/9 博客园 https://www.cnblogs.com/10 Nuix应用开发社区 https://chinaunix.net/11 javaeye https://www.javaeye.com/12 It人网 https://www.iteer.net/13 中国人才热线 https://www.cjol.com/14 天涯论坛 https://www.tianya.cn/15 风云的blog https://blog.codingnow.com/16 新浪科技频道 https://tech.sina.com.cn/17 phpchina https://www.phpchina.com/html/index.html18 游戏开发资源网 https://www.gameres.com/19 网络游戏第一门户 https://www.17173.com/20 我爱研发网 https://www.52rd.com/21 Msdn中文网 https://www.microsoft.com/china/MSDN/DeveloperCenter/default.mspx22 大富翁编程网站 https://www.delphibbs.com/23 Delphi盒子 https://www.2ccc.com/24 C++buillder研究 https://www.ccrun.com/25 It论坛 https://bbs.itren.cn/26 Java开源大全 https://www.open-open.com/27 codegurn https://www.codeguru.com/28 编程爱好者 https://www.programfan.com/29 Java中文站 https://www.java-cn.com/30 reactos https://www.reactos.org/zh/index.html31 开源力量 https://www.opensourceforce.org/32 电脑编程技巧与维护 https://www.comprg.com.cn/33 中国电子网 https://21ic.com/34 编程中国 https://www.bc-cn.net/35 嵌入式开发论坛 https://www.cevx.com/bbs/36 电脑爱好者 https://www.cfan.com.cn/37 sybase中国 https://www.sybase.com.cn/gvswse/site/china/index.jsp38 pbdr https://www.pbdr.com/39 apache https://www.apache.org/40 rootkit https://www.rootkit.com/index.php41 驱动开发网 https://www.driverdevelop.com/first.html42 安全焦点 https://www.xfocus.net/43 cnbeta网友媒体与言论平台 https://www.cnbeta.com/44 fyter的博客 https://www.fyter.cn/Default.aspx45 asp.net控件 https://www.devexpress.com/46 operamask https://www.operamasks.org/47 中国源码网 https://www.yuanma.org/48 sawin软件研发之窗 https://www.sawin.cn/49 电脑教育与WEB教育在线 https://210.40.7.188/50 中国dos联盟 https://www.cn-dos.net/51 中国bios联盟 https://www.biosren.com/index.php52 bioscentral https://bioscentral.com/53 eda专业论坛 https://www.edacn.net/bbs/54 诺基亚论坛 https://forum.nokia.com.cn/sch/index.html55 计算机科学论坛 https://www.ieee.org.cn/index.asp56 ibm developerworks 中国 https://www.ibm.com/developerworks/cn/57 w3 https://www.w3.org/58 网页设计师 https://www.w3cn.org/59 中国万维网联盟 https://www.w3china.org/index.htm60 豆瓣 https://www.douban.com/61 卓越亚马逊 https://www.amazon.cn/62 软件商务网 https://www.bizsofts.com/63 sun https://www.sun.com/64 google code https://code.google.com/65 google 开发人员主页 https://code.google.com/intl/zh-CN/66 the official microsoft asp.net https://www.asp.net/67 microsoft IIS https://www.iis.net/default.aspx?tabid=168 荣耀 https://www.royaloo.com/index.html69 侯捷网站 https://jjhou.csdn.net/70 java大本营 https://www.javadby.com/71 比特网 https://www.chinabyte.com/72 51cto https://www.51cto.com/73 infoq https://www.infoq.com/74 博客堂 https://blog.joycode.com/75 嵌入式开发网 https://www.embed.com.cn/76 嵌入式开线 https://www.mcuol.com/77 中嵌网 https://www.chinaeda.cn/78 酷勤网 https://www.kuqin.com/79 红联linux门户 https://www.linuxdiyf.com/80 itpub技术门户 https://www.itpub.net/81 程式设计俱乐部 https://www.programmer-club.com/index.asp82 uml软件工程组织 https://www.uml.org.cn/index.asp83 delphi园地 https://www.delphifans.com/84 theserverside https://www.theserverside.com/85 中国donet俱乐部 https://www.chinaaspx.com/86 编程王 https://www.kingofcoders.com/87 it168 https://www.it168.com/88 open source software in c# https://csharp-source.net/89 中国IT实验室 https://www.chinaitlab.com/90 落伍者站长论坛 https://www.im286.com/91 中国站长站 https://www.chinaz.com/92 asp.net源码下载专业站 https://www.51aspx.com/93 it职业工程师 https://www.51myit.com/94 太平洋电脑网 https://www.pconline.com.cn/95 乘风原创程序 https://study.qqcf.com/96 网易学院 https://tech.163.com/school/97 程序设计／程序开发类教程 https://www.pcvz.com/Program/Programs/Index.html98 算法源码吧 https://www.sfcode.cn/99 codegurn https://www.codeguru.cn/100 得益网 https://www.netyi.net/101 中国eclipse社区 https://www.eclipseworld.org/bbs/102 项目管理者联盟 https://www.mypm.net/103 栖息谷 https://www.21manager.com/","link":"/notes/Website/"},{"title":"iPhone","text":"故事的开始","link":"/notes/iPhone/"},{"title":"融贝三周年","text":"三周年庆典🎉","link":"/notes/3year/"},{"title":"2018创业记：如何选择合伙人？","text":"创业路上危机四伏，如何破局？ 很多朋友在2018年做出了改变，迈出了新的一步。比如身边几位朋友正摩拳擦掌准备创业。然而，看别人创业和自己创业完全是两回事儿，见得再多，自己趟水时也难免有所顾虑。 在跟他们聊过之后，我们发现了他们普遍面临的一个课题：如何选择合伙人?这是身经百战的连续创业者也很难驾轻就熟的一个课题，今天我们就来一起聊聊。本文将从能不能和朋友一起创业、合伙人应该与我互补还是相似、如何判断双方是否志同道合、如何应对常见的分歧几个部分展开来说。 风物长宜放眼量，抱持开阔的胸襟、敏锐的判断、坚韧的意志，相信大家能够与志同道合的伙伴一起，越过山丘，携手站上梦想之巅。 能不能和朋友一起创业？在创业初期，创业者选择合伙人往往会从身边的朋友“下手”。 一起创业可以说是认清一个朋友的最好方式。一篇名为《友谊的代价》的论文，考察了3510个风险投资者，以及他们在1975-2003年间11895个投资项目。 论文写道，有的人选择与自己能力相当的人合作，比如同是名校毕业；但更多的人选择与自己的熟人合作，比如曾经的同学或同事。结果表明，按能力搭档可以增加投资的成功概率，而找熟人搭档，则会明显降低成功的可能性。 所有人都喜欢强联系，但关系是关系，工作归工作。现在社会学已经有了足够多的证据说明：对工作来说，同乡会和校友录并不是扩展人脉的好地方。《中国合伙人》这部电影上映后，“千万别跟好朋友合伙开公司”也成了热议话题。电影的最后，三位合伙人分道扬镳，而剧本的原型——新东方的三位创始人也以“分家”收场。 当然，朋友合伙创业成功的案例也不在少数，况且，长期的伙伴关系更有助于共同面对创业过程中的艰难险阻，团队也更容易在创业初期获得投资人的青睐。如果在寻找合伙人的过程中，你觉得还是某个朋友更适合，那么一定要在合作之前约法三章，考虑到最坏的情况，提前用书面合同的方式确定双方的责权利，用规章制度来约束指导双方的行为，而不是靠人情关系。 中间一旦觉得发生了问题，你就必须考虑一下能否继续合作下去。其实，很多合作者走不到最后就是因为中间的小问题没有解决，一点一点积累最后爆发出来。 因此，能否和朋友一起创业这个问题，需要辩证思考。如果朋友间相互了解对方的个性和能力，工作中能做到分工明确，用规章制度来规范双方的行为，及时解决小矛盾，相互照顾，一起分担，共同奋斗，那么创业成功就会成为大概率事件。 合伙人应该与我互补还是相似？一个较为合理的答案是：理念和价值观上要相似，能力和经验上要互补。 理念和价值观上的相近，可以保证你们在重大原则问题上的判断是比较一致的，不至于出现根本性的冲突。这些重大的原则问题包括企业的战略方向、利益分配机制、做事的基本底线等等。 在这些问题上出现不同意见，通常很难取得共识。因为个性和价值观的形成，通常都不是一朝一夕的事情，也就是我们常说的“江山易改，本性难移”。如果在创业的艰难环境下，双方还要来磨合这个层面的东西，就会非常痛苦。 能力和经验上的互补相对更好理解。你擅长产品，他专于研发；你有丰富的运营经验，他则对于商业模式的建立更有心得；你对数字不敏感，他则是投资和财务领域的资深人士。这些都是很好的互补。 互补可以让你们在具体事情的推进中事半功倍，并建立起对于对方在专业领域的依靠和信任。人不可能是全能的，如果一切未知的领域都需要你自己来摸索，费时费力不说，风险还很大。 对于相似还是互补这个问题的解读，还可以反向进行。比如你们是能力经验上的相近，而在理念上互补，你可以想象一下是个什么局面，一定是你不会的他也不会，你觉得对的他觉得不对，那就真的很难合作下去了。 如何判断双方是否志同道合？对于这个问题，不同的人可能会给出非常不同的答案。雷军就曾说过，他找人有两个要素：“一要最专业，小米的合伙人都是各管一块，这样能保证整个决策非常快，把业务交给他，要能实打实做出成绩来；二要最合适，主要是指要有创业心态，对所做的事要极度喜欢，有共同的愿景，这样就会有很强的驱动力。” 雷军说，他在三个月的时间里见了超过100位做硬件的人选，终于找到了负责硬件的联合创始人周光平博士，两人第一次见面就谈了12个小时。 而周鸿祎表示，他会选择具备这四种素质的合伙人：首先应该有创业精神；其次要有很强的学习能力；第三，要有很好的开放合作心态；此外，还要能自我激励，自我驱动，同样一件事，用打工的心态和用创业的心态做，效果完全不一样。 虽然答案因人而异，但仍然可以总结出一些判断标准，以下几条可为你选择合伙人时提供参考。 1、关系有一定的深度和广度，彼此信任共事且维持朋友关系多年的创业团队关系更深，有可能经受住紧张和冲突的考验。合伙人未必需要成为最要好的朋友，但如果他们相互喜欢的话事情可能会更好办些。更重要的是，创始人之间应该尊重彼此以及他们给团队带来的不同能力。不信任合伙人的能力会导致手伸过头，还可能会导致控制权之争。在这种窝里斗的情况下大部分的合作关系都无法维系。 2、了解彼此的优势和劣势，分工明确尊重彼此的技能和优势并不意味着创始人就不需要审视合伙人的弱点了。友谊更久自然也会更了解某人的特长和技能。这些不同的技能有助于创始人团队自然地分清责任、角色，在某些情况下还可以分清头衔。根据每一位合伙人的技能明确划分职责，对创业的帮助很大。做事的时候每个人要有独立的角色，但同时永远要对其他合伙人的反馈持开放态度。 3、确保所有合伙人对成功和失败的定义一致韧性最强的创始人不会从财务的角度去衡量自己的初创企业是否成功，相反，他们会从使命的角度去衡量。他们的初创企业只是追求实现使命的手段。但是，并不是所有的创始人都这么看，甚至一开始关注使命的创始人有时候到后面也会转向考虑财务方面的事情。 有的创始人可能志存高远，为了尽快做大愿意烧很多钱，而有的人希望逐步打磨产品，限制人数规模和保留现金尺度。不仅对成功的认知会影响运营决策，对失败的认知同样会起作用。 在创业过程中，其中一位合伙人急着退出的故事屡见不鲜，因此这个教训值得一提再提。对于拥有成功企业的创始人来说，避免在这个问题上发生冲突的关键是定期讨论这件事。应该在公司早期就设定好目标，并且对这个话题进行定期复议。 4、所有合伙人均应对股权分配满意哈佛教授Wasserman发现，73%的联合创业团队一般在公司成立30天内就确定了如何进行股权分配。股权分配当然是任何共同创业的人都要首先考虑的事情之一，但事实上在那个时候，没人知道谁干活最卖力，谁对初创企业的贡献最有价值。过早确定股权分配会导致后面发生问题。如果可以的话，最好等到你有机会了解大家一起工作会是什么个情况后再正式分蛋糕。话虽如此，这件事情还是不要拖太久，围绕股权的分歧最好在公司早期就解决掉。 5、永远要相互支持这话听上去似乎太空泛，但是合伙人的关系也可能会反复无常，尤其是在受到不同观点、董事会成员等的影响下。合伙人之间的相互支持可带来信心，确保合伙人和员工都有共同的使命感。 团队应该早点理解一件事，任何情况下合伙人之间都应该背靠背相互支持，所以合伙人要尽量避免当着员工、董事会等人的面互相拆台，这样能够让公司其他人感觉到他们友情之牢固，让每一位合伙人都能保持镇定，因为他们知道对方一定会支持自己的。 如何应对常见的分歧？1、公司走向的歧见在0到1的探索期，公司的走向往往是由合伙人一起决定的。但进入1到100的扩张期，一个年轻企业通常会开始有董事会以及重要的供应、通路伙伴。久而久之，合伙人对于公司未来走向的看法，常常会越来越变得分歧。 防范这个陷阱要从根源开始：每当CEO有了新的资讯、成长、学习、领悟，应该积极地与合伙人分享，协助他们获得与你类似的成长。同时，你应该把小范围的决策授权出去，让他们也能继续主导公司某一部分的走向。最后，你应该积极管理大家对决策的期望值，新创公司必须在“快”与“好”之间做出平衡，因此决策求的是多数对，而不是样样对。 2、无法适应制度0到1的新创团队求快，因此不会有太多制度。进入1到100阶段，公司势必要开始建立一些管理系统，以在风险与发展中间取得平衡。 有些习惯了说干就干的合伙人，在此时会产生严重的不适应，时间一长甚至会觉得公司背离了创办的初衷。要解决这个问题，除了及早发现及早辅导外，请他们参与、主导制度的设计，也是协助合伙人适应新制度的方法。 3、越权管理当公司开始有部门、部门主管，合伙人还是习惯看不顺眼就管，容易造成经理人的困扰。更有甚者，造成合伙人对经理人不信任，反而让经理人没有足够的时间、空间去适应、学习。这个问题通常是惯性使然，重点就是要打破它。所以，看到这样的行为要赶快提醒伙伴们注意。 4、无法跟上公司成长的需要在公司快速扩张期，一个3人产品团队可能在一年内成长为30人，而两者之间管理上的不同，常常会让本来擅长技术、产品，但从来没有管理中大型团队经验的合伙人一时间跟不上公司发展的步伐。 回到扩张前，你应该早早找到好的CTO Mentor，在扩张中，经常鼓励他在管理知识与能力上精进。扩张后，如果他真的无法适应，也比较能够接受去寻找更有经验的CTO，而自己退居部门二把手、三把手。 5、利益分配当公司越来越成功、越赚钱、离IPO越近，股权与利益的问题就会越容易产生。尤其当初的股权分配如果没有彰显每个合伙人的相对价值，那团队中可能酝酿出不良情绪。 比较好的方法当然是早期就把这个问题解决掉，因为到了后期，你的工具会越来越有限。但也不是没有机会修正，如果有合伙人离开，你可以收回他的股权来重新分配。如果有B、C、D轮增资，你可以跟投资人要求“期权池”(ESOP)，通过发放新的选择权来平衡。最后，如果真的过于集中，负责任的CEO，甚至会拿出自己的股权分配给伙伴们。 选择合伙人未必有一定之规，创业路上可能遇到的危机也远远不止上述这些，希望这篇文章能对你有所裨益，助你在创业路上少走弯路，也祝愿创业者们在2018年博得好彩头，大鹏一日同风起，扶摇直上九万里。 本文来源：联想之星","link":"/notes/chuangye/"},{"title":"月薪多少能撑起一个家？","text":"","link":"/notes/beijing/"},{"title":"领信 APP","text":"","link":"/notes/linktrust/"},{"title":"读书","text":"酒仙桥到立水桥的距离，一辆公交车。至此时此刻，我已经在上下班的路上看过三本书了，它们是《幸福了吗》《看见》《拖延心理学》和《美国记忆冠军》。我很庆幸没有浪费这段宝贵的时光，同时我也在思考，他们给了我一些什么？我又是否体现了它们的价值？看书不记书的我，还得要斥责自己呐，我享受这车上的时光，不觉得时间流淌。还是要去记一点吧，白岩松的《幸福了吗》我记忆深刻的是九一一后一段故事，作者当时作为媒体人一种敏感。","link":"/notes/kindle/"},{"title":"中国合伙人","text":"请输入要阅读的密码。 Incorrect Password! No content to display! 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","link":"/notes/partner/"},{"title":"告别","text":"告别工作多年的公司，我要去新的地方了。","link":"/notes/juanshi/"},{"title":"Mac 技巧","text":"2015年1月14日 微软雷德蒙德公司总部，这里即将召开一场关于 WIN10 系统的发布会。然而微软新任CEO 萨蒂亚·纳德拉 却铁青着脸望向台下。毕竟，几乎被淹没在媒体记者身前各种各样发光苹果 Logo 之中的微软发布会，俨然成为了一个免费的苹果广告。 MacBook 系列笔记本之所以成为办公人士的心头宠，除了极具科技和美感的设计，主流的硬件配置之外，高效的 Mac OS X 系统才是提高生产力的关键所在。 Option + Shift +调节音量亮度mac通过音量键或者亮度键就可以简单快速的调节，但是每次一大格一跳，两者之间跨度对某些场景来说还是间隔有些大，比如在静音环境的时候想要稍微开一些音量却不想影响他人，此时你可以试试按住Option + Shift然后配合音量键，你会惊奇的发现，音量亮度会以1/4格的差距进行调节 调整窗口大小调整窗口大小的同时按住Option + Shift键将会使整个事物一次成比例地增长和缩小。的同时按住Option + Shift键将会使整个事物一次成比例地增长和缩小。 电源提示音 激活的方法很简单: 打开应用程序 - 实用工具 - 终端. 输入如下的命令: 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool true; open /System/Library/CoreServices/PowerChime.app &amp; 然后回车, 再试试充电是不是就有提示音了? 如果你不喜欢日后也可以取消命令行如下 1defaults write com.apple.PowerChime ChimeOnAllHardware -bool false;killall PowerChime 关闭任务 Command + Option + Escape 使用这个技巧会比自己在每个麻烦的应用程序上右击更快。 Launchpad中不显示App图标 在终端重启Launchpad 第一步 rm ~/Library/Application\\ Support/Dock/*.db第二步 killall Dock OK。 mac Zip 加密 最通俗的用法 1zip -q -r -e -m -o [yourName].zip someThing -q 表示不显示压缩进度状态 -r 表示子目录子文件全部压缩为zip //这部比较重要，不然的话只有something这个文件夹被压缩，里面的没有被压缩进去 -e 表示你的压缩文件需要加密，终端会提示你输入密码的 // 还有种加密方法，这种是直接在命令行里做的，比如zip -r -P Password01! modudu.zip SomeDir, 就直接用Password01!来加密modudu.zip了。 -m 表示压缩完删除原文件 -o 表示设置所有被压缩文件的最后修改时间为当前压缩时间 当跨目录的时候是这么操作的 1zip -q -r -e -m -o &apos;\\user\\someone\\someDir\\someFile.zip&apos; &apos;\\users\\someDir&apos; 截图Command + Shift + 3 捕捉整个屏幕。Command + Shift + 4 将捕获显示的自定义部分。 分割视图布局 Split Screen分屏功能这依旧是一条提升生产力的功能，习惯一个屏打开IDEA，另外一个开着Google，对于没有外接显示器来说我们可以使用Mac自带的分屏来实现（有的软件可能不支持） 使用方法: 左键按住一个程序左上方绿色最大化按钮不动，这时会让你选择当前选中App会出现在哪一边，可以是左边也可以是右边，排好之后再点击另一个App就会出现在另一侧，这样一来，同一屏幕中就同时有了两个App的界面。中间有一条分隔线，拖动分割线可以重新划分左右的区域大小，可以让你的注意力更集中在某一方面 Xcode 和模拟器分屏需要在终端实现以下命令 1defaults write com.apple.iphonesimulator AllowFullscreenMode -bool YES 选项卡或窗口之间切换不使用鼠标的情况下在选项卡或窗口之间切换。在不同应用程序之间切换：Command + Tab在相同应用程序的多个窗口之间切换：Command + ~ 要在同一个浏览器窗口中切换标签，实际上有两种方法： Command + Option +前进/后退箭头 Control + Tab通过标签向前移动，Control + Tab + Shift向后移动标签。 去格式粘贴复制文本内容的时候经常会带格式（字号、颜色、字体，有时候还有看不见的代码），手动调整会很麻烦， 使用方法： Command+CCommand+V –&gt; Command + Shift + option + V 通过以上方法就能快速的丢弃原有的格式属性，使其与当前文本格式保持一致 3、应用程序“接力”例：“电脑上复制，手机上粘贴”的通用剪贴板，是不是很NB 条件：1、所有设备均使用同一 Apple ID 登录 iCloud2、所有设备均已开启蓝牙3、所有设备均已开启 Wi-Fi 打开接力手机：设置–&gt;通用–&gt;接力 MAC：系统偏好设置–&gt; 通用 –&gt; 允许在这台Mac和iClould设备之间使用“接力” 打开iCloud手机打开iCloud：设置–&gt;头像–&gt;iCloud电脑打开iCloud：系统偏好设置–&gt; iCloud","link":"/notes/macbook/"},{"title":"机械键盘","text":"工欲善其事必先利其器! 废话不多说, 总结下XCode快捷键: 关于以上技术符号是如何打出来的, 也有一个快捷键:⌃⌘spacing 即可唤出 特殊符号界面 也可以参考下面链接中的方法:链接 偏好设置: ⌘, 隐藏Xcode: ⌘H 隐藏其他应用: ⌥⌘H 退出Xcode:⌘Q 新的表单: ⌘T 新的表单 新的窗口: ⇧⌘T 新的文件: ⌘N 新的工程: ⇧⌘N 新的组文件夹: ⌥⌘N 新的组文件夹 添加文件: ⌥⌘A 打开: ⌘O 快速打开: ⇧⌘O 关闭窗口: ⌘W 关闭所有窗口: ⌥⌘W 关闭表单: ⌃⌘W 保存: ⌘S 保存所有: ⌥⌘S 另存为: ⇧⌘S 提交: ⌥⌘C 更新: ⌥⌘X 更新全部: ⌃⌥⌘X 撤销: ⌘Z 恢复: ⇧⌘Z 剪切: ⌘X 赋值: ⌘C 粘贴: ⌘V 全选: ⌘A 在工作空间查找: ⇧⌘F 在工作空间查找并替换: ⌥⇧⌘F 查找: ⌘F 查找并替换: ⌥⌘F 查找下一个: ⌘G 查找上一个: ⇧⌘G 视图 工程: ⌘1 结构: ⌘2 查找: ⌘3 事务: ⌘4 测试: ⌘5 状态: ⌘6 断点: ⌘7 日志: ⌘8 显示或者隐藏导航条: ⌘0 显示或者隐藏导航条 标准视图: ⌘↩︎ 辅助视图: ⌥⌘↩︎ 版本视图: ⌥⇧⌘↩︎ 显示相关项目: ⌃1 显示相关项目 显示浏览历史: ⌃2 显示浏览历史 显示顶层项目: ⌃4 显示顶层项目 显示组内文件: ⌃5 显示组内文件 显示文件项目(查看属性, 方法, 函数等): ⌃6 14.gif 显示或隐藏控制台: ⇧⌘Y 在导航栏中显示: ⇧⌘J常常配合⇧⌘O使用, 先用⇧⌘O查找相关文件, 然后使用⇧⌘J定位到文件相应的位置 在导航栏中显示 在辅助窗口打开当前文件: ⌥⌘, 光标焦点移动: ⌘J 翻到下一页: ⌃⌘→ 辅助窗口翻到下一页: ⌃⌥⌘→ 复杂的翻到下一页: ⌃⌥⇧⌘→ 复杂的翻到下一页 翻到上一页: ⌃⌘← 辅助窗口翻到上一页: ⌃⌥⌘← 复杂的翻到上一页: ⌃⌥⇧⌘← 跳转到光标所在位置: ⇧⌘L 跳转到定义: ⌃⌘D先将光标放在需要跳转的类, 方法, 函数等上面, 然后按⌃⌘D, 跳进去看, 相当于按住⌘键点击鼠标左键 跳转到.h或者.m文件: ⌃⌘↑, ⌃⌘↓ 跳转到具体哪一行: ⌘L 跳转到下一个占位: ⌃/ 跳转到上一个占位: ⌃? 跳转到上一个占位 Xcode全屏: ⌃⌘F 代码右移: ⌘] 代码左移: ⌘[ 代码上移:⌥⌘[ 代码下移:⌥⌘] 注释光标所在行: ⌘/ 折叠当前代码块: ⌥⌘← 打开当前代码块: ⌥⌘→ 折叠所有代码块:⌥⇧⌘← 打开所有代码块: ⌥⇧⌘→ 折叠所有注释: ⌃⇧⌘← 打开所有知识: ⌃⇧⌘→ 运行: ⌘R 条件运行: ⌥⌘R 条件运行 测试: ⌘U 条件测试: ⌥⌘U 条件测试 配置测试: ⌘I 条件配置测试 条件配置测试 分析: ⇧⌘B 条件分析: ⌥⇧⌘B 运行编译: ⇧⌘R 测试编译: ⇧⌘U 配置编译: ⇧⌘I 编译: ⌘B 清除缓存: ⇧⌘K 清除编译文件夹中内容: ⌥⇧⌘K 停止: ⌘. 暂停: ⌃⌘Y 在当前行添加断点: ⌘\\ 激活所有断点: ⌘Y 清除控制台所有打印: ⌘K 条件编辑: ⌘&lt; 最小化: ⌘M 选择下一个表单: ⌘} 选择上一个表单:⌘{ 欢迎来到XCode界面: ⇧⌘1 来到设备界面: ⇧⌘2 API文档: ⇧⌘0 帮助查询: ⌘⇧? 查询选中: ⌃⌥⌘/ 快速查看选中: ⇧⌃⌘? 代码补全列表: ⎋ 移动到文本最顶端: ⌘↑ 移动到文本最末端: ⌘↓ 左移: ← 向右逐字移动并选中: ⇧→ 向左逐字移动并选中: ⌃⇧B, ⇧← 向上: ⌃P, ↑ 向下: ⌃N, ↓ 移动到段首并选中: ⌃⇧A 向右逐词移动并选中: ⌃⇧→ 向左逐词移动并选中: ⌃⇧← 向右节点选中: ⌥⇧→ 向左节点选中: ⌥⇧← 移动到文档最顶端并选中: ⇧⌘↑, ⇧↖︎ 向下移动并选中: ⌃⇧N, ⇧↓ 向前逐词选中: ⌃⌥⇧F 向后逐词选中: ⌃⌥⇧B 向前逐词移动: ⌥→, ⌃⌥F 向后逐词移动: ⌥←, ⌃⌥B 移动到行首: ⌃A 移动到行尾: ⌃E 移动到文档最末端并选中: ⇧⌘↓, ⇧↘︎ 向上分页选中: ⇧⇞ 向下翻页选中: ⇧⇟, ⌃⇧V 向后逐词移动: ⌥← 右移: → 移动到行的最右端并选中: ⇧⌘→ 向上逐行移动并选中: ⇧↑, ⌃⇧P 向右逐词移动并选中: ⌥⇧→ 向左逐词移动并选中: ⌥⇧← 向后逐词移动: ⌃⌥B 移动到行的最右端: ⌘→ 向后移动: ⌃B 向前移动: ⌃F 移动到行的最左端: ⌘← 向下翻页(光标移动): ⌥⇟, ⌃V 向上翻页(光标移动): ⌥⇞ 向下翻页(光标不移动): ⇟ 向下翻页到最底端: ↘︎ 向上翻页(光标不移动): ⇞ 向上翻页到最顶端: ↖︎ 逐行向上: ⌥↑ 逐行向下: ⌥↓ 删除整行: ⌃K 向前逐词删除: ⌥⌦ 向后逐词删除: ⌥⌫ 向前逐节点删除: ⌃⌦ 向后逐节点删除: ⌃⌫ 向前删除: ⌦, ⌃D 向后删除: ⌫, ⌃H 颠倒位置: ⌃T 颠倒位置 插入新的一行: ↩︎ 插入新的一行并顶到最前端: ⌃↩︎","link":"/notes/jianpan/"},{"title":"培训","text":"入职培训","link":"/notes/training/"},{"title":"programming","text":"红牛陪伴！","link":"/notes/programming/"},{"title":"为什么成为一名程序员这么难？","text":"有人说，每个看起来与正常人无异的工程师，其实都是在学习程序开发的途中熬过、压抑过、而且创伤过的反社会人士(sociopaths)。 在学习程序开发的过程中，常常看到网络上的「甘苦谈」，也听过身边前途一片光明的工程师朋友们分享过学习历程，总觉得不同的人、同样的故事却不断的重复，像是狼叫声般，从远处传来一声又一声的回响。 最近读到Erik Trautman在Viking Code School部落格中的文章《Why Learning to Code is So Damn Hard》，文章里将学习写程序(Learn to Code)的过程分成了四个阶段，并解释了两个影响各阶段形成的关键因素「资料密度」以及「知识广度」，最后集合成这张图： 这篇文章很有趣也十分符合我所听闻的那些「工程师辛酸史」，因此决定将这四个阶段介绍给大家，希望程序初学者们在进入这条不归路之前，眼睛要放亮、计划要周详，清楚明白在前方等你们的是什么，做好完全心理准备吧! 接下来我将介绍从刚开始写程序到成为一名工程师，Erik Trautman所归类必经的四个阶段： 想成为工程师，请做好准备迎接这段必经之路 先假设你学写程序的终极目标是要靠这行吃饭––进入相关领域工作或是自行创业，你是否做好万全准备可以从你的信心(Confidence)跟能力(Capability)散佈图中看出： 随着你具备的知识跟技能越来越多，你的自信心也会随之而增减，最后达到能力够信心足的「Job Ready」点。在Job Ready前则可以分成四个阶段： 第一阶段：手牵手心连心蜜月期刚开始进入程序开发界的朋友们总是怀抱着远大的梦想跟抱负，这不能怪他们，毕竟一方面，大家小时候听多了「写程序很难」、「电脑科学很硬」这种传闻，从一开始就把不少人吓去念社会科学(…没有冒犯社会科学专业人士的意思);另一方面，「全民写程序」这项运动实在太成功，坊间许多工具跟学习平台让程序开发变得超好理解、上手容易，像是Codecademy、Treehouse、跟Code School等线上平台，或是麻省理工的Scratch语言、Google的Blockly等程序语言工具，成功地营造了人人都能写程序而且靠这行吃饭的假象形象。 突然间我们的问题不再是「困难度」，而是「比天高的期望」跟「比地大的梦想」。 最重要的是，以上提到的这些工具跟平台实在太有用，带领毫无程序开发经验的初学者们一步步认识变数、条件语句、程序语法。当你一路过关斩将把程序语言基本逻辑跟语法学会的同时，你就会超有成就感、自信心大增，开始有「原来我也行嘛」、「写程序也不过就这样」的感觉，基本上觉得自己已经跟「工程师」相差不远了。 这个阶段将充满喜悦与成就感，在各种线上工具、网络教学的帮助下，你享受着用指尖下指令、电脑就能准确执行的主导感，你赞叹着程序语言的神奇与强大之处，从Hello World到简单回圈，每完成一道练习题你的成就感又增加几分，很多人会在这个时候认为自己已经爱上了电脑科学(而且觉得电脑科学也爱他们)，正处于能力提升，自信心也大增的「蜜月期」，这时你可能会觉得世界真美好、人生大概就会从此飞黄腾达，但我得残酷的告诉你： 这段旅程才刚开始而已。 第二阶段：困惑之崖就跟大部份的情侣/新婚夫妻一样，蜜月期会结束，你会慢慢发现「相爱没这么简单」。 作业难度一增加(重点是程序码长度也会跟着增加)，程序错误警告就频频出现，开始不停的除错(Debug)。而且通常最大的挑战是––当错误出现时，你根本不知道错在哪里、该问什么问题。你的学习进度在这个阶段开始停滞不前，像路走到一半突然遇到悬崖而无路可走般，开始对之前的认知感到困惑，跟着信心大失。 通常这个阶段会在你完成线上的基础教学后发生。以制作个人网站(Portfolio Website)为例好了，W3 School平台提供了一系列HTML、CSS、JavaScript等网页制作相关的程序教学，让初学者一单元一单元的学习语法跟功能，每单元还有例子示范用法，看似好简单!全部跟着学一遍之后，你准备好动手打造自己的网站，打开文字编辑器，……，然后写没两行就卡关了。 也许靠Google搜寻可以让你撑到完成网站基本架构，但当你想实现自己的创意、加上个人化的设计时，网络上的回答跟示范总是和你心里所想的不太一样，所以程序码不能全抄，然而左拼右凑出的程序码看似可行但实际上差得可远了!偏偏还不知从何debug起，可能投资了大半的时间程序码还「有减无增」，毫无进展可言。 这是一个尤其挫折的必经阶段，想成为Programmer就必须经历这个关卡，勇敢跳下悬崖、逼自己展翅高飞(当然在这个阶段摔死的小雏鸟数量十分可观)。 但即使你消灭了无数的bug，终于完成了几个小专桉后，你也别高兴得太早，未来的路还是非常长远而且挑战性更高!对于想进入这行吃饭的人来说，「困惑之崖」通常是你决定是否全心全意进入这一行的转捩点，而当你投资所有的时间心力在写程序上时，你将进入最让人心灰意冷的第三阶段。 你可能会很好奇，到底为什么紧紧相连的第一阶段(蜜月期)跟第二阶段(困惑之崖)会差这么多?如果你也正在经历以上两个阶段，你要知道，造成阶段转换的原因跟你一点关係都没有，并不完全是因为你比别人笨或比别人不努力，而是因为「资源密度」改变的缘故。 因素1：资源密度Resource Density 在第一阶段中有提到，当零经验零基础的你开始学习写程序时，身边有着无数的资源跟工具等着你来运用。到Google搜寻打「Learn to Code」你会查到超多程序学习平台、教学文、教学影片、甚至经验谈，让你感到万分的亲切及温暖，其「手牵手心连心蜜月期」的称谓当之无愧。 然而到了第二阶段时，这些教学资源的数量将大为骤减，任何一个刚脱离初学者的程序学习者都能够证实我此言不假。初学者一开始遇到的障碍都是「一般常见问题」，教学文、教科书里就会注明了;后期由于作业难度以及个人需求，问题才渐渐复杂起来，要从Stack Overflow或是一些程序人的部落格中去找寻解题线索。一直到在你遇到的问题已经棘手到网络上根本找不太到线索的时候，你便进入了下一个阶段。 第三阶段：绝望沙洲要了解进入第三阶段的关键，就要了解另一项影响着各阶段变化的重要因素：知识广度。 因素2：知识广度Scope of Knowledge 「知识广度」也就是度过每个阶段你所必备的知识领域范围。刚开始时你需要吸收的知识很集中，不管用哪种程序语言、不管功能是什么，首先都要学会变数型态、宣告语法、回圈及条件判断式等等，这时随便请一个工程师教你都是一样的，因为「重要须知」就是这几点而已。 然而学完基本功后，你所需的知识领域会一下子扩展很多，像是开始学习物件导向或是着重演算法的效率，你会需要扎实的电脑科学背景来应付，而且每一个应用都可以牵扯出更多的变化…相信我，这不是几堂MOOC课程就能救得了你的。 在这个时期，万能的Google也只会丢给你更多你不懂的东西，根本查不到相关的线索!最糟的是你根本不知道你什么不知道。(You don’t know what you don’t know.)。于是「学也学不完、越学越不懂」的无力感排山倒海而来，进入最最难熬的第三阶段––「绝望沙洲」。 这个阶段顾名思义像是在横越沙漠般，是一段非常长且寂寞的旅程，让你有不知何年何月才能走出来的绝望感。在一望无际的沙漠里，根本搞不清楚东西南北，资料查了半天毫无斩获，还不时被海市蜃楼(错误资讯或看似可行的解决方桉)给误导，搞得灰头土脸、头昏眼花，在这个阶段晒死、渴死、绝望死的有为青年更是不计其数。 但只要在绝望沙洲里熬下去，接下来就会自在许多了!累积足够的经验，程序的错误就会大量减少、达到一定知识水准，就能准确判断问题的方向切入核心，工作效率因而有所增进，知识广度也会慢慢聚焦。等你拖着一身的疲惫终于走出这荒漠时，就进入了最后的阶段。 第四阶段：创伤后的恢复期踩着千万人的尸体成功横越了沙漠，你的自信心开始回升，Google功力也可以说是神人的等级。到了这个时候，Hacker News的新闻以及超硬的MOOC课程都不成问题，你也选定了某个程序语言跟框架来专研，而且有能力制作出可以正常运作的应用程序了。 但你心里深处总有着隐隐的不安，觉得程序能「用」但其实代码凌乱无章，工程师的头衔下其实是误打误撞进这行的半调子，虽然你似乎具备了一切就职条件，却总害怕面试官发现你根基薄弱的电脑知识…你正在经历「创伤后的恢复期」。 在飞越困惑之崖、横越绝望沙洲之后，你应该已经学会该学的、做了该做的，成为一个名符其实的工程师，却总觉得自已资质平庸根基不稳，虽然有成功打造出一个个专案而信心回升，但老是感叹自己与心目中「专业工程师」仍有一大段差距…，这些都是「冒牌者症候群」(Impostor Syndrome)在作祟! 在这创伤后的恢复期中，你可能会经常自我怀疑，但只要顺着这波效率提升信心也回升的潮流继续努力，在能力与自信达到一个程度时…恭喜你：You Are Job Ready! 来源：inside 作者：Jewel","link":"/notes/programmer/"},{"title":"1803的望京西","text":"1803的望京西，雨后的残云裹着斜阳，我眯着疲惫的双眼，抿嘴微笑，略带凉意的风吹过，此刻，就想这么走，一直走，走很久很久！","link":"/notes/wjx/"},{"title":"下雪了","text":"雪下的那么深，下的那么认真。","link":"/notes/xue/"},{"title":"Hexo+Github+Netlify部署个人博客","text":"Netlify 是一个提供静态资源网络托管的综合平台，提供CI服务，能够将托管 GitHub，GitLab 等网站上的 Jekyll，Hexo，Hugo 等代码自动编译并生成静态网站。使用github分支和netlify服务的方式部署hexo，搭建一套可跨平台、可多人写作,随时随地发布编辑文字,可被百度收录,可自定域名,免费HTTPS的博客系统！！ 什么是Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 更多基础知识可参考hexo官网，本篇文章的重点是介绍部署的技巧。如果已掌握hexo的基础知识，可直接跳到部署章节进行浏览。 安装安装hexo之前需要安装一下环境： Node.js Git 安装完node后由于npm是自带的，可能版本有些落后，需要先将自身升级一下。 1npm -g install npm 由于国内互联网环境，导致npm下载失败，可使用npm淘宝镜像cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 如遇到npm下载组件失败时，可使用cnpm进行下载，只需将npm替换为cnpm，下方代码将继续使用npm，请根据自身网络环境选择适合的使用。以上环境如果没有问题，下面就开始安装hexo了 1npm install -g hexo-cli 之后在命令行中测试输入 1hexo version 创建个人站点安装hexo完成后，接下来我们就该使用hexo来创建自己的个人站点了。 123hexo init &lt;folder&gt; #使用hexo命令在指定的&lt;folder&gt;文件夹下初始化创建一个博客项目cd &lt;folder&gt; #进入创建好的项目目录npm install #使用npm安装所需依赖。 新建完成后详细的目录含义以及配置教程，请参阅hexo官网文档的介绍本篇文章暂不赘述。上面代码执行完毕之后，我们就已经创建好了一个自己的个人博客了，下面我们只需要使用hexo的命令工具生成博客并用自带的服务器模块启动，预览下我们的博客。 123hexo clean #清理各种缓存和旧文件hexo g #生成静态文件hexo s #开启服务器预览 执行完 hexo s 后命令行窗口将提示您如下信息 123456789INFO Start processingWARN ===============================================================WARN ========================= ATTENTION! ==========================WARN ===============================================================WARN NexT repository is moving here: https://github.com/theme-nextWARN ===============================================================WARN It's rebase to v6.0.0 and future maintenance will resume thereWARN ===============================================================INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 其中服务器预览地址就是 http://localhost:4000/至此，我们的个人博客创建好了，下面我们就来进入部署环节。 部署进入这里才是我们的重点环节，因为对于hexo来说入门级的教程遍布满网，随便搜一下到处都是，但是涉及到一些关键的环节，或者是高级点的教程用法，就很少，官网文档也介绍的含糊其辞，以至于有些地方我们都搞错了用法，甚至根本就不晓得怎么去用。那么这里针对部署，我进行重点介绍，并且以我本身的博客实战部署经验为案例，来讲解hexo的高级部署方式，打造可跨平台，多人写作编辑文章，可CDN加速，可HTTPS，可百度收录，可自定义域名，无需备案，无需一分钱费用的部署方案。接下来我分步骤的跟大家来介绍我的部署方案。 什么是部署经过第一个章节，我们知道，当我们使用 hexo g 和 hexo s 命令生成并开启服务后，我们本地访问的测试域名实际是指向了我们当前目录下的 public 目录，也就是说 hexo g 命令生成的静态文件就是 public 目录下的文件，部署的过程就是将这个 public 目录下的文件放到我们的服务器上这样就完成了部署。 为什么选择netlify服务部署Netlify 有如下的功能: 能够托管服务，免费 CDN 能够绑定自定义域名 能够启用免费的TLS证书，启用HTTPS 支持自动构建 提供 Webhooks 和 API 使用 Netlify首先使用你的 GitHub 账号登陆 Netlify，登陆后进入空间管理中心，，点击New site from git按钮开始部署你的博客： 然后根据自己的托管平台，可以选择GitHub、GitLab或者BitBucket（这里以 GitHub 为例）： 点击GitHub之后会弹出一个让你授权的窗口，给 Netlify 授权后，就会自动读取你 GitHub 的仓库： 选择仓库后，Netlify 会自动识别到 hexo，并填入相关信息，这时候只要无脑点击 Deploy site就可以： 稍等一段时间就可以看到你的博客已经部署成功，并且给你分配了一个二级域名（先记下这个二级域名）： 如果你要绑定自己买的域名，就直接点击第二步Set up custom domain。添加自定义域名，先添加不带www的域名作为主域名，它会自动添加一个www.domain.cc重定向到domain.cc： 设置完，Netlify 会提示你去域名DNS解析处，修改域名的CNAME记录： 去你的 DNS 解析提供商里面，将 CNAME 记录值更改为 Netlify 给你的二级域名： 修改完，就可以看到 Netlify 状态更新： Netlify默认会启用 HTTPS，而且不能关闭，如果你没有证书，它会帮你去Let’s Encrypt申请免费的证书，当然你也可以自己申请证书，以阿里免费的 ssl 证书为例，下载证书证书时选服务器类型为Apache的证书，Netlify 配置填写如下： 自动化部署上面流程走完，其实已经可以自动化部署，只要 push 了代码，就会自动更新，你可以在下面地方查看部署的信息： 如果你不想用 Netlify 的服务，也可以用 [Circle][14] 的服务，它和 GitHub 关联，提供 CI 服务。你需要做的事在根目录下新建一个.circle文件夹，里面新建一个config.yml文件（注意把相关信息替换成自己的）： # Javascript Node CircleCI 2.0 configuration file # # Check https://circleci.com/docs/2.0/language-javascript/ for more details # version: 2 jobs: build: docker: # specify the version you desire here - image: circleci/node:7.10 # Specify service dependencies here if necessary # CircleCI maintains a library of pre-built images # documented at https://circleci.com/docs/2.0/circleci-images/ # - image: circleci/mongo:3.4.4 working_directory: ~/repo steps: - checkout # Download and cache dependencies - restore_cache: keys: - v1-dependencies-{{ checksum \"package.json\" }} # fallback to using the latest cache if no exact match is found - v1-dependencies- - add_ssh_keys: fingerprints: - &quot;你的 ssh key的fingerprints&quot; - run: git config --global user.email &quot;user@domain.com&quot; - run: git config --global user.name &quot;user&quot; - run: npm install - run: sudo npm install hexo-cli -g - save_cache: paths: - node_modules key: v1-dependencies-{{ checksum \"package.json\" }} # run tests! - run: hexo clean - run: hexo g - run: hexo d这时候，你只要提交代码到这个仓库，circle 就会帮你自动部署了。 手把手教你使用Netlify部署博客及部署自动化 hexo高级部署教程,利用github+netlify部署","link":"/blog/netlify/"},{"title":"石家庄","text":"再次来到这座城，当火车到达车站的时候，我才意识到我很久没有来过了。火车站具体的位置没有弄清楚，但是真的很气派的建筑，恍惚间以为是北京南站。市内公交（至少我坐的那路）比北京的要好，或许是新车的原因。晚饭和面对一桌的初次见面的人，我抿了十分之一杯白酒，却感觉晕乎乎的。此刻躺在宾馆的床上，微困。","link":"/notes/sjz/"},{"title":"Hexo front-matter 怎么写？","text":"Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true/false comment Icarus 主题开启文章的评论功能 true/false thumbnail 封面图 Icarus 主题有效 url feature 封面图 Gridea 主题有效 url password 加密 hideInList 列表中隐藏 true/false published 发表 true/false tags 标签（不适用于分页） toc 开启目录 true/false categories 分类（不适用于分页） permalink 覆盖文章网址 link 点击文章跳转地址","link":"/blog/front-matter/"},{"title":"小米","text":"昨天，接到了小米的电话，这个刚刚满二十岁小伙子说自己有些感到孤单，我半开玩笑的说：去谈恋爱吧。二十岁，一个多少人羡慕的年龄，我在二十岁的时候，还在象牙塔中读书，小米已然工作了一年。话语中他流露出与社会间的不完全融入，苦了他了。惭愧的是我写下这段文字的时候，我并没有能够给他足够的可行性建议，更多的是一个倾听者。我感谢他能在不如意的时候想到我，","link":"/notes/xiaomi/"},{"title":"WWDC 2014","text":"Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose。 谨记自己总会死去，是让自己避免陷入“人生有所失”思考的最佳方法。","link":"/news/2014/"},{"title":"告别","text":"告别工作多年的公司，我要有自己公司了。","link":"/notes/cym/"},{"title":"WWDC 2015","text":"I think the greatest value of learning how to think…. I think everybody in this country should learn how to program a computer, should learn a computer language, because it teaches you how to think, it’s like going to law school, I don’t think anybody should be a lawyer, but I think going to law school may actually be useful coz it teaches you how to think in a certain way. In the same way the computer programming teaches you in a slightly different way how to think… And so … I view computer science as a liberal art. It should be something everybody takes in a year in their life, one of the courses they take is, you know learning how to program. ——– Steve Jobs 我认为学习思考最大的价值在于… 我觉得所有美国人都应该学习编程，学习一门编程语言，学习编程教你如何思考，就像学法律一样，学法律的人未必都成为律师，但法律教你一种思考方式。同样编程会教你另一种思考方式，所以我把计算机科学看成基础教育，是每个人都应该花一年时间学习的课程。 ——– 史蒂夫·乔布斯","link":"/news/2015/"},{"title":"WWDC 2016","text":"There’s a phrase in Buddhism, ‘Beginner’s mind.’ It’s wonderful to have a beginner’s mind. 佛教中有一句话：初学者的心态：拥有初学者的心态是件了不起的事情。","link":"/news/2016/"},{"title":"DDoS（分布式拒绝服务）攻击是无解的吗？","text":"“ DDOS？ 一言难尽啊！ ” 先说结论，DDoS是近年来网络攻击中的一棵“常青树”，的确很难缠，但说它是无解的，那也有点太看得起它了。虽然DDoS在对很多大平台的攻击中出尽了风头，但在现在互联网的解决方案中，并不缺乏应对DDoS的解决方案。 说起DDoS攻击，我脑海里能够想到的全都是中国民间俗语，什么“双拳难敌四手，好汉架不住人多”，什么“千斤拨四两”，什么“乱拳打死老师傅”等等等等。 之前有朋友跑来问我DDoS是个什么东西，为什么这么多互联网巨头都被搞得没有脾气，我记得我当时我是这么举的例子： 我们这一代人小的时候，自助餐开始在中国内地风行，那会儿这个行业里为了打击竞争对手，对手最惯常使用的阴招是雇佣很多五大三粗的人，给他们钱去对方的店里一通猛吃，杯盘狼藉之下，用不了几天这家自助餐就能给吃黄了。 而DDoS攻击比这种还阴损，如果你开了一家餐馆，你的对手如果想搞你，最好的办法就是找一堆地痞流氓到你的店里坐的满满一屋子，你如果上前问，他们就一直跟你扯淡找麻烦，导致真正想吃饭的顾客一看这个情形，掉头就走了。 用不了多久，你的餐馆就会开不下去，而你的竞争对手就会趁机蚕食掉你的市场份额，而放在网络语境里，这就是DDoS攻击的最基本原理。 而这件事之所以难缠在于，一两个无赖根本成不了气候，想要耍流氓必须要有很多个无赖集结在一起。所以和现实世界中的无赖一样，DDoS真正的杀手锏在于利用能够发动的汹涌的流量，可以瞬间冲垮被攻击网站的服务器。 如果我们回溯一下历史的话，会发现黑客组织之所以会有组织有预谋的发起DDoS攻击，基本上都是基于以下几个原因： 有些行业如果网站被恶意攻击，会造成很难估量的损失，这个时候黑客发动DDoS攻击的初衷一般是出于敲诈勒索，为了保证企业的正常运转，他们通常愿意向黑客付高额的赎金； 行业内血海一片，DDoS是恶意竞争的屠刀。这个现象从逻辑上，其实雇佣无赖去占领对手餐馆的原理是一毛一样的，而且DDOS攻击早已产业化，现在中国的DDOS黑市，出钱请黑客打1G的流量到一个网吧或网站，市场价只要不到50块钱，但对于一个创业公司或者干脆就是一个小网吧来说，这已经算是可以灭顶的无妄之灾了。 DDoS攻击往往成为掩盖真实网络攻击的烟雾弹，在遭受DDoS攻击的企业中，部分企业还伴随数据丢失的现象，黑客利用DDoS攻击掩盖其窃取用户隐私的真实目的，这种攻击行为在社交网站、金融领域等用户隐私高价值的行业尤为高发。 比如说，去年年初的时候，荷兰第一大银行荷兰商业银行于2018年1月28日晚间遭到DDoS攻击；第二大银行荷兰合作银行的网银服务29日早晨遭到攻击；第三大银行荷兰银行在那一周内共遭到7次网络攻击，仅周末就有3次。 不过这一次发生在荷兰的针对银行系统的攻击并没有造成用户隐私的泄露，原因在于这仅仅是一次来自俄罗斯一个网络间谍组织Cozy Bear对荷兰情报组织AIVD侵犯其计算机的“单纯”的报复行为。但并不是所有黑客组织发起的DDoS攻击都如此单纯。 2018年年底时万豪酒店发布了一则公告，称其旗下喜达屋酒店的5亿人次的信息被泄露，共计3.27亿人，泄露信息包括姓名、邮寄地址、电话号码、电子邮件昂面地址、护照号码、出生日期、性别等等入住信息，更糟糕的是万豪无法确定，侵入酒店系统的第三方黑客，在窃取的信息中是否包含客人的银行卡号和密码。（此案例和DDOS攻击无关，建议采用其他案例，比如2011年4月20日至26日，索尼遭受DDoS攻击，目的是为了掩盖盗取索尼PS的用户数据。） 而游戏领域，则是DDoS攻击的另一个重灾区，不光是刚才前文中提到的暴雪，包括索尼、金山、网易在内的众多知名游戏公司都曾数次遭受攻击，可以说DDoS攻击是游戏企业的噩梦。 许多刚创业的游戏公司，可能刚上线就被打死，而一些处在融资阶段的游戏公司，由于遭遇攻击而被迫停服，则很大程度上会调低投资人的预期，甚至导致融资失败。 而这些因素，都是竞对打压或者敲诈勒索的绝对软肋。 从以上的几个案例我们不难看出，和现实中的耍流氓和敲诈勒索相比，通过网络手段进行攻击的风险和成本更低，坏蛋的嘴脸也更穷凶极恶一点，无论是政府机构还是企业平台，无论你是巨头还是小蚂蚁，只要你身上有羊毛可以薅，你都时刻面临着被洗劫的风险 不过刚在开头我也讲了，虽然DDoS很难缠很让人头痛，但本质上图并不是无解的。 回到我最开始讲的那个例子。 你是一个餐馆老板，过去三十年一直是个老老实实的厨子，突然面对五十个臭流氓到你店里耍无赖的时候，你最好的应对方法，应该是什么？ 自己组建一支人马，和这些臭流氓正面刚？这恐怕不行，因为你不是臭流氓，你没有相应的作战经验。 报警请人民警察来帮忙处理？这恐怕也不行，人家在你店里没有打砸抢，只是“温和的”非暴力不合作，警察来了也只能当民事调解，并且人家马仔众多，明天再换一拨新面孔来，玩的你一点脾气都没有。 这就是面对DDoS时，无论是巨头还是小蚂蚁，他们的实实在在的困境。 但正所谓“道高一尺魔高一丈”，你在云上和我耍流氓，那我就在云上回击。 “云”的事儿，不如还交还给云来处理。我认为就目前DDoS的在攻击量级上的疯狂进击的前提下，云计算服务厂商或许是狙击它们的最有效手段。 2018年年初，峰值1.35TB/秒的流量冲击了开发者平台 GitHub。这是第一次TB量级的DDoS攻击。GitHub 受到攻击后，服务器断断续续，无法访问。攻击发生 10 分钟后，GitHub 向CDN 服务商 Akamai 请求协助，访问 GitHub 的流量已经由后者接管并在15分钟之内完成了防御。 Akamai的相关负责人在接受采访时说，我们是基于迄今为止最大规模 DDoS 攻击五倍的峰值而做的相应准备，所以 1.3T 对我们来说是小意思。 在关于流量峰值这一点上，我认为饱受双11、双12、618等全民购物狂欢的电商巨头们更有发言权，就拿京东举例子好了。 京东云在之前发布的高防版的DDoS服务中，展示出了非常明确的信心是，在多年的电商狂欢流量对抗中，京东云已经在实战中建立了一套完备的防御机制，无论是在流量峰值的建模上，还是在DDoS的防御算法上，它的部署都远远不是纸上谈兵，而是拳拳到肉的经受住了实战的洗礼。要知道，全世界每年有超过5成的DDoS攻击都来自中国，而我们的国家也是全世界超过美国的第一大“肉鸡”市场，由电商大数据加持演化而来的京东云，它在云安全的理解上可以说是非常深刻了。 所以说，如果说一定要有一个结论，我想说“上帝的归上帝，而云上的归云上”，像京东云这样的基于电商大数据考验的云计算平台，或许才是对抗DDoS的最终答案。 原文链接👇","link":"/news/ddos/"},{"title":"2020年顶级编程语言的统计数据和调查结果如何？","text":"比较编程语言是一件非常复杂的事情，所以有许多图形插图/笑话试图象征编程语言 。 我发现很少，我正在开始这篇文章。 简单来说， 编程语言使人类能够指导和控制机器。 因此，很自然会有这么多语言试图使这个过程更加强大和简单。 由于这个原因，有数百种编程语言 ，其中许多编程语言现在已经不再使用，很少有将在未来几年过时，然后有一些语言将继续并证明其在未来几年的使用和然后有新的编程语言争取接受。 本文将介绍顶级编程语言的趋势，这些趋势将在2020年继续。 为了预测2020年 编程语言的趋势，本文根据编程语言使用来自真实调查 ，各种收集的统计数据 ，搜索结果和薪资趋势的数据。 本文将帮助新学习者选择一种编程语言进行学习和专家学习，这将有助于决定切换到另一种语言或继续使用他的专业语言。 在下一节中，我准备了两个表，总结了过去五年（2015-19）中编程语言的流行趋势。 该数据来自2015 - 19年的 Stackoverflow 人气调查 。 为了清楚准确地理解，编程语言分为两组，第一组是 2000 年以前诞生的语言，第二组是 2000 年以后诞生的语言。 选择2000作为边界只是随机的，但对于理解这两组的编程趋势非常有帮助。 该表还列出了这些编程/脚本语言的起源年份和主要或记录的目的。 语言 起源 2015年 2016 2017年 2018 2019 主要目的 Javascript 1995年 54.4％ 55.4％ 62.5％ 71.5％ 67.8％ Web开发，动态内容，客户端和服务器端 Java 1995年 37.4％ 36.3％ 39.7％ 45.4％ 41.1％ 企业应用 Bash/Shell 1971年至1979年 - - - 40.4％ 36.6％ 自动化和系统管理员 Python 1991年 23.8％ 24.9％ 32.0％ 37.9％ 41.7％ 一般用途 PHP 1995年 29.7％ 25.9％ 28.1％ 31.4％ 26.4％ Web开发，服务器端 C ++ 1980至1983年 20.6％ 19.4％ 22.3％ 24.6％ 23.5％ 一般用途 C 1972年 16.4％ 15.5％ 19.0％ 22.1％ 20.6％ 通用，低级编程 Ruby 1995年 8％ 8.9％ 9.1％ 10.3％ 8.4％ Web开发 R 1993年 - - 4.5％ 6.0％ 5.8％ 统计计算 Objective-C 1986年 7.8％ 6.5％ 6.4％ 7.3％ 4.8％ 一般用途 观察： 除了Python之外，从2018年到2019年所有语言的流行度都在下降。 PythonPython是自过去五年以来不断上升的唯一语言。 它是一种通用语言，因此有人希望在2020年只学习一门编程，并希望涵盖更多的软件开发领域，然后可以选择Python 。 JAVAJava正在上升但在2019年下降，原因是Kotlin在Android平台上获得了普及。 Java是编程语言的一个很好的选择，但现在它在Oracle下面 ， 谷歌正在推广Kotlin，因此它处于冲突区域。 事实上，由于其开发人员基础，框架和遗留应用程序，大量公司正在使用Java并继续使用Java 。 C / C ++C和C ++仍然保持着大约20％，并且由于其固有的功能和遗留系统，它将会存在。 JAVASCRIPTJavaScript受欢迎程度可归因于流行的JavaScript库和node.js等框架的增长.JS是动态网站的语言，由于其积极的开发， Mozilla的支持和惩罚，它将成为未来几年的首选。 图书馆和框架 。 所以，如果有人想要进行Web开发，那么javascript是必须的。 RR近年来越来越受欢迎，原因在于数据分析的增长和普及。 它被数据科学家使用，但与Python相比，它已经成为通用语言，并且拥有大量数据科学库和模块的活跃开发人员。 因此，如果他们必须只选择其中一个，那么人们可以更喜欢Python而不是数据科学中的想要载体，那么学习两者都是一个不错的选择。 Ruby与PHP一样， Ruby也面临来自JavaScript甚至Python的激烈竞争，以建立后端Web开发编程语言。 所以，再次对于web开发javascript和Python （服务器端（Flask，Django等）将是一个不错的选择，并将提供比Ruby更多的域灵活性。 PHP在2019年 ， PHP流行度急剧下降，这可以追溯到服务器端对javascript和Python的接受程度。 因此，如果有人想要进行服务器端Web开发，那么PHP仍然是一个很好的选择，有大量流行的框架，如CakePHP ， Codeigniter等，否则选择通用编程语言会更好。 OBJECTIVE-C在Apple迁移到Swift语言之前， Objective-C是Apple软件（如MacOS ， iOS等）的主要语言。 因此，这种转变反映在两种语言的流行中，即Objective-C的受欢迎程度下降，而Swift的普及正在上升。 所以，如果有人想成为Apple产品的开发者，那么Swift应该是首选语言。 观察： SwiftSwift取代了Objective-C作为Apple相关软件和应用程序的主要语言。 由于苹果公司支持和推广它，因此自成立以来受欢迎程度越来越高，而Apple将继续使用它，所以如果有人正在寻找特定于Apple的开发平台，那么Swift将成为一种必须知道的编程语言。 这主要是供应商和产品特定的语言，在Apple的生态系统之外使用率非常低。 GoGo（Golang）越来越受到Google的维护，使用和推广。 Go开发的动机是解决对一些流行语言的批评，并在一个地方保持最佳状态。 自2017年以来， Go的受欢迎程度越来越高，并且在谷歌的支持下，它将在未来几年内享受到这一点。 谷歌也将Go作为新项目的主要语言并用Go取代其他语言，这种趋势在未来几年将变得有用和重要，因此人们可以选择Go作为一种新的编程语言。 KotlinKotlin作为Android开发的Java的替代品而被提供，并且它再次得到Google的支持和推广，因此近年来它也受到开发人员的欢迎并越来越受欢迎。 因此，随着Android的增长， Google的支持以及简洁的语法，它将成为Android 应用程序 开发人员的一个选择，是学习Android App 开发人员的不错选择。 Kotlin将成为Android 开发的杰出编程环境。 ScalaScala试图建立Java的替代品，但在开发人员中并没有得到很好的解决。 它没有来自任何跨国公司的大力支持，认为功能语言和对JVM的依赖并没有提供太大的普及范围。 可能会有稳定的增长，但速度很慢，而且肯定不是一种初学者学习的语言。 JuliaJulia旨在提高“C”的速度和Python的简单性，但奇怪的是，在Stackoverflow 调查中没有发现任何受欢迎程度，但在数据科学领域受到欢迎，并且从长远来看被视为R和Python的挑战者。 当然，朱莉娅会有增长，但仍然， Python或R更适合工作和成长。 C＃C＃是.NET框架的语言，由Microsoft开发。 它的受欢迎程度在过去几年中基本保持不变，并将继续保持类似的趋势。 这是特定于供应商的语言，因此如果想要在Microsoft开发环境中工作，可以选择此语言。 最近， 微软已开源.NET，因此会出现一些上升趋势，但它又是特定于供应商的，因此不会受到太大影响。 RUSTRust ， Clojure等是具有用户基础但不那么流行的语言，所以肯定不会有人气的上​​升。 一张图片说千言万语要了解顶级编程语言增长的明显趋势和图景，请通过各种图表来了解它。 图1和图2给出了一个非常清晰的图景，即在旧的语言堆栈中， JavaScript远远领先于其他人，并且信用在网络开发中占据了一席之地，然后C和C ++一起竞争非常接近Java 。 Python在受欢迎程度上越来越高，而且在过去的5年里，只有人气不断增加的语言。 新语言越来越流行，其中大多数语言都受到跨国公司以及微软 ， 谷歌和苹果等IT巨头的支持。 喜欢和想要的语言 从上面的表格和图中，很少有观察结果非常明显，Love of Rust在过去五年中正在增长，而Swift正在失去开发人员的热爱，而Python正处于这两者之间，过去两年中Python已经获益。 另一个独特的观察结果是，5种喜爱的语言中有4种来自2000后的群体，而只有Python是较旧的语言，而Kotlin的爱则是从2017年开始为Android 开发添加Kotlin开始的。 从上表可以看出， javascript和Python开发的愿望在过去几年中不断增长，这反映了人们对语言的热爱和热爱。 Java的数量急剧下降，这是因为Kotlin作为Android应用程序开发的替代品，以及现在拥有Java的Oracle改变了政策。 技术和编程语言 在这个图中，可以看到最大的集群用于Web开发和JavaScript ，其各种框架主导着集群，这是JavaScript增长的USP 。 第二大集群是Microsoft 技术和Python 技术 ，它再次清除了对该语言的欢迎和热爱。 Python集群与数据科学技术相关联，这些技术突出了Python的增长故事。 TIOBE 指数TIOBE索引排名编程语言基于搜索引擎搜索结果 。 搜索引擎和编程语言的选择在其页面中定义。 通过计算最受欢迎的搜索引擎的点击来计算评级。 使用的搜索查询是+“ programming”。 在TIOBE索引中， Java在过去二十年中占据主导地位，其中C在过去30年中一直保持着第一和第二的位置。 在过去的二十年里， Python已经走过了漫长的道路，即1999年的第24位，到2019年的第3位。如果有人合并C和C ++，那么它将永远占据第一的位置。 在新的语言（2000年后）中， Rust的排名上升，即从第33位升至第28位， Julia从第50位升至第39位。 值得注意的是， Kotlin似乎并未接近前20名。 编程语言（PYPL）索引的流行程度PYPL索引是通过分析在Google上搜索语言教程的频率创建的。 搜索语言教程越多，该语言就越受欢迎。 这是一个领先的指标。 原始数据来自Google趋势。 下图验证了前3种语言是Python ， Java和JavaScript 。 C＃，PHP，C / C ++也是安全的顶级位置，这种趋势再次类似于堆栈溢出和TIOBE索引 。上图显示，在新的编程语言中，即2000年后的Kotlin ， Go ， Rust和Julia在排名中上升。 就业市场与薪酬薪酬取决于产品的地理区域和需求，基于编程语言的薪资比较只是预测或估计薪资趋势的工具。 我们根据流行调查的编程语言汇总了工资，即2018年的Dice薪资调查和2018年和2019年的Stack-overflow调查。 从上表可以看出，从这两项调查中可以看出， Go/Golang 在市场上是一项薪酬非常高的工作，在2019年的Stack-overflow调查和2018年Salary Survey薪资调查中 ，甚至在高薪工作中排名第一。 现在，原因很简单， Go是谷歌支持的语言，主要用于谷歌和谷歌想要推广这种语言，所以高薪可以连接到谷歌工资单。 有一点很清楚，价格弹性是一个经济术语，它提供了不同的场景，例如产品数量增加，价格，奢侈品和品牌产品成本，高产品可用性降低了价格。 很明显，全球平均工资不是选择语言的好选择。 例如，一种接近灭绝的编程语言，但遗留系统很少，因此维护这些公司往往提供非常高的薪酬，但这些语言中的职位数量总是很少。 在其他情况下，主流语言提供了大量的工作岗位，因此平均工资下降。 因此，作为结束语，很容易预测语言趋势，但只选择一种语言来学习是一个非常困难的选择，完全取决于个人选择和他们未来的计划，例如，如果你想在Web开发中工作不能忽视Javascript ，如果你想使用Apple的产品你现在不能忽视Swift ，如果你的品味是系统级编程，那么C和C ++是你的朋友， Python让你在很多领域跑得更快，目前亲爱的数据科学 。 您会看到每种语言都会带您踏上不同的旅程。 选择目的地，然后使用该路径的语言进行驾驶。 -END- 转载声明：本文转载自「编码无限」","link":"/news/2020/"},{"title":"WWDC 2019","text":"Your time is limited, so don’t waste it living someone else’s life.…Don’t let the noise of others’ opinions drown out your own inner voice。 你的时间有限，不要浪费于重复别人的生活。不要让别人的观点淹没了你内心的声音。","link":"/news/2019/"},{"title":"WWDC 2017","text":"We think basically you watch television to turn your brain off, and you work on your computer when you want to turn your brain on. 我们认为看电视的时候，人的大脑基本停止工作，打开电脑的时候，大脑才开始运转。","link":"/news/2017/"},{"title":"WWDC 2018","text":"Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me。 是否能成为墓地里最富有的人，对我而言无足轻重。重要的是，当我晚上睡觉时，我可以说：我们今天完成了一些美妙的事。","link":"/news/2018/"},{"title":"HarmonyOS 鸿蒙","text":"鸿蒙，中国神话传说的远古时代，传说在盘古昆仑山开天辟地之前，世界是一团混沌的元气，这种自然的元气叫做鸿蒙，因此把那个时代称作鸿蒙时代，后来此一词也常被用来泛指称远古时代。 华为开发者大会于8月9日-8月11日举行，华为消费者业务 CEO、华为技术有限公司常务董事余承东以《全场景时代新体验与新生态》为题发表演讲，正式宣布自有操作系统：鸿蒙。据余承东介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。 根据余承东的说法，安卓有超过1亿行代码，内核就超过2000万行，但一般用户用到的代码不到8%，整体比较冗余，在IoT时代这既没必要也不需要。由此他提出了”微内核”的概念，也是鸿蒙OS的特点之一。区别于”宏内核”，微内核采用同一套操作平台，针对不同硬件能力的产品进行部署，并采用分布式架构，提升效率。 也就是说，手机和车载设备的用途不同，灌入同样系统无必要，但它们可以采用同样的内核，部署不同的界面或功能。余承东表示，希望未来的操作系统，都使用微内核。据介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。 余承东介绍了鸿蒙OS的四大技术特性。 首先，分布式架构首次用于终端OS，实现跨终端无缝协同体验。 鸿蒙OS的”分布式OS架构”和”分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。 第二， 确定时延引擎和高性能IPC技术实现系统流畅。 鸿蒙OS通过使用确定时延引擎和高性能IPC两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低25.7%。鸿蒙微内核结构小巧的特性使IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升5倍。 第三，基于微内核架构重塑终端设备可信安全。 鸿蒙OS采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。另外，鸿蒙OS将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。 第四，通过统一IDE支撑一次开发，多端部署，实现跨终端生态共享。 鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。 据介绍，华为将在今年首发的智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙OS会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。 原文链接👇","link":"/news/HarmonyOS/"},{"title":"木兰宽松许可证","text":"木兰宽松许可证， 第1版 2019年8月 http://license.coscl.org.cn/MulanPSL 您对“软件”的复制、使用、修改及分发受木兰宽松许可证，第1版（“本许可证”）的如下条款的约束： 0. 定义 “软件”是指由“贡献”构成的许可在“本许可证”下的程序和相关文档的集合。 “贡献者”是指将受版权法保护的作品许可在“本许可证”下的自然人或“法人实体”。 “法人实体”是指提交贡献的机构及其“关联实体”。 “关联实体”是指，对“本许可证”下的一方而言，控制、受控制或与其共同受控制的机构，此处的控制是指有受控方或共同受控方至少50%直接或间接的投票权、资金或其他有价证券。 “贡献”是指由任一“贡献者”许可在“本许可证”下的受版权法保护的作品。 1. 授予版权许可 每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的版权许可，您可以复制、使用、修改、分发其“贡献”，不论修改与否。 2. 授予专利许可 每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的（根据本条规定撤销除外）专利许可，供您制造、委托制造、使用、许诺销售、销售、进口其“贡献”或以其他方式转移其“贡献”。前述专利许可仅限于“贡献者”现在或将来拥有或控制的其“贡献”本身或其“贡献”与许可“贡献”时的“软件”结合而将必然会侵犯的专利权利要求，不包括仅因您或他人修改“贡献”或其他结合而将必然会侵犯到的专利权利要求。如您或您的“关联实体”直接或间接地（包括通过代理、专利被许可人或受让人），就“软件”或其中的“贡献”对任何人发起专利侵权诉讼（包括反诉或交叉诉讼）或其他专利维权行动，指控其侵犯专利权，则“本许可证”授予您对“软件”的专利许可自您提起诉讼或发起维权行动之日终止。 3. 无商标许可 “本许可证”不提供对“贡献者”的商品名称、商标、服务标志或产品名称的商标许可，但您为满足第4条规定的声明义务而必须使用除外。 4. 分发限制 您可以在任何媒介中将“软件”以源程序形式或可执行形式重新分发，不论修改与否，但您必须向接收者提供“本许可证”的副本，并保留“软件”中的版权、商标、专利及免责声明。 5. 免责声明与责任限制 “软件”及其中的“贡献”在提供时不带任何明示或默示的担保。在任何情况下，“贡献者”或版权所有者不对任何人因使用“软件”或其中的“贡献”而引发的任何直接或间接损失承担责任，不论因何种原因导致或者基于何种法律理论,即使其曾被建议有此种损失的可能性。 条款结束 如何将木兰宽松许可证，第1版，应用到您的软件 如果您希望将木兰宽松许可证，第1版，应用到您的新软件，为了方便接收者查阅，建议您完成如下三步： 1， 请您补充如下声明中的空白，包括软件名、软件的首次发表年份以及您作为版权人的名字； 2， 请您在软件包的一级目录下创建以“LICENSE”为名的文件，将整个许可证文本放入该文件中； 3， 请将如下声明文本放入每个源文件的头部注释中。 123456789101112Copyright (c) [2019] [name of copyright holder][Software Name] is licensed under the Mulan PSL v1.You can use this software according to the terms and conditions of the Mulan PSL v1.You may obtain a copy of Mulan PSL v1 at: http://license.coscl.org.cn/MulanPSLTHIS SOFTWARE IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULARPURPOSE.See the Mulan PSL v1 for more details. Mulan Permissive Software License，Version 1 (Mulan PSL v1) Your reproduction, use, modification and distribution of the Software shall be subject to Mulan PSL v1 (this License) with following terms and conditions: 0. Definition 1. Grant of Copyright License 2. Grant of Patent License 3. No Trademark License 4. Distribution Restriction 5. Disclaimer of Warranty and Limitation of Liability End of the Terms and Conditions How to apply the Mulan Permissive Software License，Version 1 (Mulan PSL v1) to your software To apply the Mulan PSL v1 to your work, for easy identification by recipients, you are suggested to complete following three steps: 123456789101112Copyright (c) [2019] [name of copyright holder][Software Name] is licensed under the Mulan PSL v1.You can use this software according to the terms and conditions of the Mulan PSL v1.You may obtain a copy of Mulan PSL v1 at: http://license.coscl.org.cn/MulanPSLTHIS SOFTWARE IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULARPURPOSE.See the Mulan PSL v1 for more details.","link":"/news/MulanPSL/"},{"title":"你的硬盘是如何存储数据的？","text":"链接：回形针PaperClip","link":"/news/harddisk/"},{"title":"关于知识产权、知识共享与文章翻译","text":"作者简介： 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：Python猫 一、缘起前不久，我在翻译 Guido van Rossum（Python之父）的文章时，给他留言，申请非商业用途的翻译授权。 过程中起了点小误会，略去不表，最终的结果是：他的文章以 CC BY-NC-SA 4.0 许可协议进行授权。部分对话如下： CC 协议是一种授权许可协议，我曾看到过几次，但了解不多，所以便查阅了相关的内容。 本文主要是作个记录，既是加深自己的理解，也给有需要的同学一个参考。 二、著作权、著佐权与自由版权对于知识产权，通常有如下几种说法： All Rights Reserved（保留所有权利） Some Rights Reserved（保留部分权利） All Rights Reversed（撤销所有权利） 注意最后一条的”Reversed”，它长得很像”Reserved”，但意思截然相反。 它们对权利的诉求由强转弱，从一个极端走向另一个极端。 有几个与此相关的概念： copyright，即版权、著作权 copyleft，即著作传、著佐权 copywrong，即反版权、自由版权 版权制度起源于十五世纪中期，那时西方发明了铅活字印刷术（古登堡，现代印刷术之父），出现了大量盗版，为了保护出版商的利益，政府出台了版权法。 此后版权法在世界各地普及，演化出了很多门类，它们普遍限定了一个有效期限，在此期限内，版权方受到垄断保护（即 All Rights Reserved ）。超出期限后，知识作品才会进入公共领域（public domain），才变成自由版权。 copyright 是一种限制性协议，有利于保护版权方的个体权益，但是也阻碍了知识作品的传播，不利于社会的公共利益。 我们经常会听到一个词”专利流氓”，说的就是版权被过度使用而造成的社会问题。举个例子，某家商业公司竟然曾”拥有”国旗国徽的版权。 copyleft 则是一种较为宽松的协议，对应的思想是 Some Rights Reserved（保留部分权利），使用者只要遵守少数的列明条款即可。 copyleft 之所以会译作”著作 传 “，因为有” 减少屏蔽，自由流传 “之义。 另外还翻译为”著 佐权”，也是一字之差，跟英文原词神似，非常有趣。 最后还有一个 copywrong（还有类似的”copyfree”、”copycenter”叫法），它属于另一个极端，无视版权，无拘无束。 copyleft 与 copywrong 都是对 copyright 的某种矫正，只是矫正的力度不同，总体而言，它们的目的都是促进知识作品的传播，增进整体的社会利益。 在互联网时代，它们随处可见（可能不直接用这些叫法），极大地促进了自由软件与开源社区的发展。 上图中的 6 种主流的开源许可证，你应该有所耳闻吧，在我们免费使用的各种软件或代码库中，很可能就藏着它们的身影。 右侧的 3 种（BSD、MIT、Apache）属于宽松式许可证（permissive license），对使用者几乎没有限制，接近于极端的 All Rights Reversed（撤销所有权利）。 左侧的 3 种（LGPL、Mozilla、GPL）则属于 copyleft 许可证，仅保留了少数关键的权利，此外不予限制。 三、知识共享许可协议经过一段简要的铺垫，几个概念算是讲清楚了，接着看 Python 之父在本文开头所提到的那种许可协议吧。 CC 也是 copyleft 的一种，全称为 Creative Commons license ，译作 知识共享许可协议 ，发布于 2002.12.16，目前已发展到 4.0 版本。 官网地址：https://creativecommons.org/licenses CC 协议是一个统称，它有不同的实指，区别在于所保留的权利不同。 它声明的基本权利有 4 种： 署名（Attribution，简写 BY）：注明原作者 相同方式共享（ShareAlike，简写 SA）：允许演绎，但需以相同许可协议发布 非商业性使用（Noncommercial，简写 NC）：不得用于商业目的 禁止演绎（No Derivative Works，简写 ND）：不得演绎，也作”非衍生” （注：还有一些基本要求，例如，使用者不可添加法律条款或技术手段来限制别人的合理使用。限于篇幅，这些内容就不多介绍了，详见官网。） 按照是否保留某项权利，它们可以排出 16 种组合，其中 4 种因为同时包含”SA”与”ND”，互斥而无效，还有 5 种不要求署名，基本没人使用。 所以，只有 7 种常用的 CC 协议： 上图只列出了 6 种，还有 1 种特殊的是 CC0 协议，它不要求任何权利，是”No Rights Reserved”，无版权要求，属于自由版权。 这些协议被广泛用于各类互联网产品中（主要是网站、视频、图片或文章），例如： CC0：Pexels图片、Unsplash图片、SoundCloud音乐 CC BY-SA：维基百科内容、Stack Overflow内容 CC BY-NC-ND：TED 演讲视频 CC BY-NC-SA：可汗学院视频、斯坦福公开课视频 很多个人网站或文章，基本采用了”CC BY-NC-ND”或者”CC BY-NC-SA”之一。Guido 最初给我回复的是 ND 这种，后来才澄清为 SA。 这几种权利中，BY（署名）是不言而喻的，也就是我们常见的”转载时请注明作者和出处”，体现了对于原作者的最起码的尊重。 另外的 3 种权利，值得再细细地辨析一下： SA/ND，是否允许演绎。演绎包括”再混合、转换或基于该作品创作”，基本可概括为不允许改动原作品，而且不允许翻译（这点很关键） NC，非商业用途。什么算是商业用途呢？官方笼统地概括为”出于商业利益或金融补偿”的用途，还说这取决于具体情况和使用者的意图 四、关于翻译的几个问题本文缘起于翻译，快结束了，我再补充几个跟翻译相关的问题吧，并附上我的理解。 1、翻译别人的文章会导致侵权么？翻译权是著作财产权的一种，属于著作人所有，它的基本含义是：著作权人享有自行翻译其作品和允许他人翻译其作品的权利。所以，未经作者授权或者许可的作品，就不要翻译了，翻译了也不应发布，否则就侵权了。 2、CC 协议下的作品可自由翻译么？如果作者许可的是 ND，即禁止演绎，那么，该作品是不允许被翻译的；如果许可的是 SA，即是允许翻译，但注意需”以相同方式共享”，即翻译后的作品需支持他人继续作出演绎；其它情况，对翻译行为不作约束。 3、译者对翻译的作品拥有版权么？根据我国《著作权法》第十二条所述： 改编、翻译、注释、整理已有作品而产生的作品，其著作权由改编、翻译、注释、整理人享有，但行使著作权时不得侵犯原作品的著作权。 即在不侵犯原作版权的前提下，翻译作品的版权归译者所有。 4、翻译的作品算是原创么？从狭义的概念上看，翻译属于二次创作、属于衍生、其”灵魂”是由原作品所赋予的，所以不能算是原创。原创应指独立创作、全新发明，所以在此含义上看，翻译不算是原创。 但是，还有一种具体的情境，例如在公众号发文时标注的”原创”，此原创并非是要作概念上的区分，而是要保护作者的版权，防止文章被人侵权转载（甚至是被抢去标注原创），在此情境下，我认为可以标”原创”（有”翻译”标记就更好了）。 所以，综合来看，翻译作品不是原创，但在特殊情况下，又可以是”原创”。 5、如何理解非商业用途呢？维基百科对于商业行为概括有 4 个要点：（1）以营利为目的（2）发生交易行为（3）出于双方自愿（4）符合法律规范 CC 协议所约定的 NC 条款，应参照如上解释。所以，基于 NC 条款许可的翻译作品，不应用于知识付费，也不应用于其它买卖交易，此外， 一般而言， 捐助或者赞赏等行为都不算是商业用途，则不受此限制。 原文链接 👇","link":"/news/关于知识产权、知识共享与文章翻译/"},{"title":"appleCard","text":"免年费的钛金卡，办一张来收藏也不错。","link":"/news/appleCard/"},{"title":"Dice 称这 5 种编程语言可能衰落","text":"Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。 根据 Dice 报道，并不是所有的编程语言都永远存在，因为新一代的开发人员会接受他们觉得更容易使用的其他语言和框架。为了确定哪种编程语言可能在中长期内注定失败，他们查看了 TIOBE 和 RedMonk 的受欢迎程度排名，以及 Dice 自己的职务公告数据库。列出以下语言： Ruby很久以前，Ruby 很受欢迎。这是 Tiobe 月刊上的前十名语言，开发人员称赞它学习起来有多么容易。但是在过去的 18 个月里，Tiobe 的排名从第 9 位下降到了第 12 位。 另外发现，对 Dice 过去一年发布的招聘数据的分析显示，寻找精通 Ruby 的技术专业人员的公司数量大幅下降。2018 年，Ruby 的就业数量下降了 56%。这是一个巨大的警告信号，表明很多公司正在放弃 Ruby，如果是这样的话，该语言的用户基础可能会迅速减少到几乎一无所有。 Haskell据说，Haskell 即将在 2020 年进行重大更新。有很多巨头公司和项目（Facebook、GitHub 等）曾经使用 Haskell 开发过一些重要项目。不过，Haskell 在 RedMonk 语言排行榜上的表现一直很平淡，这表明没有更多的开发者在关注这门语言。这意味着它正在死亡还是完全死了？ Objective-C苹果的 Object-C 已是 35 岁，很明显，苹果公司想让它自生自灭了。五年前，苹果公司的高管们登上舞台，为其软件生态系统推出 Swift，这是一种新的、经过改进的编程语言。毫无疑问，开发者会很快接受 Swift。 公平地说，更多的开发人员已经开始使用 Swift (特别是在功能变得更加丰富的情况下)，但是 Object-C 并没有像一些人所期望的那样在流行语言排名中崩溃，可能只是许多开发人员更喜欢使用他们一直使用的语言。 不过，到某一时刻，Object-C 很可能会完全消失。Swift 正在成为一种非常有效的语言，用于构建 iOS、MacOS 和不久的跨平台应用程序。 R早在当时，R 是一种越来越流行的数据分析语言。然而，Python 似乎正在迅速吞噬 R 的市场份额。尽管 R 仍然被学者和数据科学家所使用，但对数据分析感兴趣的公司正转向 Python，因为它的可伸缩性和易用性。因此，R 降低了 TIOBE 的编程语言流行指数，而其他研究显示，R 的使用率下降缓慢，有利于 Python。 如果 R 要以任何形式存在，那是因为数据分析人员可能最终会将其与 Python 结合使用。首席技术官 Enriko Aryanto 今年早些时候对 Dice 表示（他是加州红木城(Redwood City)的联合创始人之一，总部位于加州的匡蒂明德是一家智能营销数据平台）： 把 R 和 Python 结合起来既合理又可行，我们在内部数据科学平台上运行它们，但如果我今天要重新开始我的职业生涯，我可能会考虑专注于 Python 而不是 R。它是一种更通用的语言，有更广泛的应用程序。 Perl即使 RedMonk 的 Perl 受欢迎程度下降，考虑到仍然有大量的遗留网站使用它的代码，该语言还需要很长一段时间才能完全变平。尽管如此，开发人员普遍支持其他语言，比如构建网站，这意味着 Perl 将陷入越来越多的废弃状态。 在本文的早期版本中，我们说过 Perl 几乎没有活跃的开发。正如一些有帮助的评论者指出的那样，事实并非如此：它每年更新一次。然而，鉴于它在 RedMonk 和 TIOBE 上的衰落，他们仍然认为这是一种衰落的语言。 原文链接👇","link":"/news/DiceInsightsA/"},{"title":"BT 种子和磁力链接是如何工作的？","text":"链接：回形针PaperClip","link":"/news/BitTorrent/"},{"title":"Dice 称这  5 种编程语言未来可能各自成王","text":"上个月，我们曾报道过一篇”Dice 称这 5 种编程语言可能衰落“的文章，它基于 RedMonk 和 TIOBE 等公司的数据推测的，结果引起了广泛讨论。Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。经过了半个月，Dice 依靠更大的数据趋势来做出预测，又发布一个更大胆的预测续集，关于 5 种在未来可能会有更多使用的编程语言。 Swift苹果想要放弃 Objective-C，它是一种有着 35 年历史的编程语言，用于为苹果生态系统构建应用程序。苹果想让 Swift 来取代它，Swift 发布与五年前。根据分析公司 RedMonk 的长期语言排名，Swift 自创建以来的使用量迅速上升。 虽然如此，但 Objective-C 仍然有在使用，这主要归功于过去三十年中产生的大量遗留代码（legacy code）。不过，苹果已经不会对它抱有任何期待，Swift 才是为苹果的应用程序提供动力的主打语言，苹果在跨平台应用上只可能会加速这门编程语言的发展。 KotlinKotlin 正在上升。Kotlin 来源于一个岛屿的名字，全称是 Kotlin Island，是英语「科特林岛」之意，十年前，Kotlin 还是俄罗斯岛屿，现在它变成编程语言，JetBrains 公司开发了它，不过它受关注的原因，很大程度上归功于 Google，Google 将它作为 Android 的一流开发语言。 可以说，通过选择 Kotlin，Google 减少了对 Java 的依赖。而且 Java 与 Oracle 发生了巨大法律纠纷，但是不管谷歌的律师是否在推动该公司对 Kotlin 的支持，毋庸置疑的一点，因为它的功能和灵活性，许多开发人员也开始喜欢这种语言。 早在 2018 年，Pusher 就发起了一项开发人员调查，发现 Kotlin 的使用量正在天文数字般的增长，这很大程度上是因为 Android。Pusher 补充说明： 很大一部分开发人员，他们的工作和其他项目的程序，使用的是 Kotlin。大多数人都喜欢使用它，因为它的特性，80% 以上的开发人员都喜欢它的空安全性，其次是扩展函数、与 Java 的简化互操作性和数据类。 对 Kotlin 来说，除了安卓开发之外似乎无路可走了。所以它的最大的问题是，是否能超越 Android 生态系统而开拓新的领域。 PythonPython 是一种强大的语言，为世界各地的开发人员提供了多种用途。但是根据 TIOBE 指数(每月更新一次)，Python 的排名还在继续攀升。并且开发人员和技术专业人员也不断发现 Python 的新用途，包括数据分析和机器学习。 Python 现在也已经有了庞大的用户基础，并且它深深地嵌入到了众多的业务中，所以 Python 不太可能在短期内消失。唯一的问题是这种编程语言还能够持续增长多少，以及它接下来将还能抓住哪些行业。 GroovyGroovy 有广泛的 IDE 支持、与 Java 的相似性以及与流行的开源自动化服务器 Jenkins 的集成支持下，在 TIOBE 的排名是上升的。它已经成为相当多的系统中的”编程语言粘合剂”，它的未来似乎是光明的。 TypeScriptTypeScript 是 JavaScript 的一个超集，一些开发人员认为它不是一种”完整”的语言，因为它可以转换到 JavaScript。但不管如何说它，RedMonk和 GitHub （如下图，上升至第七名）的十月报告 TypeScript 排名都是严重上升的。去年夏天，TIOBE 就表示，TypeScript 已经开始侵吞 JavaScript 的市场份额。 不管你是否相信，TypeScript 是一种新的、改进的 JavaScript，它将取代这个更老的语言，而且许多技术专业人士认为 TypeScript 在未来几年里还有发展的空间。 原文链接👇","link":"/news/DiceInsightsB/"},{"title":"超时空从犯","text":"你回头看了我一眼 我觉得那很久很久","link":"/label/Accomplice/"},{"title":"诺基亚","text":"⬇️","link":"/news/nokia/"},{"title":"未来五年，iOS 开发如何前行？","text":"【CSDN 编者按】技术圈里一直倡导一句话，那便是“拥抱变化”，因为技术始终在飞速地更新迭代，过去掌握的技能可能突然之间就过时了。在近几年，移动开发逐渐趋于稳定，而人工智能、区块链等技术开始甚嚣尘上，客户端开发者们不由得开始迷茫，曾经如此吃香，未来又该怎么走？也许本文会有一点思路上的帮助。 作者 | David O. 译者 | 罗昭成 责编 | 沭七 出品 | CSDN（ID：CSDNnews） 以下为译文： 近十年，10~15 年前不存在的技术，让这个世界变得黯然失色。有趣的是，这些概念正在构建未来的生活方式。如果你认为你在现在已经上线的 App 中看到了这些变化，并且也在着手开发自己的 App，在未来五年，你依然会对 iOS 程序开发的发展方式感到异常震惊。 以下四点，你可以重点关注： 人工智能 人工智能（AI）是一个独特的范式转换器（Paradigm Shifter）[1]。iOS 应用程序开发领域中，睿智的开发者无时无刻都在创建基于 AI 的应用程序。例如星巴克，发布了一个名叫 My Starbucks Barista 的 iOS 应用，它会根据你当天的需要，为你订购咖啡和零食。在金融领域，也有很多 iOS 的人工智能应用程序，根据你的指示，自动进行交易。 在不久的将来，在 iOS 平台，你将会看到越来越多的 AI 应用程序，它们将以全新的方式，逐渐替换传统方式为我们提供服务。这些 AI 应用程序将代替你做选择。这个领域，有无限可能。 增强现实增强现实（AR）与 AI 一样神奇。几年前， Pokémon GO 将虚拟怪兽带到我们的世界，让全世界的人对 AR 趋之若鹜。这个游戏，在 2016 年收入约 9.5 亿美元，到 2017 年，就接近了 9 亿美元。 在未来几年，AR 将在游戏和其它应用中产生更加惊人的影响。这些变化，你将在未来几年的 iOS 应用程序中看到。 物联网（IoT） 随着时间的推移，物联网（IoT）正在逐渐壮大。现如今，你可以看到，灯、门铃、智能门锁、家庭安防系统、音箱、电视、电视盒子、手表、平板、冰箱都连接到互联网上，你可以随时随地控制它们。虽然 iOS 应用程序不能让你看到冰箱中还剩多少食物，还不能改善物联网的体验，但是 IoT 设备获取到越多的数据，越能帮助你作出正确的选择。 IoT 正在优化酒店、汽车、零售等多种行业，这几年的变化，甚是有趣。此外，当人工智能与 IoT 相结合，IoT 将有可能彻底改变全球人的生活方式。 基于云的应用程序 很多 iOS 应用程序开发专家预测，基于云的 iOS 应用程序将是下一个行业重点。在未来几年内，将有超过一半的企业与组织拥有至少一个基于云的原生应用程序[2]。 上面的预测里，有一个奇怪的事情，这个市场，80% 的份额将由 Google、微软、亚马逊占据，而苹果则只剩下 20% 左右。这意味着，如果你的 iOS 应用程序要在这 1780 亿美元的市场中占据一席之地，你需要好好磨练你的 iOS 开发技能。 此外，苹果可能会在未来几年，像其它领域一样，通过创新来抢回市场。苹果今天的成绩，我们相信它有那个能力。 结论 总之，上面提到的领域，并非只有这些领域。在 iOS 开发中，可穿戴设备，跨平台应用、移动支付和区块链技术等领域，都能开发出令人惊叹程序。 这篇文章并不是预测未来，而是告诉你一些潜在的领域，在前期发展的时候抓住机会。 谨以抛砖引玉，期待更多探讨。 相关资料： [1] https://wiki.mbalib.com/wiki/范式转换 [2] https://go.forrester.com/blogs/predictions-2018-cloud-computing-accelerates-enterprise-transformation-everywhere/ 原文链接：hackernoon 本文为 CSDN 翻译，如需转载，请注明来源出处。","link":"/news/iOSYear/"},{"title":"Software/macOS 10.14 Mojave  新⼿⼊⻔","text":"苹果 Mac 操作系统","link":"/Software/mac/"},{"title":"善用佳软--aiXcoder","text":"从程序员到数据工程师，编写程序代码是一项基本功，但是编写冗长代码的过程也极大地消耗了开发者的耐心。近来，有不少关于代码补全工具的消息爆出，例如，来自美国的 Kite，来自加拿大的 TabNine 等，一时间获得了不少程序员的关注。但其实很多人还并不知道，在这些国外产品不断被媒体推送的背后，有一款能力更为强大、更早将深度学习应用于代码补全的产品，一款源自中国的工具——aiXcoder，它的研发者们来自于北京大学。 在本文中，机器之心采访了项目总负责人北京大学计算机科学技术系副教授李戈，请他为读者朋友解读自动代码补全背后的技术，以及 aiXcoder 背后的技术特性和优势。aiXcoder 官网：https://www.aixcoder.com/#/ aiXcoder 的代码补全效果 我们先看看写 TensorFlow 时的代码补全效果： 如上所示，aiXcoder 在 TensorFlow 的代码环境下能够直接「猜测」到模型建立后的一系列代码流程。例如，在定义了 loss 之后需要定义 optimizer，之后需要 train_op、init 方法，然后最终定义模型的保存方式 saver，以及开始运行计算图。这样一个流程基本上是深度学习开发者所知晓的，但是按照流程写下来非常繁琐。在 aiXcoder 的提示下，开发速度得到了提升。 aiXcoder 支持 Java、C++/C、Python、PHP、JavaScript 等语言，以插件的方式集成到现有的 IDE 中，如 Pycharm、Android Studio、VS Code、Eclipse、Webstorm、Sublime 等，插件的背后是一个强大的云端深度学习引擎。 针对开发者，该产品目前分为社区版、专业版和企业版。社区版是完全免费的，专业版也可以通过分享而免费获得。它们间的不同之处在于模型会不会继续学习，社区版主要利用事先训练好的公用模型做预测，而专业版则会根据用户的代码习惯及结构作进一步的调整。企业版是 aiXcoder 功能最为强大的版本，它能够在企业内部的私有云中进行部署，并能够利用企业自己的代码来进行模型的优化训练，从而具有更高的准确率和运行性能。 aiXcoder 用起来怎么样 百闻不如一见，机器之心也对 aiXocder 进行了使用测试。 机器之心在 Pycharm 上试用了社区版/专业版，它们都是需要在线推断。不同的地方在于专业版还需要额外的内存，因为每一个 Pro 用户都需要额外的缓冲区来储存模型「学到的」用户习惯。当然，Pro 用户的缓冲区是是只有该插件能访问的。 使用体会 一般而言，当我们选择 Python 和 PyCharm 时，代码补全就自然用 IDE 自带的工具。使用 aiXcoder 第一个感受是它比自带的补全工具灵活得多，因为以前的补全主要体现在 Python 函数或其它包的 API，而 aiXcoder 还会预测变量名是什么、运算是什么、想调用的函数又是什么。 虽然代码补全的推断过程全是在云端完成的，但在我们的使用中，一般网络环境甚至 4G 都能有实时的反馈，所以补全速度上基本和 Pycharm 自带的工具差不多。李戈教授表示，目前 aiXcoder 绝大多数都能在 200ms 左右得到反馈，有部分地区的用户由于网络延迟问题可能会感觉到卡顿，aiXcoder 正在全国各个主要城市部署服务器，以提升用户体验。同时，aiXcoder 团队也特别关注模型压缩技术，希望把基于 CPU 的推理运算时间压缩到可接受的程度，从而推出能够在 CPU 上运行的本地版。 总体而言，aiXcoder 提供的补全功能在预测变量名、函数名或关键字等效果上确实非常灵活，而且它还会学习开发者的代码风格与编程模式，因此效果还是挺好的。 如下是自动补全的一些候选，一些函数名称可能是开发者之间经常使用的，因此得到了推荐： 对于一些变量，aiXcoder 可根据变量类型提出该变量可能的操作，比如，对于下图的变量「m」，aiXcoder 提出了一个对字符串进行增加的代码： 对比测评 aiXcoder 官方也将产品和其他代码补全工具进行了对比，包括 Kite 和 TabNine 等。 在对比过程中，aiXcoder 会使用 Kite 或 TabNine 官方提供的示例代码，并测试完成这段代码到底需要多少次按键。结果表明，aiXcoder 较其他插件在效率上提升 1.5 倍以上。 aiXcoder 是如何打造的 能够实现高效代码补全的 aiXcoder，背后有着强大的技术支撑。据李戈教授介绍，aiXcoder 很早就试过了语言模型，将代码视为一种语言从而直接建模，这就和 Deep TabNine 一样。但是研究者很快发现，只有语言模型是行不通的，它总会提出一些毫无意义、很不科学的补全建议。为此，aiXcoder 融合了基于序列的程序代码语言模型、基于抽象语法树和程序逻辑关系的图神经网络等方法，共同打造一个完整的系统。 为什么直接生成代码是困难的 如果深度学习模型能根据开发者的意图，以端到端的方式直接生成对应的代码，那么这样的模型会很「优雅」。但是经过研究发现，这样的任务需求是很难实现的，这和任务本身所依赖的数据的性质有关系。 李戈教授从机器学习所依赖的数据性质的角度，对代码生成任务和传统的图像处理任务、自然语言处理任务的不同，给出一种较为形象化的解释。 对于图像识别或图像分类任务而言，机器学习的目标是建立一个连续的数据集（图像数据）到一个近乎连续的、有着接近清晰边界的数据集（标签）之间的映射关系。 这样一来，由于图像数据异常的稠密，而标签集又有足够清晰的边界，那么这就相当于一个标签拥有大量的数据可以学习。这样的映射关系是比较容易建立的，这也是机器学习中和图像相关的任务相对较为容易完成的原因。 对于自然语言处理任务而言，机器学习需要从一个较为连续的（离散度高于图像）、有着较清晰边界的数据集建立与另一个较为连续的、有着较清晰的边界的数据集之间的映射关系。 而由于自然语言处理中的文本数据相比图像数据更为稀疏，因此自然语言处理相关的任务更难取得较好的模型性能。 但是在代码生成方面，从编程者的意图（intent）生成程序代码的问题，可以看做是「程序员意图空间」到「程序代码空间」的映射，其中意图可以是由自然语言描述的信息。如上图所示，这是从一个较为连续的、有着较清晰边界的数据集，向一个更加离散而没有清晰边界的数据集进行映射。 换句话说，尽管代码生成的意图较为清楚，但是实现该意图的代码数据却比较稀疏，而且即便对于相同的意图，其对应的实现代码之间仍存在较大差距，因此这样的任务是非常难学习的。 为此，在 aiXcoder 的实际实现中，对不同应用领域的代码都采用了特定的模型，它们仅使用该领域的数据进行训练。例如，对 TensorFlow 或 PyTorch 等框架也有其特定的代码补全模型。这样做的主要目的就是加强程序分布的稠密性，在特定领域下，代码分布更加接近连续性。可见，根据编程者的「意图」来「直接」生成完整代码是非常困难的，但李戈教授表示，可以用类似的技术来辅助人类程序员来编写代码，我们可以从程序员已经写下的代码中获取程序员的「编程意图」，然后综合分析代码，的结构信息、变量引用信息、API 序列信息、继承关系信息等等，以自动生成后续代码。然而，在这个过程中，只有语言模型是远远不够的，还需要对很多其它代码特征进行分析，才能做好生成式的代码补全。 单纯的预训练语言模型又怎么样？ 提起代码补全，有些人可能会下意识的认为这仅仅是一个普通的语言建模任务，模型只需要根据开发者之前写的代码预测之后的代码即可。因此使用最先进的预训练语言模型，再在代码数据上进行微调说不定是一种好方法。 但是李戈教授表示，这样的想法是远远不够的。预训练语言模型在代码补全任务中效果不佳，主要是因为代码补全任务本身存在诸多不同于自然语言分析任务的挑战。 首先是代码文本中存在的语义抽象性问题。代码的语义（功能语义）与其字面表示之间存在更大的差距。我们无法根据字面确定代码的准确语义。例如，在代码中，只改变一个字符就有可能完全改变整行代码的功能，因此处理代码的语言并准确提取其含义相比自然语言处理任务更棘手。 1f = open(&apos;word_ids.txt&apos;,&apos;r&apos;)f = open(&apos;word_ids.txt&apos;,&apos;w&apos;) 上图所示，在 Python 代码中，打开某个文件时使用「r」和「w」会实现完全不同的功能。 此外，代码的功能语义难以进行具体的表达和刻画，而且代码功能语义的表达方式多种多样。例如，有多种代码的形式文本用于实现某个功能，不能说某一种代码是对的而另一种是错的。 1list_a = [] for i in items: result = test(i) list_a.append(result) list_a = [test(i) for i in items] 如图所示，实现 list_a 的代码可以是多种多样的，但语言模型会将它们学习为完全不同的表征。 同时，代码文本本身的结构非常复杂。例如，代码的语义与代码结构（如行与行的缩进）之间存在较大的关联性，代码语义依赖于代码结构进行表达。这是预训练语言模型难以表示的特征。 最后，代码具有演化性的特征。代码较自然语言的迭代速度更快，因此预训练语言模型不能够及时捕捉演化特征。 考虑到代码语言中的诸多特性，单纯的预训练语言模型无法得到非常好的效果。 核心技术 既然单独的语言模型不行，那么 aiXcoder 又结合了哪些技术，它又是靠什么来补全代码的？总体而言，aiXcoder 主要依赖于其特有的对程序代码进行学习的深度神经网络模型，该模型能够对程序的如下几类特征进行分析： 程序的结构语义特征：程序语言是一种结构性很强的语言，程序的结构信息也体现着程序的语义。例如，抽象语法树是对代码进行解析的一种较为通用的结构，它体现了代码的语义特征，aiXcoder 便充分利用了抽象语法树，对程序员已经写下的代码的语义进行解读。 程序元素间的逻辑关系：程序代码的不同元素之间存在着不同的关系，例如程序变量之间的引用关系、类之间的继承关系、方法与参数之间的调用关系等等。程序本身又可以表示为多种图，例如控制流图、数据流图、调用关系图等等。aiXcoder 借助图神经网络能够对程序元素之间的多种关系进行建模，从而能够对程序元素之间的复杂关系进行分析和推理。 程序语言序列模型：当然，程序语言也具有与自然语言相似的一面，因此可以利用程序标识符之间的序列关系建立程序语言模型。aiXcoder 也使用了最新的深度学习语言模型对程序中的序列信息进行建模。 在获得程序代码的各种特征之后，就该把这些特征输入深度神经网络进行分析了，但这并不容易，因为在输入神经网络之前需要把这些特征进行向量化表示。在研究过程中，北京大学提出了一系列解决程序语言成分相量化的办法，并且在国际上最早发表了相关的论文，这些都为 aiXcoder 的构造打下了基础。 团队介绍 李戈教授所在的北京大学高可信软件技术教育部重点实验室是国内顶尖的软件科学研究团队，是北京大学计算机软件与理论全国重点学科的主要支撑，其建设历史可以追溯到 1955 年，至今已有 60 多年的学术沉淀和积累。该团队在著名软件科学家杨芙清院士和梅宏院士的带领下，已经成长为该领域国际领先的研究团队。基于深度学习的代码分析与生成一直是李戈教授的研究方向，也是北大高可信软件技术教育部重点实验室重点关注的领域，他们从 2013 年开始就开展了基于深度学习的代码分析研究，从 2015 年开始就将深度学习用于代码生成，是最开始进行相关研究的团队之一。该团队在 AAAI/IJCAI/ACL 等顶会上发表过很多代码生成的相关论文，这也是一大笔技术累积。 李戈教授是 aiXcoder 创始人，北京大学计算机科学技术系副教授，CCF 软件工程专委会秘书长，斯坦福大学计算机系人工智能实验室访问副教授。主要研究方向：程序分析，程序生成，深度学习。所在研究团队聚焦于基于机器学习概率模型的程序语言处理，在代码功能分析、代码自动补全、代码缺陷检测等方面取得并保持了国际上领先的研究成果。 机器之心原创 👇 作者：思源、一鸣","link":"/Software/aixcoder/"},{"title":"善用佳软 Blinks","text":"我们已经离不开电子屏幕了！ 不管是家用的电视机，办公用的电脑，还是无时无刻把玩的手机，大部分时间和我们共处的设备，都有显示屏。 高亮、蓝光、屏闪都会对眼睛造成损害，「护眼」变成了用户的强需求，也是设备厂商需要为用户考虑的问题。 在 MacOS 增加「夜览」功能之前，多年的护眼功能空缺是由诸如「f.lux」这类软件来填补的， 就算到现在，「f.lux」仍然不过时，除了减少蓝光，「f.lux」还能随时间变换屏幕颜色。 过滤蓝光、调整色温，是一种护眼思路，还有另外一种思路。 研究显示，盯着电脑屏幕工作的人眨眼频次大概是正常水平的 1/4，而正常眨眼可保持眼睛表面湿润，减少干燥和刺激。 「Blinks」是一款 Mac 眨眼提醒软件，它并不会提醒你原理电脑，这也不显示，而是提醒你该更密集地眨眨眼了。看看它都有哪些功能和自定义项： 1.两种提醒模式：动画和非动画 2.可随系统启动 3.可设置时间间隔 4.可设置全屏下禁用，不打扰沉浸工作 5.通知窗口不会影响在用的应用、键盘和鼠标动作 6.可设置背景透明度 原文链接👇","link":"/Software/Blinks/"},{"title":"「拖放」Mac 的底层能力，也是效率神技","text":"个人惯用 Mac 拖放，但每每身边同事看我的操作习惯，都大惊失色，感叹 Mac 还有这种操作，所以决定单独讲一篇 Mac 拖放。 Mac的拖放几乎是全局的，比如你可以将图片文件从应用拖到 Finder，同样可以将文件从 Finder 拖至应用内，甚至从应用A拖拽至应用B。 总之，基于 Finder 的文件拖拽，让系统和应用、应用和应用协同起来，大大提速。以下是一些示例。 应用-&gt;Finder 1.微信-&gt;Finder 2.浏览器-&gt;Finder 出于版权安全的考虑，以及前端技术的极速革新，部分网站已不再支持将图片拖拽至 Finder，但多数网站仍然支持。 3.PDF-&gt;Finder 如果你只需要 PDF 20P中的1P，可以单独拖拽至Finder。 Finder-&gt;应用 1.Finder-&gt;微信 2.Finder-&gt;办公套件 3.Finder-&gt;PDF 应用-&gt;应用 1.浏览器-&gt;微信 2.微信-&gt;办公套件 除了以上”应用-&gt;Finder，Finder-&gt;应用，应用-&gt;应用”几种拖放，Mac 还有其他很多地方支持此操作，比如文件拖拽至垃圾桶、应用拖拽至Docker、文件拖拽至 Docker 上应用图标即可打开…… 使用拖拽，还是复制粘贴，或是通过各个应用的菜单完成操作，都没什么问题，如果你知道了 MacOS 的一项新能力，不妨试试。 原文链接👇","link":"/Software/DragAndDrop/"},{"title":"善用佳软 uPic","text":"对于markdown重度用户而言，一款好用的图床工具能够有效提升效率。从Windows到Mac，笔者也算是辗转用过多款图床客户端，包括iPic、PicGo等等。而自从更换新的工作环境之后，笔者对于图床客户端又有了新的需求——自定义图床。 幸好，一次机缘巧合让笔者遇到了uPic，除了支持微博、SM.MS、七牛云、腾讯云等图床之外，还可以自定义配置图床。 uPic下载地址：https://github.com/gee1k/uPic/releases 笔者目前工作所用的编辑器，既不支持外链，也不支持图片粘贴后自动上传，一旦涉及多图文章，光上传图片就浪费不少时间。因此，笔者萌生了构建自定义图床的想法，更幸运的是，笔者公司对于图片上传服务并没有做太多的限制，也让这种想法成为可能。 uPic是一款开源简洁的图床客户端，方便用户直接上传图片到指定的存储空间，并获取有效的markdown图片地址，其默认图床为SM.MS，当然也支持配置腾讯云、七牛云、又拍云等常见的对象存储。最关键的是支持图床自定义配置，也让我毅然抛弃了一直以来付费使用的iPic。 其实起初并不顺利，刚上手的uPic（大概是v0.7.0版本），自定义图床配置并不适用于笔者常用的编辑器环境。好在软件开发者@svend足够热心，在了解了笔者的需求及编辑环境之后，重构了自定义图床，使得笔者的想法得以实现，包括大家在反馈群里提出的一些建议，也都及时采纳并更新。 直到最新发布的v0.8.0版本，uPic已经成为一款非常成熟且强大的图床客户端，且安装包大小也不过才10.5M。 好了，啰嗦了这么多，也该进入正题了。 uPic目前仅支持Mac端，默认上传到SM.MS匿名图床，除此之外还支持微博、码云、Github以及腾讯云、阿里云、又拍云、七牛云总共八个图床。其中，由于微博近期已经陆续开启防盗链，笔者不建议在个人博客中使用。在上传方式上，uPic支持本地选择/复制文件上传、截图上传，甚至可直接拖动文件到菜单栏uPic图标上完成上传动作。 在最新更新v0.8.0版本之后，uPic新增支持直接从浏览器中复制或者拖动在线图片上传到指定图床，这样就不用下载到本地再进行上传。 不过需要注意的是，GIF动图不大一样，直接从浏览器中复制或者拖动GIF上传至uPic图床，可能最终上传的只是GIF图中一帧的画面，所以对于GIF最好还是先下载到本地，然后使用uPic上传到图床。 在“设置——拓展——访达拓展”中勾选uPic一项，即可开启本地文件右键菜单中“使用uPic上传”的功能，也算是比较方便的一种本地文件上传方式。\u001b 一旦完成上传动作，所输出的文件链接会自动复制到剪切板，直接在文档中粘贴即可，在输出链接格式上可根据需求选择URL、HTML、Markdown三种。 点击菜单栏uPic图标，还可以查看最近十条上传记录，同时可以预览上传内容缩略图，以便选择重新复制。熟练使用快捷键操作，可以进一步提升使用效率。uPic支持三种上传方式的自定义快捷键。基本不用点击菜单了去选择，即可完成上传动作。例如，通过设定好的快捷键完成截图上传操作，按住鼠标框选所需区域，松开鼠标之后即完成截图并直接上传到图床（注意没有确认截图的过程哦～）。使用这段时间，笔者感觉uPic已经足够成为一款高效、简洁的图床客户端，支持强大的自定义图床配置，支持复制/拖动上传以及快捷键操作。不过在部分体验上iPic依然值得uPic借鉴，例如复制图片后点击菜单栏的iPic，能够比较直观地看到已复制图片及近期上传图片的预览，体验更加直观。不得不提的是，开发者@svend虽然只利用业余时间更新维护，同样保持了较高的更新频率，发现bug或者其他不稳定的因素更是会连夜修复，并且会及时反馈用户的意见。作为一款免费的Mac图床客户端，uPic已经赢得了越来越多的用户亲睐。 原文链接👇","link":"/Software/uPic/"},{"title":"善用佳软-Moom","text":"「Moom」是一款 Mac 窗口整理软件，功能和「Magnet」类似，软件提供了几个预置的窗口位置供你选择，使窗口排列不会杂乱无章，不管是单项事务还是协同任务都能井井有条。 首先要说，个人更喜欢「Magnet」，因为其存在感低，只需要记住几个快捷键便能随心所欲地使用并获得极好的体验。 「Moom」在热键的效率上并不如「Magnet」，因为他的热键逻辑是需要两步才能完成，即第一步呼出「Moom」，第二部选择预设动作。但它给了用户其他可能更好的选择。 只需要将鼠标指针悬停在任意窗口的绿色最大化按钮上，「Moom」的弹出菜单就会出现，选择其中的预设即可将该窗口变换到想要的位置和尺寸比例。 这更符合使用直觉，并被很多更倾向使用鼠标的用户接受。 还有，当你将鼠标指针悬停在任意窗口的绿色最大化按钮上，并按住 Option 键，「Moom」会给你更多的选择，主要是 1/4 窗口的扩展。 「Moom」还支持”边缘和角落吸附”，拖拽窗口到屏幕边缘或一角，便能触发相应的窗口变换。 「Moom」还提供了诸多自定义项，比如尺寸比例、保存当前窗口位置比例为预设、响应时间等，如果你更喜欢其和窗口的融合性，不妨试试。 原文链接👇","link":"/Software/Moom/"},{"title":"善用佳软 预览","text":"「预览」作为 Mac 自带的 PDF&amp;图片 应用，大都数用户只是拿来当 图像查看器 使用，而并不了解它的诸多功能。Mac 很多系统级应用都有很好的体验，比如截图、提醒事项、录屏等等，它们满足硬性需求，且和 iPhone 能更好的协同，虽然部分不如第三方软件功能丰富，但也十分简洁。 我使用「预览」最频繁的功能就是 PDF 创建、合并和排序了。 比如要做上个月的报销凭证，所有凭证拍照、收集完毕后，在 Finder 中全选-右键，可以创建 PDF。打开该 PDF 文件，可以通过上下拖拽进行排序，如果要加入新的凭证，可以从 Finder 将图片或 PDF 文件拖拽至「预览」左侧缩略图列表中。 除了这个，「预览」还有很多功能，随便讲几个： 1.签名 需要给文件签名，没有打印机，只需要用「预览」打开需要签名的文件，点击签名菜单，可以通过 触摸板书写、摄像头获取两种方式生成签名，附加在需要签名的文件上。 2.加密 如果你的 PDF 文件涉及机密，可以点击「预览」的导出，选择 PDF 格式，选择密码选项，设置需要的密码即可。 3.格式转换「预览」可以将图像文件转换为许多文件类型，包括 HEIC、JPEG、JPEG 2000、PDF、PNG 和 TIFF 等，只需要在导出时选择需要的格式。其中，JPEG、JPEG 2000支持调节质量大小，PDF 支持加密和滤镜选项，Quartz 滤镜还包括了减小文件尺寸的子选项。 4.图片处理 调整尺寸、颜色、即时 Alpha抠图、速写、形状…… 能够满足简单的图片处理需求。 还有其他一些功能就不一一介绍了，有兴趣的同学可以查看这「预览」的官方使用手册，不妨挖掘下。","link":"/Software/preview/"},{"title":"git如何删除已经提交的文件夹","text":"在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹 在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决 首先进入你的master文件夹下, Git Bash Here ,打开命令窗口 $ git --help # 帮助命令 $ git pull origin master # 将远程仓库里面的项目拉下来 $ ls # 查看有哪些文件夹 $ git rm -r --cached .idea # 删除.idea文件夹 $ git commit -m '删除.idea' # 提交,添加操作说明 $ git push -u origin master # 将本次更改更新到github项目上去 作者： 皮皮今","link":"/program/Git/git-del/"},{"title":"GIT","text":"同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus Torvalds 虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。 开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 最后实际情况是这样的：Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以感受一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。","link":"/program/Git/git/"},{"title":"Node.js","text":"一、简介Node.js 是一个基于Google Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 能方便地搭建响应速度快、易于扩展的网络应用，Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。 官网：https://nodejs.org/en/中文：https://cnodejs.org、https://nodejs.cn 简单说Node.js就是运行在服务器端的JavaScript，是现在流行的语言中能同时运行在前端与后台的程序语言，你可以把JavaScript想像成Java与C#。相关技术： 数据库：MongoDB，非关系型数据库，NoSQL（Not only SQL） MVC框架：AngularJS Web服务器：Express 模板引擎：jade、ejs、htmljs、swig、hogan.js 二、搭建Node.js开发环境2.1、安装Node.js去官网下下载最新版本的Node.js一步一步按提示安装即可，如果安装失败就手动安装，将Node.js的安装位置配置到环境变量的path中。 1brew install node 安装完成后启动命令行，测试： 1node -v 三、第一个Node.js程序在上面的示例中，我们是通过IDE完成编译与运行的，其实手动运行也可以，比如编写一段代码如下： server.js 12345678910111213//依赖一个http模块，相当于java中的import，与C#中的usingvar http = require(&apos;http&apos;);//创建一个服务器对象server = http.createServer(function (req, res) {//设置请求成功时响应头部的MIME为纯文本res.writeHeader(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});//向客户端输出字符res.end(&quot;Hello World\\n&quot;);});//让服务器监听本地8000端口开始运行server.listen(8000,&apos;127.0.0.1&apos;);console.log(&quot;server is runing at 127.0.0.1:8000&quot;); 在node环境下解释运行： 运行结果： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。创建服务器：服务器可以监听客户端的请求，类似于TomCat、IIS、Apache 、Nginx 等 HTTP 服务器。接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。 四、NPM（Node.js包管理器）NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： a)、允许用户从NPM服务器下载别人编写的第三方包到本地使用。 b)、允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 c)、允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 官网：https://www.npmjs.com/ 4.1、查看npm版本由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功 4.2、升级npm如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级 1npm install npm -g 4.3、安装模块 npm install -参数 如果带参数-g表示全局安装，否则只是安装到某个目录下。 以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express 1sudo npm install express -g 4.4、卸载模块我们可以使用以下命令来卸载 Node.js 模块。 sudo npm uninstall 如先使用安装指令安装bootstrap: 1npm install bootstrap 再使用卸载指令删除模块： 1npm uninstall bootstrap 可以到 /node_modules/ 目录下查看包是否还存在 4.5、模块列表使用模块列表命令可以方便的看到当前项目中依赖的包： 1npm ls 4.6、更新模块我们可以使用以下命令更新模块：npm update模块名称npm up -g 模块名称 4.7、搜索模块npm search模块名称 4.8、NPM 常用命令除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。使用npm help 可查看某条命令的详细帮助，例如npm help install。在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。使用npm update -g可以把全局安装的对应命令行程序更新至最新版。使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 4.9、更换NPM 镜像因为npm的服务器在国外，在网络状态不好的情况下引入一个模块会因为网络延迟而失败，可以更换成国内速度更快的镜像服务器，这里以使用淘宝 NPM 镜像（https://npm.taobao.org/）为例： 1npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了： 1＄ cnpm install [name] 这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 如是安装失败，可以试试： 12345678910alias cnpm=\"npm --registry=https://registry.npm.taobao.org \\--cache=$HOME/.npm/.cache/cnpm \\--disturl=https://npm.taobao.org/dist \\--userconfig=$HOME/.cnpmrc\"# Or alias it in .bashrc or .zshrc$ echo '\\n#alias for cnpm\\nalias cnpm=\"npm --registry=https://registry.npm.taobao.org \\ --cache=$HOME/.npm/.cache/cnpm \\ --disturl=https://npm.taobao.org/dist \\ --userconfig=$HOME/.cnpmrc\"' &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc 五、ExpressExpress 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。使用Node.js作为AngularJS开发Web服务器的最佳方式是使用Express模块。 Express官网： https://expressjs.com/ Express4.x API：https://expressjs.com/zh-cn/4x/api.html 5.2、Express框架核心特性可以设置中间件来响应 HTTP 请求。 定义了路由表用于执行不同的 HTTP 请求动作。 可以通过向模板传递参数来动态渲染 HTML 页面。 丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 5.3、安装 Express安装 Express 并将其保存到依赖列表中： 1npm install express --save 以上命令全局安装express。也可安装时指定安装中间件。 body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。 cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。 multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。 123＄ npm install body-parser --save ＄ npm install cookie-parser --save ＄ npm install multer --save 默认这些模块都已经添加。 5.4、第一个Express框架实例接下来我们使用 Express 框架来输出 “Hello World”。以下实例中我们引入了 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。 创建一个目录，如Project，进入命令行： 使用npm install express 导入express模块。 在目录下创建hello.js文件，如下所示： 12345678910111213141516//引入express模块var express = require(&apos;express&apos;);//创建一个app对象，类似一个web 应用（网站）var app = express();//接受指定路径的请求，指定回调函数app.get(&apos;/&apos;, function (req, res){res.send(&apos;Hello World&apos;);});//创建一个web服务器，可以认为就是web服务器对象//监听8081端口，当监听成功时回调var server = app.listen(8081, function () { var host = server.address().address; //地址 var port = server.address().port; //端口 console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port);});}) 5.5、开发Express项目 创建好的项目如下： app.js是网站： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);var app = express();//指定视图引擎为ejsapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;ejs&apos;);// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, &apos;public&apos;, &apos;favicon.ico&apos;)));app.use(logger(&apos;dev&apos;));app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.use(&apos;/&apos;, index);app.use(&apos;/users&apos;, users);// catch 404 and forward to error handlerapp.use(function(req, res, next) { var err = new Error(&apos;Not Found&apos;); err.status = 404; next(err);});// error handlerapp.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&apos;env&apos;) === &apos;development&apos; ? err : {}; // render the error page res.status(err.status || 500); res.render(&apos;error&apos;);});module.exports = app; bin\\www是web服务器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/usr/bin/env node/** * 依赖模块，导入 */var app = require(&apos;../app&apos;);var debug = require(&apos;debug&apos;)(&apos;nodejsexpress:server&apos;);var http = require(&apos;http&apos;);/** * 从上下文环境中获得监听端口，如果空则3000 */var port = normalizePort(process.env.PORT || &apos;3000&apos;);app.set(&apos;port&apos;, port);/** * 创建Web服务器 */var server = http.createServer(app);/** * 开始监听 */server.listen(port);server.on(&apos;error&apos;, onError); //指定发生错误时的事件server.on(&apos;listening&apos;, onListening); //当监听成功时的回调/** * 规范化端口 */function normalizePort(val) { var port = parseInt(val, 10); if (isNaN(port)) { // named pipe return val; } if (port &gt;= 0) { // port number return port; } return false;}/** *错误事件监听 */function onError(error) { if (error.syscall !== &apos;listen&apos;) { throw error; } var bind = typeof port === &apos;string&apos; ? &apos;Pipe &apos; + port : &apos;Port &apos; + port; //错误处理 switch (error.code) { case &apos;EACCES&apos;: console.error(bind + &apos; requires elevated privileges&apos;); process.exit(1); //结束程序 break; case &apos;EADDRINUSE&apos;: console.error(bind + &apos; is already in use&apos;); process.exit(1); break; default: throw error; }}/** * 当用户访问服务器成功时的回调 */function onListening() { var addr = server.address(); var bind = typeof addr === &apos;string&apos; ? &apos;pipe &apos; + addr : &apos;port &apos; + addr.port; debug(&apos;Listening on &apos; + bind);} routers/index.js路由，有点类似控制器或Servlet： 123456789var express = require(&apos;express&apos;);var router = express.Router();/* 获得首页 */router.get(&apos;/&apos;, function(req, res, next) { res.render(&apos;index&apos;, { title: &apos;Express&apos; });});module.exports = router; views/index.ejs首页视图： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 在www上右键选择“运行方式”-&gt;Run ‘/bin/www’ 运行结果： 5.5.1、request对象Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例 req.baseUrl：获取路由当前安装的URL路径 req.body / req.cookies：获得「请求主体」/ Cookies req.fresh / req.stale：判断请求是否还「新鲜」 req.hostname / req.ip：获取主机名和IP地址 req.originalUrl：获取原始请求URL req.params：获取路由的parameters req.path：获取请求路径 req.protocol：获取协议类型 req.query：获取URL的查询参数串 req.route：获取当前匹配的路由 req.subdomains：获取子域名 req.accepts()：检查可接受的请求的文档类型 req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码 req.get()：获取指定的HTTP请求头 req.is()：判断请求头Content-Type的MIME类型 5.5.2、response对象Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： 123456789101112131415161718res.app：同req.app一样res.append()：追加指定HTTP头res.set()在res.append()后将重置之前设置的头res.cookie(name，value [，option])：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie()：清除Cookieres.download()：传送指定路径的文件res.get()：返回指定的HTTP头res.json()：传送JSON响应res.jsonp()：传送JSONP响应res.location()：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect()：设置响应的Location HTTP头，并且设置状态码302res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。res.send()：传送HTTP响应res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set()：设置HTTP头，传入object可以一次设置多个头res.status()：设置HTTP状态码res.type()：设置Content-Type的MIME类型 5.5.3、express获取参数有三种方法req.query 适合 https://localhost:3000/form?num=8888req.body 适合https://localhost:3000/form，Post请求中的参数req.params 适合获取form后的num：https://localhost:3000/form/num （一）、GET 12var num = req.query.num;res.send(&quot;你获取的get数据为:&quot; + num); （二）、POST 解析post数据需要用到body-parser 1npm install body-parser --save app.js 1234567891011121314151617181920var express = require(&apos;express&apos;);var app = express();//引入body-parservar bodyParser = require(&apos;body-parser&apos;);app.use(express.static(&apos;public&apos;));//需要use的app.use(bodyParser.json()); // for parsing application/jsonapp.use(bodyParser.urlencoded({extended: true})); // for parsing application/x-www-form-urlencoded//获取数据app.post(&apos;/form&apos;, function(req, res) {var num = req.body.num;res.send(&quot;你获取的post数据为:&quot; + num);});//设置监听端口app.listen(3000); public/test.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;form action=\"/form\" method=\"post\"&gt;&lt;input type=\"text\" name=\"num\" value=\"tinyphp\"&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （三）、获取路径参数 app.js 1234567891011var express = require(&apos;express&apos;);var app = express();//获取数据app.get(&apos;/form/:num&apos;, function(req, res) {var num = req.params.num;res.send(&quot;你获取到form/后的参数:&quot; + num);});//设置监听端口app.listen(3000); 5.6 ejs基础ejs是一个Express Web应用的模板引擎，在NodeJS开发中可以选择的模板引擎可能是所有Web应用开发中范围最广的，如jade、ejs、htmljs、swig、hogan.js，但ejs是最容易上手的，与jsp,asp,php的原始模板引擎风格很像。 官网：https://www.embeddedjs.com/ 添加一个product.js路由： 12345678910111213141516var express = require(&apos;express&apos;);var router = express.Router();/* 产品 */router.get(&apos;/&apos;, function(req, res, next) { var products=[]; products.push({name:&quot;ZTE U880&quot;,price:899.8}); products.push({name:&quot;HuWei 荣耀8&quot;,price:1899.8}); products.push({name:&quot;iPhone 7 Plus 128G&quot;,price:5899.8}); //将product视图与指定的对象渲染后输出到客户端 res.render(&apos;product&apos;, { title: &apos;天狗商城&apos;, pdts:products});});module.exports = router; 在views目录下添加product.ejs视图，这里是一个简单的MVC： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;%= title %&gt; &lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt; - 产品列表&lt;/h1&gt; &lt;table border=\"1\" width=\"80%\"&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;%pdts.forEach(function(pdt,index){%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=index+1%&gt; &lt;/td&gt; &lt;td&gt; &lt;%=pdt.name%&gt; &lt;/td&gt; &lt;td&gt; &lt;%=pdt.price%&gt; &lt;/td&gt; &lt;/tr&gt; &lt;%});%&gt; &lt;/table&gt; &lt;ul&gt; &lt;% for(var i=0; i&lt;pdts.length; i++) {%&gt; &lt;li&gt; &lt;%=pdts[i].name%&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/body&gt;&lt;/html&gt; 修改app，注册定义好的模块product： 123456789101112131415161718192021var index = require('./routes/index');var users = require('./routes/users');var pdts = require('./routes/product');var app = express();//指定视图引擎为ejsapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'ejs');// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, 'public')));app.use('/', index);app.use('/users', users);app.use('/pdt', pdts); 运行结果： 原因：没有安装ejs模块解决办法：进入到项目目录，安装ejs 12&gt; npm install --save ejs&gt; 重新运行： 5.7、lodash这是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库。可以非常方便的操作json。 官网：https://lodashjs.com/ 安装： 1npm i -g npm 1npm i --save lodash 安装时先用cd切换到当前项目下。 如果浏览器使用可以直接引入： 添加lodash依赖： 依赖成功后会在package.json中添加引用： 后台Node.js使用，可以引入模块： 123456789101112131415161718192021222324252627282930313233343536373839//导入lodash模块var _= require(&apos;lodash&apos;);var products=[];products.push({name:&quot;ZTE U880&quot;,price:899.8});products.push({name:&quot;HuWei 荣耀8&quot;,price:1899.8});products.push({name:&quot;iPhone 7 Plus 128G&quot;,price:5899.8});//1、取出第一个元素var obj1=_.first(products);console.log(obj1.name); //ZTE U880//2、取出最后一个元素var obj2=_.last(products);console.log(obj2.name); //iPhone 7 Plus 128G//3、指定查找条件返回符合条件的索引var obj3=_.findIndex(products,function(obj){ return obj.price&gt;=1000&amp;&amp;obj.name.indexOf(&quot;7&quot;)&gt;0;});console.log(obj3); //2//4、指定查找条件返回查找到的对象var obj4=_.find(products,function(obj){ return obj.price&gt;=1000&amp;&amp;obj.name.indexOf(&quot;7&quot;)&gt;0;});console.log(obj4); //{ name: &apos;iPhone 7 Plus 128G&apos;, price: 5899.8 }//5、排序var obj5=_.orderBy(products,[&quot;price&quot;,&quot;name&quot;],[&quot;desc&quot;,&quot;asc&quot;]);console.log(obj5);//[ { name: &apos;iPhone 7 Plus 128G&apos;, price: 5899.8 },//{ name: &apos;HuWei 荣耀8&apos;, price: 1899.8 },//{ name: &apos;ZTE U880&apos;, price: 899.8 } ]//6、查找价格为1899.8的产品的keyvar obj6=_.findKey(products,{price:1899.8});console.log(obj6); //1 API的使用非常简单，但需要注意版本，可以现查现用，API地址：https://lodash.com/docs/4.17.2 5.8、参数5.8.1、URL中的参数占位Checks route params (req.params), ex: /user/:id 127.0.0.1:3000/index，这种情况下，我们为了得到index，我们可以通过使用req.params得到，通过这种方法我们就可以很好的处理Node中的路由处理问题，同时利用这点可以非常方便的实现MVC模式； http://127.0.0.1:3000/pdt/9527/phone 1234//获得产品根据Idrouter.get(&apos;/:id/:category&apos;,function(request,res,next){ res.send(request.params.id+&quot;,&quot;+request.params.category);}); 运行结果： 5.8.2、URL中的QueryStringChecks query string params (req.query), ex: ?id=12 127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用req.query.id就可以获得，类似于PHP的get方法； http://127.0.0.1:3000/pdt/9527?name=jobs 123router.get(&apos;/:id&apos;,function(request,res,next){ res.send(&quot;name:&quot;+request.query.name);}); 运行结果： 5.8.3、HTTP正文中的参数在post请求中获得表单中的数据。 Checks urlencoded body params (req.body), ex: id= 127.0.0.1：300/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过req.body.id获取，类似于PHP的post方法； 页面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;%= title %&gt; &lt;/title&gt; &lt;link rel=&apos;stylesheet&apos; href=&apos;/stylesheets/style.css&apos; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt; - 产品列表&lt;/h1&gt; &lt;table border=&quot;1&quot; width=&quot;80%&quot;&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;/tr&gt; &lt;%pdts.forEach(function(pdt,index){%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=index+1%&gt; &lt;/td&gt; &lt;td&gt; &lt;%=pdt.name%&gt; &lt;/td&gt; &lt;td&gt; &lt;%=pdt.price%&gt; &lt;/td&gt; &lt;/tr&gt; &lt;%});%&gt; &lt;/table&gt; &lt;ul&gt; &lt;% for(var i=0; i&lt;pdts.length; i++) {%&gt; &lt;li&gt; &lt;%=pdts[i].name%&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt;&lt;p&gt; &lt;%if(typeof msg!=&quot;undefined&quot;){%&gt; &lt;%=msg%&gt; &lt;%}%&gt;&lt;/p&gt; &lt;form action=&quot;pdt/add&quot; method=&quot;post&quot;&gt; &lt;p&gt; 名称：&lt;input name=&quot;name&quot; /&gt; &lt;/p&gt; &lt;p&gt; 价格：&lt;input name=&quot;price&quot; /&gt; &lt;/p&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 代码： 123456router.post(&apos;/add&apos;,function(request,res,next){ var entity={name:request.body.name,price:request.body.price}; products.push(entity); //将product视图与指定的对象渲染后输出到客户端 res.render(&apos;product&apos;, { title: &apos;天狗商城&apos;, pdts:products,msg:&quot;添加成功&quot;});}); 结果： 5.9、JSON如果需要Node.js向外提供返回JSON的接口，Express也是非常方便的，可以使用原来在浏览器中使用到的JSON对象，这是一个浏览器内置对象在服务可以直接使用： 将对象序列化成字符： 12345//对象var rose={&quot;name&quot;:&quot;Rose&quot;,&quot;weight&quot;:&quot;65&quot;}; //序列化成字符串 var str=JSON.stringify(rose); alert(str); 结果： 反序列化，将字符转换成对象： 1234//将字符串转换成JavaScript对象var markStr=&apos;{&quot;name&quot;:&quot;mark&quot;,&quot;weight&quot;:&quot;188&quot;}&apos;; var mark=JSON.parse(markStr); alert(mark.name+&quot;，&quot;+mark.weight); 结果： Express已经封装了一个json方法，直接调用该方法就可以序列化对象： 1234/* 产品 */router.get(&apos;/rest&apos;, function(req, res, next) { res.json(products);}); 六、RESTful（表述性状态转移）REST是英文Representational State Transfer的缩写，中文称之为“表述性状态转移” 基于HTTP协议，是另一种服务架构，传递是JSON、POX（Plain Old XML）而不是SOAP格式的数据，充分利用HTTP谓词（Verb），侧重数据的传输，业务逻辑交给客户端自行处理 REST是一种分布式服务架构的风格约束，像Java、.Net（WCF、WebAPI）都有对该约束的实现，使URL变得更加有意义，更加简洁明了，如： https://www.zhangguo.com/products/1get请求 表示获得所有产品的第1个 https://www.zhangguo.com/products/productpost请求 表示添加一个产品 https://www.zhangguo.com/products/1/priceget请求 表示获得第1个产品的价格 https://www.zhangguo.com/products/1delete请求 删除编号为1的产品 REST设计需要遵循的原则网络上的所有事物都被抽象为资源（resource）；每个资源对应一个唯一的资源标识符（resource identifier）；通过通用的连接器接口（generic connector interface）对资源进行操作；对资源的各种操作不会改变资源标识符；所有的操作都是无状态的（stateless） 谓词GET表示查询操作，相当于Retrieve、Select操作POST表示插入操作，相当于Create，Insert操作PUT表示修改操作，相当于Update操作DELETE表示删除操作，相当于Delete操作 其它还有： NodeJS+Express可以很容易的实现REST application/x-www-form-urlencoded multipart/form-data application/json res.setHeader(‘Content-Type’, ‘application/json;charset=utf-8’); 示例代码cars.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var express = require(&apos;express&apos;);var router = express.Router();var _= require(&apos;lodash&apos;);var cars=[];cars.push({id:201701,name:&quot;BMW&quot;,price:190,speed:&quot;210km/h&quot;,color:&quot;白色&quot;});cars.push({id:201702,name:&quot;BYD&quot;,price:25,speed:&quot;160km/h&quot;,color:&quot;红色&quot;});cars.push({id:201703,name:&quot;Benz&quot;,price:300,speed:&quot;215km/h&quot;,color:&quot;蓝色&quot;});cars.push({id:201704,name:&quot;Honda&quot;,price:190,speed:&quot;170km/h&quot;,color:&quot;黑色&quot;});cars.push({id:201705,name:&quot;QQ&quot;,price:130,speed:&quot;210km/h&quot;,color:&quot;白色&quot;});/* Get *//*获得所有汽车*//*url /cars/*/router.get(&apos;/&apos;, function(req, res, next) { res.json(cars);});/*Get*//*获得汽车通过id*//*url：/cars/:id */router.get(&apos;/:id&apos;, function(req, res, next) { //从路径中映射参数，转换成数字 var id=parseInt(req.params.id); var car=_.find(cars,{id:id}); res.json(car);});/*Post*//*添加汽车*//*url：/cars/car */router.post(&apos;/car&apos;, function(req, res, next) { var car=req.body; //从请求正文中获得json对象 car.id=_.last(cars).id+1; //将编号修改为最后一辆车的编号+1 cars.push(car); //将汽车对象添加到集合中 res.json(car); //将添加成功的车以json的形式返回});/*Put*//*修改汽车*//*url：/cars/car */router.put(&apos;/car&apos;, function(req, res, next) { var car=req.body; //从请求正文中获得json对象 console.log(req.body); var index=_.findIndex(cars,{id:parseInt(car.id)}); //根据id获得车在集合中的下标 cars[index]=car; //替换原对象 //res.json(car); //将修改后的车以json的形式返回 res.send({status:&quot;success&quot;, message:&quot;更新成功!&quot;}); });/*Delete*//*删除汽车*//*url：/cars/:id */router.delete(&apos;/id/:id&apos;, function(req, res, next) { //获得url中的编号参数 var id=parseInt(req.params.id); var index=_.findIndex(cars,{id:id}); //根据id获得车在集合中的下标 cars.splice(index,1); //在cars数组中删除下标从index开始的1条数据 res.send({status:&quot;success&quot;, message:&quot;删除成功!&quot;}); });module.exports = router; 示例代码app.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);var index = require(&apos;./routes/index&apos;);var users = require(&apos;./routes/users&apos;);var pdts = require(&apos;./routes/product&apos;);var task = require(&apos;./routes/task&apos;);var cars = require(&apos;./routes/cars&apos;);var app = express();//指定视图引擎为ejsapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;ejs&apos;);// uncomment after placing your favicon in /public//app.use(favicon(path.join(__dirname, &apos;public&apos;, &apos;favicon.ico&apos;)));app.use(logger(&apos;dev&apos;));app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.use(&apos;/&apos;, index);app.use(&apos;/users&apos;, users);app.use(&apos;/pdt&apos;, pdts);app.use(&quot;/task&quot;,task);app.use(&quot;/cars&quot;,cars);// catch 404 and forward to error handlerapp.use(function(req, res, next) { var err = new Error(&apos;Not Found&apos;); err.status = 404; next(err);});// error handlerapp.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&apos;env&apos;) === &apos;development&apos; ? err : {}; // render the error page res.status(err.status || 500); res.render(&apos;error&apos;);});module.exports = app; Get 获得所有汽车 url /cars/ Get 获得汽车通过id url：/cars/:id Post 添加汽车 url：/cars/car 参数中的json格式一定要使用标准格式，注意引号，注意Content-Type，默认的Content-Type类型是：application/x-www-form-urlencoded Put 修改汽车 url：/cars/car Delete 删除汽车 url：/cars/:id node.js跨域 修改app.js文件拦截所有的请求，修改头部 1234567891011121314151617app.use(logger(&apos;dev&apos;));app.use(bodyParser.json());app.use(bodyParser.urlencoded({ extended: false }));app.use(cookieParser());app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.all(&apos;*&apos;, function(req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;content-type&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;); res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); if(req.method == &quot;OPTIONS&quot;) { res.send(&quot;200&quot;); } else { next(); }}); 结果： 九、视频From: https://www.cnblogs.com/best/p/6204116.html","link":"/program/JavaScript/node/"},{"title":"centos 6.5 网站建设","text":"Step 1、为centos配置rpmforge及epel源。centos官方的源其实也够用，不过像php的一些扩展如 php-mcrypt在官方源中并没有。12rpm -ivh https://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm 12rpm -ivh https://mirrors.ustc.edu.cn/centos/6.5/extras/x86_64/Packages/epel-release-6-8.noarch.rpm 12rpm -ivh https://mirrors.163.com/centos/7/extras/x86_64/Packages/epel-release-7-2.noarch.rpm Step 2. 安装php/mysql/httpd安装apacheyum -y install httpd httpd-devel 安装mysqlyum -y install mysql mysql-devel mysql-server mysql-libs 安装phpyum -y install php 安装php扩展123yum -y install php-mysql php-gd php-imap php-ldap php-odbc php-mbstring php-devel php-soap php-cli php-pdoyum -y install php-mcrypt php-tidy php-xml php-xmlrpc php-pear 其它不常用php扩展, www.linuxidc.com 可不用安装yum -y install php-pecl-memcache php-eaccelerator 安装phpmyadminyum -y install phpmyadmin 安装完成之后，启动12service httpd startservice mysqld start Step 3.配置httpd、mysqld开机自启动12chkconfig mysqld onchkconfig httpd on Step 4.配置phpmyadmin修改/usr/share/phpmyadmin/config.inc.php将这里abcde文字修改为自己的字符，可任意$cfg['blowfish_secret'] = 'abcde'; 常见问题1. phpmyadmin提示未开启php-mcrypt,这是因为没有安装php-mrcrpt扩展。在官方源没有php-mrcrpt扩展，请安装epel源后再yum install php-mcrypt 2. phpmyadmin无法访问phpmyadmin默认只能使用 https://localhost/phpmyadmin 来访问，可以修改/etc/httpd/conf.d/phpmyadmin.conf中对应部分为 12345&lt;Directory &quot;/usr/share/phpmyadmin&quot;&gt;Order Deny,AllowDeny from allAllow from All&lt;/Directory&gt; 不过强烈不支持这么做的，把phpmyadmin暴露了不安全注意：apache解析php，修改httpd.conf文件，添加 12Addtype application/x-httpd-php .php .phtmlAddtype application/x-httpd-php-source .phps myql可以远程登录设置mysql密码 123mysql&gt;; USE mysql;mysql&gt;; UPDATE user SET Password=PASSWORD(&apos;newpassword&apos;) WHERE user=&apos;root&apos;;mysql&gt;; FLUSH PRIVILEGES; 1.2.3 允许远程登录 1234mysql -u root -pEnter Password: &lt;your new password&gt;mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;用户名&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos; WITHGRANT OPTION; 完成后就能用mysql-front远程管理mysql了。设为开机启动chkconfig mysqld on","link":"/program/Linux/centos/"},{"title":"Linux","text":"","link":"/program/Linux/linux/"},{"title":"Nginx","text":"什么是Nginx?Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 什么是反向代理？反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 安装与使用安装nginx官网下载地址：https://nginx.org，发布版本分为 Linux 和 windows 版本。 也可以下载源码，编译后运行。 从源代码编译 Nginx 把源码解压缩之后，在终端里运行如下命令： 默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。 Windows 安装 为了安装 Nginx / Win32，需先下载它。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下： Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。 使用nginx 的使用比较简单，就是几条命令。 常用到的命令如下： 123456789101112131415nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。nginx -s reopen ：重新打开日志文件。nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。nginx -v：显示 nginx 的版本。nginx -V：显示 nginx 的版本，编译器版本和配置参数。 如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下： 如果是运行在 Linux 下，写一个 shell 脚本，大同小异。 nginx 配置实战我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。 http反向代理配置 我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。 nginx.conf 配置文件如下： 注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件 好了，让我们来试试吧： 启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。 更改 host： 在 C:Windows\\System32\\drivers\\etc 目录下的host文件中添加一条DNS 记录127.0.0.1 www.javastack.cn 启动前文中 startup.bat 的命令 在浏览器中访问 www.javastack.cn，不出意外，已经可以访问了。 负载均衡配置 上一个例子中，代理仅仅指向一个服务器。 但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。 nginx也可以实现简单的负载均衡功能。 假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 www.javastack.cn，公网IP为 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。 nginx.conf 配置如下： 网站有多个webapp的配置 当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。 举个例子：假如 www.javastack.cn 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分: www.javastack.cn/finance/ www.javastack.cnproduct/ www.javastack.cn/admin/ 我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。 那么，问题来了，用户在实际访问 www.javastack.cn 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。 配置也不难，来看看怎么做吧：https反向代理配置 一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。 这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点： HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口 SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key 其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。 静态站点配置 有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。 举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。 配置如下：然后，添加 HOST： 127.0.0.1 static.zp.cn，此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。 跨域解决方案 web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用 各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路： CORS 在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。 jsonp 把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。 这两种思路，本文不展开讨论。 需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。 举例：www.javastack.cn 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。 前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧： 首先，在 enable-cors.conf 文件中设置 cors ：接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置：到此，就完成了。","link":"/program/Linux/nginx/"},{"title":"Django部署——uwsgi+Nginx","text":"用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了! 环境： 123python3.6centos 7Django1.11 1、本地跑起来Django这里不讲Django项目实施过程，假设你已经写了一个Django项目，并且在本地127.0.0.1:8000能够跑起来。喏，给你个参考，项目大概长这样： kindle目录为我创建的Django App 2、修改项目配置也就是项目目录下的settings.py文件，主要强调几个地方： ①关闭DEBUG模式：②修改ALLOWED_HOSTS：③配置静态文件存放路径： 修改好配置之后执行:python manage.py collectstatic将项目用到的静态文件复制到项目根目录下的static文件中 3、安装uwsgi和Nginx这个没什么说的。。。在自己的云服务器上装好这两个工具安装好uwsgi后最好验证一下，验证方法：创建一个test.py文件： 1234def application(env, start_response): start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html&apos;)]) return [b&apos;Hello world!&apos;] #python3 # return [&apos;Hello world!&apos;] #python2 启动uwsgi服务器： 1uwsgi --http :8000 --wsgi-file test.py 如果可以正常启动而不报错那就应该没问题，不放心的话再在终端验证一下：wget https://127.0.0.1:8000看一下能否正确获取内容 4、配置项目的uwsgi在项目所在文件夹下创建uwsgi.ini配置文件，也就是这里:在uwsgi.ini里进行如下配置： 123456789101112131415161718192021222324252627282930[uwsgi]# Django-related settings # 这里的端口可以根据自己需要设定socket = 127.0.0.1:8001 # the base directory (full path)# 这个是Django项目的根目录，也就是包含App的那个目录，仔细对照上图chdir = /home/python/book2kindle # Django s wsgi file# 这里是项目名(不是App名).wsgimodule = book2kindle.wsgi # process-related settings# mastermaster = true # maximum number of worker processesprocesses = 32 # ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = true plugin python = true # 这个是项目的虚拟python环境，如果没用虚拟环境，可以不设定home = /home/python/book2kindle_env 5、配置项目的nginx找到nginx的配置文件夹，centos7的nginx配置文件在/etc/nginx下，该路径下有一个nginx.conf总配置文件，还有两个文件夹./conf.d、./default.d，我们将nginx.conf复制一份到conf.d文件夹下，命名为nginx.conf（或者项目名.conf）进行如下修改（根据中文注释进行相应配置即可）： 12345678910111213141516171819202122http { upstream django { # 注意这里的server要和uwsgi.ini配置文件中的socket保持一致 server 127.0.0.1:8002; # for a web port socket } server { listen 80; server_name xxx.com; # 这里填自己的域名或者服务器的ip（决定你今后访问网站的方式） charset utf-8; root /usr/share/nginx/html; location / { root /home/python/book2kindle/kindle; # 这是Django App的路径 uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed } location /static { # Django项目静态文件的路径 alias /home/python/book2kindle/static; } } } 6、启动uwsgi和nginx进入uwsgi.ini文件夹下执行：uwsgi --ini uwsgi.ini在终端执行：service nginx restart然后就可以根据域名（前提是要将域名解析到服务器ip地址）或者服务器ip来访问网站了！ OK，完事！就是这么简单！","link":"/program/Python/django/"},{"title":"Django笔记","text":"Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。 一. 版本选择Django 2.0.x 支持 Python 3.4, 3.5 和 3.6 （注意，不再支持 Python 2） 二. 安装 Django2.1. 用 pip 来安装 2.1.1 需要先安装pip (1). Linux, Mac OSX, Windows 下都可用 get-pip.py 来安装pip：https://pip.pypa.io/en/latest/installing.html 或者直接下载：get-pip.py 然后运行在终端运行 python get-pip.py 就可以安装 pip。 Note: 也可以下载 pip 源码包，运行 python setup.py install 进行安装 2.1.2 利用 pip 安装 Django （sudo) pip install Django 或者 (sudo) pip install Django==1.8.16 或者 pip install Django==1.11.8 如果想升级 pip 可以用： (sudo) pip install --upgrade pip2.2. 下载源码安装 https://www.djangoproject.com/download/ 如果是源码包, 比如 django-1.11.8.tar.gz 2.2.1 Linux 或 Mac 下 tar -xvf django-1.11.8.tar.gz cd django-1.11.8 (sudo) python setup.py install三. 检查是否安装成功终端上输入 python ,点击 Enter，进行 python 环境 &gt;&gt;&gt; import django &gt;&gt;&gt; django.VERSION (1, 11, 8, &apos;final&apos;, 0) &gt;&gt;&gt; &gt;&gt;&gt; django.get_version() &apos;1.11.8&apos;如果运行后看到版本号，就证明安装成功了！ 四. 搭建多个互不干扰的开发环境（可选）我们有的时候会发现，一个电脑上有多个项目，一个依赖 Django 1.8，另一个比较旧的项目又要用 Django 1.5，这时候怎么办呢？ 我们需要一个依赖包管理的工具来处理不同的环境。 4.1 虚拟环境依赖安装开发会用 virtualenv 来管理多个开发环境 Linux/MacOS 下 virtualenvwrapper 使得virtualenv变得更好用，所以我们一起安装了 # 安装: (sudo) pip install virtualenv virtualenvwrapper修改~/.bash_profile或其它环境变量相关文件(如 .bashrc 或用 ZSH 之后的 .zshrc)，添加以下语句 export WORKON_HOME=$HOME/.virtualenvs export PROJECT_HOME=$HOME/workspace source /usr/local/bin/virtualenvwrapper.sh修改后使之立即生效(也可以重启终端使之生效)： source ~/.bash_profile4.2 虚拟环境使用方法：mkvirtualenv zqxt：创建运行环境zqxt workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境 deactivate: 退出终端环境 其它的： rmvirtualenv ENV：删除运行环境ENV mkproject mic：创建mic项目和运行环境mic mktmpenv：创建临时运行环境 lsvirtualenv: 列出可用的运行环境 lssitepackages: 列出当前环境安装了的包 创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。","link":"/program/Python/django-bi-ji/"},{"title":"MongoDB","text":"MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。 数据库 数据库是一个集合的物理容器。每个数据库获取其自己设定在文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库。 集合 集合是一组MongoDB的文件。它与一个RDBMS表是等效的。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。通常情况下，在一个集合中的所有文件都是类似或相关目的。 文档 文档是一组键值对。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。下面给出的示例显示了一个博客网站，仅仅是一个逗号分隔的键值对的文档结构。 1234567891011121314151617181920212223{ _id: ObjectId(7df78ad8902c) title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by: &apos;yiibai tutorial&apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100, comments: [ { user:&apos;user1&apos;, message: &apos;My first comment&apos;, dateCreated: new Date(2011,1,20,2,15), like: 0 }, { user:&apos;user2&apos;, message: &apos;My second comments&apos;, dateCreated: new Date(2011,1,25,7,45), like: 5 } ]} 创建数据库 MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。 语法use DATABASE语句的基本语法如下：use DATABASE_NAME 例子：12345678910111213141516171819如果想创建一个数据库名称为 &lt;mydb&gt;, 那么 use DATABASE 语句应该如下：&gt;use mydbswitched to db mydb要检查当前选择的数据库使用命令 db&gt;dbmydb如果想查询数据库列表，那么使用命令 show dbs.&gt;show dbslocal 0.78125GBtest 0.23012GB所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。&gt;db.movie.insert({&quot;name&quot;:&quot;yiibai tutorials&quot;})&gt;show dbslocal 0.78125GBmydb 0.23012GBtest 0.23012GB MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。 删除数据库MongoDB db.dropDatabase() 命令用于删除现有的数据库。 语法dropDatabase()指令的基本语法如下：db.dropDatabase() 这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库 例子：如果想删除新的数据库 , 那么 dropDatabase() 命令将如下所示： 12345&gt;use mydbswitched to db mydb&gt;db.dropDatabase()&gt;{ &quot;dropped&quot; : &quot;mydb&quot;, &quot;ok&quot; : 1 }&gt; 创建集合MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置 参数 类型 描述 Name String 要创建的集合的名称 Options Document （可选）指定有关内存大小和索引选项 选项参数是可选的，所以需要指定集合的唯一名字。 语法createCollection()方法的基本语法如下 12345&gt;use testswitched to db test&gt;db.createCollection(&quot;mycollection&quot;){ &quot;ok&quot; : 1 }&gt; 可以通过使用 show collections 命令来检查创建的集合 123&gt;show collectionsmycollectionsystem.indexes 选项列表 字段 类型 描述 capped Boolean （可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。 autoIndexID Boolean （可选）如果为true，自动创建索引_id字段。默认的值是 false. size number （可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。 max number （可选）指定上限集合允许的最大文件数。 尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。 语法 :123&gt;db.createCollection(&quot;mycol&quot;, { capped : true, autoIndexID : true, size : 6142800, max : 10000 } ){ &quot;ok&quot; : 1 }&gt; 在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。 1234567&gt;db.yiibai.insert({&quot;name&quot; : &quot;yiibai&quot;})&gt;show collectionsmycolmycollectionsystem.indexesyiibai&gt; 删除集合MongoDB 的 db.collection.drop() 用于从数据库中删除集合。 语法drop() 命令的基本语法如下db.COLLECTION_NAME.drop() 例子：下面给出的例子将删除给定名称的集合：mycollection 12345&gt;use mydbswitched to db mydb&gt;db.mycollection.drop()true&gt; 插入文档将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。 语法insert()命令的基本语法如下：&gt;db.COLLECTION_NAME.insert(document) 例子123456789&gt;db.mycol.insert({ _id: ObjectId(7df78ad8902c), title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by: &apos;yiibai tutorials&apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100}) 这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。 在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。 _id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下：_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer) 要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。 例子1234567891011121314151617181920212223242526&gt;db.post.insert([{ title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by: &apos;yiibai tutorials&apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100},{ title: &apos;NoSQL Database&apos;, description: &apos;NoSQL database doesn&apos;t have tables&apos;, by: &apos;yiibai tutorials&apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 20, comments: [ { user:&apos;user1&apos;, message: &apos;My first comment&apos;, dateCreated: new Date(2013,11,10,2,35), like: 0 } ]}]) 查询文档要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。 语法find()方法的基本语法如下&gt;db.COLLECTION_NAME.find()find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。 语法&gt;db.mycol.find().pretty() 例子1234567891011&gt;db.mycol.find().pretty(){ &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;yiibai tutorials&quot;, &quot;url&quot;: &quot;https://www.yiibai.com&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;}&gt; 除了find()方法还有findOne()方法，仅返回一个文档。 RDBMS Where子句等效于MongoDB查询文档在一些条件的基础上，可以使用下面的操作 操作 语法 示例 RDBMS等效语句 Equality {&lt;key&gt;:&lt;value&gt;} db.mycol.find({“by”:”yiibai tutorials”}).pretty() where by = ‘yiibai tutorials’ Less Than {&lt;key&gt;:{$lt:&lt;value&gt;}} db.mycol.find({“likes”:{$lt:50}}).pretty() where likes &lt; 50 Less Than Equals {&lt;key&gt;:{$lte:&lt;value&gt;}} db.mycol.find({“likes”:{$lte:50}}).pretty() where likes &lt;= 50 Greater Than {&lt;key&gt;:{$gt:&lt;value&gt;}} db.mycol.find({“likes”:{$gt:50}}).pretty() where likes &gt; 50 Greater Than Equals {&lt;key&gt;:{$gte:&lt;value&gt;}} db.mycol.find({“likes”:{$gte:50}}).pretty() where likes &gt;= 50 Not Equals {&lt;key&gt;:{$ne:&lt;value&gt;}} db.mycol.find({“likes”:{$ne:50}}).pretty() where likes != 50 AND 在 MongoDB语法在 find()方法，如果您传递多个键通过”,”将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示：&gt;db.mycol.find({key1:value1, key2:value2}).pretty() 例子下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview” 1234567891011&gt;db.mycol.find({&quot;by&quot;:&quot;yiibai tutorials&quot;,&quot;title&quot;: &quot;MongoDB Overview&quot;}).pretty(){ &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;yiibai tutorials&quot;, &quot;url&quot;: &quot;https://www.yiibai.com&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;}&gt; 对于上面给出的例子相当于where子句：’ where by=’yiibai tutorials’ AND title=’MongoDB Overview’ ‘。可以传递任何数目的键-值对在find子句。 OR 在 MongoDB语法要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示： 1234567&gt;db.mycol.find( { $or: [ {key1: value1}, {key2:value2} ] }).pretty() 例子下面给出的例子将显示所有撰写含有 ‘yiibai tutorials’ 或是标题为 ‘MongoDB Overview’ 的教程 1234567891011&gt;db.mycol.find({$or:[{&quot;by&quot;:&quot;tutorials point&quot;},{&quot;title&quot;: &quot;MongoDB Overview&quot;}]}).pretty(){ &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;yiibai tutorials&quot;, &quot;url&quot;: &quot;https://www.yiibai.com&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;}&gt; 使用 AND 和 OR 在一起例子下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 ‘MongoDB Overview’ 或 ‘yiibai tutorials’. 等效于SQL的where子句：’where likes&gt;10 AND (by = ‘yiibai tutorials’ OR title = ‘MongoDB Overview’)’ 1234567891011&gt;db.mycol.find(&quot;likes&quot;: {$gt:10}, $or: [{&quot;by&quot;: &quot;yiibai tutorials&quot;}, {&quot;title&quot;: &quot;MongoDB Overview&quot;}] }).pretty(){ &quot;_id&quot;: ObjectId(7df78ad8902c), &quot;title&quot;: &quot;MongoDB Overview&quot;, &quot;description&quot;: &quot;MongoDB is no sql database&quot;, &quot;by&quot;: &quot;yiibai tutorials&quot;, &quot;url&quot;: &quot;https://www.yiibai.com&quot;, &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;], &quot;likes&quot;: &quot;100&quot;}&gt; 更新文档MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。 MongoDB Update() 方法语法update()方法的基本语法如下 1&gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA) 例子考虑mycol集合有如下数据。 123{ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;} 下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial” 123456&gt;db.mycol.update({&apos;title&apos;:&apos;MongoDB Overview&apos;},{$set:{&apos;title&apos;:&apos;New MongoDB Tutorial&apos;}})&gt;db.mycol.find(){ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;New MongoDB Tutorial&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Tutorial Overview&quot;}&gt; 默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 ‘multi’ 设置为 true。 1&gt;db.mycol.update({&apos;title&apos;:&apos;MongoDB Overview&apos;},{$set:{&apos;title&apos;:&apos;New MongoDB Tutorial&apos;}},{multi:true}) MongoDB Save() 方法save() 方法取代，通过新文档到 save()方法 语法mongodb 的 save()方法如下所示的基本语法：&gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA}) 例子下面的例子将替换该文件_id ‘5983548781331adf45ec7’ 12345678910&gt;db.mycol.save( { &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot; })&gt;db.mycol.find(){ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;}&gt; 删除文档MongoDB 的 remove()方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志deletion criteria : 根据文件（可选）删除条件将被删除。justOne : （可选）如果设置为true或1，然后取出只有一个文档。 语法remove()方法的基本语法如下&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA) 例子考虑mycol集合有如下数据。 123{ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;} 下面的例子将删除所有的文件，其标题为 ‘MongoDB Overview’ 12345&gt;db.mycol.remove({&apos;title&apos;:&apos;MongoDB Overview&apos;})&gt;db.mycol.find(){ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Toturials Overview&quot;}&gt; 只删除一个如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1) 删除所有文件如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。 123&gt;db.mycol.remove()&gt;db.mycol.find()&gt; MongoDB投影mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。 MongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。 语法 find()方法的基本语法如下&gt;db.COLLECTION_NAME.find({},{KEY:1}) 例子 考虑集合 myycol 有下列数据 123{ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;} 下面的例子将显示文档的标题，在查询文档时。 12345&gt;db.mycol.find({},{&quot;title&quot;:1,_id:0}){&quot;title&quot;:&quot;MongoDB Overview&quot;}{&quot;title&quot;:&quot;NoSQL Overview&quot;}{&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;}&gt; 请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0 限制文档MongoDB Limit() 方法 要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。 语法limit()方法的基本语法如下&gt;db.COLLECTION_NAME.find().limit(NUMBER) 例子 考虑集合 myycol 有下列数据 123{ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;} 下面的例子将只显示2个文档，在查询文档时。 1234&gt;db.mycol.find({},{&quot;title&quot;:1,_id:0}).limit(2){&quot;title&quot;:&quot;MongoDB Overview&quot;}{&quot;title&quot;:&quot;NoSQL Overview&quot;}&gt; 如果不指定 limit()方法的参数数量，然后它会显示集合中的所有文档。 MongoDB Skip() 方法 除了 limit()方法还有一个方法 skip()也接受数字类型参数并用于跳过文件数。 语法 skip() 方法的基础语法如下所示：&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 例子： 下面的例子将仅显示第二个文档。 123&gt;db.mycol.find({},{&quot;title&quot;:1,_id:0}).limit(1).skip(1){&quot;title&quot;:&quot;NoSQL Overview&quot;}&gt; 请注意，skip() 方法的默认值是 0 文档排序要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。 语法 sort()方法的基本语法如下&gt;db.COLLECTION_NAME.find().sort({KEY:1}) 例子 考虑集合 myycol 有如下数据 123{ &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;}{ &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;} 下面的例子将显示的文件排序按标题降序排序。 12345&gt;db.mycol.find({},{&quot;title&quot;:1,_id:0}).sort({&quot;title&quot;:-1}){&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;}{&quot;title&quot;:&quot;NoSQL Overview&quot;}{&quot;title&quot;:&quot;MongoDB Overview&quot;}&gt; 请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。 MongoDB索引索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。 索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。 要创建索引，需要使用MongoDB的ensureIndex()方法。 语法 ensureIndex()方法的基本语法如下&gt;db.COLLECTION_NAME.ensureIndex({KEY:1}) 这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1. 例子 123456&gt;db.mycol.ensureIndex({&quot;title&quot;:1})&gt;在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。&gt;db.mycol.ensureIndex({&quot;title&quot;:1,&quot;description&quot;:-1})&gt; ensureIndex() 方法还接受选项列表（这是可选），其列表如下： MongoDB 聚合聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。 语法 aggregate()方法的基本语法如下&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 例子： 在集合中有以下数据： 123456789101112131415161718192021222324252627{ _id: ObjectId(7df78ad8902c) title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by_user: &apos;Yiibai Yiibai &apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100},{ _id: ObjectId(7df78ad8902d) title: &apos;NoSQL Overview&apos;, description: &apos;No sql database is very fast&apos;, by_user: &apos;Yiibai Yiibai&apos;, url: &apos;https://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 10},{ _id: ObjectId(7df78ad8902e) title: &apos;Neo4j Overview&apos;, description: &apos;Neo4j is no sql database&apos;, by_user: &apos;Neo4j&apos;, url: &apos;https://www.neo4j.com&apos;, tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 750}, 现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表： 123456789101112131415&gt; db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}]){ &quot;result&quot; : [ { &quot;_id&quot; : &quot;Yiibai Yiibai&quot;, &quot;num_tutorial&quot; : 2 }, { &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 } ], &quot;ok&quot; : 1}&gt; 用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。 MongoDB 复制复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。 为什么要复制？ 为了让数据安全 数据的高（24*7）可用性 灾难恢复 无停机维护（如备份，索引重建，压缩） 读取缩放（额外的副本来读取） 副本集是透明的应用 MongoDB复制的工作原理MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。 副本集是一组两个或更多个节点（通常至少3节点是必需的）。 在副本集一个节点是主节点和其余的节点都是次要的。 所有的数据复制是从主到次节点。 在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。 故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。 mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。副本集特征 N个节点的集群 任何节点可为原发/主节点 所有的写操作进入到主节点 自动故障转移 自动恢复","link":"/program/Python/mongodb/"},{"title":"python3 与 MongoDB 之间的交互","text":"MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。 1. 准备工作在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。 2. 连接MongoDB连接MongoDB时，我们需要使用PyMongo库里面的MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）： 12import pymongoclient = pymongo.MongoClient(host=&apos;localhost&apos;, port=27017) 这样就可以创建MongoDB的连接对象了。 另外，MongoClient的第一个参数host还可以直接传入MongoDB的连接字符串，它以mongodb开头，例如： 1client = MongoClient(&apos;mongodb://localhost:27017/&apos;) 这也可以达到同样的连接效果。 3. 指定数据库MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库： 1db = client.test 这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定： 1db = client[&apos;test&apos;] 这两种方式是等价的。 4. 指定集合MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。 下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式：collection = db.students collection = db['students']这样我们便声明了一个Collection对象。 5. 插入数据接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示： 123456student = { &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;} 这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下： 12result = collection.insert(student)print(result) 在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。 运行结果如下： 15932a68615c2606814c91f3d 当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下： 12345678910111213student1 = { &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;}student2 = { &apos;id&apos;: &apos;20170202&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 21, &apos;gender&apos;: &apos;male&apos;} 12result = collection.insert([student1, student2])print(result) 返回结果是对应的_id的集合： [ObjectId('5932a80115c2606a59e8a048'), ObjectId('5932a80115c2606a59e8a049')]实际上，在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下： 12345678910student = { &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;}result = collection.insert_one(student)print(result)print(result.inserted_id) 运行结果如下： 12&lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt;5932ab0f15c2606f0c1cf6c5 与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。 对于insert_many()方法，我们可以将数据以列表形式传递，示例如下： 1234567891011121314student1 = { &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;}student2 = { &apos;id&apos;: &apos;20170202&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 21, &apos;gender&apos;: &apos;male&apos;} 123result = collection.insert_many([student1, student2])print(result)print(result.inserted_ids) 运行结果如下： 12&lt;pymongo.results.InsertManyResult object at 0x101dea558&gt;[ObjectId(&apos;5932abf415c2607083d3b2ac&apos;), ObjectId(&apos;5932abf415c2607083d3b2ad&apos;)] 该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。 6. 查询插入数据后，我们可以利用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。示例如下： 123result = collection.find_one({&apos;name&apos;: &apos;Mike&apos;})print(type(result))print(result) 这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果如下： 12&lt;class &apos;dict&apos;&gt;{&apos;_id&apos;: ObjectId(&apos;5932a80115c2606a59e8a049&apos;), &apos;id&apos;: &apos;20170202&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 21, &apos;gender&apos;: &apos;male&apos;} 可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。 此外，我们也可以根据ObjectId来查询，此时需要使用bson库里面的objectid： 1234from bson.objectid import ObjectIdresult = collection.find_one({&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;)})print(result) 其查询结果依然是字典类型，具体如下： {'_id': ObjectId('593278c115c2602667ec6bae'), 'id': '20170101', 'name': 'Jordan', 'age': 20, 'gender': 'male'}当然，如果查询结果不存在，则会返回None。 对于多条数据的查询，我们可以使用find()方法。例如，这里查找年龄为20的数据，示例如下： 1234results = collection.find({&apos;age&apos;: 20})print(results)for result in results: print(result) 运行结果如下： 1234&lt;pymongo.cursor.Cursor object at 0x1032d5128&gt;{&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;), &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;}{&apos;_id&apos;: ObjectId(&apos;593278c815c2602678bb2b8d&apos;), &apos;id&apos;: &apos;20170102&apos;, &apos;name&apos;: &apos;Kevin&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;}{&apos;_id&apos;: ObjectId(&apos;593278d815c260269d7645a8&apos;), &apos;id&apos;: &apos;20170103&apos;, &apos;name&apos;: &apos;Harden&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;} 返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。 如果要查询年龄大于20的数据，则写法如下： results = collection.find({'age': {'$gt': 20}})这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。 这里将比较符号归纳为下表。腾讯云自媒体分享计划","link":"/program/Python/pymongo/"},{"title":"数据类型和变量","text":"Python 数据类型和变量 数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种： 整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。 计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 字符串字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。 如果字符串内部既包含’又包含”怎么办？可以用转义字符\\来标识，比如： 'I\\'m \\&quot;OK\\&quot;!'表示的字符串内容是： I'm &quot;OK&quot;!转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看： 12345678910&gt;&gt;&gt; print(&apos;I\\&apos;m ok.&apos;)I&apos;m ok.&gt;&gt;&gt; print(&apos;I\\&apos;m learning\\nPython.&apos;)I&apos;m learningPython.&gt;&gt;&gt; print(&apos;\\\\\\n\\\\&apos;)\\\\ 如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义，可以自己试试： 1234&gt;&gt;&gt; print(&apos;\\\\\\t\\\\&apos;)\\ \\&gt;&gt;&gt; print(r&apos;\\\\\\t\\\\&apos;)\\\\\\t\\\\ 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容，可以自己试试： 1234567&gt;&gt;&gt; print(&apos;&apos;&apos;line1... line2... line3&apos;&apos;&apos;)line1line2line3 上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分： 12345678910111213141516┌────────────────────────────────────────────────────────┐│Command Prompt - python _ □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; print(&apos;&apos;&apos;line1 ││... line2 ││... line3&apos;&apos;&apos;) ││line1 ││line2 ││line3 ││ ││&gt;&gt;&gt; _ ││ ││ ││ │└────────────────────────────────────────────────────────┘ 当输入完结束符12如果写成程序并存为.py文件，就是： print(‘’’line1line2line3’’’) 1多行字符串&apos;&apos;&apos;...&apos;&apos;&apos;还可以在前面加上r使用，请自行测试： -- coding: utf-8 --print(r’’’hello,\\nworld’’’) 1234 Run### 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来： TrueTrueFalseFalse3 &gt; 2True3 &gt; 5False 123布尔值可以用and、or和not运算。#### and运算是与运算，只有所有都为True，and运算结果才是True： True and TrueTrueTrue and FalseFalseFalse and FalseFalse5 &gt; 3 and 3 &gt; 1True 12#### or运算是或运算，只要其中有一个为True，or运算结果就是True： True or TrueTrueTrue or FalseTrueFalse or FalseFalse5 &gt; 3 or 1 &gt; 3True 12#### not运算是非运算，它是一个单目运算符，把True变成False，False变成True： not TrueFalsenot FalseTruenot 1 &gt; 2True 1布尔值经常用在条件判断中，比如： if age &gt;= 18: print(‘adult’)else: print(‘teenager’) 1234567891011121314151617181920### 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。### 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：`a = 1`变量a是一个整数。`t_007 = &apos;T007&apos;`变量t_007是一个字符串。`Answer = True`变量Answer是一个布尔值True。在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： -- coding: utf-8 --a = 123 # a是整数print(a)a = ‘ABC’ # a变为字符串print(a) 123 Run这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： int a = 123; // a是整数类型变量a = “ABC”; // 错误：不能把字符串赋给整型变量 123和静态语言相比，动态语言更灵活，就是这个原因。请不要把赋值语句的等号等同于数学的等号。比如下面的代码： x = 10x = x + 2 123456789101112如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。最后，理解变量在计算机内存中的表示也非常重要。当我们写：`a = &apos;ABC&apos;`时，Python解释器干了两件事情：在内存中创建了一个&apos;ABC&apos;的字符串；在内存中创建了一个名为a的变量，并把它指向&apos;ABC&apos;。也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： -- coding: utf-8 --a = ‘ABC’b = aa = ‘XYZ’print(b) 12345678910111213141516171819202122232425 Run最后一行打印出变量b的内容到底是&apos;ABC&apos;呢还是&apos;XYZ&apos;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&apos;XYZ&apos;，但实际上b的值是&apos;ABC&apos;，让我们一行一行地执行代码，就可以看到到底发生了什么事：执行a = &apos;ABC&apos;，解释器创建了字符串&apos;ABC&apos;和变量a，并把a指向&apos;ABC&apos;：![](https://www.liaoxuefeng.com/files/attachments/923791878255456/0)执行b = a，解释器创建了变量b，并把b指向a指向的字符串&apos;ABC&apos;：![](https://www.liaoxuefeng.com/files/attachments/923792058613440/0)执行a = &apos;XYZ&apos;，解释器创建了字符串&apos;XYZ&apos;，并把a的指向改为&apos;XYZ&apos;，但b并没有更改：![](https://www.liaoxuefeng.com/files/attachments/923792191637760/0)所以，最后打印变量b的结果自然是&apos;ABC&apos;了。### 常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：`PI = 3.14159265359`但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/： 10 / 33.3333333333333335 1/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 9 / 33.0 1还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 10 // 33 123你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数： 10 % 31 无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。 小结Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。 对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。 注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。","link":"/program/Python/python-type/"},{"title":"python3 与 MySQL 之间的交互","text":"什么是 PyMySQL？PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 安装mysql模块在文件中引入模块 import pymysql 1.Connection对象• 用于建立与数据库的连接• 创建对象：调用connect()方法conn=connect(参数列表)• 参数host：连接的mysql主机，如果本机是’localhost’• 参数port：连接的mysql主机的端口，默认是3306• 参数db：数据库的名称• 参数user：连接的用户名• 参数password：连接的密码• 参数charset：通信采用的编码方式，默认是’gb2312’，要求与数据库创建时指定的编码一致，否则中文会乱码 2.对象的方法• close()关闭连接• commit()事务，所以需要提交才会生效• rollback()事务，放弃之前的操作• cursor()返回Cursor对象，用于执行sql语句并获得结果 Cursor对象• 执行sql语句• 创建对象：调用Connection对象的cursor()方法cursor1=conn.cursor() 对象的方法• close()关闭• execute(operation [, parameters ])执行语句，返回受影响的行数• fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组• next()执行查询语句时，获取当前行的下一行• fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回• scroll(value[,mode])将行指针移动到某个位置• mode表示移动的方式• mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动。相对的• mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0，绝对的。 举个例子便于理解12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 导入python操作mysql的模块import pymysql# 获取连接对象conn = pymysql.connect(host='127.0.0.1', user='root', password='123456', database='python01', port=3306, charset='utf8')# 获取执行工具cur = conn.cursor()# sql语句,增删改#sql = 'select birthday from t_user'sql = 'select id,name,pwd,birthday from t_user'# 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数count = cur.execute(sql)print('查询的结果有%s条数据'%count)#获取第一行dateOne = cur.fetchone()print(dateOne)#向上移动一行cur.scroll(-1)#向下移动一行cur.scroll(1)cur.scroll(1,mode='absolute') 绝对的，这里指的是第一行cur.scroll(1,mode='relative') 相对的#获取所有行的数据dataAll = cur.fetchall()print(dataAll)for temp in dataAll: print(temp) print(dataAll[-1][2]) #dataAll[-1]得到的是一个用户所有的信息，dataAll[-1][2]获取最后一个人的密码for temp in cur: print(temp)s = 'id:%s,name:%s,pwd:%s,birthday:%s'for temp in dataAll: print(s%(temp[0],temp[1],temp[2],temp[3]))# 关闭cur.close()conn.close() 3.对象的属性• rowcount只读属性，表示最近一次execute()执行后受影响的行数• connection获得当前连接对象 2.增删改查(CRUD)1.增• 创建testInsert.py文件，向学生表中插入一条数据 123456789101112#encoding=utf-8import pymysqltry: conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;) cs1=conn.cursor() count=cs1.execute(&quot;insert into students(sname) values(&apos;张良&apos;)&quot;) print(count) conn.commit() cs1.close() conn.close()except Exception,e: print(e) 2.修改• 创建testUpdate.py文件，修改学生表的一条数据 123456789101112#encoding=utf-8import pymysqltry: conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;) cs1=conn.cursor() count=cs1.execute(&quot;update students set sname=&apos;刘邦&apos; where id=6&quot;) print(count) conn.commit() cs1.close() conn.close()except Exception,e: print(e) 3.删除• 创建testDelete.py文件，删除学生表的一条数据 1234567891011#encoding=utf-8 import pymysqltry: conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;) cs1=conn.cursor() count=cs1.execute(&quot;delete from students where id=6&quot;) print(count) conn.commit() cs1.close() conn.close()except Exception as e: print(e) 4.查• 创建testSelectOne.py文件，查询一条学生信息 12345678910import Pymysql try:conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)cur=conn.cursor()cur.execute(&apos;select * from students where id=7&apos;)result=cur.fetchone()print resultcur.close()conn.close()except Exception as e:print(e) • 创建testSelectMany.py文件，查询全部学生信息 1234567891011#encoding=utf8 import Pymysqltry:conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)cur=conn.cursor()cur.execute(&apos;select * from students&apos;)result=cur.fetchall()print resultcur.close()conn.close()except Exception as e:print(e) 实例一：参数1234567891011121314151617181920212223242526# 导入python操作mysql的模块import pymysqlimport time# 获取连接对象conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)# 获取执行工具cur = conn.cursor()# sql语句,增删改，sql注入sql = &apos;insert into t_user(name,pwd,birthday) values(%s,%s,%s)&apos;# 参数列表name = input(&apos;输入姓名:&apos;)pwd = input(&apos;输入密码:&apos;)birthday = input(&apos;输入生日:&apos;) # 2017年10月01日--&gt;日期struct_time(---&gt;2017-10-01)birthday = time.strptime(birthday,&apos;%Y年%m月%d日&apos;) #这里我们就用到了时间与字符串的相互转换(详情见MySQL高级)params = [name,pwd,birthday]# 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数count = cur.execute(sql,params)#提交conn.commit()print(&apos;受影响的行数:%s&apos;%count)# 关闭cur.close()conn.close() 实例二：抛出异常12345678910111213141516171819202122232425262728293031323334# 导入python操作mysql的模块import pymysqltry: conn = None cur = None # 获取连接对象 conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;) # 模拟异常 # a = 1 / 0 # 获取执行工具 cur = conn.cursor() # sql语句,增删改 sql = &apos;insert into t_user(name,pwd,birthday) values(&quot;小伊&quot;,&quot;123456&quot;,str_to_date(&quot;2017年10月20日&quot;,&quot;%Y年%m月%d日&quot;))&apos; # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数 count = cur.execute(sql) # 提交 conn.commit() print(&apos;受影响的行数:%s&apos; % count)except Exception as ex: # 打印异常信息，测试时候使用，项目上线，去掉 print(str(ex)) # 将异常继续抛出 # raisefinally: if cur != None: cur.close() if conn != None: conn.close() 实例三：12345678910111213141516171819202122232425262728293031# 导入python操作mysql的模块import pymysql# 获取连接对象conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)# 获取执行工具cur = conn.cursor()# sql语句,增删改#sql = &apos;select birthday from t_user&apos;sql = &apos;select id,name,pwd,birthday from t_user&apos;# 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数count = cur.execute(sql)print(&apos;查询的结果有%s条数据&apos;%count)#获取第一行# dateOne = cur.fetchone()# print(dateOne)# for temp in cur:# print(temp)s = &apos;id:%s,name:%s,pwd:%s,birthday:%s&apos;for temp in dataAll: print(s%(temp[0],temp[1],temp[2],temp[3]))# 关闭cur.close()conn.close() 3.封装这个库的名字：mySqlHelper python操作mysql进行增删改查的封装 1、增删改，代码类似 2、查询 代码分析 1、获取连接对象 2、sql语句不同，参数不同 3、获取执行对象 增删改 查询 1、fetchone 2、fetchall 4、处理结果 5、关闭面向对象 建立类，封装属性和函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import pymysqlclass MysqlHelper: &apos;&apos;&apos;python操作mysql的增删改查的封装&apos;&apos;&apos; def __init__(self, host, user, password, database, port=3306, charset=&apos;utf8&apos;): &apos;&apos;&apos; 初始化参数 :param host: 主机 :param user: 用户名 :param password: 密码 :param database: 数据库 :param port: 端口号，默认是3306 :param charset: 编码，默认是utf8 &apos;&apos;&apos; self.host = host self.port = port self.database = database self.user = user self.password = password self.charset = charset def connect(self): &apos;&apos;&apos; 获取连接对象和执行对象 :return: &apos;&apos;&apos; self.conn = pymysql.connect(host=self.host, user=self.user, password=self.password, database=self.database, port=self.port, charset=self.charset) self.cur = self.conn.cursor() def fetchone(self, sql, params=None): &apos;&apos;&apos; 根据sql和参数获取一行数据 :param sql: sql语句 :param params: sql语句对象的参数元组，默认值为None :return: 查询的一行数据 &apos;&apos;&apos; dataOne = None try: count = self.cur.execute(sql, params) if count != 0: dataOne = self.cur.fetchone() except Exception as ex: print(ex) finally: self.close() return dataOne def fetchall(self, sql, params=None): &apos;&apos;&apos; 根据sql和参数获取一行数据 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 查询的一行数据 &apos;&apos;&apos; dataall = None try: count = self.cur.execute(sql, params) if count != 0: dataall = self.cur.fetchall() except Exception as ex: print(ex) finally: self.close() return dataall def __item(self, sql, params=None): &apos;&apos;&apos; 执行增删改 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 &apos;&apos;&apos; count = 0 try: count = self.cur.execute(sql, params) self.conn.commit() except Exception as ex: print(ex) finally: self.close() return count def update(self, sql, params=None): &apos;&apos;&apos; 执行修改 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 &apos;&apos;&apos; return self.__item(sql, params) def insert(self, sql, params=None): &apos;&apos;&apos; 执行新增 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 &apos;&apos;&apos; return self.__item(sql, params) def delete(self, sql, params=None): &apos;&apos;&apos; 执行删除 :param sql: sql语句 :param params: sql语句对象的参数列表，默认值为None :return: 受影响的行数 &apos;&apos;&apos; return self.__item(sql, params) def close(self): &apos;&apos;&apos; 关闭执行工具和连接对象 &apos;&apos;&apos; if self.cur != None: self.cur.close() if self.conn != None: self.conn.close() 1.测试查询多条数据1234567891011121314151617181920import mysqlHelper# 初始化对象helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)# 连接helper.connect()# sqlsql = &apos;select * from t_user where name = %s and id &gt; %s&apos;# paramsparams = [&apos;小茗&apos;,1]# 执行data = helper.fetchall(sql, params)# 判断if data: for temp in data: print(temp)else: # None,False,0 print(&apos;没有数据.&apos;)helper.close() 2.测试查询一条数据12345678910111213141516171819import mysqlHelper# 初始化对象helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)# 连接helper.connect()# sqlsql = &apos;select * from t_user where id = %s&apos;#sql = &apos;select * from t_user where id = 1&apos;# paramsparams = [2]# 执行data = helper.fetchone(sql, params)#data = helper.fetchone(sql)# 判断if data: print(data)else: # None,False,0 print(&apos;没有数据.&apos;) 3.测试增删改12345678910111213141516171819202122import mysqlHelperimport time# 初始化对象helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)# 连接helper.connect()# sqlsql = &apos;update t_user set name =%s,pwd=%s,birthday=%s where id=%s&apos;# paramsid = input(&apos;输入编号:&apos;)name = input(&apos;输入姓名:&apos;)pwd = input(&apos;输入密码:&apos;)birthday = time.strptime(input(&apos;输入生日:&apos;), &apos;%Y年%m月%d日&apos;)params = [name, pwd, birthday,id]# 执行count = helper.update(sql, params)# 判断if count: print(&apos;操作成功.&apos;)else: # None,False,0 print(&apos;操作失败.&apos;) 4.登录和注册登录和注册的时候需要对密码进行加密 注意： • 需要对密码进行加密• 如果使用md5加密，则密码包含32个字符• 如果使用sha1加密，则密码包含40个字符，这里使用这种方式 123456789101112131415161718create table userinfos( id int primary key auto_increment, uname varchar(20), upwd char(40), isdelete bit default 0);/*ret = doPwd(&apos;123&apos;)print(ret)结果：40bd001563085fc35165329ea1ff5c5ecbdbbeef */-- 插入如下数据，用户名为123,密码为123,这是sha1加密后的值insert into userinfos values(1,&apos;123&apos;,&apos;40bd001563085fc35165329ea1ff5c5ecbdbbeef&apos;,0); 登录与注册1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from mysqlHelper import MysqlHelperimport hashlibdef login(): &apos;&apos;&apos;登录&apos;&apos;&apos; name = input(&apos;输入用户名:&apos;) pwd = input(&apos;输入密码:&apos;) #加密 pwd = doPwd(pwd) helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;) helper.connect() sql = &apos;select * from t_user where name=%s and pwd=%s&apos; params = [name, pwd] data = helper.fetchone(sql, params) if data: print(&apos;登录成功.&apos;) else: # None,False,0 print(&apos;登录失败.&apos;)def doPwd(pwd): &apos;&apos;&apos;sha1编码&apos;&apos;&apos; mysha1 = hashlib.sha1() mysha1.update(pwd.encode(&apos;utf-8&apos;)) pwd = mysha1.hexdigest() return pwddef register(): &apos;&apos;&apos;注册&apos;&apos;&apos; name = input(&apos;输入用户名:&apos;) pwd = input(&apos;输入密码:&apos;) # 加密 pwd = doPwd(pwd) helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;) helper.connect() sql = &apos;insert into t_user(name,pwd) values(%s,%s)&apos; params = [name, pwd] count = helper.insert(sql, params) if count: print(&apos;操作成功.&apos;) else: # None,False,0 print(&apos;操作失败.&apos;)if __name__ == &apos;__main__&apos;: #register() login()","link":"/program/Python/pymysql/"},{"title":"字典、列表、数组和字符串","text":"Python 字典、列表、数组和字符串 字典 1234567# -*- coding: UTF-8 -*-dict_1 = {'1': 'a', '2': 'b', '3': 'c'}print(dict_1) # 打印字典print(type(dict_1)) # 打印新赋值的字典的类型print(str(dict_1), end='字符串\\n') # 把字典转化成字符串后打印print(tuple(dict_1), end='元组\\n') # 把字典转化为元组后打印print(list(dict_1), end='列表\\n') # 把字典转化为列表后打印 元组 123456# -*- coding: UTF-8 -*-tuple_1 = (1, 2, 3, 4, 5)print(tuple_1) # 打印元组print(type(tuple_1)) # 打印新赋值的元祖的类型print(str(tuple_1), end='字符串\\n') # 把元组转化成字符串后打印print(list(tuple_1), end='列表\\n') # 把元组转化为列表后打印 元组不可转化为字典列表 123456# -*- coding: UTF-8 -*-list_1 = [1, 2, 3, 4, 5]print(list_1) # 打印列表print(type(list_1)) # 打印新赋值的列表的类型print(str(list_1), end='字符串\\n') # 把列表转化成字符串后打印print(tuple(list_1), end='元组\\n') # 把列表转化为元组后打印 元组不可转化为字典字符串 123456# -*- coding: UTF-8 -*-string_1 = '(1, 2, 3, 4, 5)'print(string_1) # 打印字符串print(type(string_1)) # 打印新赋值的字符串print(tuple(eval(string_1)), end='元组\\n') # 把字符串转化成元组后输出print(list(eval(string_1)), end='列表\\n') # 把字符串转化成列表后输出 只有特殊字符串才能转化为字典1234string_2 = '{\"name\":\"tom\",\"age\":6}'print(string_2) # 打印新赋值的字符串print(type(string_2)) # 打印新赋值的字符串的类型print(dict(eval(string_2)), end='字典\\n') # 把字符串转化为字典后打印","link":"/program/Python/python/"},{"title":"Python导图","text":"推荐：XMind 一个全功能的思维导图和头脑风暴软件。 Python 系列 (一) 核心知识 Python系列 (一) 基础编程 Python系列(二)常用标准库及拓展知识 Python应用领域和数据结构","link":"/program/Python/mind/"},{"title":"Python爬虫","text":"现在Python语言大火，在网络爬虫、人工智能、大数据等领域都有很好的应用。今天我向大家介绍一下Python爬虫的一些知识和常用类库的用法，希望能对大家有所帮助。 其实爬虫这个概念很简单，基本可以分成以下几个步骤： 发起网络请求 获取网页 解析网页获取数据 发起网络请求这个步骤常用的类库有标准库urllib以及Python上常用的requests库。解析网页常用的类库有的BeautifulSoup。另外requests的作者还开发了另一个很好用的库requests-html，提供了发起请求和解析网页的二合一功能，开发小型爬虫非常方便。另外还有一些专业的爬虫类库，其中比较出名的就是scrapy。本文将会简单介绍一下这些类库，之后还会专门写一篇文章介绍scrapy的用法。 标准库urllib首先先来看标准库urllib。标准库的优点是Python自带的，不需要安装任何第三方库，缺点就是urllib属于偏底层的库，使用起来比较麻烦。下面是urllib发起请求的一个简单例子，大家看看就好。可以看到为了发起一个简单的请求，我们需要创建opener、request、ProxyHandler等好几个对象，比较麻烦。 1234567891011121314151617181920import urllib.request as requestimport requestsproxies = { 'https': 'https://127.0.0.1:1080', 'http': 'http://127.0.0.1:1080'}headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'}print('--------------使用urllib--------------')url = 'http://www.google.com'opener = request.build_opener(request.ProxyHandler(proxies))request.install_opener(opener)req = request.Request(url, headers=headers)response = request.urlopen(req)print(response.read().decode()) requestsrequests是Kenneth Reitz大神的著名作品之一，优点就是极度简单和好用。首先来安装requests。 1pip install requests 下面是一个简单的例子，和上面urllib示例代码实现的功能相同，但是代码量少多了，也更易读。 1234print('--------------使用requests--------------')response = requests.get('https://www.google.com', headers=headers, proxies=proxies)response.encoding = 'utf8'print(response.text) requests还可以方便的发送表单数据，模拟用户登录。返回的Response对象还包含了状态码、header、raw、cookies等很多有用的信息。 12345678data = { 'name': 'yitian', 'age': 22, 'friends': ['zhang3', 'li4']}response = requests.post('http://httpbin.org/post', data=data)pprint(response.__dict__)print(response.text) 关于requests我就不多做介绍了，因为它有中文文档，虽然比官方落后几个小版本号，不过无伤大雅，大家可以放心参阅。 1http://cn.python-requests.org/zh_CN/latest/ beautifulsoup利用前面介绍的requests类库，我们可以轻易地获取HTML代码，但是为了从HTML中找到所需的数据，我们还需要HTML/XML解析库，BeautifulSoup就是这么一个常用的库。首先先来安装它： 1pip install beautifulsoup4 这次就用我简书主页作为例子，爬取一下我简书的文章列表。首先先用requests获取到网页内容。 1234567891011from pprint import pprintimport bs4import requestsheaders = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'}url = 'https://www.jianshu.com/u/7753478e1554'response = requests.get(url, headers=headers) 然后就是BeautifulSoup的代码了。在使用BeautifulSoup的时候首先需要创建一个HTML树，然后从树中查找节点。BeautifulSoup主要有两种查找节点的办法，第一种是使用find和find_all方法，第二种方法是使用select方法用css选择器。拿到节点之后，用contents去获取它的子节点，如果子节点是文本，就会拿到文本值，注意这个属性返回的是列表，所以要加[0]。 123456html = bs4.BeautifulSoup(response.text, features='lxml')note_list = html.find_all('ul', class_='note-list', limit=1)[0]for a in note_list.select('li&gt;div.content&gt;a.title'): title = a.contents[0] link = f'https://www.jianshu.com{a[\"href\"]}' print(f'《{title}》,{link}') BeautifulSoup也有中文文档，同样也是稍微落后两个小版本，影响不大。 1https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ requests-html这个类库是requests的兄弟，同样也是Kenneth Reitz大神的作品。它将请求网页和解析网页结合到了一起。本来如果你用requests的话只能请求网页，为了解析网页还得使用BeautifulSoup这样的解析库。现在只需要requests-html一个库就可以办到。首先先来安装。 1pip install requests-html 然后我们来看看用requests-html如何重写上面这个例子。 123456789101112131415from requests_html import HTMLSessionfrom pprint import pprinturl = 'https://www.jianshu.com/u/7753478e1554'headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'}session = HTMLSession()r = session.get(url, headers=headers)note_list = r.html.find('ul.note-list', first=True)for a in note_list.find('li&gt;div.content&gt;a.title'): title = a.text link = f'https://www.jianshu.com{a.attrs[\"href\"]}' print(f'《{title}》,{link}') requests-html除了可以使用css选择器来搜索以外，还可以使用xpath来查找。 1234for a in r.html.xpath('//ul[@class=\"note-list\"]/li/div[@class=\"content\"]/a[@class=\"title\"]'): title = a.text link = f'https://www.jianshu.com{a.attrs[\"href\"]}' print(f'《{title}》,{link}') requests-html还有一个很有用的特性就是浏览器渲染。有些网页是异步加载的，直接用爬虫去爬只能得到一个空页面，因为数据是靠浏览器运行JS脚本异步加载的，这时候就需要浏览器渲染了。而浏览器渲染用requests-html做非常简单，只要多调用一个render函数即可。render函数有两个参数，分别指定页面下滑次数和暂停时间。render函数第一次运行的时候，requests-html会下载一个chromium浏览器，然后用它渲染页面。简书的个人文章页面也是一个异步加载的例子，默认只会显示最近几篇文章，通过浏览器渲染模拟页面下滑，我们可以得到所有文章列表。 12345678session = HTMLSession()r = session.get(url, headers=headers)# render函数指示requests-html用chromium浏览器渲染页面r.html.render(scrolldown=50, sleep=0.2)for a in r.html.xpath('//ul[@class=\"note-list\"]/li/div[@class=\"content\"]/a[@class=\"title\"]'): title = a.text link = f'https://www.jianshu.com{a.attrs[\"href\"]}' print(f'《{title}》,{link}') 类似的，今日头条的个人页面也是异步加载的，所以也得调用render函数。 1234567891011121314from requests_html import HTMLSessionheaders = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'}session = HTMLSession()r = session.get('https://www.toutiao.com/c/user/6662330738/#mid=1620400303194116', headers=headers)r.html.render()for i in r.html.find('div.rbox-inner a'): title = i.text link = f'https://www.toutiao.com{i.attrs[\"href\"]}' print(f'《{title}》 {link}') 最后是requests-html的官网地址以及中文文档。 12https://html.python-requests.org/https://cncert.github.io/requests-html-doc-cn/ scrapy以上介绍的几个框架都是各自有各自的作用，把它们结合起来可以达到编写爬虫的目的，但是要说专业的爬虫框架，还是得谈谈scrapy。作为一个著名的爬虫框架，scrapy将爬虫模型框架化和模块化，利用scrapy，我们可以迅速生成功能强大的爬虫。不过scrapy概念众多，要仔细说还得专门开篇文章，这里就只简单演示一下。首先安装scrapy，如果是Windows系统，还需要安装pypiwin32。 12pip install scrapy pip install pypiwin32 然后创建scrapy项目并添加一个新爬虫。 123scrapy startproject myprojectcd myprojectscrapy genspider my jianshu.com 打开配置文件settings.py，设置用户代理，否则会遇到403错误。 1USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0' 然后修改一下爬虫。 1234567891011121314# -*- coding: utf-8 -*-import scrapyclass JianshuSpider(scrapy.Spider): name = 'jianshu' allowed_domains = ['jianshu.com'] start_urls = ['https://www.jianshu.com/u/7753478e1554'] def parse(self, response): for article in response.css('div.content'): yield { 'title': article.css('a.title::text').get(), 'link': 'https://www.jianshu.com' + article.xpath('a[@class=\"title\"]/@href').get() } 最后运行一下爬虫。 1scrapy crawl my 👇","link":"/program/Python/spider/"},{"title":"Markdown 的设计哲学","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 主要内容 Markdown是什么？谁创造了它？为什么要使用它？怎么使用？谁在用？尝试一下 正文1. Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 2. 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历： 14岁参与RSS 1.0规格标准的制订。 2004年入读斯坦福，之后退学。 2005年创建Infogami，之后与Reddit合并成为其合伙人。 2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。 2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。 2013年1月自杀身亡。 天才都有早逝的归途。 3. 为什么要使用它？ 它是易读（看起来舒服）、易写（语法简单）、易更改纯文本。处处体现着极简主义的影子。 兼容HTML，可以转换为HTML格式发布。 跨平台使用。 越来越多的网站支持Markdown。 更方便清晰地组织你的电子邮件。（Markdown-here, Airmail） 摆脱Word（我不是认真的）。 4. 怎么使用？如果不算扩展，Markdown的语法绝对简单到让你爱不释手。 Markdown语法主要分为如下几大部分：标题，段落，区块引用，代码区块，强调，列表，分割线，链接，图片，反斜杠 \\，符号’`’。 4.1 标题两种形式：1）使用=和-标记一级和二级标题。 一级标题=========二级标题--------- 效果： 一级标题 二级标题 2）使用#，可表示1-6级标题。 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 4.2 段落段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 4.3 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： &gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 4.4 代码区块代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如普通段落： void main(){ printf(“Hello, Markdown.”);} 代码区块： void main() { printf(&quot;Hello, Markdown.&quot;); }注意:需要和普通段落之间存在空行。 4.5 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，斜体粗体，粗体 4.6 列表使用·、+、或-标记无序列表，如： -（+*） 第一项-（+*） 第二项- （+*）第三项 注意：标记后面最少有一个_空格或制表符_。若不在引用区块中，必须和前方段落之间存在空行。 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1 . 第一项2 . 第二项3 . 第三项 效果： 第一项 第二项 第三项 4.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_。 4.8 链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。 效果： younghz的Markdown库。 参考式： [younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https:://github.com/younghz/Markdown “Markdown”[2]:https:://github.com/younghz/Markdown “Markdown” 效果： younghz的Markdown库1younghz的Markdown库2 注意：上述的[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;不出现在区块中。 4.9 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 4.10 反斜杠\\相当于反转义作用。使符号成为普通符号。 4.11 符号’`’起到标记作用。如： `ctrl+a` 效果： ctrl+a 5. 谁在用？Markdown的使用者： GitHub 简书 Stack Overflow Apollo Moodle Reddit 等等 6. 尝试一下 Chrome下的插件诸如stackedit与markdown-here等非常方便，也不用担心平台受限。 在线的dillinger.io评价也不错 Windowns下的MarkdownPad也用过，不过免费版的体验不是很好。 Mac下的Mou是国人贡献的，口碑很好。 Linux下的ReText不错。 当然，最终境界永远都是笔下是语法，心中格式化 :)。 注意：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。虽然有人想出面搞一个所谓的标准化的Markdown，[创始人John Gruber](https://blog.codinghorror.com/standard-markdown-is-now-common-markdown/ )。 以上基本是所有traditonal markdown的语法。 其它：列表的使用(非traditonal markdown)： 用|表示表格纵向边界，表头和表内容用-隔开，并可用:进行对齐设置，两边都有:则表示居中，若不加:则默认左对齐。 代码库 链接 MarkDown https://github.com/younghz/Markdown MarkDownCopy https://github.com/younghz/Markdown 视频 关于其它扩展语法可参见具体工具的使用说明。","link":"/program/Markdown/markdown/"},{"title":"Python利用openpyxl来操作Excel","text":"自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。 如下所示： 123456from openpyxl import load_workbookfrom openpyxl.styles import colors, Font, Fill, NamedStylefrom openpyxl.styles import PatternFill, Border, Side, Alignment # 加载文件wb = load_workbook(&apos;./5a.xlsx&apos;) workbook： 工作簿，一个excel文件包含多个sheet。 worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。 cell： 单元格，存储数据对象文章所用表格为： 操作sheet12345678# 读取sheetnameprint(&apos;输出文件所有工作表名：\\n&apos;, wb.sheetnames)ws = wb[&apos;5a&apos;] # 或者不知道名字时sheet_names = wb.sheetnames # 返回一个列表ws2 = wb[sheet_names[0]] # index为0为第一张表print(ws is ws2) # 两者是一样的 输出文件所有工作表名：[‘5a’]True 1234# 修改sheetname ws.title = &apos;5a_&apos;print(&apos;修改sheetname：\\n&apos;, wb.sheetnames) 修改sheetname：[‘5a_’] 12345678# 创建新的sheet# 创建的新表必须要赋值给一个对象，不然只有名字但是没有实际的新表 ws4 = wb.create_sheet(index=0, title=&apos;newsheet&apos;)# 什么参数都不写的话，默认插入到最后一个位置且名字为sheet,sheet1...按照顺序排列 ws5 = wb.create_sheet()print(&apos;创建新的sheet:\\n&apos;, wb.sheetnames) 创建新的sheet:[‘newsheet’, ‘5a_’, ‘Sheet’] 123# 删除sheetwb.remove(ws4) # 这里只能写worksheet对象，不能写sheetnameprint(&apos;删除sheet：\\n&apos;, wb.sheetnames) 删除sheet：[‘5a_’, ‘Sheet’] 1234567# 修改sheet选项卡背景色，默认为白色，设置为RRGGBB模式ws.sheet_properties.tabColor = &quot;FFA500&quot; # 读取有效区域 print(&apos;最大列数为：&apos;, ws.max_column)print(&apos;最大行数为：&apos;, ws.max_row) 最大列数为： 5最大行数为： 17 1234567# 插入行和列ws.insert_rows(1) # 在第一行插入一行ws.insert_cols(2, 4) # 从第二列开始插入四列 # 删除行和列ws.delete_cols(6, 3) # 从第六列（F列）开始，删除3列即（F:H）ws.delete_rows(3) # 删除第三行 单元格操作12345# 读取c = ws[&apos;A1&apos;]c1 = ws.cell(row=1, column=2)print(c, c1)print(c.value, c1.value) &lt;Cell ‘5a_’.A1&gt; &lt;Cell ‘5a_’.B1&gt;dth_title Province 1234# 修改ws[&apos;A1&apos;] = &apos;景区名称&apos;ws.cell(1, 2).value = &apos;省份&apos;print(c.value, c1.value) 景区名称 省份 1234567891011# 读取多个单元格 cell_range = ws[&apos;A1&apos;:&apos;D5&apos;]colC = ws[&apos;C&apos;]col_range = ws[&apos;C:D&apos;]row10 = ws[10]row_range = ws[5:10]# 其返回的结果都是一个包含单元格的元组print(type(cell_range))for i in row10: print(i) # row10只有有效单元格 &lt;class ‘tuple’&gt;&lt;Cell ‘5a_’.A10&gt;&lt;Cell ‘5a_’.B10&gt;&lt;Cell ‘5a_’.C10&gt;&lt;Cell ‘5a_’.D10&gt;&lt;Cell ‘5a_’.E10&gt; 123456# 按照行列操作for row in ws.iter_rows(min_row=1, max_row=3, min_col=1, max_col=2): for cell in row: print(cell)# 也可以用worksheet.iter_col(),用法都一样 &lt;Cell ‘5a_’.A1&gt;&lt;Cell ‘5a_’.B1&gt;&lt;Cell ‘5a_’.A2&gt;&lt;Cell ‘5a_’.B2&gt;&lt;Cell ‘5a_’.A3&gt;&lt;Cell ‘5a_’.B3&gt; 1234567891011121314# 合并单元格ws.merge_cells(&apos;F1:G1&apos;)ws[&apos;F1&apos;] = &apos;合并两个单元格&apos;# 或者ws.merge_cells(start_row=2, start_column=6, end_row=3, end_column=8)ws.cell(2, 6).value = &apos;合并三个单元格&apos; # 取消合并单元格ws.unmerge_cells(&apos;F1:G1&apos;)# 或者ws.unmerge_cells(start_row=2, start_column=6, end_row=3, end_column=8) wb.save(&apos;./5a.xlsx&apos;)# 保存之前的操作,保存文件时，文件必须是关闭的！！！ 注意！！！，openpyxl对Excel的修改并不像是xlwings包一样是实时的，他的修改是暂时保存在内存中的，所以当 后面的修改例如我接下来要在第一行插入新的一行做标题，那么当我对新的A1单元格操作的时候，还在内存中的原A1(现在是A2)的单元格 原有的修改就会被覆盖。所以要先保存，或者从一开始就计划好更改操作避免这样的事情发生。 样式修改单个单元格样式123456789101112131415161718192021222324252627282930313233343536373839wb = load_workbook(&apos;./5a.xlsx&apos;) # 读取修改后的文件ws = wb[&apos;5a_&apos;]# 我们来设置一个表头ws.insert_rows(1) # 在第一行插入新的一行ws.merge_cells(&apos;A1:E1&apos;) # 合并单元格a1 = ws[&apos;A1&apos;]ws[&apos;A1&apos;] = &apos;5A级风景区名单&apos; # 设置字体ft = Font(name=&apos;微软雅黑&apos;, color=&apos;000000&apos;, size=15, b=True)&quot;&quot;&quot;name:字体名称color:颜色通常是RGB或aRGB十六进制值b(bold):加粗（bool）i(italic):倾斜(bool)shadow：阴影（bool）underline：下划线（‘doubleAccounting’, ‘single’, ‘double’, ‘singleAccounting’）charset:字符集(int)strike:删除线(bool)&quot;&quot;&quot;a1.font = ft # 设置文本对齐 ali = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;)&quot;&quot;&quot;horizontal:水平对齐(&apos;centerContinuous&apos;, &apos;general&apos;, &apos;distributed&apos;, &apos;left&apos;, &apos;fill&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;right&apos;)vertical:垂直对齐（&apos;distributed&apos;, &apos;top&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;bottom&apos;）&quot;&quot;&quot;a1.alignment = ali # 设置图案填充 fill = PatternFill(&apos;solid&apos;, fgColor=&apos;FFA500&apos;)# 颜色一般使用十六进制RGB# &apos;solid&apos;是图案填充类型，详细可查阅文档 a1.fill = fill openpyxl.styles.fills模块参数文档 123456789101112131415161718192021# 设置边框bian = Side(style=&apos;medium&apos;, color=&apos;000000&apos;) # 设置边框样式&quot;&quot;&quot;style:边框线的风格{&apos;dotted&apos;,&apos;slantDashDot&apos;,&apos;dashDot&apos;,&apos;hair&apos;,&apos;mediumDashDot&apos;, &apos;dashed&apos;,&apos;mediumDashed&apos;,&apos;thick&apos;,&apos;dashDotDot&apos;,&apos;medium&apos;, &apos;double&apos;,&apos;thin&apos;,&apos;mediumDashDotDot&apos;}&quot;&quot;&quot; border = Border(top=bian, bottom=bian, left=bian, right=bian)&quot;&quot;&quot;top（上）,bottom（下）,left（左）,right（右）:必须是 Side类型diagonal: 斜线 side类型 diagonalDownd: 右斜线 booldiagonalDown: 左斜线 bool&quot;&quot;&quot; # a1.border = borderfor item in ws[&apos;A1:E1&apos;][0]: # 去元组中的每一个cell更改样式 item.border = border wb.save(&apos;./5a.xlsx&apos;) # 保存更改 再次注意！！！： 不能使用 a1.border = border，否则只会如下图情况，B1：E1单元格没有线。我个人认为是因为线框涉及到相邻单元格边框的改动所以需要单独对每个单元格修改才行。不能使用ws[‘A1:E1’].border = border,由前面的内容可知，openpyxl的多个单元格其实是一个元组，而元组是没有style的方法的,所以必须一个一个改！！其实官方有其他办法，后面讲。 按列或行设置样式12345678910111213141516171819202122232425262728293031323334353637383940# 现在我们对整个表进行设置 # 读取wb = load_workbook(&apos;./5a.xlsx&apos;)ws = wb[&apos;5a_&apos;] # 读取数据表格范围rows = ws.max_rowcols = ws.max_column # 字体font1 = Font(name=&apos;微软雅黑&apos;, size=11, b=True)font2 = Font(name=&apos;微软雅黑&apos;, size=11) # 边框line_t = Side(style=&apos;thin&apos;, color=&apos;000000&apos;) # 细边框line_m = Side(style=&apos;medium&apos;, color=&apos;000000&apos;) # 粗边框border1 = Border(top=line_m, bottom=line_t, left=line_t, right=line_t)# 与标题相邻的边设置与标题一样border2 = Border(top=line_t, bottom=line_t, left=line_t, right=line_t) # 填充fill = PatternFill(&apos;solid&apos;, fgColor=&apos;CFCFCF&apos;) # 对齐alignment = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;) # 将样式打包命名sty1 = NamedStyle(name=&apos;sty1&apos;, font=font1, fill=fill, border=border1, alignment=alignment)sty2 = NamedStyle(name=&apos;sty2&apos;, font=font2, border=border2, alignment=alignment) for r in range(2, rows+1): for c in range(1, cols): if r == 2: ws.cell(r, c).style = sty1 else: ws.cell(r, c).style = sty2 wb.save(&apos;./5a.xlsx&apos;) 最后：","link":"/program/Python/python-excel/"},{"title":"3D touch","text":"","link":"/program//3Dtouch/"},{"title":"python操作excel的包(openpyxl、xlsxwriter)","text":"现在支持python操作excel的包有下列这些 官网上最推荐的是openpyxl，其他包支持较老的excel版本。 xlsxwriter无法对打开的excel进行写操作，excel必须处于关闭状态才能写成功。 xlswriter 基本代码：12345678import xlsxwriterworkbook = xlsxwriter.Workbook(&apos;hello.xlsx&apos;)worksheet = workbook.add_worksheet()worksheet.write(&apos;A1&apos;, &apos;Hello world&apos;)workbook.close() openpyxl基本代码：1234567891011121314from openpyxl import Workbookwb = Workbook()ws = wb.active#设置单元格值ws[&apos;A1&apos;] = 42#加入一行数据ws.append([1, 2, 3])import datetime#python 类型数据会被自动转换ws[&apos;A2&apos;] = datetime.datetime.now()#保存修改wb.save(&quot;sample.xlsx&quot;) 来源:脚本之家","link":"/program/Python/python-writer/"},{"title":"细说GCD（Grand Central Dispatch）如何用","text":"文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。文中的Demo在这里 https://github.com/ming1016/GCDDemo 对着文章试着来调demo体会更深哦，细细嚼消化好:) GCD（Grand Central Dispatch） 介绍GCD属于系统级的线程管理，在Dispatch queue中执行需要执行的任务性能非常的高。GCD这块已经开源，地址https://libdispatch.macosforge.org。GCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。 GCD概要 和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。 操作是在多线程上还是单线程主要是看队列的类型和执行方法，并行队列异步执行才能在多线程，并行队列同步执行就只会在这个并行队列在队列中被分配的那个线程执行。（TorchLennon 指出先前文中此句一处错误） 基本概念 系统标准两个队列 1234//全局队列，一个并行的队列dispatch_get_global_queue//主队列，主线程中的唯一队列，一个串行队列dispatch_get_main_queue 自定义队列 1234//串行队列dispatch_queue_create(&quot;com.starming.serialqueue&quot;, DISPATCH_QUEUE_SERIAL)//并行队列dispatch_queue_create(&quot;com.starming.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT) 同步异步线程创建 1234//同步线程dispatch_sync(..., ^(block))//异步线程dispatch_async(..., ^(block)) 队列（dispatch queue） Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。系统提供四个全局并发队列，这四个队列有这对应的优先级，用户是不能够创建全局队列的，只能获取。 12dipatch_queue_t queue;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0); user create queue：创建自己定义的队列，可以用dispatch_queue_create函数，函数有两个参数，第一个自定义的队列名，第二个参数是队列类型，默认NULL或者DISPATCH_QUEUE_SERIAL的是串行，参数为DISPATCH_QUEUE_CONCURRENT为并行队列。 12dispatch_queue_t queuequeue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT); 自定义队列的优先级：可以通过dipatch_queue_attr_make_with_qos_class或dispatch_set_target_queue方法设置队列的优先级 12345678//dipatch_queue_attr_make_with_qos_classdispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, -1);dispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.qosqueue&quot;, attr);//dispatch_set_target_queuedispatch_queue_t queue = dispatch_queue_create(&quot;com.starming.gcddemo.settargetqueue&quot;,NULL); //需要设置优先级的queuedispatch_queue_t referQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0); //参考优先级dispatch_set_target_queue(queue, referQueue); //设置queue和referQueue的优先级一样 dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行，如下 12345678910111213141516171819dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t firstQueue = dispatch_queue_create(&quot;com.starming.gcddemo.firstqueue&quot;, DISPATCH_QUEUE_SERIAL);dispatch_queue_t secondQueue = dispatch_queue_create(&quot;com.starming.gcddemo.secondqueue&quot;, DISPATCH_QUEUE_CONCURRENT);dispatch_set_target_queue(firstQueue, serialQueue);dispatch_set_target_queue(secondQueue, serialQueue);dispatch_async(firstQueue, ^{ NSLog(@&quot;1&quot;); [NSThread sleepForTimeInterval:3.f];});dispatch_async(secondQueue, ^{ NSLog(@&quot;2&quot;); [NSThread sleepForTimeInterval:2.f];});dispatch_async(secondQueue, ^{ NSLog(@&quot;3&quot;); [NSThread sleepForTimeInterval:1.f];}); 队列类型队列默认是串行的，如果设置改参数为NULL会按串行处理，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block 123456789101112- (id)init;{ self = [super init]; if (self != nil) { NSString *label = [NSString stringWithFormat:@&quot;%@.isolation.%p&quot;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@&quot;%@.work.%p&quot;, [self class], self]; self.workQueue = dispatch_queue_create([label UTF8String], 0); } return self;} 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为 QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。 示例：后台加载显示图片 12345678910override func viewDidLoad() { super.viewDidLoad() dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { // 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成， let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(dispatch_get_main_queue()) { // 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。 self.fadeInNewImage(overlayImage) // 更新UI } }} 何时使用何种队列类型 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。 可以使用下面的方法简化QoS等级参数的写法 1234567891011121314151617181920212223var GlobalMainQueue: dispatch_queue_t { return dispatch_get_main_queue()}var GlobalUserInteractiveQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0)}var GlobalUserInitiatedQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)}var GlobalUtilityQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0)}var GlobalBackgroundQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0)}//使用起来就是这样，易读而且容易看出在使用哪个队列dispatch_async(GlobalUserInitiatedQueue) { let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(GlobalMainQueue) { self.fadeInNewImage(overlayImage) }} dispatch_once用法dispatch_once_t要是全局或static变量，保证dispatch_once_t只有一份实例 12345678910+ (UIColor *)boringColor;{ static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; }); return color;} dispatch_async设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列 123456789- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;{ dispatch_async(self.isolationQueue, ^(void){ // do actual processing here dispatch_async(self.resultQueue, ^(void){ handler(YES); }); });} 可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。 12345678910111213141516171819//代码框架dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{ // 更新界面 });});//下载图片的示例dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSURL * url = [NSURL URLWithString:@&quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) { dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; }); }}); dispatch_after延后执行dispatch_after只是延时提交block，不是延时立刻执行。 12345678- (void)foo{ double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self bar]; });} 范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。 12345678910111213func showOrHideNavPrompt() { let delayInSeconds = 1.0 let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 在这里声明推迟的时间 dispatch_after(popTime, GlobalMainQueue) { // 等待delayInSeconds将闭包异步到主队列 let count = PhotoManager.sharedManager.photos.count if count &gt; 0 { self.navigationItem.prompt = nil } else { self.navigationItem.prompt = &quot;Add photos with faces to Googlyify them!&quot; } }} 例子中的dispatch time的参数，可以先看看函数原型 1dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta ); 第一个参数为DISPATCH_TIME_NOW表示当前。第二个参数的delta表示纳秒，一秒对应的纳秒为1000000000，系统提供了一些宏来简化 123#define NSEC_PER_SEC 1000000000ull //每秒有多少纳秒#define USEC_PER_SEC 1000000ull //每秒有多少毫秒#define NSEC_PER_USEC 1000ull //每毫秒有多少纳秒 这样如果要表示一秒就可以这样写 123dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC); dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样 1234567891011121314151617181920212223242526272829303132333435363738//创建队列self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);//改变setter- (void)setCount:(NSUInteger)count forKey:(NSString *)key{ key = [key copy]; //确保所有barrier都是async异步的 dispatch_barrier_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } });}- (void)dispatchBarrierAsyncDemo { //防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。 dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.starming.gcddemo.dataqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(dataQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;read data 1&quot;); }); dispatch_async(dataQueue, ^{ NSLog(@&quot;read data 2&quot;); }); //等待前面的都完成，在执行barrier后面的 dispatch_barrier_async(dataQueue, ^{ NSLog(@&quot;write data 1&quot;); [NSThread sleepForTimeInterval:1]; }); dispatch_async(dataQueue, ^{ [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;read data 3&quot;); }); dispatch_async(dataQueue, ^{ NSLog(@&quot;read data 4&quot;); });} swift示例 12345678910111213141516171819202122//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。private let concurrentPhotoQueue = dispatch_queue_create(&quot;com.raywenderlich.GooglyPuff.photoQueue&quot;, DISPATCH_QUEUE_CONCURRENT)func addPhoto(photo: Photo) { dispatch_barrier_async(concurrentPhotoQueue) { // 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。 self._photos.append(photo) // barrier能够保障不会和其他任务同时进行。 dispatch_async(GlobalMainQueue) { // 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。 self.postContentAddedNotification() } }}//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。var photos: [Photo] { var photosCopy: [Photo]! dispatch_sync(concurrentPhotoQueue) { // 同步调度到concurrentPhotoQueue队列执行读操作 photosCopy = self._photos // 保存 } return photosCopy}//这样读写问题都解决了。 都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。 dispatch_apply进行快速迭代类似for循环，但是在并发队列的情况下dispatch_apply会并发执行block任务。 12345678910111213for (size_t y = 0; y &lt; height; ++y) { for (size_t x = 0; x &lt; width; ++x) { // Do something with x and y here }}//因为可以并行执行，所以使用dispatch_apply可以运行的更快- (void)dispatchApplyDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_apply(10, concurrentQueue, ^(size_t i) { NSLog(@&quot;%zu&quot;,i); }); NSLog(@&quot;The end&quot;); //这里有个需要注意的是，dispatch_apply这个是会阻塞主线程的。这个log打印会在dispatch_apply都结束后才开始执行} dispatch_apply能避免线程爆炸，因为GCD会管理并发 123456789101112131415161718- (void)dealWiththreadWithMaybeExplode:(BOOL)explode { dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); if (explode) { //有问题的情况，可能会死锁 for (int i = 0; i &lt; 999 ; i++) { dispatch_async(concurrentQueue, ^{ NSLog(@&quot;wrong %d&quot;,i); //do something hard }); } } else { //会优化很多，能够利用GCD管理 dispatch_apply(999, concurrentQueue, ^(size_t i){ NSLog(@&quot;correct %zu&quot;,i); //do something hard }); }} 示例： 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) { i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } }} Block组合Dispatch_groupsdispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。 当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。 第一种使用dispatch_group_wait的swift的例子： 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { dispatch_async(GlobalUserInitiatedQueue) { // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) { // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion { // 执行闭包内容 completion(error: storedError) } } }} oc例子 1234567891011121314- (void)dispatchGroupWaitDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;1&quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;2&quot;); }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;go on&quot;);} 第二种使用dispatch_group_notify的swift的例子： 123456789101112131415161718192021222324252627func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { // 不用加dispatch_async，因为没有阻塞主进程 var storedError: NSError! var downloadGroup = dispatch_group_create() for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { // dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。 if let completion = completion { completion(error: storedError) } }} oc例子 1234567891011121314151617181920212223242526272829303132//dispatch_group_notify- (void)dispatchGroupNotifyDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;1&quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;2&quot;); }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@&quot;end&quot;); }); NSLog(@&quot;can continue&quot;);}//dispatch_group_wait- (void)dispatchGroupWaitDemo { dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); //在group中添加队列的block dispatch_group_async(group, concurrentQueue, ^{ [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;1&quot;); }); dispatch_group_async(group, concurrentQueue, ^{ NSLog(@&quot;2&quot;); }); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@&quot;can continue&quot;);} 如何对现有API使用dispatch_group_t 12345678910111213141516171819202122232425262728293031323334//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block{ if (group == NULL) { [self performBlock:block]; } else { dispatch_group_enter(group); [self performBlock:^(){ block(); dispatch_group_leave(group); }]; }}//NSURLConnection也可以这样做+ (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler{ if (group == NULL) { [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; } else { dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){ handler(response, data, error); dispatch_group_leave(group); }]; }} 注意事项 dispatch_group_async等价于dispatch_group_enter() 和 dispatch_group_leave()的组合。 dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的 Dispatch Block队列执行任务都是block的方式， 创建block 1234567891011121314- (void)createDispatchBlock { //normal way dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.starming.gcddemo.concurrentqueue&quot;,DISPATCH_QUEUE_CONCURRENT); dispatch_block_t block = dispatch_block_create(0, ^{ NSLog(@&quot;run block&quot;); }); dispatch_async(concurrentQueue, block); //QOS way dispatch_block_t qosBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INITIATED, -1, ^{ NSLog(@&quot;run qos block&quot;); }); dispatch_async(concurrentQueue, qosBlock);} dispatch_block_wait：可以根据dispatch block来设置等待时间，参数DISPATCH_TIME_FOREVER会一直等待block结束 123456789101112- (void)dispatchBlockWaitDemo { dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t block = dispatch_block_create(0, ^{ NSLog(@&quot;star&quot;); [NSThread sleepForTimeInterval:5.f]; NSLog(@&quot;end&quot;); }); dispatch_async(serialQueue, block); //设置DISPATCH_TIME_FOREVER会一直等到前面任务都完成 dispatch_block_wait(block, DISPATCH_TIME_FOREVER); NSLog(@&quot;ok, now can go on&quot;);} dispatch_block_notify：可以监视指定dispatch block结束，然后再加入一个block到队列中。三个参数分别为，第一个是需要监视的block，第二个参数是需要提交执行的队列，第三个是待加入到队列中的block 1234567891011121314- (void)dispatchBlockNotifyDemo { dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^{ NSLog(@&quot;first block start&quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;first block end&quot;); }); dispatch_async(serialQueue, firstBlock); dispatch_block_t secondBlock = dispatch_block_create(0, ^{ NSLog(@&quot;second block run&quot;); }); //first block执行完才在serial queue中执行second block dispatch_block_notify(firstBlock, serialQueue, secondBlock);} dispatch_block_cancel：iOS8后GCD支持对dispatch block的取消 123456789101112131415- (void)dispatchBlockCancelDemo { dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_block_t firstBlock = dispatch_block_create(0, ^{ NSLog(@&quot;first block start&quot;); [NSThread sleepForTimeInterval:2.f]; NSLog(@&quot;first block end&quot;); }); dispatch_block_t secondBlock = dispatch_block_create(0, ^{ NSLog(@&quot;second block run&quot;); }); dispatch_async(serialQueue, firstBlock); dispatch_async(serialQueue, secondBlock); //取消secondBlock dispatch_block_cancel(secondBlock);} 使用dispatch block object（调度块）在任务执行前进行取消dispatch block object可以为队列中的对象设置示例，下载图片中途进行取消 123456789101112131415161718192021222324252627282930313233343536373839404142func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! let downloadGroup = dispatch_group_create() var addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] addresses += addresses + addresses // 扩展address数组，复制3份 var blocks: [dispatch_block_t] = [] // 一个保存block的数组 for i in 0 ..&lt; addresses.count { dispatch_group_enter(downloadGroup) let block = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) { // 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS let index = Int(i) let address = addresses[index] let url = NSURL(string: address) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } blocks.append(block) dispatch_async(GlobalMainQueue, block) // 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。 } for block in blocks[3 ..&lt; blocks.count] { let cancel = arc4random_uniform(2) // 随机返回一个整数，会返回0或1 if cancel == 1 { dispatch_block_cancel(block) // 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。 dispatch_group_leave(downloadGroup) // 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。 } } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } }} Dispatch IO 文件操作dispatch io读取文件的方式类似于下面的方式，多个线程去读取文件的切片数据，对于大的数据文件这样会比单线程要快很多。 123dispatch_async(queue,^{/*read 0-99 bytes*/});dispatch_async(queue,^{/*read 100-199 bytes*/});dispatch_async(queue,^{/*read 200-299 bytes*/}); dispatch_io_create：创建dispatch io dispatch_io_set_low_water：指定切割文件大小 dispatch_io_read：读取切割的文件然后合并。 苹果系统日志API里用到了这个技术，可以在这里查看：https://github.com/Apple-FOSS-Mirror/Libc/blob/2ca2ae74647714acfc18674c3114b1a5d3325d7d/gen/asl.c 12345678910111213141516171819202122232425262728293031323334353637383940pipe_q = dispatch_queue_create(&quot;PipeQ&quot;, NULL);//创建pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM, fd, pipe_q, ^(int err){ close(fd);});*out_fd = fdpair[1];//设置切割大小dispatch_io_set_low_water(pipe_channel, SIZE_MAX);dispatch_io_read(pipe_channel, 0, SIZE_MAX, pipe_q, ^(bool done, dispatch_data_t pipedata, int err){ if (err == 0) { size_t len = dispatch_data_get_size(pipedata); if (len &gt; 0) { //对每次切块数据的处理 const char *bytes = NULL; char *encoded; uint32_t eval; dispatch_data_t md = dispatch_data_create_map(pipedata, (const void **)&amp;bytes, &amp;len); encoded = asl_core_encode_buffer(bytes, len); asl_msg_set_key_val(aux, ASL_KEY_AUX_DATA, encoded); free(encoded); eval = _asl_evaluate_send(NULL, (aslmsg)aux, -1); _asl_send_message(NULL, eval, aux, NULL); asl_msg_release(aux); dispatch_release(md); } } if (done) { //semaphore +1使得不需要再等待继续执行下去。 dispatch_semaphore_signal(sem); dispatch_release(pipe_channel); dispatch_release(pipe_q); }}); Dispatch Source 用GCD监视进程Dispatch Source用于监听系统的底层对象，比如文件描述符，Mach端口，信号量等。主要处理的事件如下表 方法 说明 DISPATCH_SOURCE_TYPE_DATA_ADD 数据增加 DISPATCH_SOURCE_TYPE_DATA_OR 数据OR DISPATCH_SOURCE_TYPE_MACH_SEND Mach端口发送 DISPATCH_SOURCE_TYPE_MACH_RECV Mach端口接收 DISPATCH_SOURCE_TYPE_MEMORYPRESSURE 内存情况 DISPATCH_SOURCE_TYPE_PROC 进程事件 DISPATCH_SOURCE_TYPE_READ 读数据 DISPATCH_SOURCE_TYPE_SIGNAL 信号 DISPATCH_SOURCE_TYPE_TIMER 定时器 DISPATCH_SOURCE_TYPE_VNODE 文件系统变化 DISPATCH_SOURCE_TYPE_WRITE 文件写入 方法 dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。 dispatch_source_set_event_handler：设置事件处理handler dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。 dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。 1234567891011NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];if (mail == nil) { return;}pid_t const pid = mail.processIdentifier;self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(self.source, ^(){ NSLog(@&quot;Mail quit.&quot;);});//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法dispatch_resume(self.source); 监视文件夹内文件变化 12345678910111213141516171819202122232425NSURL *directoryURL; // assume this is set to a directoryint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) { char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@&quot;Unable to open \\&quot;%@\\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno); return;}dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^(){ unsigned long const data = dispatch_source_get_data(source); if (data &amp; DISPATCH_VNODE_WRITE) { NSLog(@&quot;The directory changed.&quot;); } if (data &amp; DISPATCH_VNODE_DELETE) { NSLog(@&quot;The directory has been deleted.&quot;); }});dispatch_source_set_cancel_handler(source, ^(){ close(fd);});self.source = source;dispatch_resume(self.source);//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听 NSTimer在主线程的runloop里会在runloop切换其它模式时停止，这时就需要手动在子线程开启一个模式为NSRunLoopCommonModes的runloop，如果不想开启一个新的runloop可以用不跟runloop关联的dispatch source timer，如下。 12345678dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^(){ NSLog(@&quot;Time flies.&quot;);});dispatch_time_t startdispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);self.source = source;dispatch_resume(self.source); Dispatch Semaphore和的介绍另外一种保证同步的方法。使用dispatch_semaphore_signal加1dispatch_semaphore_wait减1，为0时等待的设置方式来达到线程同步的目的和同步锁一样能够解决资源抢占的问题。 12345678910111213//dispatch semaphore- (void)dispatchSemaphoreDemo { //创建semaphore dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;start&quot;); [NSThread sleepForTimeInterval:1.f]; NSLog(@&quot;semaphore +1&quot;); dispatch_semaphore_signal(semaphore); //+1 semaphore }); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@&quot;continue&quot;);} 锁这里简单介绍下iOS中常用的各种锁和他们的性能。 NSRecursiveLock：递归锁，可以在一个线程中反复获取锁不会造成死锁，这个过程会记录获取锁和释放锁的次数来达到何时释放的作用。 NSDistributedLock：分布锁，基于文件方式的锁机制，可以跨进程访问。 NSConditionLock：条件锁，用户定义条件，确保一个线程可以获取满足一定条件的锁。因为线程间竞争会涉及到条件锁检测，系统调用上下切换频繁导致耗时是几个锁里最长的。 OSSpinLock：自旋锁，不进入内核，减少上下文切换，性能最高，但抢占多时会占用较多cpu，好点多，这时使用pthread_mutex较好。 pthread_mutex_t：同步锁基于C语言，底层api性能高，使用方法和其它的类似。 @synchronized：更加简单。 dispatch_suspend和dispatch_resume挂起和恢复队列dispatch_suspend这里挂起不会暂停正在执行的block，只是能够暂停还没执行的block。 dispatch_set_context和dispatch_get_contextGCD深入操作 缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域 I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close 测试：使用dispatch_benchmark小工具 原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。 GCD死锁当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (void)deadLockCase1 { NSLog(@&quot;1&quot;); //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;); }); NSLog(@&quot;3&quot;);}- (void)deadLockCase2 { NSLog(@&quot;1&quot;); //3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行 dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{ NSLog(@&quot;2&quot;); }); NSLog(@&quot;3&quot;);}- (void)deadLockCase3 { dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.starming.gcddemo.serialqueue&quot;, DISPATCH_QUEUE_SERIAL); NSLog(@&quot;1&quot;); dispatch_async(serialQueue, ^{ NSLog(@&quot;2&quot;); //串行队列里面同步一个串行队列就会死锁 dispatch_sync(serialQueue, ^{ NSLog(@&quot;3&quot;); }); NSLog(@&quot;4&quot;); }); NSLog(@&quot;5&quot;);}- (void)deadLockCase4 { NSLog(@&quot;1&quot;); dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;2&quot;); //将同步的串行队列放到另外一个线程就能够解决 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;3&quot;); }); NSLog(@&quot;4&quot;); }); NSLog(@&quot;5&quot;);}- (void)deadLockCase5 { dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@&quot;1&quot;); //回到主线程发现死循环后面就没法执行了 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;); }); NSLog(@&quot;3&quot;); }); NSLog(@&quot;4&quot;); //死循环 while (1) { // }} GCD实际使用FMDB如何使用dispatch_queue_set_specific和dispatch_get_specific来防止死锁作用类似objc_setAssociatedObject跟objc_getAssociatedObject 1234567891011static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;//创建串行队列，所有数据库的操作都在这个队列里_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);//标记队列dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);//检查是否是同一个队列来避免死锁的方法- (void)inDatabase:(void (^)(FMDatabase *db))block { FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);} DTCoreText使用GCD加快解析速度DTCoreText采用的是SAX解析，iOS自带了XML/HTML的解析引擎libxml，提供了两个解析接口，DOM解析和SAX解析，前者使用简单但是占用内存多，SAX解析由于不会返回一个dom树，采用的是查到一个标签比如回调startElement方法碰到内容就回调_characters碰到类似就回调endElement这样的方式。 根据这种解析方式DTCoreText使用多线程解析能够更快的解析，DTHTMLAttributedStringBuilder使用三个dispatch_queue _dataParsingQueue：解析html的 _treeBuildingQueue：生成dom树的 _stringAssemblyQueue：组装NSAttributeString的获取三个队列全部完成采用了dispatch_group的dispatch_group_wait这种阻塞同步方式来返回结果。 iOS系统版本新特性iOS8iOS8新加了一个功能叫Quality of Service(QoS)，里面提供了一下几个更容易理解的枚举名来使用user interactive，user initiated，utility和background。下面的表做了对比 Global queue Corresponding QoS class 说明 Main thread NSQualityOfServiceUserInteractive UI相关，交互等 DISPATCH_QUEUE_PRIORITY_HIGH NSQualityOfServiceUserInitiated 用户发起需要马上得到结果进行后续任务 DISPATCH_QUEUE_PRIORITY_DEFAULT NSQualityOfServiceDefault 默认的不应该使用这个设置任务 DISPATCH_QUEUE_PRIORITY_LOW NSQualityOfServiceUtility 花费时间稍多比如下载，需要几秒或几分钟的 DISPATCH_QUEUE_PRIORITY_BACKGROUND NSQualityOfServiceBackground 不可见在后台的操作可能需要好几分钟甚至几小时的 参考资料WWDC Building Responsive and Efficient Apps with GCD：https://developer.apple.com/videos/play/wwdc2015-718/ 文档 官方文档：https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/","link":"/program//GCD/"},{"title":"《Python札记》1_列表list","text":"写于开始之前笔者即将开始写一个系列的《Python札记》。本系列的札记主要是自学齐伟老师《跟老齐学Python轻松入门》一书整理而来。书第一遍断断续续花了5个月，第二遍边看边整理，保守3个月。 在此深深感谢齐伟老师带我入门Python。工欲善其事，必先利其器，本札记的学习环境为：Python3.7.2 + pycharm + jupyter notebook： Python3取代了Python2，成为主流 针对Python语言，Pycharm是最好的IDE Jupyter notebook是利用Python进行机器学习的强大利器 本札记一定会在2个月之内完成，主要内容包含： 学习笔记整理 代码实战练习 各种练习题 利用Python实现常用算法 机器学习_Python算法 希望对Python感兴趣的朋友有所帮助，自己也在努力学习中，将来主要方向是：机器学习+数据挖掘+量化投资 良好的开始是成功的一半！Let`s go go go!!! 列表是Python中使用非常广泛的一种对象，用方括号[ ]来表示。括号里面可以是数字，字符串或者True，False的布尔值，或者是多种不同类型的对象，里面也可以嵌套列表。如果列表是空的，用bool()来进行判断，会返回 False。 一、索引、切片、反转列表和字符串一样，都是序列，里面的元素是有序的，也有索引和切片。索引index左边从0开始，右边从-1开始，index()函数可以查看某个元素的索引编号。 索引 左边0开始，右边-1开始 通过index()函数查看索引编号 12345# lang = ['python', 'java', 'html']# lang.index('python')0 # 索引从0开始# lang.index('html')2 切片 索引左边从0开始，右边-1开始 含头不含尾 步长可正可负 12345678910111213lst = [1, 2, 3, 4, 5, 6]print(lst[:]) # 相当于是复制 lst[1, 2, 3, 4, 5, 6]print(lst[::2]) # 步长是2 [开始:结束:步长][1, 3, 5]print(lst[-3:-1])lst = [1,2,3,4,5,6]print(lst[1:5:2]) # 常规用法print(lst[-5:-2:2]) # 标号-5代表的是元素2，标号-2代表的是5，步长为2print(lst[-5:4:2])print(lst[1:-2:2])[2,4] 反转 通过步长-1进行反转，[::-1] 通过reversed()进行反转，得到的是可迭代对象，并且将迭代对象转为为列表显示 123456789101112# 反转1print(lst[::-1]) # 通过步长为-1进行反转print(lst) # 不影响原来对象[6, 5, 4, 3, 2, 1][1, 2, 3, 4, 5, 6]# 反转2print(list(reversed(lst))) # 通过reversed函数进行反转[6,5,4,3,2,1]print(list(reversed('abcde'))) # 对字符串进行反转，列表显示['e', 'd', 'c', 'b', 'a'] 二、操作列表基本操作 len()：求长度 +：连接两个序列 *：复制序列 in：判断元素是否在列表中 max()、min()：按照元素的字典顺序进行排序 1、修改元素 列表中的元素可以进行修改，但是字符串中的不能进行修改。列表中修改的时候，直接通过索引号进行指定： 1234lst[2] = 7 # 指定第三个元素为7print(lst)[1, 2, 7, 4, 5, 6] 2、增加元素追加元素的方法有两种，都是追加在末尾 append()函数进行追加 切片的方式进行追加：a[len(a):] = [ x ] 1234lst.append(8) lst[len(lst):] = [8]print(lst)[1, 2, 7, 4, 5, 6, 8] # 例子承接上面，第三个元素为7，不是3 3、列表函数 函数 作用 append 将单个元素追加到列表的最右边，即末尾部分；list[len(list):] = [x]，x是待追加的元素； 没有返回值None extend 将两个列表进行合并，扩充列表的作用； 参数必须是可迭代对象； list[len(list):] = L，L是待并入的列表； 完成追加过程，列表L不变，list发生变化； 没有返回值None insert 指定位置添加元素 格式：list.insert(i,x)，i是插入的位置，x是待追加元素 ； i如果是0，相当于是插在首位；i如果是len(list)，相当于是插在最后面，则等价于append()函数 1234567891011121314151617181920212223242526# extend()函数lst = [1, 2, 7, 4, 5, 6, 8]print(id(lst)) # 查看lst的内存地址lst1 = ['python', 'java', 'html']lst.extend(lst1)print(id(lst)) # 查看追加列表之后的内存地址，与原来系相同的print(\"lst:\", lst)print(\"lst1:\", lst1)24353342649682435334264968lst: [1, 2, 7, 4, 5, 6, 8, 'python', 'java', 'html']lst1: ['python', 'java', 'html']# append与extend区别lst1 = [1, 2, 3]lst2 = ['python', 'html', 'java']lst1.append(lst2)print(lst1)[1, 2, 3, ['python', 'html', 'java']] # 整建制，将lst2当做一个整体lst1 = [1, 2, 3]lst2 = ['python', 'html', 'java']lst1.extend(lst2)print(lst1)[1, 2, 3, 'python', 'html', 'java'] # 个体化，将lst2的每个元素进行追加 结论： 列表是可以进行修改的，原地修改 append是将一个元素加到列表的末尾，整建制追加 extend将两个列表进行合并，个体化扩编 extend方法执行之后，内存中id不变，只是在该id上的内容发生了变化 insert()函数中的i如果超过最大索引值，则自动追加到末尾，相当于是append()函数的作用 三种方法均是原地修改，无返回值 函数 作用 count 查看元素重复出现的次数 如果不存在，返回0，而不是报错 index 查看索引编号，不存在则报错 检索的是元素第一次出现的位置 remove 删除元素，原地修改，无返回值； list.remove(x)：如果x不存在，则会报错； 如果x出现多次，删除第一个x，剩下不变 pop pop([i]):参数是可选的； 为空，默认删除最后一个，并且将该元素作为返回值； 如果不为空，可删除索引为i的元素，并且将该元素作为返回值 reverse 原地反转，没有生成新的列表，没有返回值 reversed 类似reverse，区别：生成的列表能够用于迭代 remove和pop的区别 remove 没有返回值，pop有返回值 remove的参数是元素，pop的参数是索引 1234567891011121314151617181920lst1 = [1, 2, 3, 4, 5, 6]lst1.remove(2)print(lst1)# lst1.remove(7)# print(lst1) ValueError: list.remove(x): x not in listlst1.pop(2)print(lst1)[1, 3, 4, 5, 6] # 将元素2删除掉[1, 3, 5, 6] # 将索引为2的元素3删除掉，本步骤是接在上面的执行，即在列表[1, 3, 4, 5, 6] 中删除4# 关于反转lst = [1, 2, 3, 4, 5]print(lst[::-1]) # 反转实现1print(lst) # 原来的列表对象不改变lst.reverse() # 反转实现2print(lst) # 原来的列表变成反转之后的新列表lst1= reversed(lst)print(lst1) # lst1是一个列表反转迭代器对象：&lt;list_reverseiterator object at 0x00000233C677F320&gt;print(list(lst1)) # 用list函数显示lst1的内容 函数 作用 sort 排序函数，用于列表list中，原地修改没有返回值； 默认从小到大；将reverse=True则变成从大到小排序sort(self, /, *, key=None, reverse=False) sorted 对所有可迭代对象进行操作，返回一个新的 list，不是在原来的list上进行操作 sorted(iterable[, cmp[, key[, reverse]]]) 12345678910111213141516171819202122232425# sort()lst = [1, 4, 5, 8, 2, 6, 3]lst.sort()print(lst)lst1 = ['python', ‘Java’, 'html', 'c', 'php']lst1.sort(key=len) # 列表中的字符串进行排序；如果长度相同，则按照出现的先后顺序print(lst1)[1, 2, 3, 4, 5, 6, 8]['c', 'php', 'Java', 'html', 'python']# sorted()lst = [1, 4, 5, 8, 2, 6, 3]lst1 = sorted(lst)print(lst) # 原对象不变print(lst1) # 新列表为排序后的对象lst2 =[('python', 'A'),('java', 'C'),('c', 'D'),('php', 'B')]lst3 = sorted(lst2, key=lambda x: x[1]) # 由元组构成的复合列表，按照元组的第二个元素进行排序，通过匿名函数lamba()print(lst3)[('python', 'A'), ('php', 'B'), ('java', 'C'), ('c', 'D')]lst4 = sorted(lst2, key=lambda x: len(x[0])) # 通过元组中第一个元素的长度进行排序print(lst4)[('c', 'D'), ('php', 'B'), ('java', 'C'), ('python', 'A')] 自定义类中的元素进行排序1234567891011121314151617181920212223class Student: def __init__(self, name, age, grade): self.name = name self.age = age self.grade = grade def __repr__(self): return repr((self.name, self.grade, self.age)) students_objects = [ Student('Tom', 'B', 12), Student('xiaoming','A',17), Student('xiaohong', 'C', 12), Student('Peter', 'D', 8),]lst5 = sorted(students_objects, key=lambda t:t.age) # 自定义类中，按照年龄进行排序print(lst5)lst6 = sorted(students_objects, key=lambda t:(t.age, t.grade)) # 使用元组，先根据年龄排序，若年龄相同按照grade排序print(lst6)[('xiaoming', 17, 'A'), ('Tom', 12, 'B'), ('xiaohong', 12, 'C'), ('Peter', 8, 'D')][('xiaoming', 17, 'A'), ('Tom', 12, 'B'), ('xiaohong', 12, 'C'), ('Peter', 8, 'D')] 原文链接👇","link":"/program/Python/python3-notes01/"},{"title":"什么是RxSwift","text":"相信大家很早就听说过函数式响应编程概念，我是去年面试的时候接触到函数式响应编程的，当时也是第一次接触到MVVM这个概念，转眼都一年过去了，我却没有在函数式编程上做深入的研究，说来还真是惭愧。不过最近由于想要使用RxSwift，所以趁这个时候好好接触和研究一下传说中的函数式编程，由于网上关于RxSwift的教程资料很少，这篇文章其实就是最RxSwift官方文档和一些概念做一些解读。算是大家学习的参考文章吧！ 先挖个坑，这可能会是一个RxSwift系列，希望大家在学习的时候有所参考。 RxSwift是什么RxSwif是ReactiveX的Swift版本，也就是一个函数式响应编程的框架。对，就这一句话。想要知道他做什么的，我们先来了解一下观察者模式。 观察者模式关于观察者模式我想大伙应该都很了解了吧，什么KVO，通知等都是观察者模式，在设计模式中他可是一个重中之重的设计模式啊！比如一个宝宝在睡觉，爸爸妈妈，爷爷奶奶总不能在那边一只看着吧？那样子太累了。他们该做啥事就做啥事呗，只要听到宝宝的哭声，他们就给宝宝喂奶就行了。这就是一个典型的观察者模式。宝宝是被观察者，爸爸妈妈等是观察者也称作订阅者，只要被观察者发出了某些事件比如宝宝哭声、叫声都是一个事件，通知到订阅者，订阅者们就可以做相应的处理工作。哈哈，观察者模式很简单吧？ RxSwift做了什么RxSwift把我们程序中每一个操作都看成一个事件，比如一个TextField中的文本改变，一个按钮被点击，或者一个网络请求结束等，每一个事件源就可以看成一个管道，也就是sequence，比如TextField，当我们改变里面的文本的时候，这个TextField就会不断的发出事件，从他的这个sequence中不断的流出，我们只需要监听这个sequence，每流出一个事件就做相应的处理。同理，Button也是一个sequence，每点击一次就流出一个事件。也就是我们把每一步都想成是一个事件就好去理解RxSwift了。看下图是不是很好理解了？ Observable和Observer理解了观察者模式这两个概念就很好理解了，Observable就是可被观察的，也就是我们说的宝宝，他也是事件源。而Observer就是我们的观察者，也就是当收到事件的时候去做某些处理的爸爸妈妈。观察者需要去订阅(subscribe)被观察者，才能收到Observable的事件通知消息。下面开始一些基本概念解读，通读一遍你会对RxSwift有非常深刻的认识了，其实也就是对整理了一下官方文档和加上自己的一些理解 创建和订阅被观察者下面创建被观察者其实就是创建一个Obserable的sequence，就是创建一个流，然后就可以被订阅subscribe，这样被观察者发出时间消失，我们就能做相应的处理 DisposeBagDisposeBag其实就相当于iOS中的ARC似得，会在适当的时候销毁观察者，相当于内存管理者吧。 subscribesubscribe是订阅sequence发出的事件，比如next事件，error事件等。而subscribe(onNext:)是监听sequence发出的next事件中的element进行处理，他会忽略error和completed事件。相对应的还有subscribe(onError:) 和 subscribe(onCompleted:) nevernever就是创建一个sequence，但是不发出任何事件信号。 1234567let disposeBag = DisposeBag()let neverSequence = Observable.never() let neverSequenceSubscription = neverSequence .subscribe { _ in print(&quot;This will never be printed&quot;)}.addDisposableTo(disposeBag) 结果是什么都不打印 emptyempty就是创建一个空的sequence,只能发出一个completed事件 12345678let disposeBag = DisposeBag() Observable.empty() .subscribe { event in print(event) } .addDisposableTo(disposeBag) completed justjust是创建一个sequence只能发出一种特定的事件，能正常结束 1234567let disposeBag = DisposeBag() Observable.just(&quot;&quot;) .subscribe { event in print(event) } .addDisposableTo(disposeBag) 12next()completed ofof是创建一个sequence能发出很多种事件信号 12345678let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .subscribe(onNext: { element in print(element) }) .addDisposableTo(disposeBag) 如果把上面的onNext:去掉的话，结果会是这样子，也正好对应了我们subscribe中，subscribe只监听事件。 12345next()next()next()next()completed fromfrom就是从集合中创建sequence，例如数组，字典或者Set 12345let disposeBag = DisposeBag() Observable.from([&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) create我们也可以自定义可观察的sequence，那就是使用createcreate操作符传入一个观察者observer，然后调用observer的onNext，onCompleted和onError方法。返回一个可观察的obserable序列。 1234567891011121314let disposeBag = DisposeBag() let myJust = { (element: String) -&gt; Observable in return Observable.create { observer in observer.on(.next(element)) observer.on(.completed) return Disposables.create() }} myJust(&quot;&quot;) .subscribe { print($0) } .addDisposableTo(disposeBag) 123next()completed rangerange就是创建一个sequence，他会发出这个范围中的从开始到结束的所有事件 12345let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .subscribe { print($0) } .addDisposableTo(disposeBag) 123456789101112next(1)next(2)next(3)next(4)next(5)next(6)next(7)next(8)next(9)next(10)completed repeatElement创建一个sequence，发出特定的事件n次 123456let disposeBag = DisposeBag() Observable.repeatElement(&quot;&quot;) .take(3) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) generategenerate是创建一个可观察sequence，当初始化的条件为true的时候，他就会发出所对应的事件 12345let disposeBag = DisposeBag() Observable.generate( initialState: 0, condition: { $0 123012 deferreddeferred会为每一为订阅者observer创建一个新的可观察序列下面例子中每次进行subscribe的时候都会去创建一个新的deferredSequence，所以Emitting会打印两遍。 1234567891011121314151617181920212223let disposeBag = DisposeBag()var count = 1 let deferredSequence = Observable.deferred { print(&quot;Creating \\(count)&quot;) count += 1 return Observable.create { observer in print(&quot;Emitting...&quot;) observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) return Disposables.create() }} deferredSequence .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) deferredSequence .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) 12345678Creating 1Emitting... Creating 2Emitting... error创建一个可观察序列，但不发出任何正常的事件，只发出error事件并结束 12345let disposeBag = DisposeBag() Observable.error(TestError.test) .subscribe { print($0) } .addDisposableTo(disposeBag) error(test) doOndoOn我感觉就是在直接onNext处理时候，先执行某个方法，doOnNext( :)方法就是在subscribe(onNext:)前调用，doOnCompleted(:)就是在subscribe(onCompleted:)前面调用的。 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .do(onNext: { print(&quot;Intercepted:&quot;, $0) }, onError: { print(&quot;Intercepted error:&quot;, $0) }, onCompleted: { print(&quot;Completed&quot;) }) .subscribe(onNext: { print($0) },onCompleted: { print(&quot;结束&quot;) }) .addDisposableTo(disposeBag) 1234567891011Intercepted: Intercepted: Intercepted: Intercepted: Completed结束 学会使用SubjectsSubjet是observable和Observer之间的桥梁，一个Subject既是一个Obserable也是一个Observer，他既可以发出事件，也可以监听事件。 PublishSubject当你订阅PublishSubject的时候，你只能接收到订阅他之后发生的事件。subject.onNext()发出onNext事件，对应的还有onError()和onCompleted()事件 12345678910let disposeBag = DisposeBag()let subject = PublishSubject() subject.addObserver(&quot;1&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;&quot;)subject.onNext(&quot;&quot;) subject.addObserver(&quot;2&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;️&quot;)subject.onNext(&quot;️&quot;) 1234567Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 1 Event: next(️)Subscription: 2 Event: next(️) ReplaySubject当你订阅ReplaySubject的时候，你可以接收到订阅他之后的事件，但也可以接受订阅他之前发出的事件，接受几个事件取决与bufferSize的大小 12345678910let disposeBag = DisposeBag()let subject = ReplaySubject.create(bufferSize: 1) subject.addObserver(&quot;1&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;&quot;)subject.onNext(&quot;&quot;) subject.addObserver(&quot;2&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;️&quot;)subject.onNext(&quot;️&quot;) 12345678Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 2 Event: next() //订阅之后还可以接受一次前面发出的事件Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 1 Event: next(️)Subscription: 2 Event: next(️) BehaviorSubject当你订阅了BehaviorSubject，你会接受到订阅之前的最后一个事件。 1234567891011121314let disposeBag = DisposeBag()let subject = BehaviorSubject(value: &quot;&quot;) subject.addObserver(&quot;1&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;&quot;)subject.onNext(&quot;&quot;) subject.addObserver(&quot;2&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;️&quot;)subject.onNext(&quot;️&quot;) subject.addObserver(&quot;3&quot;).addDisposableTo(disposeBag)subject.onNext(&quot;&quot;)subject.onNext(&quot;&quot;) 12345678910111213141516Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 2 Event: next() //订阅之前的最后一个事件Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 3 Event: next(️) //订阅之前的最后一个事件Subscription: 1 Event: next()Subscription: 3 Event: next()Subscription: 2 Event: next()Subscription: 1 Event: next()Subscription: 3 Event: next()Subscription: 2 Event: next() PublishSubject, ReplaySubject和BehaviorSubject是不会自动发出completed事件的。 VariableVariable是BehaviorSubject一个包装箱，就像是一个箱子一样，使用的时候需要调用asObservable()拆箱，里面的value是一个BehaviorSubject，他不会发出error事件，但是会自动发出completed事件。 1234567891011let disposeBag = DisposeBag()let variable = Variable(&quot;&quot;) variable.asObservable().addObserver(&quot;1&quot;).addDisposableTo(disposeBag)variable.value = &quot;&quot;variable.value = &quot;&quot; variable.asObservable().addObserver(&quot;2&quot;).addDisposableTo(disposeBag)variable.value = &quot;️&quot;variable.value = &quot;️&quot; 1234567891011Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 1 Event: next()Subscription: 2 Event: next()Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 1 Event: next(️)Subscription: 2 Event: next(️)Subscription: 1 Event: completedSubscription: 2 Event: completed 联合操作联合操作就是把多个Observable流合成单个Observable流 startWith在发出事件消息之前，先发出某个特定的事件消息。比如发出事件2 ，3然后我startWith(1)，那么就会先发出1，然后2 ，3. 123456let disposeBag = DisposeBag() Observable.of(&quot;2&quot;, &quot;3&quot;) .startWith(&quot;1&quot;) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) merge合并两个Observable流合成单个Observable流，根据时间轴发出对应的事件 123456789101112131415161718192021let disposeBag = DisposeBag() let subject1 = PublishSubject()let subject2 = PublishSubject() Observable.of(subject1, subject2) .merge() .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) subject1.onNext(&quot;️&quot;) subject1.onNext(&quot;️&quot;) subject2.onNext(&quot;①&quot;) subject2.onNext(&quot;②&quot;) subject1.onNext(&quot;&quot;) subject2.onNext(&quot;③&quot;) 12345①② ③ zip绑定超过最多不超过8个的Observable流，结合在一起处理。注意Zip是一个事件对应另一个流一个事件。 1234567891011121314151617181920let disposeBag = DisposeBag() let stringSubject = PublishSubject()let intSubject = PublishSubject() Observable.zip(stringSubject, intSubject) { stringElement, intElement in &quot;\\(stringElement) \\(intElement)&quot; } .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) stringSubject.onNext(&quot;️&quot;)stringSubject.onNext(&quot;️&quot;) intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext(&quot;&quot;)intSubject.onNext(3) 1234️ 1 将stringSubject和intSubject压缩到一起共同处理️ 23 combineLatest绑定超过最多不超过8个的Observable流，结合在一起处理。和Zip不同的是combineLatest是一个流的事件对应另一个流的最新的事件，两个事件都会是最新的事件，可将下图与Zip的图进行对比。 12345678910111213141516171819let disposeBag = DisposeBag() let stringSubject = PublishSubject()let intSubject = PublishSubject() Observable.combineLatest(stringSubject, intSubject) { stringElement, intElement in &quot;\\(stringElement) \\(intElement)&quot; } .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) stringSubject.onNext(&quot;️&quot;) stringSubject.onNext(&quot;️&quot;)intSubject.onNext(1) intSubject.onNext(2) stringSubject.onNext(&quot;&quot;) 1234️ 1️ 22 switchLatestswitchLatest可以对事件流进行转换，本来监听的subject1，我可以通过更改variable里面的value更换事件源。变成监听subject2了 1234567891011121314151617181920212223let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: &quot;⚽️&quot;)let subject2 = BehaviorSubject(value: &quot;&quot;) let variable = Variable(subject1) variable.asObservable() .switchLatest() .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) subject1.onNext(&quot;&quot;)subject1.onNext(&quot;&quot;) variable.value = subject2 subject1.onNext(&quot;⚾️&quot;) subject2.onNext(&quot;&quot;)variable.value = subject1subject2.onNext(“XX&quot;)subject1.onNext(“XX&quot;) 12345678⚽️ ⚾️XX 变换操作map通过传入一个函数闭包把原来的sequence转变为一个新的sequence的操作 12345let disposeBag = DisposeBag()Observable.of(1, 2, 3) .map { $0 * $0 } .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) 12341 每一个元素自己相乘49 flatMap将一个sequence转换为一个sequences，当你接收一个sequence的事件，你还想接收其他sequence发出的事件的话可以使用flatMap，她会将每一个sequence事件进行处理以后，然后再以一个sequence形式发出事件。而且flatMap有一次拆包动作，请看代码解析。 1234567891011121314151617181920212223242526let disposeBag = DisposeBag() struct Player { var score: Variable //里面是一个Variable} let = Player(score: Variable(80)) let = Player(score: Variable(90))let = Player(score: Variable(550)) let player = Variable() //将player转为Variable player.asObservable() //拆箱转成可被监听的sequence .flatMap { $0.score.asObservable() } // flatMap有一次拆包动作，$0本来应该是一个BehaviorSubject类型，但是直接访问了score。所以猜想flatMap对behaviorSubject进行了onNext拆包取数据 .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) .score.value = 85 player.value = //更换了value，相当于又添加了一个sequence，两个sequence都可以接收 .score.value = 95.score.value = 222player.value = .score.value = 100 1234567880859095222550100 flatMapLatestflatMapLatest只会接收最新的value事件，将上例改为flatMapLatest。结果为 12345808590550 scanscan就是给一个初始化的数，然后不断的拿前一个结果和最新的值进行处理操作。 123456789let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .scan(1) { aggregateValue, newValue in aggregateValue + newValue } .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) 1234111111111 过滤和约束filterfilter很好理解，就是过滤掉某些不符合要求的事件 123456789101112let disposeBag = DisposeBag() Observable.of( &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .filter { $0 == &quot;&quot; } .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) distinctUntilChangeddistinctUntilChanged就是当下一个事件与前一个事件是不同事件的事件才进行处理操作 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .distinctUntilChanged() .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) elementAt只处理在指定位置的事件 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .elementAt(3) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) single找出在sequence只发出一次的事件，如果超过一个就会发出error错误 12345Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .single() .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) 123 //单一信号超过了一个Received unhandled error: /var/folders/hz/v15ld5mj0nqf83d21j13y0tw0000gn/T/./lldb/7229/playground107.swift:69:__lldb_expr_107 -&gt; Sequence contains more than one element. 12345Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .single { $0 == &quot;&quot; } //青蛙只有一个，completed .subscribe { print($0) } .addDisposableTo(disposeBag) 12345Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .single { $0 == &quot;&quot; } //兔子有两个，会发出error .subscribe { print($0) } .addDisposableTo(disposeBag) 12345Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .single { $0 == &quot;&quot; } //没有蓝色球，会发出error .subscribe { print($0) } .addDisposableTo(disposeBag) take只处理前几个事件信号, 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .take(3) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) takeLast只处理后几个事件信号 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .takeLast(3) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) takeWhile当条件满足的时候进行处理 1234let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .takeWhile { $0 takeUntil接收事件消息，直到另一个sequence发出事件消息的时候。 1234567891011121314151617181920let disposeBag = DisposeBag() let sourceSequence = PublishSubject()let referenceSequence = PublishSubject() sourceSequence .takeUntil(referenceSequence) .subscribe { print($0) } .addDisposableTo(disposeBag) sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;) referenceSequence.onNext(&quot;&quot;) //停止接收消息 sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;) 12345next()next()next()completed skip取消前几个事件 1234567let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .skip(2) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) skipWhile满足条件的事件消息都取消 12345let disposeBag = DisposeBag() Observable.of(1, 2, 3, 4, 5, 6) .skipWhile { $0 skipWhileWithIndex满足条件的都被取消，传入的闭包同skipWhile有点区别而已 12345let disposeBag = DisposeBag() Observable.of(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) .skipWhileWithIndex { element, index in index skipUntil直到某个sequence发出了事件消息，才开始接收当前sequence发出的事件消息 123456789101112131415161718192021let disposeBag = DisposeBag() let sourceSequence = PublishSubject()let referenceSequence = PublishSubject() sourceSequence .skipUntil(referenceSequence) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;) referenceSequence.onNext(&quot;&quot;) sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;)sourceSequence.onNext(&quot;&quot;)} 数学操作toArray将sequence转换成一个array，并转换成单一事件信号，然后结束 1234567let disposeBag = DisposeBag() Observable.range(start: 1, count: 10) .toArray() .subscribe { print($0) } .addDisposableTo(disposeBag) 123next([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])completed reduce用一个初始值，对事件数据进行累计操作。reduce接受一个初始值，和一个操作符号 1234567let disposeBag = DisposeBag() Observable.of(10, 100, 1000) .reduce(1, accumulator: +) .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) 1231111concat concat会把多个sequence和并为一个sequence，并且当前面一个sequence发出了completed事件，才会开始下一个sequence的事件。在第一sequence完成之前，第二个sequence发出的事件都会被忽略，但会接收一完成之前的二发出的最后一个事件。不好解释，看例子说明 1234567891011121314151617181920212223242526let disposeBag = DisposeBag() let subject1 = BehaviorSubject(value: &quot;&quot;)let subject2 = BehaviorSubject(value: &quot;&quot;) let variable = Variable(subject1) variable.asObservable() .concat() .subscribe { print($0) } .addDisposableTo(disposeBag) subject1.onNext(&quot;&quot;)subject1.onNext(&quot;&quot;) variable.value = subject2 subject2.onNext(&quot;&quot;) //1完成前，会被忽略subject2.onNext(&quot;teng&quot;) //1完成前，会被忽略subject2.onNext(&quot;fei&quot;) //1完成前的最后一个，会被接收 subject1.onCompleted() subject2.onNext(&quot;&quot;) 123456next()next()next()next(fei)next() 连接性操作Connectable Observable有订阅时不开始发射事件消息，而是仅当调用它们的connect（）方法时。这样就可以等待所有我们想要的订阅者都已经订阅了以后，再开始发出事件消息，这样能保证我们想要的所有订阅者都能接收到事件消息。其实也就是等大家都就位以后，开始发出消息。 publish将一个正常的sequence转换成一个connectable sequence 123456789101112131415161718let intSequence = Observable.interval(1, scheduler: MainScheduler.instance) .publish() _ = intSequence .subscribe(onNext: { print(&quot;Subscription 1:, Event: \\($0)&quot;) }) delay(2) { _ = intSequence.connect() } //相当于把事件消息推迟了两秒 delay(4) { _ = intSequence .subscribe(onNext: { print(&quot;Subscription 2:, Event: \\($0)&quot;) })} delay(6) { _ = intSequence .subscribe(onNext: { print(&quot;Subscription 3:, Event: \\($0)&quot;) })} 1234567891011Subscription 1:, Event: 0Subscription 1:, Event: 1Subscription 2:, Event: 1Subscription 1:, Event: 2Subscription 2:, Event: 2Subscription 1:, Event: 3Subscription 3:, Event: 3Subscription 2:, Event: 3Subscription 1:, Event: 4Subscription 3:, Event: 4 replay将一个正常的sequence转换成一个connectable sequence，然后和replaySubject相似，能接收到订阅之前的事件消息。 123456789101112131415161718let intSequence = Observable.interval(1, scheduler: MainScheduler.instance) .replay(5) //接收到订阅之前的5条事件消息 _ = intSequence .subscribe(onNext: { print(&quot;Subscription 1:, Event: \\($0)&quot;) }) delay(2) { _ = intSequence.connect() } delay(4) { _ = intSequence .subscribe(onNext: { print(&quot;Subscription 2:, Event: \\($0)&quot;) })} delay(8) { _ = intSequence .subscribe(onNext: { print(&quot;Subscription 3:, Event: \\($0)&quot;) })} multicast将一个正常的sequence转换成一个connectable sequence，并且通过特性的subject发送出去，比如PublishSubject，或者replaySubject，behaviorSubject等。不同的Subject会有不同的结果。 123456789101112131415161718let subject = PublishSubject() _ = subject .subscribe(onNext: { print(&quot;Subject: \\($0)&quot;) }) let intSequence = Observable.interval(1, scheduler: MainScheduler.instance) .multicast(subject) _ = intSequence .subscribe(onNext: { print(&quot;\\tSubscription 1:, Event: \\($0)&quot;) }) delay(2) { _ = intSequence.connect() } delay(4) { _ = intSequence .subscribe(onNext: { print(&quot;\\tSubscription 2:, Event: \\($0)&quot;) })} 错误处理catchErrorJustReturn遇到error事件的时候，就return一个值，然后结束 123456789101112131415let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject() sequenceThatFails .catchErrorJustReturn(&quot;&quot;) .subscribe { print($0) } .addDisposableTo(disposeBag) sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onError(TestError.test) 1234567next()next()next()next()next()completed catchError捕获error进行处理，可以返回另一个sequence进行订阅 123456789101112131415161718192021let disposeBag = DisposeBag() let sequenceThatFails = PublishSubject()let recoverySequence = PublishSubject() sequenceThatFails .catchError { print(&quot;Error:&quot;, $0) return recoverySequence } .subscribe { print($0) } .addDisposableTo(disposeBag) sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onNext(&quot;&quot;)sequenceThatFails.onError(TestError.test) recoverySequence.onNext(&quot;&quot;) 1234567next()next()next()next()Error: testnext() retry遇见error事件可以进行重试，比如网络请求失败，可以进行重新连接 123456789101112131415161718192021222324252627let disposeBag = DisposeBag()var count = 1 let sequenceThatErrors = Observable.create { observer in observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) if count == 1 { observer.onError(TestError.test) print(&quot;Error encountered&quot;) count += 1 } observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) observer.onNext(&quot;&quot;) observer.onCompleted() return Disposables.create()} sequenceThatErrors .retry(3) //不传入数字的话，只会重试一次 .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) debugdebug打印所有的订阅, 事件和disposals 123456sequenceThatErrors .retry(3) .debug() .subscribe(onNext: { print($0) }) .addDisposableTo(disposeBag) RxSwift.Resources.total查看RxSwift所有资源的占用 12print(RxSwift.Resources.total) 啊，文章终于结束，这篇文章比较长，基本上涵盖了官方文档所有的概念，希望能在你学习RxSwift的时候能有一些参考价值吧！！！ 笔记整理：Edison联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；","link":"/program//RxSwift/"},{"title":"KVO crash 自修复技术实现与原理解析","text":"前言 【前言】KVO API设计非常不合理，于是有很多的KVO三方库，比如 KVOController 用更优的API来规避这些crash，但是侵入性比较大，必须编码规范来约束所有人都要使用该方式。有没有什么更优雅，无感知的接入方式？ 简介 KVO crash 也是非常常见的 Crash 类型，在探讨 KVO crash 原因前，我们先来看一下传统的KVO写发： 12345678910111213141516171819202122232425262728#warning move this to top of .m file//#define MyKVOContext(A) static void * const A = (void*)&amp;A;static void * const MyContext = (void*)&amp;MyContext;#warning move this to viewdidload or init method // KVO注册监听: // _A 监听 _B 的 @&quot;keyPath&quot; 属性 //[self.B addObserver: self.A forKeyPath:@&quot;keyPath&quot; options:NSKeyValueObservingOptionNew context:MyContext];- (void)dealloc { // KVO反注册 [_B removeObserver:_A forKeyPath:@&quot;keyPath&quot;];}// KVO监听执行 #warning — please move this method to the class of _A - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if(context != MyContext) { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; return; } if(context == MyContext) { //if ([keyPath isEqualToString:@&quot;keyPath&quot;]) { id newKey = change[NSKeyValueChangeNewKey]; BOOL boolValue = [newKey boolValue]; }} 看到如上的写发，大概我们就明白了 API 设计不合理的地方： B 需要做的工作太多，B可能引起Crash的点也太多： B 需要主动移除监听者的时机，否则就crash： B 在释放变为nil后，hook dealloc时机 A 在释放变为nil后 否则报错 Objective-C Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT) KVO的被观察者dealloc时仍然注册着KVO导致的crash B 不能移除监听者A的时机，否则就crash： B没有被A监听 B已经移除A的监听。 添加KVO重复添加观察者或重复移除观察者（KVO 注册观察者与移除观察者不匹配）导致的crash。 采取的措施： B添加A监听的时候，避免重复添加，移除的时候避免重复移除。 B dealloc时及时移除 A A dealloc时，让 B 移除A。 避免重复添加，避免重复移除。 报错信息一览： 12018-01-24 16:08:54.100667+0800 BootingProtection[63487:29487624] *** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;&lt;CYLObserverView: 0x7fb287002fb0; frame = (0 0; 207 368); layer = &lt;CALayer: 0x604000039360&gt;&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled. 其他情况的crash 1234567891011121314151617181920212223242526272829*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;An instance 0x7f8827d21d20 of class XXXX was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x61000003db00&gt; (&lt;NSKeyValueObservance 0x61000025ae80: Observer: 0x7f882890b4c0, Key path: dataSource, Options: &lt;New: YES, Old: NO, Prior: NO&gt; Context: 0x10dfe7730, Property: 0x61000025b810&gt;)&apos;*** First throw call stack:( 0 CoreFoundation 0x00000001102b0b0b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x00000001167eb141 objc_exception_throw + 48 2 CoreFoundation 0x0000000110319625 +[NSException raise:format:] + 197 3 Foundation 0x0000000111322b53 NSKVODeallocate + 294 4 UIKit 0x00000001138ec544 __destroy_helper_block_.125 + 80 5 libsystem_blocks.dylib 0x00000001185a999d _Block_release + 111 6 UIKit 0x00000001139bd187 -[UIViewAnimationBlockDelegate .cxx_destruct] + 43 7 libobjc.A.dylib 0x00000001167e99bc _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127 8 libobjc.A.dylib 0x00000001167f5d34 objc_destructInstance + 129 9 libobjc.A.dylib 0x00000001167f5d66 object_dispose + 22 10 libobjc.A.dylib 0x00000001167ffb8e _ZN11objc_object17sidetable_releaseEb + 202 11 CoreFoundation 0x000000011021952d -[__NSDictionaryI dealloc] + 125 12 libobjc.A.dylib 0x00000001167ffb8e _ZN11objc_object17sidetable_releaseEb + 202 13 libobjc.A.dylib 0x00000001168002fa _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 866 14 CoreFoundation 0x00000001101ffe96 _CFAutoreleasePoolPop + 22 15 CoreFoundation 0x000000011023baec __CFRunLoopRun + 2172 16 CoreFoundation 0x000000011023b016 CFRunLoopRunSpecific + 406 17 GraphicsServices 0x0000000118f1ea24 GSEventRunModal + 62 18 UIKit 0x0000000113904134 UIApplicationMain + 159 19 HaiDiLao 0x000000010d50b5ef main + 111 20 libdyld.dylib 0x000000011856265d start + 1 21 ??? 0x0000000000000001 0x0 + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 防crash措施于是有很多的KVO三方库，比如 KVOController 用更优的API来规避这些crash，但是侵入性比较大，必须编码规范来约束所有人都要使用该方式。有没有什么更优雅，无感知的接入方式？ 那便是我们下面要讲的 KVO crash 防护机制。 我们可以对比下其他的一些KVO防护方案： 网络上有一些类似的方案，“大白健康系统”方案大致如下： KVO的被观察者dealloc时仍然注册着KVO导致的crash 的情况，可以将NSObject的dealloc swizzle， 在object dealloc的时候自动将其对应的kvodelegate所有和kvo相关的数据清空，然后将kvodelegate也置空。避免出现KVO的被观察者dealloc时仍然注册着KVO而产生的crash 这样未免太过麻烦，我们可以借助第三方库 CYLDeallocBlockExecutor hook 任意一个对象的 dealloc 时机，然后在 dealloc 前进行我们需要进行的操作，因此也就不需要为 NSObject 加 flag 来进行全局的筛选。flag 效率非常底，影响 app 性能。 “大白健康系统”思路是建立一个delegate，观察者和被观察者通过delegate间接建立联系，由于没有demo源码，这种方案比较繁琐。可以考虑建立一个哈希表，用来保存观察者、keyPath的信息，如果哈希表里已经有了相关的观察者，keyPath信息，那么继续添加观察者的话，就不载进行添加，同样移除观察的时候，也现在哈希表中进行查找，如果存在观察者，keypath信息，那么移除，如果没有的话就不执行相关的移除操作。要实现这样的思路就需要用到methodSwizzle来进行方法交换。我这通过写了一个NSObject的cagegory来进行方法交换。示例代码如下：下面是核心的swizzle方法： 原函数 swizzle后的函数 addObserver:forKeyPath:options:context: cyl_crashProtectaddObserver:forKeyPath:options:context: removeObserver:forKeyPath: cyl_crashProtectremoveObserver:forKeyPath: removeObserver:forKeyPath:context: cyl_crashProtectremoveObserver:forKeyPath:context 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)cyl_crashProtectaddObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context{ if (!observer || !keyPath || keyPath.length == 0) { return; } @synchronized (self) { NSInteger kvoHash = [self _cyl_crashProtectHash:observer :keyPath]; if (!self.KVOHashTable) { self.KVOHashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsStrongMemory]; } if (![self.KVOHashTable containsObject:@(kvoHash)]) { [self.KVOHashTable addObject:@(kvoHash)]; [self cyl_crashProtectaddObserver:observer forKeyPath:keyPath options:options context:context]; [self cyl_willDeallocWithSelfCallback:^(__unsafe_unretained id observedOwner, NSUInteger identifier) { [observedOwner cyl_crashProtectremoveObserver:observer forKeyPath:keyPath context:context]; }]; __unsafe_unretained typeof(self) unsafeUnretainedSelf = self; [observer cyl_willDeallocWithSelfCallback:^(__unsafe_unretained id observerOwner, NSUInteger identifier) { [unsafeUnretainedSelf cyl_crashProtectremoveObserver:observerOwner forKeyPath:keyPath context:context]; }]; } }}- (void)cyl_crashProtectremoveObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context { //TODO: 加上 context 限制，防止父类、子类使用同一个keyPath。 [self cyl_crashProtectremoveObserver:observer forKeyPath:keyPath];}- (void)cyl_crashProtectremoveObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath{ //TODO: white list if (!observer || !keyPath || keyPath.length == 0) { return; } @synchronized (self) { if (!observer) { return; } NSInteger kvoHash = [self _cyl_crashProtectHash:observer :keyPath]; NSHashTable *hashTable = [self KVOHashTable]; if (!hashTable) { return; } if ([hashTable containsObject:@(kvoHash)]) { [self cyl_crashProtectremoveObserver:observer forKeyPath:keyPath]; [hashTable removeObject:@(kvoHash)]; } }} 之后我们就可以模拟dealloc中不写removeObserver，同时也可以写，同时也可以多次 addObserver、removeObserver 这样就完全不干扰我们平时的代码书写逻辑了。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//KVOcrash/"},{"title":"有一种 Block 叫 Callback，有一种 Callback 叫 CompletionHandler","text":"iOS10推送部分的API，大量使用了 CompletionHandler 这种命名方式，那么本文我们将对比下这种 Block 的特殊性，以便更好的理解和在自己的项目中实践 CompletionHandler 样式的 Blcok。 我们作为开发者去集成一个 Lib （也可以叫轮子、SDK、下文统一叫 Lib）时，我们会发现我们遇到的 Block， 按照功能的角度划分，其实可以分为这几种： Lib 通知开发者，Lib操作已经完成。一般命名为 Callback 开发者通知 Lib，开发者的操作已经完成。一般可以命名为 CompletionHandler。 这两处的区别： 前者是 “Block 的执行”，后者是 “Block 的填充”。 Callback vs CompletionHandler 命名与功能的差别，Apple 也没有明确的编码规范指出过，只不过如果按照“执行与填充”的功能划分的话，callback与 completionHandler 的命名可以区分开来对待。同时也方便调用者理解 block 的功能。但总体来说，Apple 官方的命名中，“Block 填充“这个功能一般都会命名为 “completionHandler”，“Block 执行”这个功能大多命名为了“callback” ，也有少部分命名为了 “completionHandler”。 比如： NSURLSession 中，下面的函数将 “callback” 命名为了 “completionHandler”： 1- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler; 我们常常见到 CompletionHandler 被用到了第一种场景，而第一种场景“Block 执行”命名为 Callback 则更合适。 不是所有 Block 都适合叫做 CompletionHandler 一般情况下，CompletionHandler 的设计往往考虑到多线程操作，于是，你就完全可以异步操作，然后在线程结束时执行该 CompletionHandler，下文的例子中会讲述下 CompletionHandler 方式在多线程场景下的一些优势。 CompletionHandler + Delegate 组合在 iOS10 中新增加的 UserNotificaitons 中大量使用了这种 Block，比如： 123- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler; 文档 对 completionHandler 的注释是这样的： 1The block to execute when you have finished processing the user’s response. You must execute this block from your method and should call it as quickly as possible. The block has no return value or parameters. 同样在这里也有应用： 123- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)taskdidReceiveChallenge:(NSURLAuthenticationChallenge *)challengecompletionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * __nullable credential))completionHandler; 还有另外一个也非常普遍的例子（Delegate 方式使用URLSession 时候必不可少的 4个代理函数之一 ） 123- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler; 在代理方法实现代码里面，若是不执行 completionHandler(NSURLSessionResponseAllow) 话，http请求就终止了。 CompletionHandler + Block 组合函数中将函数作为参数或者返回值，就叫做高阶函数。 按照这种定义，Block 中将 Block 作为参数，这也就是高阶函数。 结合实际的应用场景来看一个例子： 如果有这样一个需求： 拿我之前的一个 IM 项目 ChatKit-OC （开源的，下面简称 ChatKit）为例，当你的应用想要集成一个 IM 服务时，可能这时候，你的 APP 已经上架了，已经有自己的注册、登录等流程了。用 ChatKit 进行聊天很简单，只需要给 ChatKit 一个 id 就够了。聊天是正常了，但是双方只能看到一个id，这样体验很不好。但是如何展示头像、昵称呢？于是就设计了这样一个接口，-setFetchProfilesBlock: 。 这是上层（APP）提供用户信息的 Block，由于 ChatKit 并不关心业务逻辑信息，比如用户昵称，用户头像等。用户可以通过 ChatKit 单例向 ChatKit 注入一个用户信息内容提供 Block，通过这个用户信息提供 Block，ChatKit 才能够正确的进行业务逻辑数据的绘制。 示意图如下： 具体实现如下： 方法定义如下： 123456789101112131415161718192021/*!* @brief The block to execute with the users&apos; information for the userIds. Always execute this block at some point when fetching profiles completes on main thread. Specify users&apos; information how you want ChatKit to show.* @attention If you fetch users fails, you should reture nil, meanwhile, give the error reason.*/typedef void(^LCCKFetchProfilesCompletionHandler)(NSArray&lt;id&lt;LCCKUserDelegate&gt;&gt; *users, NSError *error);/*!* @brief When LeanCloudChatKit wants to fetch profiles, this block will be invoked.* @param userIds User ids* @param completionHandler The block to execute with the users&apos; information for the userIds. Always execute this block at some point during your implementation of this method on main thread. Specify users&apos; information how you want ChatKit to show.*/typedef void(^LCCKFetchProfilesBlock)(NSArray&lt;NSString *&gt; *userIds, LCCKFetchProfilesCompletionHandler completionHandler);@property (nonatomic, copy) LCCKFetchProfilesBlock fetchProfilesBlock;/*!* @brief Add the ablitity to fetch profiles.* @attention You must get peer information by peer id with a synchronous implementation.* If implemeted, this block will be invoked automatically by LeanCloudChatKit for fetching peer profile.*/- (void)setFetchProfilesBlock:(LCCKFetchProfilesBlock)fetchProfilesBlock; 用法如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#warning 注意：setFetchProfilesBlock 方法必须实现，如果不实现，ChatKit将无法显示用户头像、用户昵称。以下方法循环模拟了通过 userIds 同步查询 users 信息的过程，这里需要替换为 App 的 API 同步查询 [[LCChatKit sharedInstance] setFetchProfilesBlock:^(NSArray&lt;NSString *&gt; *userIds, LCCKFetchProfilesCompletionHandler completionHandler) { if (userIds.count == 0) { NSInteger code = 0; NSString *errorReasonText = @&quot;User ids is nil&quot;; NSDictionary *errorInfo = @{ @&quot;code&quot;:@(code), NSLocalizedDescriptionKey : errorReasonText, }; NSError *error = [NSError errorWithDomain:NSStringFromClass([self class]) code:code userInfo:errorInfo]; !completionHandler ?: completionHandler(nil, error); return; } NSMutableArray *users = [NSMutableArray arrayWithCapacity:userIds.count];#warning 注意：以下方法循环模拟了通过 userIds 同步查询 users 信息的过程，这里需要替换为 App 的 API 同步查询 [userIds enumerateObjectsUsingBlock:^(NSString *_Nonnull clientId, NSUInteger idx, BOOL *_Nonnull stop) { NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;peerId like %@&quot;, clientId]; //这里的LCCKContactProfiles，LCCKProfileKeyPeerId都为事先的宏定义， NSArray *searchedUsers = [LCCKContactProfiles filteredArrayUsingPredicate:predicate]; if (searchedUsers.count &gt; 0) { NSDictionary *user = searchedUsers[0]; NSURL *avatarURL = [NSURL URLWithString:user[LCCKProfileKeyAvatarURL]]; LCCKUser *user_ = [LCCKUser userWithUserId:user[LCCKProfileKeyPeerId] name:user[LCCKProfileKeyName] avatarURL:avatarURL clientId:clientId]; [users addObject:user_]; } else { //注意：如果网络请求失败，请至少提供 ClientId！ LCCKUser *user_ = [LCCKUser userWithClientId:clientId]; [users addObject:user_]; } }]; // 模拟网络延时，3秒 // sleep(3); #warning 重要：completionHandler 这个 Bock 必须执行，需要在你**获取到用户信息结束**后，将信息传给该Block！ !completionHandler ?: completionHandler([users copy], nil); }]; 对于以上 Fetch 方法的这种应用场景，其实用方法的返回值也可以实现，但是与 CompletionHandler 相比，无法自由切换线程是个弊端。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//block-callback/"},{"title":"Block","text":"简介block可以当做匿名函数，可以在两个对象间将语句当做数据来进行传递。具有封闭性closure，方便取得上下文相关状态信息。 Block的创建 可以如声明函数那样声明一个block变量 定义函数的方法定义block 把block当做一个函数来调用1234567891011121314151617int main(int argc, const char * argv[]) { @autoreleasepool { // Declare the block variable double (^distanceFromRateAndTime)(double rate, double time); // Create and assign the block distanceFromRateAndTime = ^double(double rate, double time) { return rate * time; }; // Call the block double dx = distanceFromRateAndTime(35, 1.5); NSLog(@&quot;A car driving 35 mph will travel &quot; @&quot;%.2f miles in 1.5 hours.&quot;, dx); } return 0;} 不带参数的Blockblock可以简写为^ { … } 1234double (^randomPercent)(void) = ^ { return (double)arc4random() / 4294967295;};NSLog(@&quot;Gas tank is %.1f%% full”, randomPercent() * 100); Block的闭包（closure）block内部可以访问定义在block外部的非局部变量。非局部变量会以拷贝形式存储到block中。 123456789NSString *make = @&quot;Honda&quot;;NSString *(^getFullCarName)(NSString *) = ^(NSString *model) { return [make stringByAppendingFormat:@&quot; %@&quot;, model];};NSLog(@&quot;%@&quot;, getFullCarName(@&quot;Accord&quot;)); // Honda Accord// Try changing the non-local variable (it won&apos;t change the block)make = @&quot;Porsche&quot;;NSLog(@&quot;%@&quot;, getFullCarName(@&quot;911 Turbo&quot;)); // Honda 911 Turbo 修改非局部变量用__block存储修饰符号（storage modifier）声明非局部变量 12345678__block int i = 0;int (^count)(void) = ^ { i += 1; return i;};NSLog(@&quot;%d&quot;, count()); // 1NSLog(@&quot;%d&quot;, count()); // 2NSLog(@&quot;%d&quot;, count()); // 3 Block作为函数的参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.h#import@interface Car : NSObject@property double odometer;- (void)driveForDuration:(double)duration withVariableSpeed:(double (^)(double time))speedFunction steps:(int)numSteps;@end//调用block// Car.m#import &quot;Car.h&quot;@implementation Car@synthesize odometer = _odometer;- (void)driveForDuration:(double)duration withVariableSpeed:(double (^)(double time))speedFunction steps:(int)numSteps { double dt = duration / numSteps; for (int i=1; i&amp;lt;=numSteps; i++) { _odometer += speedFunction(i*dt) * dt; }}@end//在main函数中block定义在另一个函数的调用过程中。// main.m#import#import &quot;Car.h&quot;int main(int argc, const char * argv[]) { @autoreleasepool { Car *theCar = [[Car alloc] init]; // Drive for awhile with constant speed of 5.0 m/s [theCar driveForDuration:10.0 withVariableSpeed:^(double time) { return 5.0; } steps:100]; NSLog(@&quot;The car has now driven %.2f meters&quot;, theCar.odometer); // Start accelerating at a rate of 1.0 m/s^2 [theCar driveForDuration:10.0 withVariableSpeed:^(double time) { return time + 5.0; } steps:100]; NSLog(@&quot;The car has now driven %.2f meters&quot;, theCar.odometer); } return 0;} 定义Block类型123456789101112131415// Car.h#import// Define a new type for the blocktypedef double (^SpeedFunction)(double);@interface Car : NSObject@property double odometer;- (void)driveForDuration:(double)duration withVariableSpeed:(SpeedFunction)speedFunction steps:(int)numSteps;@end 风险block会存在导致retain cycles的风险，如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。NSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。 123456self.queue = [[NSOperationQueue alloc] init];MyOperation *operation = [[MyOperation alloc] init];operation.completionBlock = ^{ [self finishedOperation];};[self.queue addOperation:operation]; 另一个解决方法 1234567891011121314151617181920@interface Encoder ()@property (nonatomic, copy) void (^completionHandler)();@end@implementation Encoder- (void)encodeWithCompletionHandler:(void (^)())handler{ self.completionHandler = handler; // 进行异步处理...}// 这个方法会在完成后被调用一次- (void)finishedEncoding{ self.completionHandler(); self.completionHandler = nil; //一旦任务完成就设置为nil}@end","link":"/program//block/"},{"title":"Camera","text":"相机原理感光度(ISO)ISO也叫胶卷速度，衡量图像传感器对光的敏感程度。亮的时候需要的ISO就越小，暗的时候相反ISO就高噪点会多。 光圈光圈用来衡量到达图像感应器的光所通过的通孔大小。iPhone6的光圈值是f/2.2，2.2就是表示镜头焦距和光圈的有效直径比例。 对焦将离相机一定范围内物体渲染清晰，太近太远会模糊这种情况叫做失焦。 保存获取文件关于Core Image处理RAW格式可以参考CoreImage/CIRAWFilter.h，以及WWDC上的讲座WWDC 2014 session 514 https://developer.apple.com/videos/wwdc/2014/#514 如何处理图像数据处理位图的类是UIImage，CGImage(Core Graphics)和CIImage(Core Image)。从NSData得到UIImage使用imageWithContentsOfFiles:方法。 从相机捕捉图像 相比较UIImagePickerController使用AVFoundation能够直接访问相机，提供完全的操作权，比如用编程方式更改硬件参数，或者操纵实时预览图。 先创建AVCaptureStillImageOutput对象，使用captureStillImageAsynchronouslyFromConnection: completionHandler: 方法。 使用AVCaptureStillImageOutput中的类方法jpegStillImageNSDataRepresentation:将其转换成NSData对象，接着用imageWithData:得到一个UIImage 过程中可以调节很多参数例如曝光，聚焦，光补偿，闪光灯，ISO等。所有这些设置都会被应用到一个AVCaptureDevice里。 AVFoundation相关类可以通过以下类访问来自相机设备原始数据并控制他们的组件。 AVCaptureDevice：控制硬件特性，比如镜头位置，曝光，闪光灯 AVCaptureDeviceInput：设备数据 AVCaptureOutput：抽象类包括了三种静态图片捕捉类 AVCaptureStillImageOutput：用于捕捉静态图片 AVCaptureMetadataOutput：启用检测人脸和二维码 AVCaptureVideoOutput：实时预览图提供原始帧 AVCaptureSession：管理输入输出之间数据流，以及在出现问题时生成运行时错误。 AVCaptureVideoPreviewLayer：CALayer的子类，用于自动显示相机产生的实时图像， 捕捉设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//先需要一个AVCaptureSession对象let session = AVCaptureSession()//接着遍历所能提供视频数据设备并检查position属性。let availableCameraDevices = AVCaptureDevice.devicesWithMediaType(AVMediaTypeVideo)for device in availableCameraDevices as [AVCaptureDevice] { if device.position == .Back { backCameraDevice = device } else if device.position == .Front { frontCameraDevice = device }}//发现合适的相机设备，就可以获得相关的AVCaptureDeviceInput对象。将它设置为session输入：var error:NSError?let possibleCameraInput: AnyObject? = AVCaptureDeviceInput.deviceInputWithDevice(backCameraDevice, error: &amp;error)if let backCameraInput = possibleCameraInput as? AVCaptureDeviceInput { if self.session.canAddInput(backCameraInput) { self.session.addInput(backCameraInput) }}//第一次调用AVCaptureDeviceInput.deviceInputWithDevice()会出发系统提示，向用户请求访问相机。let authorizationStatus = AVCaptureDevice.authorizationStatusForMediaType(AVMediaTypeVideo)switch authorizationStatus {case .NotDetermined: // 许可对话没有出现，发起授权许可 AVCaptureDevice.requestAccessForMediaType(AVMediaTypeVideo, completionHandler: { (granted:Bool) -&gt; Void in if granted { // 继续 } else { // 用户拒绝，无法继续 } })case .Authorized: // 继续case .Denied, .Restricted: // 用户明确地拒绝授权，或者相机设备无法访问}//允许访问后的处理，有两种方法显示来自相机的图像流。//第一种，生成一个带有AVCaptureVideoPreviewLayer的view。用capture session做初始参数。AVCaptureVideoPreviewLayer会自动的显示来自相机输出previewLayer = AVCaptureVideoPreviewLayer.layerWithSession(session) as AVCaptureVideoPreviewLayerpreviewLayer.frame = view.boundsview.layer.addSublayer(previewLayer)//第二种，从输出数据流捕捉单一图像帧，使用OpenGL手动显示在view上。这种方法适用于想实时预览滤镜效果的情况。glContext = EAGLContext(API: .OpenGLES2) //glView = GLKView(frame: viewFrame, context: glContext)ciContext = CIContext(EAGLContext: glContext)//AVCaptureVideoOutputvideoOutput = AVCaptureVideoDataOutput()videoOutput.setSampleBufferDelegate(self, queue: dispatch_queue_create(&quot;sample buffer delegate&quot;, DISPATCH_QUEUE_SERIAL))if session.canAddOutput(self.videoOutput) {session.addOutput(self.videoOutput)}//创建完AVCaptureVideoDataOutput后需要通过代理captureOutput(_:didOutputSampleBuffer:fromConnection:)获得所有图像帧，将他们绘制在GLKView中。func captureOutput(captureOutput: AVCaptureOutput!, didOutputSampleBuffer sampleBuffer: CMSampleBuffer!, fromConnection connection: AVCaptureConnection!) { let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) let image = CIImage(CVPixelBuffer: pixelBuffer) if glContext != EAGLContext.currentContext() { EAGLContext.setCurrentContext(glContext) } glView.bindDrawable() ciContext.drawImage(image, inRect:image.extent(), fromRect: image.extent()) glView.display()}//注意的问题， AVCaptureVideoPreviewLayer会自动处理样本旋转90度的情况。//使用AVCaptureStillImageOutput捕捉静态图片。stillCameraOutput = AVCaptureStillImageOutput()if self.session.canAddOutput(self.stillCameraOutput) { self.session.addOutput(self.stillCameraOutput)}//配置，为对象找最合适的配置。有两个方法，简单的方法是使用session presetsession.sessionPreset = AVCaptureSessionPresetPhoto //AVCaptureSessionPresetPhoto会为照片捕捉选择最合适的配置，允许使用最高的感光度（ISO）和曝光时间。基于相位检测（phase detection）的自动对焦，以及输出全分辨率的JPEG格式压缩的静态图片。使用AVCaptureDeviceFormat这个类可以有更多的操控，比如静态分辨率，视频预览分辨率，自动对焦类型，感光度和曝光时间限制，支持格式都在AVCaptureDevice.formats中，可以赋值给AVCaptureDevice的activeFormat。 操作相机到了iOS8后可以对所有参数进行手动调整了。包括镜头光圈。 123456789101112131415//先启动相机sessionQueue = dispatch_queue_create(&quot;com.example.camera.capture_session&quot;, DISPATCH_QUEUE_SERIAL)dispatch_async(sessionQueue) { () -&gt; Void in self.session.startRunning()}//建议将所有block调用操作和配置分配到后台串行队列中。在相机设备改变一些参数前先锁定，改完再解锁var error:NSError?if currentDevice.lockForConfiguration(&amp;error) { // 锁定成功，继续配置 // currentDevice.unlockForConfiguration()}else { // 出错，相机可能已经被锁} 对焦AVCaptureFocusMode枚举描述可用对焦模式 locked：镜片固定位置 AutoFocus：先自动对焦一次就处于Locked模式 ContinuousAutoFocus：场景改变自动重新对焦到画面中心点 对焦可以使用UISlider设置，类似单反对焦环。手动对焦有个辅助标识指向清晰区域，可以通过对焦峰值（focus peaking）将对焦区域高亮显示的方式，方法是使用阈值边缘（threshold edge）滤镜，自定义CIFilter或GPUImageThresholdEdgeDetectionFilter，并调用AVCaptureAudioDataOutputSampleBufferDelegate下的captureOutput(_:didOutputSampleBuffer:fromConnection:)方法将它覆盖到实时预览图上。 1234567891011121314151617181920212223242526//设置对焦模式需要在锁定后let focusMode:AVCaptureFocusMode = ...if currentCameraDevice.isFocusModeSupported(focusMode) { ... // 锁定以进行配置 currentCameraDevice.focusMode = focusMode ... // 解锁}//AutoFocus会让屏幕中心为清晰区，也可以通过预览图上点击手势改变这个区域。var pointInPreview = focusTapGR.locationInView(focusTapGR.view)var pointInCamera = previewLayer.captureDevicePointOfInterestForPoint(pointInPreview)...// 锁定，配置// 设置感兴趣的点currentCameraDevice.focusPointOfInterest = pointInCamera// 在设置的点上切换成自动对焦currentCameraDevice.focusMode = .AutoFocus...// 解锁//iOS8中可以通过选项移动镜片的位置... // 锁定，配置var lensPosition:Float = ... // 0.0 到 1.0的floatcurrentCameraDevice.setFocusModeLockedWithLensPosition(lensPosition) { (timestamp:CMTime) -&gt; Void in // timestamp 对应于应用了镜片位置的第一张图像缓存区}... // 解锁 曝光曝光档数范围在minExposureTargetBias和maxExposureTargetBias之间。0为默认没有补偿 12345678910111213141516var exposureBias:Float = ... // 在 minExposureTargetBias 和 maxExposureTargetBias 之间的值... // 锁定，配置currentDevice.setExposureTargetBias(exposureBias) { (time:CMTime) -&gt; Void in}... // 解锁//设置ISO和曝光时间var activeFormat = currentDevice.activeFormatvar duration:CTime = ... //在activeFormat.minExposureDuration 和 activeFormat.maxExposureDuration 之间的值，或用 AVCaptureExposureDurationCurrent 表示不变var iso:Float = ... // 在 activeFormat.minISO 和 activeFormat.maxISO 之间的值，或用 AVCaptureISOCurrent 表示不变... // 锁定，配置currentDevice.setExposureModeCustomWithDuration(duration, ISO: iso) { (time:CMTime) -&gt; Void in}... // 解锁//检验曝光是否准确可以通过KVO观察AVCaptureDevice的exposureTargetOffset属性。 白平衡iOS8可以手动控制白平衡。可以通过开尔文所表示的温度来调节色温和色彩。典型色温值在2000-3000K（类似蜡烛或灯泡的暖光源）到8000K（纯净的蓝色天空）之间。色彩范围从最小的-150（偏绿）到150（偏品红）。 12345678910var incandescentLightCompensation = 3_000var tint = 0 // 不调节let temperatureAndTintValues = AVCaptureWhiteBalanceTemperatureAndTintValues(temperature: incandescentLightCompensation, tint: tint)var deviceGains = currentCameraDevice.deviceWhiteBalanceGainsForTemperatureAndTintValues(temperatureAndTintValues)... // 锁定，配置currentCameraDevice.setWhiteBalanceModeLockedWithDeviceWhiteBalanceGains(deviceGains) { (timestamp:CMTime) -&gt; Void in }}... // 解锁 实时人脸检测使用AVCaptureMetadataOutput可以检测人脸和二维码。 1234567891011121314var metadataOutput = AVCaptureMetadataOutput()metadataOutput.setMetadataObjectsDelegate(self, queue: self.sessionQueue)if session.canAddOutput(metadataOutput) { session.addOutput(metadataOutput)}metadataOutput.metadataObjectTypes = [AVMetadataObjectTypeFace]func captureOutput(captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [AnyObject]!, fromConnection connection: AVCaptureConnection!) { for metadataObject in metadataObjects as [AVMetadataObject] { if metadataObject.type == AVMetadataObjectTypeFace { var transformedMetadataObject = previewLayer.transformedMetadataObjectForMetadataObject(metadataObject) } }} 捕捉静态图片捕捉高分辨率图像调用captureStillImageAsynchronouslyFromConnection(connection, completionHandler)。在视觉上反应图片捕捉何时开始以及何时结束可以使用KVO来观察AVCaptureStillImageOutput的isCapturingStillImage属性。 12345678910111213141516171819202122232425262728293031dispatch_async(sessionQueue) { () -&gt; Void in let connection = self.stillCameraOutput.connectionWithMediaType(AVMediaTypeVideo) // 将视频的旋转与设备同步 connection.videoOrientation = AVCaptureVideoOrientation(rawValue: UIDevice.currentDevice().orientation.rawValue)! self.stillCameraOutput.captureStillImageAsynchronouslyFromConnection(connection) { (imageDataSampleBuffer, error) -&gt; Void in if error == nil { // 如果使用 session .Photo 预设，或者在设备输出设置中明确进行了设置 // 我们就能获得已经压缩为JPEG的数据 let imageData = AVCaptureStillImageOutput.jpegStillImageNSDataRepresentation(imageDataSampleBuffer) // 样本缓冲区也包含元数据，我们甚至可以按需修改它 let metadata:NSDictionary = CMCopyDictionaryOfAttachments(nil, imageDataSampleBuffer, CMAttachmentMode(kCMAttachmentMode_ShouldPropagate)).takeUnretainedValue() if let image = UIImage(data: imageData) { // 保存图片，或者做些其他想做的事情 ... } } else { NSLog(&quot;error while capturing still image: \\(error)&quot;) } }} 分级捕捉通过设定-1，0，-1三个不同曝光档数用HDR算法合并成一张。 12345678910111213141516171819202122dispatch_async(sessionQueue) { () -&gt; Void in let connection = self.stillCameraOutput.connectionWithMediaType(AVMediaTypeVideo) connection.videoOrientation = AVCaptureVideoOrientation(rawValue: UIDevice.currentDevice().orientation.rawValue)! var settings = [-1.0, 0.0, 1.0].map {(bias:Float) -&gt; AVCaptureAutoExposureBracketedStillImageSettings in AVCaptureAutoExposureBracketedStillImageSettings.autoExposureSettingsWithExposureTargetBias(bias) } var counter = settings.count self.stillCameraOutput.captureStillImageBracketAsynchronouslyFromConnection(connection, withSettingsArray: settings) {(sampleBuffer, settings, error) -&gt; Void in ... // 保存 sampleBuffer(s) // 当计数为0，捕捉完成 counter-- }} 操作图像1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//将两个图片拼接，并在图片上加个区域强调-(UIImage*)composeStereogramLeft:(UIImage *)leftImage right:(UIImage *)rightImage{ float w = leftImage.size.width; float h = leftImage.size.height; UIGraphicsBeginImageContext(CGSizeMake(w * 2.0, h + 32.0)); [leftImage drawAtPoint:CGPointMake(0.0, 32.0)]; [rightImage drawAtPoint:CGPointMake(w, 32.0)]; float leftCircleX = (w / 2.0) - 8.0; float rightCircleX = leftCircleX + w; float circleY = 8.0; [[UIColor blackColor] setFill]; UIRectFill(CGRectMake(0.0, 0.0, w * 2.0, 32.0)); [[UIColor whiteColor] setFill]; CGRect leftRect = CGRectMake(leftCircleX, circleY, 16.0, 16.0); CGRect rightRect = CGRectMake(rightCircleX, circleY, 16.0, 16.0); UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:leftRect]; [path appendPath:[UIBezierPath bezierPathWithOvalInRect:rightRect]]; [path fill]; UIImage *savedImg = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return savedImg;}//使用CGBitmapContextCreate创建位图绘制环境，然后可以遍历位图获得各个颜色通道值，维持一张图片中的绿色和蓝色的原值，然后将蓝色和绿色的值按一定方式计算后赋值给另一张图片的红色值。//可以访问实际像素的所有信息，做任何处理，不过Core Image也会提供一些滤镜方便使用。UInt8 *rightPtr = rightBitmap;UInt8 *leftPtr = leftBitmap;UInt8 r1, g1, b1;UInt8 r2, g2, b2;UInt8 ra, ga, ba;for (NSUInteger idx = 0; idx &lt; bitmapByteCount; idx += 4) { r1 = rightPtr[0]; g1 = rightPtr[1]; b1 = rightPtr[2]; r2 = leftPtr[0]; g2 = leftPtr[1]; b2 = leftPtr[2]; // r1/g1/b1 右侧图像，用于计算合并值 // r2/g2/b2 左侧图像，用于被合并值赋值 // ra/ga/ba 合并后的像素 ra = 0.7 * g1 + 0.3 * b1; ga = b2; ba = b2; leftPtr[0] = ra; leftPtr[1] = ga; leftPtr[2] = ba; rightPtr += 4; // 指向下一个像素 (4字节, 包括透明度 alpha 值) leftPtr += 4;}CGImageRef composedImage = CGBitmapContextCreateImage(_leftContext);UIImage *retval = [UIImage imageWithCGImage:composedImage];CGImageRelease(composedImage);return retval; 元数据存储图像信息的标准格式是Exif（可交换图像文件格式）。通常会保存照相时间日期，快门速度和光圈，设备支持还会包括GPS坐标。可以使用CGImageSourceCopyPropertiesAtIndex方法访问Exif信息。","link":"/program//camera/"},{"title":"CFRunLoop ","text":"简介简单的说run loop是事件驱动的一个大循环，如下代码所示123456789101112int main(int argc, char * argv[]) { //程序一直运行状态 while (AppIsRunning) { //睡眠状态，等待唤醒事件 id whoWakesMe = SleepForWakingUp(); //得到唤醒事件 id event = GetEvent(whoWakesMe); //开始处理事件 HandleEvent(event); } return 0;} Cocoa会涉及到Run Loops的 系统级：GCD，mach kernel，block，pthread 应用层：NSTimer，UIEvent，Autorelease，NSObject(NSDelayedPerforming)，NSObject(NSThreadPerformAddition)，CADisplayLink，CATransition，CAAnimation，dispatch_get_main_queue()（GCD中dispatch到main queue的block会被dispatch到main RunLoop执行），NSPort，NSURLConnection，AFNetworking(这个第三方网络请求框架使用在开启新线程中添加自己的run loop监听事件) 在Main thread堆栈中所处位置堆栈最底层是start(dyld)，往上依次是main，UIApplication(main.m) -&gt; GSEventRunModal(Graphic Services) -&gt; RunLoop(包含CFRunLoopRunSpecific，CFRunLoopRun，CFRunLoopDoSouces0，CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION) -&gt; Handle Touch Event RunLoop原理CFRunLoop开源代码：https://opensource.apple.com/source/CF/CF-855.17/ 执行顺序的伪代码123456789101112131415161718192021222324252627SetupThisRunLoopRunTimeoutTimer(); // by GCD timerdo { __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); __CFRunLoopDoBlocks(); __CFRunLoopDoSource0(); CheckIfExistMessagesInMainDispatchQueue(); // GCD __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); var wakeUpPort = SleepAndWaitForWakingUpPorts(); // mach_msg_trap // Zzz... // Received mach_msg, wake up __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // Handle msgs if (wakeUpPort == timerPort) { __CFRunLoopDoTimers(); } else if (wakeUpPort == mainDispatchQueuePort) { // GCD __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() } else { __CFRunLoopDoSource1(); } __CFRunLoopDoBlocks();} while (!stop &amp;&amp; !timeout); 构成Thread包含一个CFRunLoop，一个CFRunLoop包含一种CFRunLoopMode，mode包含CFRunLoopSource，CFRunLoopTimer和CFRunLoopObserver。 CFRunLoopModeRunLoop只能运行在一种mode下，如果要换mode当前的loop也需要停下重启成新的。利用这个机制，ScrollView过程中NSDefaultRunLoopMode的mode会切换UITrackingRunLoopMode来保证ScrollView的流畅滑动不受只能在NSDefaultRunLoopMode时处理的事件影响滑动。同时mode还是可定制的。 NSDefaultRunLoopMode：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时 UIInitializationRunLoopMode：启动时 NSRunLoopCommonModes：Mode集合Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes来解决12345678910111213//将timer添加到NSDefaultRunLoopMode中[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];//然后再添加到NSRunLoopCommonModes里NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; CFRunLoopTimerNSTimer是对RunLoopTimer的封装 1234567+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation *)invocation repeats:(BOOL)yesOrNo;- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes;+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;- (void)addToRunLoop:(NSRunLoop *)runloop forMode:(NSString *)mode; CFRunLoopSource source0：处理如UIEvent，CFSocket这样的事件 source1：Mach port驱动，CFMachport，CFMessagePort CFRunLoopObserverCocoa框架中很多机制比如CAAnimation等都是由RunLoopObserver触发的。observer到当前状态的变化进行通知。 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU}; 使用RunLoop的案例AFNetworking使用NSOperation+NSURLConnection并发模型都会面临NSURLConnection下载完成前线程退出导致NSOperation对象接收不到回调的问题。AFNetWorking解决这个问题的方法是按照官方的guidhttps://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLConnection_Class/Reference/Reference.html#//apple_ref/occ/instm/NSURLConnection/initWithRequest:delegate:startImmediately:上写的NSURLConnection的delegate方法需要在connection发起的线程runloop中调用，于是AFNetWorking直接借鉴了Apple自己的一个Demohttps://developer.apple.com/LIBRARY/IOS/samplecode/MVCNetworking/Introduction/Intro.html的实现方法单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。 1234567891011121314151617181920212223+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }}+ (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} 类似的可以用这个方法创建一个常驻服务的线程。 TableView中实现平滑滚动延迟加载图片利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。 12345UIImage *downloadedImage = ...;[self.avatarImageView performSelector:@selector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]]; 接到程序崩溃时的信号进行自主处理例如弹出提示等1234567CFRunLoopRef runLoop = CFRunLoopGetCurrent();NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runLoop));while (1) { for (NSString *mode in allModes) { CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); }} 异步测试12345678910111213141516171819202122- (BOOL)runUntilBlock:(BOOL(^)())block timeout:(NSTimeInterval)timeout{ __block Boolean fulfilled = NO; void (^beforeWaiting) (CFRunLoopObserverRef observer, CFRunLoopActivity activity) = ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { fulfilled = block(); if (fulfilled) { CFRunLoopStop(CFRunLoopGetCurrent()); } }; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeWaiting, true, 0, beforeWaiting); CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // Run! CFRunLoopRunInMode(kCFRunLoopDefaultMode, timeout, false); CFRunLoopRemoveObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); return fulfilled;} ming1016","link":"/program//cfrunloop/"},{"title":"iOS-制作Framework","text":"前言之前有很多的大神们已经写过framework的制作，但最近由于Xcode7的出现，很多之前的教程内容已经不符，对于初学者来说，找到一篇能够直接明了，简单易学的制作framework的文章比较困难。本文将基于Xcode7创建一个简单的工程，通过两种方法来教大家如何制作一个自己的framework。 简介Mac OS X扩展了framework的功能，让我们能够利用它来共享代码和资源。通过framework我们可以共享所有形式的资源，如动态共享库，nib文件，图像字符资源以及文档等。系统会在需要的时候将framework载入内存中，多个应用程序可以同时使用同一个framework。这种方法可以使得你的代码易分享，在多个工程中复用，并且可以隐藏实现细节，控制公开的头文件。 制作步骤 打开Xcode，创建新工程。手下留情，请先看图！ 创建功能类。这里我创建一个继承自NSObject的SayHello类在新创建的类里面声明方法并实现。这里我写一个sayHello的方法，以便后面测试使用。 SayHello.h 1234#import &lt;Foundation/Foundation.h&gt;@interface SayHello : NSObject-(void)sayHello;@end SayHello.m 1234567 #import &quot;SayHello.h&quot;@implementation SayHello-(void)sayHello { NSLog(@&quot;你好，第一次见面，请多关照&quot;); } @end 在TARGETS下选中工程，在Build Settings下更改几个参数。 在Architectures下增加armv7s，并选中。将Build Active Architecture Only 设置为NO。 设置Headers将你要公开的头文件移动到Public下，要隐藏的放在Private或者Project下，当然，隐藏的头文件就无法再被引用。 然后需要在Test.h（必须是公开的，否则无法引用）中将你所有要公开的.h引入。打包framework 方法一 选中模拟器，编译程序 选中测试机，编译程序 在finder中找到framework文件 选中图中所标示的framework，然后右键show in finder。找到下图中所示的Test文件，一个是Debug-iphoneos（真机）下的，一个是Debug-iphonesimulator(模拟器)下的。 4.通过终端命令将两个framework合为一个模拟器和真机都可使用的framework。 打开控制台输入 lipo -create iphoneos下frameworkTest的路径 simulator下frameworkTest的路径 -output 新的路径，这样就完成了模拟器和真机版本的合并，新路径下的frameworkTest就是你合并后的文件，将这个文件名字改成和你未合并之前的Test一样的名字，放到framework文件夹下，替换掉原来的frameworkTest文件。 上面这段命令就是把真机和模拟器的frameworkTest合并成一个MyNewFrameworktest文件并存放在桌面上的New文件夹下。 5.将修改后的framework拷贝出来保存，这就是我们最终制作的framework。 方法二 1.选中TARGETS下的工程，点击上方的Editor,选择Add Target创建一个Aggregate. 选择Other下的Aggregate，点击Next创建。 2.嵌入脚本。选中刚刚创建的Aggregate,然后选中右侧的Build Phases,点击左下方加号，选择New Run Script Phase 将这段脚本复制进去。 1234567891011121314151617181920212223242526272829303132333435363738394041# Sets the target folders and the final framework product.# 如果工程名称和Framework的Target名称不一样的 话，要自定义FMKNAME# 例如: FMK_NAME = &quot;MyFramework&quot;FMK_NAME=${PROJECT_NAME}# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_DIR=${SRCROOT}/Products/$ {FMK_NAME}.framework# Working dir will be deleted after the framework creation.WRK_DIR=buildDEVICE_DIR=${WRK_DIR}/Release-iphoneos/$ {FMK_NAME}.frameworkSIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework# -configuration ${CONFIGURATION}# Clean and Building both architectures.xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean buildxcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build# Cleaning the oldest.if [ -d &quot;${INSTALL_DIR}&quot; ]thenrm -rf &quot;${INSTALL_DIR}&quot; fi mkdir -p &quot;${INSTALL_DIR}&quot;cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;$ {INSTALL_DIR}/${FMK_NAME}&quot;rm -r &quot;${WRK_DIR}&quot;open &quot;${INSTALL_DIR}&quot; 3.编译。如图所示，command+B编译。 4.在finder中找到framework，拷贝出来。 使用制作完成的framework直接将你制作出来的framework添加到要使用的工程里，在需要使用的文件里引入头文件，使用framework中的功能类。如下图 提醒 在制作framework或者lib的时候，如果使用了category，则使用改FMWK的程序运行时会crash，此时需要在该工程中 other linker flags添加两个参数 -ObjC -all_load. 带有图片资源的需要把图片打包成Bundle文件，和framework一起拷贝到相应的项目中。 公开的类中如果引用的private的类，打包以后对外会报错，找不到那个private的类，可以把那个private的.h放到 结言现在，相信你已经可以按照文档步骤制作出一个framework，相信过程中可能还会遇到一些问题，希望大家能够把这些问题记录并整理，将这些经验分享出来。也欢迎大家联系、讨论。最后，希望大家能完成带有图片资源的Bundle的制作。 Try your best!","link":"/program//framework/"},{"title":"连续启动 crash 自修复技术实现与原理解析","text":"前言 实现原理 优化：降低50%以上误报机率 对原有API设计的几点优化意见 机制状态应当用枚举来做为API透出 关键数值应当做为初始化参数供用户设置 修复、上报逻辑应当支持用户异步操作 什么时候会出现该异常？ 连续启动 crash 自修复技术实现与原理解析 前言 如果 app 连续 crash 两次无法启动，用户往往会选择卸载。 连续启动 crash 应该是 crash 类型中最严重的一类，该问题常常与数据库操作有关，比如：数据库损坏、服务端返回数据错误，存入数据库，app 读取时产生数组越界、找不到方法。 那么除了热修复，能否“自修复”该问题呢？ 在微信读书团队发布的《iOS 启动连续闪退保护方案》 一文中，给出了连续启动crash的自修复技术的思路讲解，并在GitHub上给出了技术实现，并开源了 GYBootingProtection。方案思路很好，很轻量级。 实现原理 在微信读书团队给出的文章中已经有比较详细的阐述，在此不做赘述，实现的流程图如下所示：但有个实现上可以优化下，可以降低50%以上误报机率，监听用户手动划掉 APP 这个事件，其中一些特定场景，是可以获取的。另外在这里也给出对其 API 设计的建议。最后给出优化后的实现。 优化：降低50%以上误报机率 用户主动 kill 掉 APP 分为两种情况： App在前台时用户手动划掉APP的时候 APP在后台时划掉APP 第一种场景更为常见，可以通过监听 UIApplicationWillTerminateNotification 来捕获该动作，捕获后恢复计数。第二种情况，无法监听到。但也足以降低 50% 以上的误报机率。 对原有API设计的几点优化意见1. 机制状态应当用枚举来做为API透出该机制当前所处的状态，比如：NeedFix 、isFixing，建议用枚举来做为API透出。比如： APP 启动正常 正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值 APP 出现连续启动 Crash，需要采取修复措施 APP 出现连续启动 Crash，正在修复中 2. 关键数值应当做为初始化参数供用户设置 当前启动Crash的状态 达到需要执行上报操作的“连续启动崩溃计数”个数。 达到需要执行修复操作的“连续启动崩溃计数”个数。 APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零 3. 修复、上报逻辑应当支持用户异步操作reportBlock 上报逻辑，repairtBlock 修复逻辑 比如： 12typedef void (^BoolCompletionHandler)(BOOL succeeded, NSError *error);typedef void (^RepairBlock)(ABSBoolCompletionHandler completionHandler); 用户执行 BoolCompletionHandler 后即可知道是否执行完毕，并且支持异步操作。 异步操作带来的问题，可以通过前面提到的枚举API来实时监测状态，来决定各种其他操作。 什么时候会出现该异常？连续启动 crash 自修复技术实现与原理解析下面给出优化后的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//// CYLBootingProtection.h// //// Created by ChenYilong on 18/01/10.// Copyright © 2018年 ChenYilong. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;typedef void (^ABSBoolCompletionHandler)(BOOL succeeded, NSError *error);typedef void (^ABSRepairBlock)(ABSBoolCompletionHandler completionHandler);typedef void (^ABSReportBlock)(NSUInteger crashCounts);typedef NS_ENUM(NSInteger, BootingProtectionStatus) { BootingProtectionStatusNormal, /**&lt; APP 启动正常 */ BootingProtectionStatusNormalChecking, /**&lt; 正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值 */ BootingProtectionStatusNeedFix, /**&lt; APP 出现连续启动 Crash，需要采取修复措施 */ BootingProtectionStatusFixing, /**&lt; APP 出现连续启动 Crash，正在修复中... */};/*** 启动连续 crash 保护。* 启动后 `_crashOnLaunchTimeIntervalThreshold` 秒内 crash，反复超过 `_continuousCrashOnLaunchNeedToReport` 次则上报日志，超过 `_continuousCrashOnLaunchNeedToFix` 则启动修复操作。*/@interface CYLBootingProtection : NSObject/*** 启动连续 crash 保护方法。* 前置条件：在 App 启动时注册 crash 处理函数，在 crash 时调用[CYLBootingProtection addCrashCountIfNeeded]。* 启动后一定时间内（`crashOnLaunchTimeIntervalThreshold`秒内）crash，反复超过一定次数（`continuousCrashOnLaunchNeedToReport`次）则上报日志，超过一定次数（`continuousCrashOnLaunchNeedToFix`次）则启动修复程序；在一定时间内（`crashOnLaunchTimeIntervalThreshold`秒） 秒后若没有 crash 将“连续启动崩溃计数”计数置零。 `reportBlock` 上报逻辑， `repairtBlock` 修复逻辑，完成后执行 `[self setCrashCount:0]`*/- (void)launchContinuousCrashProtect;/*!* 当前启动Crash的状态*/@property (nonatomic, assign, readonly) BootingProtectionStatus bootingProtectionStatus;/*!* 达到需要执行上报操作的“连续启动崩溃计数”个数。*/@property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToReport;/*!* 达到需要执行修复操作的“连续启动崩溃计数”个数。*/@property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToFix;/*!* APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零*/@property (nonatomic, assign, readonly) NSTimeInterval crashOnLaunchTimeIntervalThreshold;/*!* 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。*/@property (nonatomic, copy, readonly) NSString *context;/*!* @details 启动后kCrashOnLaunchTimeIntervalThreshold秒内crash，反复超过continuousCrashOnLaunchNeedToReport次则上报日志，超过continuousCrashOnLaunchNeedToFix则启动修复程序；当所有操作完成后，执行 completion。在 crashOnLaunchTimeIntervalThreshold 秒后若没有 crash 将 kContinuousCrashOnLaunchCounterKey 计数置零。* @param context 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。*/- (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold context:(NSString *)context;/*!* 当前“连续启动崩溃“的状态*/+ (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix;/*!* 设置上报逻辑，参数 crashCounts 为启动连续 crash 次数*/- (void)setReportBlock:(ABSReportBlock)reportBlock;/*!* 设置修复逻辑*/- (void)setRepairBlock:(ABSRepairBlock)repairtBlock;+ (void)setLogger:(void (^)(NSString *))logger;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376//// CYLBootingProtection.m////// Created by ChenYilong on 18/01/10.// Copyright © 2018年 ChenYilong. All rights reserved.//#import &quot;CYLBootingProtection.h&quot;#import &lt;UIKit/UIKit.h&gt;static dispatch_queue_t _exceptionOperationQueue = 0;void (^Logger)(NSString *log);@interface CYLBootingProtection ()@property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToReport;@property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToFix;@property (nonatomic, assign) NSTimeInterval crashOnLaunchTimeIntervalThreshold;@property (nonatomic, copy) NSString *context;@property (nonatomic, copy) ABSReportBlock reportBlock;@property (nonatomic, copy) ABSRepairBlock repairBlock;/*!* 设置“连续启动崩溃计数”个数*/- (void)setCrashCount:(NSInteger)count;/*!* 设置“连续启动崩溃计数”个数*/+ (void)setCrashCount:(NSUInteger)count context:(NSString *)context;/*!* “连续启动崩溃计数”个数*/- (NSUInteger)crashCount;/*!* “连续启动崩溃计数”个数*/+ (NSUInteger)crashCountWithContext:(NSString *)context;@end@implementation CYLBootingProtection+ (void)initialize { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _exceptionOperationQueue = dispatch_queue_create(&quot;com.ChenYilong.CYLBootingProtection.fileCacheQueue&quot;, DISPATCH_QUEUE_SERIAL); });}- (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold context:(NSString *)context { if (!(self = [super init])) { return nil; } _continuousCrashOnLaunchNeedToReport = continuousCrashOnLaunchNeedToReport; _continuousCrashOnLaunchNeedToFix = continuousCrashOnLaunchNeedToFix; _crashOnLaunchTimeIntervalThreshold = crashOnLaunchTimeIntervalThreshold; _context = [context copy]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillTerminate:) name:UIApplicationWillTerminateNotification object:[UIApplication sharedApplication]]; return self;}/*!* App在前台时用户手动划掉APP的时候，不计入检测。* 但是APP在后台时划掉APP，无法检测出来。* 见：https://stackoverflow.com/a/35041565/3395008*/- (void)applicationWillTerminate:(NSNotification *)note { BOOL isNormalChecking = [self isNormalChecking]; if (isNormalChecking) { [self decreaseCrashCount]; }}- (void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self];}/*支持同步修复、异步修复，两种修复方式- 异步修复，不卡顿主UI，但有修复未完成就被再次触发crash、或者用户kill掉的可能。需要用户手动根据修复状态，来选择性地进行操作，应该有回掉。- 同步修复，最简单直观，在主线程删除或者下载修复包。*/- (void)launchContinuousCrashProtect { NSAssert(_repairBlock, @&quot;_repairBlock is nil!&quot;); [[self class] Logger:@&quot;CYLBootingProtection: Launch continuous crash report&quot;]; [self resetBootingProtectionStatus]; NSUInteger launchCrashes = [self crashCount]; // 上报 if (launchCrashes &gt;= self.continuousCrashOnLaunchNeedToReport) { NSString *logString = [NSString stringWithFormat:@&quot;CYLBootingProtection: App has continuously crashed for %@ times. Now synchronize uploading crash report and begin fixing procedure.&quot;, @(launchCrashes)]; [[self class] Logger:logString]; if (_reportBlock) { dispatch_async(dispatch_get_main_queue(),^{ _reportBlock(launchCrashes); }); } } // 修复 if ([self isUpToBootingProtectionCount]) { [[self class] Logger:@&quot;need to repair&quot;]; [self setIsFixing:YES]; if (_repairBlock) { ABSBoolCompletionHandler completionHandler = ^(BOOL succeeded, NSError *__nullable error){ if (succeeded) { [self resetCrashCount]; } else { [[self class] Logger:error.description]; } }; dispatch_async(dispatch_get_main_queue(),^{ _repairBlock(completionHandler); }); } } else { [self increaseCrashCount:launchCrashes]; // 正常流程，无需修复 [[self class] Logger:@&quot;need no repair&quot;]; // 记录启动时刻，用于计算启动连续 crash // 重置启动 crash 计数 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.crashOnLaunchTimeIntervalThreshold * NSEC_PER_SEC)), dispatch_get_main_queue(), ^(void){ // APP活过了阈值时间，重置崩溃计数 NSString *logString = [NSString stringWithFormat:@&quot;CYLBootingProtection: long live the app ( more than %@ seconds ), now reset crash counts&quot;, @(self.crashOnLaunchTimeIntervalThreshold)]; [[self class] Logger:logString]; [self resetCrashCount]; }); }}//减少计数的时机：用户手动划掉APP- (void)decreaseCrashCount { NSUInteger oldCrashCount = [self crashCount]; [self decreaseCrashCountWithOldCrashCount:oldCrashCount];}- (void)decreaseCrashCountWithOldCrashCount:(NSUInteger)oldCrashCount { dispatch_sync(_exceptionOperationQueue, ^{ if (oldCrashCount &gt; 0) { [self setCrashCount:oldCrashCount-1]; } [self resetBootingProtectionStatus]; });}//重制计数的时机：修复完成、或者用户手动划掉APP- (void)resetCrashCount { [self setCrashCount:0]; [self resetBootingProtectionStatus];}//只在未达到计数上限时才会增加计数- (void)increaseCrashCount:(NSUInteger)oldCrashCount { dispatch_sync(_exceptionOperationQueue, ^{ [self setIsNormalChecking:YES]; [self setCrashCount:oldCrashCount+1]; });}- (void)resetBootingProtectionStatus { [self setIsNormalChecking:NO]; [self setIsFixing:NO];}- (BootingProtectionStatus)bootingProtectionStatus { return [[self class] bootingProtectionStatusWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix];}/*!*@attention 注意之所以要检查 `BootingProtectionStatusNormalChecking` 原因如下：`-launchContinuousCrashProtect` 方法与 `-bootingProtectionStatus` 方法，如果 `-launchContinuousCrashProtect` 先执行，那么会造成如下问题：假设n为上限，但crash（n-1）次，但是用 `-bootingProtectionStatus` 判断出来，当前已经处于n次了。原因如下：crash（n-1）次，正常流程，计数+1，变成n次，随后在检查 `-bootingProtectionStatus` 时，发现已经处于异常状态了，实际是正常状态。所以需要使用`BootingProtectionStatusNormalChecking` 来进行区分。*/+ (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix { BOOL isNormalChecking = [self isNormalCheckingWithContext:context]; if (isNormalChecking) { return BootingProtectionStatusNormalChecking; } BOOL isUpToBootingProtectionCount = [self isUpToBootingProtectionCountWithContext:context continuousCrashOnLaunchNeedToFix:continuousCrashOnLaunchNeedToFix]; if (!isUpToBootingProtectionCount) { return BootingProtectionStatusNormal; } BootingProtectionStatus type; BOOL isFixingCrash = [self isFixingCrashWithContext:context]; if (isFixingCrash) { type = BootingProtectionStatusFixing; } else { type = BootingProtectionStatusNeedFix; } return type;}- (NSUInteger)crashCount { return [[self class] crashCountWithContext:_context];}- (void)setCrashCount:(NSInteger)count { if (count &gt;=0) { [[self class] setCrashCount:count context:_context]; }}- (void)setIsFixing:(BOOL)isFixingCrash { [[self class] setIsFixing:isFixingCrash context:_context];}/*!* 是否正在修复*/- (BOOL)isFixingCrash { return [[self class] isFixingCrashWithContext:_context];}- (void)setIsNormalChecking:(BOOL)isNormalChecking { [[self class] setIsNormalChecking:isNormalChecking context:_context];}/*!* 是否正在检查*/- (BOOL)isNormalChecking { return [[self class] isNormalCheckingWithContext:_context];}+ (NSUInteger)crashCountWithContext:(NSString *)context { NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context]; NSUInteger crashCount = [[NSUserDefaults standardUserDefaults] integerForKey:continuousCrashOnLaunchCounterKey]; NSString *logString = [NSString stringWithFormat:@&quot;crashCount:%@&quot;, @(crashCount)]; [[self class] Logger:logString]; return crashCount;}+ (void)setCrashCount:(NSUInteger)count context:(NSString *)context { NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@&quot;setCrashCount:%@&quot;, @(count)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setInteger:count forKey:continuousCrashOnLaunchCounterKey]; [defaults synchronize];}+ (void)setIsFixing:(BOOL)isFixingCrash context:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@&quot;setisFixingCrash:{%@}&quot;, @(isFixingCrash)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setBool:isFixingCrash forKey:continuousCrashFixingKey]; [defaults synchronize];}+ (BOOL)isFixingCrashWithContext:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context]; BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey]; NSString *logString = [NSString stringWithFormat:@&quot;isFixingCrash:%@&quot;, @(isFixingCrash)]; [[self class] Logger:logString]; return isFixingCrash;}+ (void)setIsNormalChecking:(BOOL)isNormalChecking context:(NSString *)context { NSString *continuousCrashNormalCheckingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context]; NSString *logString = [NSString stringWithFormat:@&quot;setIsNormalChecking:{%@}&quot;, @(isNormalChecking)]; [[self class] Logger:logString]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setBool:isNormalChecking forKey:continuousCrashNormalCheckingKey]; [defaults synchronize];}+ (BOOL)isNormalCheckingWithContext:(NSString *)context { NSString *continuousCrashFixingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context]; BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey]; NSString *logString = [NSString stringWithFormat:@&quot;isIsNormalChecking:%@&quot;, @(isFixingCrash)]; [[self class] Logger:logString]; return isFixingCrash;}- (BOOL)isUpToBootingProtectionCount { return [[self class] isUpToBootingProtectionCountWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix];}+ (BOOL)isUpToBootingProtectionCountWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix { BOOL isUpToCount = [self crashCountWithContext:context] &gt;= continuousCrashOnLaunchNeedToFix; if (isUpToCount) { return YES; } return NO;}- (void)setReportBlock:(ABSReportBlock)block { _reportBlock = block;}- (void)setRepairBlock:(ABSRepairBlock)block { _repairBlock = block;}/*!* “连续启动崩溃计数”个数，对应的Key* 默认为 &quot;_CONTINUOUS_CRASH_COUNTER_KEY&quot;*/+ (NSString *)continuousCrashOnLaunchCounterKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @&quot;&quot;; NSString *continuousCrashOnLaunchCounterKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_COUNTER_KEY&quot;, validContext]; return continuousCrashOnLaunchCounterKey;}/*!* 是否正在修复记录，对应的Key* 默认为 &quot;_CONTINUOUS_CRASH_FIXING_KEY&quot;*/+ (NSString *)continuousCrashFixingKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @&quot;&quot;; NSString *continuousCrashFixingKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_FIXING_KEY&quot;, validContext]; return continuousCrashFixingKey;}/*!* 是否正在检查是否在特定时间内会Crash，对应的Key* 默认为 &quot;_CONTINUOUS_CRASH_CHECKING_KEY&quot;*/+ (NSString *)continuousCrashNormalCheckingKeyWithContext:(NSString *)context { BOOL isValid = [[self class] isValidString:context]; NSString *validContext = isValid ? context : @&quot;&quot;; NSString *continuousCrashFixingKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_CHECKING_KEY&quot;, validContext]; return continuousCrashFixingKey;}#pragma mark -#pragma mark - log and util Methods+ (void)setLogger:(void (^)(NSString *))logger { Logger = [logger copy];}+ (void)Logger:(NSString *)log { if (Logger) Logger(log);}+ (BOOL)isValidString:(id)notValidString { if (!notValidString) { return NO; } if (![notValidString isKindOfClass:[NSString class]]) { return NO; } NSInteger stringLength = 0; @try { stringLength = [notValidString length]; } @catch (NSException *exception) {} if (stringLength == 0) { return NO; } return YES;}@end 下面是相应的验证步骤： 等待15秒会有对应计数清零的操作日志输出： 1234567891011121314152018-01-18 16:25:37.162980+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: Launch continuous crash report2018-01-18 16:25:37.163140+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{0}2018-01-18 16:25:37.165738+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:{0}2018-01-18 16:25:37.166883+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:02018-01-18 16:25:37.167102+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:02018-01-18 16:25:37.167253+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{1}2018-01-18 16:25:37.167938+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:12018-01-18 16:25:37.168806+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：need no repair2018-01-18 16:25:52.225197+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: long live the app ( more than 15 seconds ), now reset crash counts2018-01-18 16:25:52.225378+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:02018-01-18 16:25:52.226234+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:{0}2018-01-18 16:25:52.226595+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:{0} Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//crash/"},{"title":"构建iOS稳定应用架构时方案选择的思考","text":"工程结构架构，减少耦合混乱以及防治需求大改造成结构重构，如何构建稳定可扩展可变换的工程结构的思考 我打算采用Information flow的方式自上而下，两大层分为基础层和展现层的结构。基础层分为多层，展现层也可分为多层。主要思想是将基础层的最下一层当做零部件，将业务层最下层当做组装大部件，通过流程串起来形成一个完整的产品，做零件时按照做出一个就扔进对应基础层的篮子里思路来，目录结构也可以按照这种来进行。这两大层的最下层按照零件拆得越小越容易应对需求变化越容易保护巩固上层的思路来就好。拿微信这个大家都熟悉的产品的几个功能来简单示例说明下这个思路构建后的结构，模块比较多，一些模块就不深入到最底层分析了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556基础层－ 网络－－ 收发数据－－－单例（持续使用数据）－－－本地（缓存和持续化存储数据对业务的封装输出）－－－单次使用（API接口Model封装输出和业务逻辑封装的ViewModel，将这些做为业务零件）－ 存储－－－ NSUserDefault（对轻量需要存储的添加下一层业务零件封装）－－－ keychain（对安全级别较高需要存储的添加下一层业务零件封装）－－－ 文件存储（对时效需求短的需要存储的添加下一层业务零件封装）－－－ 数据库存储（对数据量大的需要存储的添加下一层业务零件封装，业务层上一层加一层封装CoreData或SQLite方便日后切换数据库用）－ 动画（下层将动画框架输出成各个可以复用的动画功能小零件）－ 视图风格－ 列表控件－－ 上拉加载更多－－ 下拉刷新－－ GuideView－ WebView控件－ AlertView－ iOS系统空间封装－－ 拍照控件－－ 通讯录－ 二维码－ 语音－ 安全－ 支付－ 统计－ 日志展现层－ 首页－－ 订阅－－ 扫描二维码－－ 发布视频－ 列表－－ 时间轴列表－－－ Listview头部封面－－－ 外链情况Cell－－－ 图片Cell－－－ 广告插入Cell－－－ 留言评论－－－ 赞区域－－ 我的列表－－ 订阅列表－－ 文章列表－ 详细页－－ 分享－－ 内容区－－ 评论－ 登录－－ 注册－－ 登录－－ 忘记密码－－ 条款－－ 上传头像－－ 个人信息修改 基础层中各个模块上层可以使用类似CocoaPod或Cathage方式，下一层再对其引用进行业务封装。 这里注意最下层需要拆的粒度越细越好。减少横向依赖。类似Common这样的东西可以拆到基础层的对应模块里，比如说配置文件里和统计相关的放到基础层的统计里，网络相关的放到网络里，颜色字体放到视图风格里，不要都堆在一个文件里。再或者是各种第三方的Category也放到对应的组里，比如说UIView+Additions和UIColor+Expanded就放到视图风格这个模块中，不要专门搞个Category放所有的Category。 数据流控制模式MVC和MVCS/MVVM/VIPER的选择其实这些都是对MVC的扩展，只是扩展的方向不同而已。VIPER把视图和数据拆得过细变相增加了复杂度很多人也都不熟也没有意愿去了解它的实现，但是模块复用却达到了最优，MVCS是这几个里对MVC优化最简单的只是把数据的存储拆开了。MVVM正好介于VIPER和MVCS之间，从ViewController里拆出来的ViewModel能够将数据经过逻辑处理用于View的显示，View有操作用过ReactiveCocoa将信号传给ViewModel来处理。 如果是我个人选择我会选择VIPER，因为它更符合细粒度模块划分的思想。但是用在团队多人开发上，还是偏向MVVM这种折中方案。MVVM按照先前对应用的结构分层，会将View和ViewController放到展现层的最下面的两层里，将ViewModel和Model放到基础层对应模块的最下面一层中。最后要说的是无论选择哪种，只要是按照减少ViewController大小，将改胖的地方放到Model或View都是可以的，招式学多后最高境界就是无招胜有招嘛，有时也不需要刻板的在一个项目中将所有的模块都按照统一的思路给框死，比如说一个模块很简单就用MVC，一般复杂就用MVVM，要是项目本身业务非常庞大可以整体采用VIPER来进行ViewController的完全拆分。 可以通过下列图表看其中的不同： 名称 逻辑和视图 数据 MVC View + ViewController + Model MVCS View + ViewController + Store + Model MVVM View + ViewController + ViewModel + Model VIPER View + ViewController + Wireframe + Presenter + Interactor + Data Manager + Entity(Model) 代码规范这块最有权威的应该是苹果自己提出的https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html，按照这套来肯定是没问题的，而且首先应该遵守。代码结构主要根据不同团队的经验来做。下面举个我常用的代码结构 123456789101112131415161718@property...#pragma mark - Life cycle生命周期，类似addSubview和Notification的监听和销毁都放在这里#pragma mark - Interface接口#pragma mark - Event response#pragma mark - Private method如果是ViewController，这个地方就是瘦身的关键，业务和逻辑功能相关的就放到ViewModel里。#pragma mark - Delegate代理#pragma mark - Getters and Setters建议所有的Property都设置，这样修改配置会比较方便，看起来不会很混乱 ming1016","link":"/program//gou-jian/"},{"title":"GPU处理图像","text":"Shader着色器Shader出现在OpenGL ES 2.0中，允许创建自己的Shader。必须同时创建两个Shader，分别是Vertex shader和Fragment shader. Shader工具Shader会有很多坑，不过一些工具能够帮助你跳过这些坑 GPUImage：https://github.com/BradLarson/GPUImage ShaderToy：https://www.shadertoy.com/ Shaderific：https://www.shaderific.com/ Quartz Composer：官方工具 Shader使用范例Vertex shader12345678attribute vec4 position;attribute vec4 inputTextureCoordinate；varying vec2 textureCoordinate;void main(){ gl_position = position; textureCoordinate = inputTextureCoordinate.xy;} Fragment shader直通滤镜 123456varying highp vec2 textureCoordinate; //highp属性负责变量精度，这个被加入可以提高效率uniform sampler2D inputImageTexture; //接收一个图片的引用，当做2D的纹理，这个数据类型就是smpler2D。void main(){ gl_FragColor = texture2D(inputImageTexture, textureCoordinate); //texture是GLSL（着色语言）特有的方法} GLSL着色语言GLSL的官方快速入门指导 OpenGL ES：https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf OpenGL：https://www.khronos.org/files/opengl-quick-reference-card.pdf 变量赋值三个可以赋值给我们的变量的标签 Uniforms：在渲染循环里作为不变的输入值 Attributes：随顶点位置不同会变的输入值 Varyings：用来在Vertex shader和Fragment shader之间传递信息的，比如在Vertex shader中写入varying值，然后就可以在Fragment shader中读取和处理 向量有很多种向量，但是有三种会经常看到 vec2：两个浮点数，适合在Fragment shader中保存X和Y坐标的情况 vec3：三个浮点数 vec4：四个浮点数，在图像处理中持续追踪每个像素的R,G,V,A这四个值。 矩阵是浮点数组的数组。三个经常处理的矩阵对象 mat2：相当于保存了两个vec2对象的值或四个浮点数。 mat3 mat4 向量和矩阵运算线性代数发挥作用的地方。想知道线性代数如何工作可以看这个资源站：https://betterexplained.com/articles/linear-algebra-guide/ 线性代数可以一次在很多值上进行并行操作，so，正好适合需求，GLSL内建了很多函数可以处理庞大的计算转换 GLSL特有函数GLSL内建的函数可以在Shaderific网站上找到：https://www.shaderific.com/glsl-functions。很多C语言数学库基本数学运算都有对应的函数。 step()：GPU处理条件逻辑不是很好。step()允许在不产生分支的前提下实现条件逻辑。传入step()函数的值小于阈值就返回0.0，大于等于阈值就返回1.0。 mix()：将两个颜色值混合为一个。 clamp()：可以确保值在一个区间内。 复杂的Shader的例子一个饱和度调节的Fragment shader的例子，出自《图形着色器：理论和实践》这本书。 1234567891011121314varying highp vec2 textureCoordinate; //uniform sampler2D inputImageTexture;uniform lowp float saturation;const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721); //光亮度里三个值相加要为1，各个值代表着颜色的百分比，中间是绿色的值，70%的比重会让效果更好点。void main(){ lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate); //根据坐标取样图片颜色信息 lowp float luminance = dot(textureColor.rgb, luminanceWeighting); //GLSL中的点乘运算，线性代数的点运算符相乘两个数字。点乘计算需要将纹理颜色信息和相对应的亮度权重相乘。然后取出所有的三个值相加到一起计算得到这个像素的中和亮度值。 lowp vec3 greyScaleColor = vec3(luminance); //创建一个三个值都是亮度信息的vec3，如果只指定一个值，编译器会将其它的都设置成这个值 gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w); //用mix函数把计算的灰度值，初识的纹理颜色和得到的饱和度信息结合起来。} 球形滤镜示例123456789101112131415161718192021222324varying highp vec2 textureCoordinate;uniform sampler2D inputImageTexture;uniform highp vec2 center;uniform highp float radius;uniform highp float aspectRatio;uniform highp float refractiveIndex;void main(){ highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio)); //归一化坐标空间需要考虑屏幕是一个单位宽和一个单位长。 highp float distanceFromCenter = distance(center, textureCoordinateToUse); //计算特定像素点距离球形的中心有多远。使用GLSL内建的distance()函数，用勾股定律计算出中心坐标和长宽比矫正过的纹理坐标的距离 lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius); //计算片段是否在球体内。 distanceFromCenter = distanceFromCenter / radius; //标准化到球心的距离，重新设置distanceFromCenter highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter); //模拟一个玻璃球，需要计算球的“深度”是多少。 highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth)); //归一化 highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex); //GLSL的refract()函数以刚才创建的球法线和折射率来计算当光线通过球时从任意一个点看起来如何。 gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere; //最后凑齐所有计算需要的颜色信息。} 调试Shader使用gl_FragColor调试代码。GPUImage是个开源的资源有些很酷的shader，非常好的学习shader的方式，可以拿一个你觉得很有意思的shader对着源码一点点看下去。GPUImage还有一个shader设计器https://github.com/BradLarson/GPUImage/tree/master/examples/Mac/ShaderDesigner 的Mac应用，可以测试shader而不用准备OpenGL代码。 性能调优简单的方法达到调优目的，可以用下载Imagination Technologies PowerVR SDKhttps://community.imgtec.com/developers/powervr/这个工具帮助分析shader 消除条件逻辑：使用step()这样的函数 减少依赖纹理的读取：如果希望从附近像素取样而不是计算Fragment shader相邻像素的偏差，最好在Vertex shader中计算然后把结果以varying的方式传入Fragment shader里。 计算尽量简单：能够得到一个近似值就尽量用，不要用类似sin()，cos()，tan()的比较消耗的操作。 尽可能的将计算放到Vertex上：如果计算在图片上会有相同的结果或线性变化最好这样做。因为Vertex shader对每个顶点运行一次，而Fragment shader会在每个像素上运行一次。 移动设备使用合适的精度：在向量上使用低精度的值会变得更快。两个lowp vec4相加可以在一个时钟周期内完成，两个highp vec4相加则需要四个时钟周期。 边界探测基于OpenCV库，不过这些步骤在GPUImage中都有完整的实现 Sobel边界探测这种操作在滤镜方面比机器视觉方面多。Sobel边界探测用于探测边界的出现位置，边界是由明变暗或者由暗变明的区域。在被处理的图片中一个像素的亮度反映了这个像素周围边界的强度。 第一步，将彩色图片弄成灰阶图，这个过程就是将每个像素的红绿蓝部分合一代表亮度的值。如是果YUV而不是RGB格式的可以省略这步，因为YUV是将亮度信息和色度信息分开的。如果简化到只剩亮度的话一个像素周围的边界强度就可以由周围3*3个临近像素计算得到。这个计算涉及Convolution Matrix（卷积矩阵），每个像素都要与这个矩阵计算出一个数值，因为没有顺序要求所以可以采取并行运算。 Sobel的水平处理矩阵 -1 0 +1-2 0 +2-1 0 +1 Sobel的垂直矩阵 -1 -2 -10 0 0+1 +2 +1 和Sobel类似的变体，Prewitt边界探测。这个变体会在横向竖向矩阵中用不同的矩阵，但是运作过程差不多。 OpenGL ES代码1234567891011121314151617181920212223242526272829303132333435precision mediump float;//varying的都是在Vertex shader上定义了varying vec2 textureCoordinate;varying vec2 leftTextureCoordinate;varying vec2 rightTextureCoordinate;varying vec2 topTextureCoordinate;varying vec2 topLeftTextureCoordinate;varying vec2 topRightTextureCoordinate;varying vec2 bottomTextureCoordinate;varying vec2 bottomLeftTextureCoordinate;varying vec2 bottomRightTextureCoordinate;uniform sampler2D inputImageTexture;void main(){ float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r; float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r; float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r; float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r; float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r; float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r; float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r; float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r; float h = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity; float v = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity; float mag = length(vec2(h, v)); //length()函数计算出水平和垂直矩阵转化后值的平方和的平方根的值，这个值会被拷贝进输出像素的红绿蓝通道中，这样就可以来代表边界的明显程度了。 gl_FragColor = vec4(vec3(mag), 1.0);} Canny边界探测Canny探测会比Sobel复杂些，这样做会得到一条物体边界的干净线条。 探测过程： 先用Sobel矩阵得到边界梯度的强度。这个和Sobel比就是最后一个计算有些不同 12345678910vec2 gradientDirection;gradientDirection.x = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;gradientDirection.y = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;float gradientMagnitude = length(gradientDirection);vec2 normalizedDirection = normalize(gradientDirection);normalizedDirection = sign(normalizedDirection) * floor(abs(normalizedDirection) + 0.617316); // Offset by 1-sin(pi/8) to set to 0 if near axis, 1 if awaynormalizedDirection = (normalizedDirection + 1.0) * 0.5; // Place -1.0 - 1.0 within 0 - 1.0gl_FragColor = vec4(gradientMagnitude, normalizedDirection.x, normalizedDirection.y, 1.0); 着色器步骤 1234567891011121314151617181920212223242526precision mediump float;varying highp vec2 textureCoordinate;uniform sampler2D inputImageTexture;uniform highp float texelWidth; //要处理的图片中临近像素之间的距离。uniform highp float texelHeight; //同上uniform mediump float upperThreshold; //预期边界强度上下限uniform mediump float lowerThreshold; void main(){ vec3 currentGradientAndDirection = texture2D(inputImageTexture, textureCoordinate).rgb; vec2 gradientDirection = ((currentGradientAndDirection.gb * 2.0) - 1.0) * vec2(texelWidth, texelHeight); float firstSampledGradientMagnitude = texture2D(inputImageTexture, textureCoordinate + gradientDirection).r; float secondSampledGradientMagnitude = texture2D(inputImageTexture, textureCoordinate - gradientDirection).r; float multiplier = step(firstSampledGradientMagnitude, currentGradientAndDirection.r); multiplier = multiplier * step(secondSampledGradientMagnitude, currentGradientAndDirection.r); float thresholdCompliance = smoothstep(lowerThreshold, upperThreshold, currentGradientAndDirection.r); multiplier = multiplier * thresholdCompliance; gl_FragColor = vec4(multiplier, multiplier, multiplier, 1.0);} Harris边角探测多步骤的方法来探测场景中的边角。 先弄得只有亮度信息，再通过Sobel矩阵，普里维特矩阵或者其它相关的矩阵计算出一个像素X和Y方向的梯度值，计算的结果会将X梯度传入红色部分，Y梯度传入绿色部分，X与Y梯度的乘积传入蓝色部分。 对计算的结果进行高斯模糊。将模糊后图中取出红绿蓝编码的值带到计算边角点可能性公式： R = Ix2 × Iy2 − Ixy × Ixy − k × (Ix2 + Iy2)2 #资料 相关数学 3D Math Primer for Graphics and Game Development https://www.amazon.com/Math-Primer-Graphics-Game-Development/dp/1568817231/ref=sr_1_1?ie=UTF8&amp;qid=1422837187&amp;sr=8-1&amp;keywords=3d+math+primer+for+graphics+and+game+development The Nature of Code https://natureofcode.com/ The Computational Beauty of Nature https://www.amazon.com/Computational-Beauty-Nature-Explorations-Adaptation/dp/0262561271/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422837256&amp;sr=1-1&amp;keywords=computational+beauty+of+nature 相关GLSL Graphic Shaders: Theory and Practice https://www.amazon.com/Graphics-Shaders-Theory-Practice-Second/dp/1568814348/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422837351&amp;sr=1-1&amp;keywords=graphics+shaders+theory+and+practice The OpenGL Shading Language https://www.amazon.com/OpenGL-Shading-Language-Randi-Rost/dp/0321637631/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422896457&amp;sr=1-1&amp;keywords=opengl+shading+language OpenGL 4 Shading Language Cookbook https://www.amazon.com/OpenGL-Shading-Language-Cookbook-Second/dp/1782167021/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1422896457&amp;sr=1-2&amp;keywords=opengl+shading+language GPU Gems https://http.developer.nvidia.com/GPUGems/gpugems_part01.html GPU Pro: Advanced Rendering Techniques https://www.amazon.com/GPU-Pro-Advanced-Rendering-Techniques/dp/1568814720/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422837427&amp;sr=1-4&amp;keywords=gpu+pro ming1016","link":"/program//gpu/"},{"title":"HTTP状态码汇总","text":"HTTP状态码 HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。 HTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。 微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。 编号 名称 解释 1️⃣❌❌ 🔴🔴🔴 1xx消息 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。 100 Continue 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 Processing 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 2️⃣❌❌ 🔴🔴🔴 2xx成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。 202 Accepted 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 Non-Authoritative Information 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 No Content 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 Reset Content 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 Partial Content 服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。 响应必须包含如下的头部域： Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag和／或Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。 207 Multi-Status 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 3️⃣❌❌ 🔴🔴🔴 3xx重定向 这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。 302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 See Other 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 Not Modified 如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag和／或Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 Use Proxy 被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。 306 Switch Proxy 在最新版的规范中，306状态码已经不再被使用。 307 Temporary Redirect 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 4️⃣❌❌ 🔴🔴🔴 4xx客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400 Bad Request 由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 401 Unauthorized 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 Payment Required 该状态码是为了将来可能的需求而预留的。 403 Forbidden 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 Method Not Allowed 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 Proxy Authentication Required 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。 408 Request Timeout 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 Gone 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 Length Required 服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。 412 Precondition Failed 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long 请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 Unsupported Media Type 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 Requested Range Not Satisfiable 如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。 假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。 417 Expectation Failed 在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。 418 I’m a teapot 本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。 421 There are too many connections from your internet address 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 Unprocessable Entity 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV） 423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424 Failed Dependency 由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV） 425 Unordered Collection 在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。 426 Upgrade Required 客户端应当切换到TLS/1.0。（RFC 2817） 449 Retry With 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 5️⃣❌❌ 🔴🔴🔴 5xx服务器错误 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。 500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 Not Implemented 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。 504 Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 HTTP Version Not Supported 服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 Variant Also Negotiates 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 Insufficient Storage 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918） 509 Bandwidth Limit Exceeded 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 Not Extended 获取资源所需要的策略并没有没满足。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//http/"},{"title":"iOS Background Tasks","text":"三种方式使得iOS程序即使在关闭或崩溃的情况下也能够在后台持续进行一些任务，比如更新程序界面快照，下载文件等。这三个方法分别是Background Fetch，Remote Notification和NSURLSession的backgroundSessionConfiguration Background Fetch开启首先在info plist文件中开启UIBackgroundModes的Background fetch。或者手动编辑这个值1234&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;fetch&lt;/string&gt;&lt;/array&gt; iOS默认不进行background fetch，需要设置一个时间的间隔 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ //UIApplicationBackgroundFetchIntervalMinimum表示尽可能频繁去获取，如果需要指定至少多少时间更新一次就需要给定一个时间值 [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum]; return YES;} 最后在App Delegate里实现下面的方法，这个方法只能在30秒内完成。 123456789101112131415161718192021222324252627- (void) application:(UIApplication *)applicationperformFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{ NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration]; NSURL *url = [[NSURL alloc] initWithString:@&quot;https://yourserver.com/data.json&quot;]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { if (error) { completionHandler(UIBackgroundFetchResultFailed); return; } // 解析响应/数据以决定新内容是否可用 BOOL hasNewData = ... if (hasNewData) { completionHandler(UIBackgroundFetchResultNewData); } else { completionHandler(UIBackgroundFetchResultNoData); } }]; // 开始任务 [task resume];} 测试 通过查看UIApplication的applicationState123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ NSLog(@&quot;Launched in background %d&quot;, UIApplicationStateBackground == application.applicationState); return YES;} Remote Notification在普通的远程通知里带上content-available标志就可以在通知用户同时在后台进行更新。通知结构如下 123456{ &quot;aps&quot; : { &quot;content-available&quot; : 1 }, &quot;content-id&quot; : 42} 接收一条带有content-available的通知会调用下面的方法 12345678910- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{ NSLog(@&quot;Remote Notification userInfo is %@&quot;, userInfo); NSNumber *contentID = userInfo[@&quot;content-id&quot;]; // 根据 content ID 进行操作 completionHandler(UIBackgroundFetchResultNewData);} 利用NSURLSession进行background transfer task使用[NSURLSessionConfiguration backgroundSessionConfiguration]创建一个后台任务，当应用退出后，崩溃或进程被关掉都还是会运行。 范例，先处理一条远程通知，并将NSURLSessionDownloadTask添加到后台传输服务队列。 123456789101112131415161718192021222324252627282930313233- (NSURLSession *)backgroundURLSession{ static NSURLSession *session = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ NSString *identifier = @&quot;io.objc.backgroundTransferExample&quot;; NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier]; session = [NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:[NSOperationQueue mainQueue]]; }); return session;}- (void) application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{ NSLog(@&quot;Received remote notification with userInfo %@&quot;, userInfo); NSNumber *contentID = userInfo[@&quot;content-id&quot;]; NSString *downloadURLString = [NSString stringWithFormat:@&quot;https://yourserver.com/downloads/%d.mp3&quot;, [contentID intValue]]; NSURL* downloadURL = [NSURL URLWithString:downloadURLString]; NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL]; NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request]; task.taskDescription = [NSString stringWithFormat:@&quot;Podcast Episode %d&quot;, [contentID intValue]]; //执行resume保证开始了任务 [task resume]; completionHandler(UIBackgroundFetchResultNewData);} 下载完成后调用NSURLSessionDownloadDelegate的委托方法，这些委托方法全部是必须实现的。了解所有类型session task的生命周期可以参考官方文档：https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42 123456789101112131415161718192021222324252627#Pragma Mark - NSURLSessionDownloadDelegate- (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location{ NSLog(@&quot;downloadTask:%@ didFinishDownloadingToURL:%@&quot;, downloadTask.taskDescription, location); // 必须用 NSFileManager 将文件复制到应用的存储中，因为临时文件在方法返回后会被删除 // ... // 通知 UI 刷新}- (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes{}- (void) URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{} 后台的任务完成后如果应用没有在前台运行，需要实现UIApplication的两个delegate让系统唤醒应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void) application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler{ // 你必须重新建立一个后台 seesiong 的参照 // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为 // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession NSURLSession *backgroundSession = [self backgroundURLSession]; NSLog(@&quot;Rejoining session with identifier %@ %@&quot;, identifier, backgroundSession); // 保存 completion handler 以在处理 session 事件后更新 UI [self addCompletionHandler:completionHandler forSession:identifier];}- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{ NSLog(@&quot;Background URL session %@ finished events.\\n&quot;, session); if (session.configuration.identifier) { // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler [self callCompletionHandlerForSession:session.configuration.identifier]; }}- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier{ if ([self.completionHandlerDictionary objectForKey:identifier]) { NSLog(@&quot;Error: Got multiple handlers for a single session identifier. This should not happen.\\n&quot;); } [self.completionHandlerDictionary setObject:handler forKey:identifier];}- (void)callCompletionHandlerForSession: (NSString *)identifier{ CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier]; if (handler) { [self.completionHandlerDictionary removeObjectForKey: identifier]; NSLog(@&quot;Calling completion handler for session %@&quot;, identifier); handler(); }} ming1016","link":"/program//ios-background-tasks/"},{"title":"iOS设计模式","text":"iOS 设计模式 MVC Model：模型 View：视图 Controller：控制器 单例单例使用懒加载方式在第一次实例时创建，如[NSUserDefaults standardUserDefaults]，[UIApplication sharedApplication]，[UIScreen mainScreen]，[NSFileManager defaultManager] 系统的单例类 UIApplication NSNotificationCenter NSFileManager NSUserDefaults NSURLCache NSHTTPCookieStorage123456789101112131415161718@interfaceLibraryAPI : NSObject + (LibraryAPI*)sharedInstance; @end+ (LibraryAPI*)sharedInstance { // 声明一个静态变量去保存类的实例，确保它在类中的全局可用 static LibraryAPI *_sharedInstance = nil; // dispatch_once_t确保初始化器只执行一次 static dispatch_once_t oncePredicate; // 单例的关键，一旦类被初始化，初始化器不会再被调用 dispatch_once(&amp;oncePredicate, ^{ _sharedInstance = [[LibraryAPI alloc] init]; }); return _sharedInstance; } 12345678910111213141516171819202122232425262728293031323334353637@implementation XNShareTool /** 步骤: 1.一个静态变量_inastance 2.重写allocWithZone, 在里面用dispatch_once, 并调用super allocWithZone 3.自定义一个sharedXX, 用来获取单例. 在里面也调用dispatch_once, 实例化_instance -----------可选------------ 4.如果要支持copy. 则(先遵守NSCopying协议)重写copyWithZone, 直接返回_instance即可. */ /**第1步: 存储唯一实例*/ static XNShareTool *_instance; /**第2步: 分配内存孔家时都会调用这个方法. 保证分配内存alloc时都相同*/ +(id)allocWithZone:(struct _NSZone *)zone{ //调用dispatch_once保证在多线程中也只被实例化一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instance = [super allocWithZone:zone]; }); return _instance; } /**第3步: 保证init初始化时都相同*/ +(instancetype)sharedTool{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instance = [[XNShareTool alloc] init]; }); return _instance; } /**第4步: 保证copy时都相同*/ -(id)copyWithZone:(NSZone *)zone{ return _instance; } @end 门面模式Facade暴露接口 装饰器模式Decorator常见的实现是Category和Delegation， 适配器模式Adapter包装一个对象暴露一个标准的接口。可以使用协议的方式实现，比如UITableViewDelegate，UIScrollViewDelegate，NSCoding和NSCopying协议。 观察者模式ObserverNotifications和Key-Value Observing(KVO)都是这个设计模式 备忘录模式Memento比如NSUserDefaults，或者用类似的方式进行状态保存使得再次进入时能够和离开时一样。可以使用UIApplicationDidEnterBackgroundNotification 这个通知去保存状态。 命令模式通过Target-Action机制和Invocation实现命令模式 ming1016","link":"/program//ios-design-pattern/"},{"title":"iOS并发编程","text":"线程使用Instruments的CPU strategy view查看代码如何在多核CPU中执行。创建线程可以使用POSIX 线程API，或者NSThread（封装POSIX 线程API）。下面是并发4个线程在一百万个数字中找最小值和最大值的pthread例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#import &lt;pthread.h&gt;struct threadInfo { uint32_t * inputValues; size_t count;};struct threadResult { uint32_t min; uint32_t max;};void * findMinAndMax(void *arg){ struct threadInfo const * const info = (struct threadInfo *) arg; uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; info-&gt;count; ++i) { uint32_t v = info-&gt;inputValues[i]; min = MIN(min, v); max = MAX(max, v); } free(arg); struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result)); result-&gt;min = min; result-&gt;max = max; return result;}int main(int argc, const char * argv[]){ size_t const count = 1000000; uint32_t inputValues[count]; // 使用随机数字填充 inputValues for (size_t i = 0; i &lt; count; ++i) { inputValues[i] = arc4random(); } // 开始4个寻找最小值和最大值的线程 size_t const threadCount = 4; pthread_t tid[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) { struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info)); size_t offset = (count / threadCount) * i; info-&gt;inputValues = inputValues + offset; info-&gt;count = MIN(count - offset, count / threadCount); int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info); NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err); } // 等待线程退出 struct threadResult * results[threadCount]; for (size_t i = 0; i &lt; threadCount; ++i) { int err = pthread_join(tid[i], (void **) &amp;(results[i])); NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err); } // 寻找 min 和 max uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i &lt; threadCount; ++i) { min = MIN(min, results[i]-&gt;min); max = MAX(max, results[i]-&gt;max); free(results[i]); results[i] = NULL; } NSLog(@&quot;min = %u&quot;, min); NSLog(@&quot;max = %u&quot;, max); return 0;} 使用NSThread来写 123456789101112131415161718192021222324252627282930313233343536373839404142@interface FindMinMaxThread : NSThread@property (nonatomic) NSUInteger min;@property (nonatomic) NSUInteger max;- (instancetype)initWithNumbers:(NSArray *)numbers;@end@implementation FindMinMaxThread { NSArray *_numbers;}- (instancetype)initWithNumbers:(NSArray *)numbers{ self = [super init]; if (self) { _numbers = numbers; } return self;}- (void)main{ NSUInteger min; NSUInteger max; // 进行相关数据的处理 self.min = min; self.max = max;}@end//启动一个新的线程，创建一个线程对象NSMutableSet *threads = [NSMutableSet set];NSUInteger numberCount = self.numbers.count;NSUInteger threadCount = 4;for (NSUInteger i = 0; i &lt; threadCount; i++) { NSUInteger offset = (count / threadCount) * i; NSUInteger count = MIN(numberCount - offset, numberCount / threadCount); NSRange range = NSMakeRange(offset, count); NSArray *subset = [self.numbers subarrayWithRange:range]; FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset]; [threads addObject:thread]; [thread start];} Grand Central DispatchGCD中的FIFO队列称为dispatch queue，用来保证先进来的任务先得到执行。 dispatch queue分三种 Serial：又叫private dispatch queues，同时只执行一个任务。Serial queue常用于同步访问特定的资源或数据。当你创建多个Serial queue时，虽然各自是同步，但serial queue之间是并发执行。 Concurrent：又叫global dispatch queue，可以并发的执行多个任务，但执行完成顺序是随机的。 Main dispatch queue：全局可用的serial queue，在应用程序主线程上执行任务。 GCD概要 和operation queue一样都是基于队列的并发编程API，他们通过集中管理大家协同使用的线程池。 公开的5个不同队列：运行在主线程中的main queue，3个不同优先级的后台队列（High Priority Queue，Default Priority Queue，Low Priority Queue），以及一个优先级更低的后台队列Background Priority Queue（用于I/O） 可创建自定义队列：串行或并列队列。自定义一般放在Default Priority Queue和Main Queue里。 dispatch_once用法12345678910+ (UIColor *)boringColor;{ static UIColor *color; //只运行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; }); return color;} dispatch_async（较常用）可以避免界面会被一些耗时的操作卡死，比如读取网络数据，大数据IO，还有大量数据的数据库读写，这时需要在另一个线程中处理，然后通知主线程更新界面，GCD使用起来比NSThread和NSOperation方法要简单方便。 12345678910111213141516171819//代码框架dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 耗时的操作 dispatch_async(dispatch_get_main_queue(), ^{ // 更新界面 });});//下载图片的示例dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSURL * url = [NSURL URLWithString:@&quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;]; NSData * data = [[NSData alloc]initWithContentsOfURL:url]; UIImage *image = [[UIImage alloc]initWithData:data]; if (data != nil) { dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; }); }}); dispatch_after延后执行12345678- (void)foo{ double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self bar]; });} 范例，实现一个推迟出现弹出框提示，比如说提示用户评价等功能。 12345678910111213func showOrHideNavPrompt() { let delayInSeconds = 1.0 let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 在这里声明推迟的时间 dispatch_after(popTime, GlobalMainQueue) { // 等待delayInSeconds将闭包异步到主队列 let count = PhotoManager.sharedManager.photos.count if count &gt; 0 { self.navigationItem.prompt = nil } else { self.navigationItem.prompt = &quot;Add photos with faces to Googlyify them!&quot; } }} GCD队列队列默认是串行的，只能执行一个单独的block，队列也可以是并行的，同一时间执行多个block 123456789101112- (id)init;{ self = [super init]; if (self != nil) { NSString *label = [NSString stringWithFormat:@&quot;%@.isolation.%p&quot;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@&quot;%@.work.%p&quot;, [self class], self]; self.workQueue = dispatch_queue_create([label UTF8String], 0); } return self;} 5种队列，主队列（main queue）,四种通用调度队列，自己定制的队列。四种通用调度队列为 QOS_CLASS_USER_INTERACTIVE：user interactive等级表示任务需要被立即执行提供好的体验，用来更新UI，响应事件等。这个等级最好保持小规模。 QOS_CLASS_USER_INITIATED：user initiated等级表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。 QOS_CLASS_UTILITY：utility等级表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。这个任务节能。 QOS_CLASS_BACKGROUND：background等级表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。 示例：后台加载显示图片 12345678910override func viewDidLoad() { super.viewDidLoad() dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { // 将工作从主线程转移到全局队列中，这是dispatch_async调用，异步提交保证调用线程会继续执行下去，这样viewDidLoad在主线程上能够更早完成， let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(dispatch_get_main_queue()) { // 新图完成，把一个闭包加入主线程用来更新UIImageView，只有在主线程能操作UIKit。 self.fadeInNewImage(overlayImage) // 更新UI } }} 何时使用何种队列类型 主队列（顺序）：队列中有任务完成需要更新UI时，dispatch_after在这种类型中使用。 并发队列：用来执行与UI无关的后台任务，dispatch_sync放在这里，方便等待任务完成进行后续处理或和dispatch barrier同步。dispatch groups放在这里也不错。 自定义顺序队列：顺序执行后台任务并追踪它时。这样做同时只有一个任务在执行可以防止资源竞争。dipatch barriers解决读写锁问题的放在这里处理。dispatch groups也是放在这里。 可以使用下面的方法简化QoS等级参数的写法 1234567891011121314151617181920212223var GlobalMainQueue: dispatch_queue_t { return dispatch_get_main_queue()}var GlobalUserInteractiveQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0)}var GlobalUserInitiatedQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)}var GlobalUtilityQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0)}var GlobalBackgroundQueue: dispatch_queue_t { return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0)}//使用起来就是这样，易读而且容易看出在使用哪个队列dispatch_async(GlobalUserInitiatedQueue) { let overlayImage = self.faceOverlayImageFromImage(self.image) dispatch_async(GlobalMainQueue) { self.fadeInNewImage(overlayImage) }} 使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。 123456789101112131415//创建队列self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);//改变setter- (void)setCount:(NSUInteger)count forKey:(NSString *)key{ key = [key copy]; //确保所有barrier都是async异步的 dispatch_barrier_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } });} swift示例 12345678910111213141516171819202122//使用dispatch_queue_create初始化一个并发队列。第一个参数遵循反向DNS命名习惯，方便描述，第二个参数是指出是并发还是顺序。private let concurrentPhotoQueue = dispatch_queue_create(&quot;com.raywenderlich.GooglyPuff.photoQueue&quot;, DISPATCH_QUEUE_CONCURRENT)func addPhoto(photo: Photo) { dispatch_barrier_async(concurrentPhotoQueue) { // 将写操作加入到自定义的队列。开始执行时这个就是队列中唯一的一个在执行的任务。 self._photos.append(photo) // barrier能够保障不会和其他任务同时进行。 dispatch_async(GlobalMainQueue) { // 涉及到UI所以这个通知应该在主线程中，所以分派另一个异步任务到主队列中。 self.postContentAddedNotification() } }}//上面是解决了写可能发生死锁，下面是使用dispatch_sync解决读时可能会发生的死锁。var photos: [Photo] { var photosCopy: [Photo]! dispatch_sync(concurrentPhotoQueue) { // 同步调度到concurrentPhotoQueue队列执行读操作 photosCopy = self._photos // 保存 } return photosCopy}//这样读写问题都解决了。 都用异步处理避免死锁，异步的缺点在于调试不方便，但是比起同步容易产生死锁这个副作用还算小的。 异步API写法设计一个异步的API调用dispatch_async()，这个调用放在API的方法或函数中做。让API的使用者设置一个回调处理队列 123456789- (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler;{ dispatch_async(self.isolationQueue, ^(void){ // do actual processing here dispatch_async(self.resultQueue, ^(void){ handler(YES); }); });} dispatch_apply进行快速迭代1234567891011for (size_t y = 0; y &lt; height; ++y) { for (size_t x = 0; x &lt; width; ++x) { // Do something with x and y here }}//使用dispatch_apply可以运行的更快dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) { for (size_t x = 0; x &lt; width; x += 2) { // Do something with x and y here }}); 示例： 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! var downloadGroup = dispatch_group_create() let addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] dispatch_apply(UInt(addresses.count), GlobalUserInitiatedQueue) { i in let index = Int(i) let address = addresses[index] let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } }} Block组合Dispatch_groupsdispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。 当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。 第一种使用dispatch_group_wait的swift的例子： 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { dispatch_async(GlobalUserInitiatedQueue) { // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) { // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion { // 执行闭包内容 completion(error: storedError) } } }} 第二种使用dispatch_group_notify的swift的例子： 123456789101112131415161718192021222324252627func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { // 不用加dispatch_async，因为没有阻塞主进程 var storedError: NSError! var downloadGroup = dispatch_group_create() for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] { let url = NSURL(string: address) dispatch_group_enter(downloadGroup) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } dispatch_group_notify(downloadGroup, GlobalMainQueue) { // dispatch_group_notify和dispatch_group_wait的区别就是是异步执行闭包的，当dispatch groups中没有剩余的任务时闭包才执行。这里是指明在主队列中执行。 if let completion = completion { completion(error: storedError) } }} 1234567891011121314151617181920212223dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(0, 0);dispatch_group_async(group, queue, ^(){ // 会处理一会 [self doSomeFoo]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.foo = 42; });});dispatch_group_async(group, queue, ^(){ // 处理一会儿 [self doSomeBar]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.bar = 1; });});// 上面的都搞定后这里会执行一次dispatch_group_notify(group, dispatch_get_main_queue(), ^(){ NSLog(@&quot;foo: %d&quot;, self.foo); NSLog(@&quot;bar: %d&quot;, self.bar);}); 如何对现有API使用dispatch_group_t 12345678910111213141516171819202122232425262728293031323334//给Core Data的-performBlock:添加groups。组合完成任务后使用dispatch_group_notify来运行一个block即可。- (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block{ if (group == NULL) { [self performBlock:block]; } else { dispatch_group_enter(group); [self performBlock:^(){ block(); dispatch_group_leave(group); }]; }}//NSURLConnection也可以这样做+ (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler{ if (group == NULL) { [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; } else { dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){ handler(response, data, error); dispatch_group_leave(group); }]; }} 注意事项 dispatch_group_enter() 必须运行在 dispatch_group_leave() 之前。 dispatch_group_enter() 和 dispatch_group_leave() 需要成对出现的 使用dispatch block object（调度块）在任务执行前进行取消dispatch block object可以为队列中的对象设置示例，下载图片中途进行取消 123456789101112131415161718192021222324252627282930313233343536373839404142func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) { var storedError: NSError! let downloadGroup = dispatch_group_create() var addresses = [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] addresses += addresses + addresses // 扩展address数组，复制3份 var blocks: [dispatch_block_t] = [] // 一个保存block的数组 for i in 0 ..&lt; addresses.count { dispatch_group_enter(downloadGroup) let block = dispatch_block_create(DISPATCH_BLOCK_INHERIT_QOS_CLASS) { // 创建一个block，block的标志是DISPATCH_BLOCK_INHERIT_QOS_CLASS let index = Int(i) let address = addresses[index] let url = NSURL(string: address) let photo = DownloadPhoto(url: url!) { image, error in if let error = error { storedError = error } dispatch_group_leave(downloadGroup) } PhotoManager.sharedManager.addPhoto(photo) } blocks.append(block) dispatch_async(GlobalMainQueue, block) // 把这个block放到GlobalMainQueue上异步调用。因为全局队列是一个顺序队列所以方便取消对象block，同时可以保证下载任务在downloadPhotosWithCompletion返回后才开始执行。 } for block in blocks[3 ..&lt; blocks.count] { let cancel = arc4random_uniform(2) // 随机返回一个整数，会返回0或1 if cancel == 1 { dispatch_block_cancel(block) // 如果是1就取消block，这个只能发生在block还在队列中并没有开始的情况下。因为把block已经放到了GlobalMainQueue中，所以这个地方会先执行，执行完了才会执行block。 dispatch_group_leave(downloadGroup) // 因为已经dispatch_group_enter了，所以取消时也要将其都leave掉。 } } dispatch_group_notify(downloadGroup, GlobalMainQueue) { if let completion = completion { completion(error: storedError) } }} 用GCD监视进程1234567891011NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@&quot;com.apple.mail&quot;];if (mail == nil) { return;}pid_t const pid = mail.processIdentifier;self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(self.source, ^(){ NSLog(@&quot;Mail quit.&quot;);});//在事件源传到你的事件处理前需要调用dispatch_resume()这个方法dispatch_resume(self.source); 监视文件夹内文件变化12345678910111213141516171819202122232425NSURL *directoryURL; // assume this is set to a directoryint const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) { char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@&quot;Unable to open \\&quot;%@\\&quot;: %s (%d)&quot;, [directoryURL path], buffer, errno); return;}dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^(){ unsigned long const data = dispatch_source_get_data(source); if (data &amp; DISPATCH_VNODE_WRITE) { NSLog(@&quot;The directory changed.&quot;); } if (data &amp; DISPATCH_VNODE_DELETE) { NSLog(@&quot;The directory has been deleted.&quot;); }});dispatch_source_set_cancel_handler(source, ^(){ close(fd);});self.source = source;dispatch_resume(self.source);//还要注意需要用DISPATCH_VNODE_DELETE 去检查监视的文件或文件夹是否被删除，如果删除了就停止监听 GCD版定时器12345678dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0, 0, DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^(){ NSLog(@&quot;Time flies.&quot;);});dispatch_time_t startdispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC,100ull * NSEC_PER_MSEC);self.source = source;dispatch_resume(self.source); GCD深入操作 缓冲区：dispatch_data_t基于零碎的内存区域，使用dispatch_data_apply来遍历，还可以用dispatch_data_create_subrange来创建一个不做任何拷贝的子区域 I/O调度：使用GCD提供的dispatch_io_read，dispatch_io_write和dispatch_io_close 测试：使用dispatch_benchmark小工具 原子操作： libkern/OSAtomic.h里可以查看那些函数，用于底层多线程编程。 Cocoa NSOperation使用NSOperation的两种方式。一种用定义好的两个子类NSInvocationOperation和NSBlockOperation，另一个是继承NSOperation。 NSOperation是设计用来扩展的，只需继承重写NSOperation的一个方法main，然后把NSOperation子类的对象放入NSOperationQueue队列中，该队列就会启动并开始处理它。 NSInvocationOperation例子 1234567891011121314151617181920212223242526272829#import &quot;ViewController.h&quot;#define kURL @&quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad{ [super viewDidLoad]; NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; NSOperationQueue *queue = [[NSOperationQueue alloc]init]; [queue addOperation:operation]; //放进去就开始了 // Do any additional setup after loading the view, typically from a nib.}-(void)downloadImage:(NSString *)url{ NSLog(@&quot;url:%@&quot;, url); NSURL *nsUrl = [NSURL URLWithString:url]; NSData *data = [[NSData alloc]initWithContentsOfURL:nsUrl]; UIImage * image = [[UIImage alloc]initWithData:data]; [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];}-(void)updateUI:(UIImage*) image{ self.imageView.image = image;} Operation Queue是在GCD上实现了一些方便的功能。优点是不需要关心线程管理，数据同步。Cocoa operation相关的类是NSOperation，NSOperationQueue。 NSOperationQueue有主队列和自定义队列两种类型队列。主队列在主线程上运行，自定义队列在后台。 重写main方法自定义自己的operations。较简单，不需要管理isExecuting和isFinished，main返回时operation就结束了。 123456@implementation YourOperation - (void)main { // 进行处理 ... }@end 重写start方法能够获得更多的控制权，还可以在一个操作中执行异步任务 123456789101112131415161718192021@implementation YourOperation - (void)start { self.isExecuting = YES; self.isFinished = NO; // 开始处理，在结束时应该调用 finished ... } - (void)finished { self.isExecuting = NO; self.isFinished = YES; }@end//使操作队列有取消功能，需要不断检查isCancelled属性- (void)main{ while (notDone &amp;&amp; !self.isCancelled) { // 进行处理 }} 定义好operation类以后，将一个operation加到队列里： 123NSOperationQueue *queue = [[NSOperationQueue alloc] init];YourOperation *operation = [[YourOperation alloc] init];[queue addOperation:operation]; 如果是在主队列中进行一个一次性任务，可以将block加到操作队列 123[[NSOperationQueue mainQueue] addOperationWithBlock:^{ // 代码...}]; 通过maxConcurrentOperationCount属性控制一个特定队列中并发执行操作的数量。设置为1就是串行队列。 对operation优先级排序，指定operation之间的依赖关系。 1234//确保operation1和operation2是在intermediateOperation和finishOperation之前执行[intermediateOperation addDependency:operation1];[intermediateOperation addDependency:operation2];[finishedOperation addDependency:intermediateOperation]; NSThreadNSThread抽象度最高，也是Apple所推荐的。缺点是需要自己管理线程的生命周期，线程同步。线程同步对数据加锁会有一定系统开销。NSThread实现的技术有三种 Cocoa threads POSIX threads Multiprocessing Services 创建方式123456789101112- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument //实例方法+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument //类方法//直接创建线程并且运行1、[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];//先创建线程对象，再运行线程操作，运行前可以设置线程优先级等线程信息。2、NSThread* myThread = [[NSThread alloc] initWithTarget:selfselector:@selector(doSomething:)object:nil];[myThread start];//不显式创建线程的方法，使用NSObject的类方法创建一个线程3、[Obj performSelectorInBackground:@selector(doSomething) withObject:nil]; 示例 12345678910111213141516171819202122232425262728293031#import &quot;ViewController.h&quot;#define kURL @&quot;https://avatar.csdn.net/2/C/D/1_totogo2010.jpg&quot;@interface ViewController ()@end@implementation ViewController-(void)downloadImage:(NSString *) url{ NSData *data = [[NSData alloc] initWithContentsOfURL:[NSURL URLWithString:url]]; UIImage *image = [[UIImage alloc]initWithData:data]; if(image == nil){ }else{ //更新主线程外的数据使用performSelector:onThread:withObject:waitUntilDone: [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; }}-(void)updateUI:(UIImage*) image{ self.imageView.image = image;}- (void)viewDidLoad{ [super viewDidLoad];// [NSThread detachNewThreadSelector:@selector(downloadImage:) toTarget:self withObject:kURL]; NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(downloadImage:) object:kURL]; [thread start];}@end NSThread的线程同步，使用NSLock卖票的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;UIKit/UIKit.h&gt;@class ViewController;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;{ int tickets; int count; NSThread* ticketsThreadone; NSThread* ticketsThreadtwo; NSCondition* ticketsCondition; NSLock *theLock;}@property (strong, nonatomic) UIWindow *window;@property (strong, nonatomic) ViewController *viewController;@end- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@&quot;Thread-1&quot;]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@&quot;Thread-2&quot;]; [ticketsThreadtwo start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@&quot;ViewController&quot; bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES;}- (void)run{ while (TRUE) { // 上锁 // [ticketsCondition lock]; [theLock lock]; if(tickets &gt;= 0){ [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@&quot;当前票数是:%d,售出:%d,线程名:%@&quot;,tickets,count,[[NSThread currentThread] name]); tickets--; }else{ break; } [theLock unlock]; // [ticketsCondition unlock]; }} 没有线程同步lock,卖票数可能会是-1.加上能够保证数据的正确。 NSThread线程的顺序执行同步可以通过[NSCondition signal]的方式发送信号，在一个线程唤醒另一个线程等待 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &quot;AppDelegate.h&quot;#import &quot;ViewController.h&quot;@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{ tickets = 100; count = 0; theLock = [[NSLock alloc] init]; // 锁对象 ticketsCondition = [[NSCondition alloc] init]; ticketsThreadone = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadone setName:@&quot;Thread-1&quot;]; [ticketsThreadone start]; ticketsThreadtwo = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [ticketsThreadtwo setName:@&quot;Thread-2&quot;]; [ticketsThreadtwo start]; NSThread *ticketsThreadthree = [[NSThread alloc] initWithTarget:self selector:@selector(run3) object:nil]; [ticketsThreadthree setName:@&quot;Thread-3&quot;]; [ticketsThreadthree start]; self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; // Override point for customization after application launch. self.viewController = [[ViewController alloc] initWithNibName:@&quot;ViewController&quot; bundle:nil]; self.window.rootViewController = self.viewController; [self.window makeKeyAndVisible]; return YES;}-(void)run3{ while (YES) { [ticketsCondition lock]; [NSThread sleepForTimeInterval:3]; [ticketsCondition signal]; [ticketsCondition unlock]; }}- (void)run{ while (TRUE) { // 上锁 [ticketsCondition lock]; [ticketsCondition wait]; [theLock lock]; if(tickets &gt;= 0){ [NSThread sleepForTimeInterval:0.09]; count = 100 - tickets; NSLog(@&quot;当前票数是:%d,售出:%d,线程名:%@&quot;,tickets,count,[[NSThread currentThread] name]); tickets--; }else{ break; } [theLock unlock]; [ticketsCondition unlock]; }} wait是等待，假啊一个线程3去唤醒其它两个线程锁中的wait 其它同步可以使用@synchronized来简化NSLock使用，这样就不必显示编写创建NSLock加锁并解锁相关代码。 1234567- (void)doSomeThing:(id)anObj{ @synchronized(anObj) { // Everything between the braces is protected by the @synchronized directive. }} 还有些其它的锁对象，比如循环锁NSRecursiveLock，条件锁NSConditionLock，分布式锁NSDistributedLock等，可查阅官方文档。 Run Loops Run loop比GCD和操作队列要容易，不必处理并发中复杂情况就能异步执行。 主线程配置main run loop，其它线程默认都没有配置run loop。一般都在主线程中调用后分配给其它队列。如果要在其它线程添加run loop至少添加一个input source，不然一运行就会退出。 在后台操作UI使用操作队列处理123456789//weak引用参照self避免循环引用，及block持有self，operationQueue retain了block，而self有retain了operationQueue。__weak id weakSelf = self;[self.operationQueue addOperationWithBlock:^{ NSNumber* result = findLargestMersennePrime(); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ MyClass* strongSelf = weakSelf; strongSelf.textLabel.text = [result stringValue]; }];}]; drawRect在后台绘制drawRect:方法会影响性能，所以可以放到后台执行。 123456//使用UIGraphicsBeginImageContextWithOptions取代UIGraphicsGetCurrentContext:方法UIGraphicsBeginImageContextWithOptions(size, NO, 0);// drawing code hereUIImage *i = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return i; 可以把这个方法运用到table view中，使table view的cell在滚出边界时能在didEndDisplayingCell委托方法中取消。WWDC中有讲解：Session 211 – Building Concurrent User Interfaces on iOS https://developer.apple.com/videos/wwdc/2012/ 还有个使用CALayer里drawsAsynchronously属性的方法。不过有时work，有时不一定。 网络异步请求网络都要使用异步方式，但是不要直接使用dispatch_async，这样没法取消这个网络请求。dataWithContentsOfURL:的超时是30秒，那么这个线程需要干等到超时完。解决办法就是使用NSURLConnection的异步方法，把所有操作转化成operation来执行。NSURLConnection是通过run loop来发送事件的。AFNetworking是建立一个独立的线程设置一个非main run loop。下面是处理URL连接重写自定义operation子类里的start方法 1234567891011- (void)start{ NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ { self.connection = [NSURLConnectionconnectionWithRequest:request delegate:self]; }];} 重写start方法需要管理isExecuting和isFinished状态。下面是取消操作的方法 123456789101112131415- (void)cancel{ [super cancel]; [self.connection cancel]; self.isFinished = YES; self.isExecuting = NO;}//连接完成发送回调- (void)connectionDidFinishLoading:(NSURLConnection *)connection{ self.data = self.buffer; self.buffer = nil; self.isExecuting = NO; self.isFinished = YES;} 后台处理I/O异步处理文件可以使用NSInputStream。官方文档：https://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html 实例：https://github.com/objcio/issue-2-background-file-io 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@interface Reader : NSObject- (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion;- (id)initWithFileAtPath:(NSString*)path;//采用main run loop的事件将数据发到后台操作线程去处理- (void)enumerateLines:(void (^)(NSString*))blockcompletion:(void (^)())completion{ if (self.queue == nil) { self.queue = [[NSOperationQueue alloc] init]; self.queue.maxConcurrentOperationCount = 1; } self.callback = block; self.completion = completion; self.inputStream = [NSInputStream inputStreamWithURL:self.fileURL]; self.inputStream.delegate = self; [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [self.inputStream open]; }@end//input stream在主线程中发送代理消息，接着就可以在操作队列加入block操作- (void)stream:(NSStream*)stream handleEvent:(NSStreamEvent)eventCode{ switch (eventCode) { ... case NSStreamEventHasBytesAvailable: { NSMutableData *buffer = [NSMutableData dataWithLength:4 * 1024]; NSUInteger length = [self.inputStream read:[buffer mutableBytes] maxLength:[buffer length]]; if (0 &lt; length) { [buffer setLength:length]; __weak id weakSelf = self; [self.queue addOperationWithBlock:^{ [weakSelf processDataChunk:buffer]; }]; } break; } ... }}//处理数据chunk，原理就是把数据切成很多小块，然后不断更新和处理buffer缓冲区，逐块读取和存入方式来处理大文件响应快而且内存开销也小。- (void)processDataChunk:(NSMutableData *)buffer;{ if (self.remainder != nil) { [self.remainder appendData:buffer]; } else { self.remainder = buffer; } [self.remainder obj_enumerateComponentsSeparatedBy:self.delimiter usingBlock:^(NSData* component, BOOL last) { if (!last) { [self emitLineWithData:component]; } else if (0 &lt; [component length]) { self.remainder = [component mutableCopy]; } else { self.remainder = nil; } }];} 并发开发会遇到的困难问题多个线程访问共享资源比如两个线程都会把计算结果写到一个整型数中。为了防止，需要一种互斥机制来访问共享资源 互斥锁同一时刻只能有一个线程访问某个资源。某线程要访问某个共享资源先获得共享资源的互斥锁，完成操作再释放这个互斥锁，然后其它线程就能访问这个共享资源。 还有需要解决无序执行问题，这时就需要引入内存屏障。 在Objective-C中如果属性声明为atomic就能够支持互斥锁，但是因为加解锁会有性能代价，所以一般是声明noatomic的。 死锁当多个线程在相互等待对方锁结束时就会发生死锁，程序可能会卡住。 1234567891011121314void swap(A, B){ lock(lockA); lock(lockB); int a = A; int b = B; A = b; B = a; unlock(lockB); unlock(lockA);}//一般没问题，但是如果两个线程使用相反的值同时调用上面这个方法就可能会死锁。线程1获得X的一个锁，线程2获得Y的一个锁，它们会同时等待另一个锁的释放，但是却是没法等到的。swap(X, Y); // 线程 1swap(Y, X); // 线程 2 为了防止死锁，需要使用比简单读写锁更好的办法，比如write preferencehttps://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock，或read-copy-update算法https://en.wikipedia.org/wiki/Read-copy-update 优先级反转运行时低优先级任务由于先取得了释放了锁的共享资源而阻塞了高优先级任务，这种情况叫做优先级反转 最佳安全实践避免问题的方法从主线程中取到数据，利用一个操作队列在后台处理数据，完后返回后台队列中得到的数据到主队列中。这样的操作不会有任何锁操作。 并发测试 使用SenTestingKit框架测试：https://github.com/nxtbgthng/SenTestingKitAsync kiwi：https://github.com/allending/Kiwi GHunit：https://github.com/gabriel/gh-unit/ming1016","link":"/program//ios-bing-fa/"},{"title":"iOS函数响应式编程以及ReactiveCocoa的使用","text":"打算在项目中大面积使用RAC来开发，所以整理一些常用的实践范例和比较完整的api说明方便开发时随时查阅 声明式编程泛型Declarative programming函数反应式编程是声明式编程的子编程范式之一 高阶函数需要满足两个条件 一个或者多个函数作为输入。 有且仅有一个函数输出。 Objective-c里使用block作为函数 1234[array enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop){ NSLog(@&quot;%@&quot;,number);}]; 映射map123NSArray * mappedArray = [array rx_mapWithBlock:^id(id each){ return @(pow([each integerValue],2));}]; 过滤filter123NSArray *filteredArray = [array rx_filterWithBlock:^BOOL(id each){ return ([each integerValue] % 2 == 0);}] 折叠fold12345[[array rx_mapWithBlock:^id (id each){ return [each stringValue]; }] rx_foldInitialValue:@&quot;&quot; block:^id (id memo , id each){ return [memo stringByAppendingString:each];}]; Currying用函数生成另一个函数 12345678910func filterGenerator(lastnameCondition: String) -&gt; (Staff) -&gt; (Bool) { return {staff in return staff.lastname == lastnameCondition }}let filterWang = filterGenerator(&quot;Wang&quot;) let filterHu = filterGenerator(&quot;Hu&quot;)staffs.filter(filterHu) RAC中使用高阶函数映射12345678910111213NSArray *array = @[ @1, @2, @3 ];RACSequence * stream = [array rac_sequence];//RACSequence是一个RACStream的子类。[stream map:^id (id value){ return @(pow([value integerValue], 2));}];//RACSequence有一个方法返回数组:arrayNSLog(@&quot;%@&quot;,[stream array]);//避免污染变量的作用域NSLog(@&quot;%@&quot;,[[[array rac_sequence] map:^id (id value){ return @(pow([value integerValue], 2)); }] array]); 过滤123NSLog(@&quot;%@&quot;, [[[array rac_sequence] filter:^BOOL (id value){ return [value integerValue] % 2 == 0; }] array]); 折叠12345NSLog(@&quot;%@&quot;,[[[array rac_sequence] map:^id (id value){ return [value stringValue]; }] foldLeftWithStart:@&quot;&quot; reduce:^id (id accumulator, id value){ return [accumulator stringByAppendingString:value]; }]); 绑定键值12345678910111213RACSignal * validEmailSignal = [self.textField.rac_textSignal map:^id (NSString *value){ return @([value rangeOfString:@&quot;@&quot;].location != NSNotFound);}];RAC(self.button, enabled) = validEmailSignal;RAC(self.textField, textColor) = [validEmailSignal map: ^id (id value){ if([value boolValue]){ return [UIColor greenColor]; }else{ return [UIColor redColor]; }}]; 实践比较好的一个完整的RAC实践的例子：https://github.com/ashfurrow/FunctionalReactivePixels 网络请求生成对应model12345678910111213141516171819202122232425262728+ (RACSignal *)importPhotos{ RACReplaySubject * subject = [RACReplaySubject subject]; NSURLRequest * request = [self popularURLRequest]; [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError){ if (data) { id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; [subject sendNext:[[[results[@&quot;photos&quot;] rac_sequence] map:^id(NSDictionary *photoDictionary){ FRPPhotoModel * model = [FRPPhotoModel new]; [self configurePhotoModel:model withDictionary:photoDictionary]; [self downloadThumbnailForPhotoModel:model]; return model; }] array]]; [subject sendCompleted]; } else{ [subject sendError:connectionError]; } }]; return subject;} 过滤相同大小的图片，取出他们的url，返回第一个1234567+ (NSString *)urlForImageSize:(NSInteger)size inDictionary:(NSArray *)array{ return [[[[[array rac_sequence] filter:^ BOOL (NSDictionary * value){ return [value[@&quot;size&quot;] integerValue] == size; }] map:^id (id value){ return value[@&quot;url&quot;]; }] array] firstObject];} 观察model里的图片数据，进行为空过滤判断，将data转为UIImage，再把绑定新信号的值给对象的关键路径12345678- (void)setPhotoModel:(FRPPhotoModel *)photoModel{ self.subscription = [[[RACObserver(photoModel, thumbnailData) filter:^ BOOL (id value){ return value != nil; }] map:^id (id value){ return [UIImage imageWithData:value]; }] setKeyPath:@keypath(self.imageView, image) onObject:self.imageView];} UITableViewCell复用时需要取消cell上各个组件的订阅1234- (void)perpareForReuse { [super prepareForReuse]; [self.subscription dispose], self.subscription = nil;} Delegate的使用123456789101112131415161718192021222324252627//注意：你必须retain这个delegate对象，否则他们将会被释放，你将会得到一个EXC_BAD_ACCESS异常。添加下列私有属性到画廊视图控制器：@property (nonatomic, strong) id collectionViewDelegate;//同时你也需要导入RACDelegateProxy.h，因为他不是ReactiveCocoa的核心部分，不包含在ReactiveCocoa.h中。RACDelegateProxy *viewControllerDelegate = [[RACDelegateProxy alloc] initWithProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)];[[viewControllerDelegate rac_signalForSelector:@selector(userDidScroll:toPhotoAtIndex:) fromProtocol:@protocol(FRPFullSizePhotoViewControllerDelegate)] subscribeNext:^(RACTuple *value){ @strongify(self); [self.collectionView scrollToItemAtIndexPath:[NSIndexPath indexPathForItem:[value.second integerValue] inSection:0] atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO]; }];self.collectionViewDelegate = [[RACDelegateProxy alloc] initWithProtocol:@protocol(UICollectionViewDelegate)];[[self.collectionViewDelegate rac_signalForSelector:@selector(collectionView:didSelectItemAtIndexPath:)] subscribeNext:^(RACTuple *arguments) { @strongify(self); FRPFullSizePhotoViewController *viewController = [[FRPFullSizePhotoViewController alloc] initWithPhotoModels:self.photosArray currentPhotoIndex:[(NSIndexPath *)arguments.second item]]; viewController.delegate = (id&lt;FRPFullSizePhotoViewControllerDelegate&gt;)viewControllerDelegate; [self.navigationController pushViewController:viewController animated:YES]; }]; 处理异常，完成执行刷新操作，异常打印日志，执行对应方法12345RAC(self, photosArray) = [[[[FRPPhotoImporter importPhotos] doCompleted:^{ @strongify(self); [self.collectionView reloadData]; }] logError] catchTo:[RACSignal empty]]; 网络请求处理数据，获取数据返回主线程123456789101112131415161718192021+ (RACSignal *)importPhotos { NSURLRequest *request = [self popularURLRequest]; return [[[[[[NSURLConnection rac_sendAsynchronousRequest:request] reduceEach:^id(NSURLResponse *response , NSData *data){ //注意：我们可以用下面的reduceEach:替代使用RACTuple的第一个map:，以便提供编译时检查。 return data; }] deliverOn:[RACScheduler mainThreadScheduler]] map:^id (NSData *data) { id results = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; return [[[results[@&quot;photo&quot;] rac_sequence] map:^id (NSDictionary *photoDictionary) { FRPPhotoModel *model = [FRPPhotoModel new]; [self configurePhotoModel:model withDictionary:photoDictionary]; [self downloadThumbnailForPhotoModel:model]; return model; }] array]; }] publish] autoconnect]; //信号链条最末端的信号操作publish. publish返回一个RACMulitcastConnection,当信号连接上时，他将订阅该接收信号。autoconnect为我们做的是：当它返回的信号被订阅，连接到 该(订阅背后的)信号（underly signal）。} 信号的信号Signal of signals，一个外部信号包含一个内部信号，在输出信号的subscribeNext:块中订阅内部信号，会引起嵌套麻烦。使用flattenMap后会生成一个新的信号，和先前信号平级，订阅会订阅到返回的新信号里的值。map方法也是创建一个新信号，但是会将返回的信号也当做值，这样就得不到真正需要的值了。123456[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) { return [self signInSignal];}] subscribeNext:^(id x) { //x NSLog(@&quot;Sign in result: %@&quot;, x);}]; 不同信号顺序链接，程序需要等待前一个信号发出完成事件（sendCompleted），然后再订阅下一个信号（then）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (RACSignal *)requestAccessToTwitterSignal{ // 定义一个错误，如果用户拒绝访问则发送 NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil]; // 创建并返回信号 @weakify(self) return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 请求访问twitter @strongify(self) [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType options:nil completion:^(BOOL granted, NSError *error) { // 处理响应 if (!granted) { [subscriber sendError:accessError]; } else { [subscriber sendNext:nil]; [subscriber sendCompleted]; } }]; return nil; }];}//throttle可以避免连续输入造成的不必要的请求，then会忽略前一个信号的值，底层的实现是先过滤之前信号发的值，再使用concat连接then返回的信号。[[[[[[[self requestAccessToTwitterSignal] then:^RACSignal *{ @strongify(self) return self.searchText.rac_textSignal; }] filter:^BOOL(NSString *text) { @strongify(self) return [self isValidSearchText:text]; }] throttle:0.5] flattenMap:^RACStream *(NSString *text) { @strongify(self) //flattenMap来将每个next事件映射到一个新的被订阅的信号 return [self signalForSearchWithText:text]; }] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(NSDictionary *jsonSearchResult) { NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;]; NSArray *tweets = [statuses linq_select:^id(id tweet) { return [RWTweet tweetWithStatus:tweet]; }]; [self.resultsViewController displayTweets:tweets]; } error:^(NSError *error) { NSLog(@&quot;An error occurred: %@&quot;, error); }]; - (RACSignal *)signalForSearchWithText:(NSString *)text { // 1 - define the errors NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:nil]; NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:nil]; @weakify(self) return [RACSignal createSignal:^RACDisposable *(id subscriber) { @strongify(self); SLRequest *request = [self requestforTwitterSearchWithText:text]; NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType]; if (twitterAccounts.count == 0) { [subscriber sendError:noAccountsError]; } else { [request setAccount:[twitterAccounts lastObject]]; [request performRequestWithHandler: ^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error) { if (urlResponse.statusCode == 200) { NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil]; [subscriber sendNext:timelineData]; [subscriber sendCompleted]; } else { [subscriber sendError:invalidResponseError]; } }]; } return nil; }];} 异步加载图片1234567891011121314151617181920-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl { RACScheduler *scheduler = [RACScheduler schedulerWithPriority:RACSchedulerPriorityBackground]; return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]]; UIImage *image = [UIImage imageWithData:data]; [subscriber sendNext:image]; [subscriber sendCompleted]; return nil; }] subscribeOn:scheduler];}cell.twitterAvatarView.image = nil;[[[self signalForLoadingImage:tweet.profileImageUrl] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(UIImage *image) { cell.twitterAvatarView.image = image; }]; 观察viewModel里的tableView的数据键值和全部读取键值，只要有一个有新值就会调用123456789@weakify(self);[[[RACSignal merge: @[RACObserve(self.viewModel, tweets), RACObserve(self.viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) { @strongify(self); [self.tableView reloadData]; }];//bufferWithTime设置为0是为了避免同一时刻两个值被同时设置新值产生了table进行了两次reloadData 封装hook方法，某个selector被调用时，再执行一段指定代码和hook一样。12345@weakify(self);[[tableView rac_signalForSelector:@selector(layoutSubviews)]subscribeNext:^(id x) { @strongify(self); [self doSomethingBeforeTableViewLayoutSubviews];}]; 使用RACCommand来实现按钮的状态根据输入邮箱判断邮箱是否非法还有提交到服务器后出错处理等Demo的github地址：https://github.com/olegam/RACCommandExample 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980- (void)bindWithViewModel { RAC(self.viewModel, email) =self.emailTextField.rac_textSignal; self.subscribeButton.rac_command = self.viewModel.subscribeCommand; RAC(self.statusLabel, text) =RACObserve(self.viewModel, statusMessage); }@interface SubscribeViewModel :NSObject @property(nonatomic, strong)RACCommand *subscribeCommand; // writeto this property @property(nonatomic, strong) NSString *email; // read from this property @property(nonatomic, strong) NSString *statusMessage; @end #import &quot;SubscribeViewModel.h&quot; #import &quot;AFHTTPRequestOperationManager+RACSupport.h&quot; #import&quot;NSString+EmailAdditions.h&quot; static NSString *const kSubscribeURL =@&quot;https://reactivetest.apiary.io/subscribers&quot;; @interface SubscribeViewModel () @property(nonatomic, strong) RACSignal*emailValidSignal; @end @implementation SubscribeViewModel - (id)init { self= [super init]; if(self) { [self mapSubscribeCommandStateToStatusMessage]; } returnself; } -(void)mapSubscribeCommandStateToStatusMessage { RACSignal *startedMessageSource = [self.subscribeCommand.executionSignals map:^id(RACSignal *subscribeSignal) { return NSLocalizedString(@&quot;Sending request...&quot;, nil); }]; RACSignal *completedMessageSource = [self.subscribeCommand.executionSignals flattenMap:^RACStream *(RACSignal *subscribeSignal) { return[[[subscribeSignal materialize] filter:^BOOL(RACEvent *event) { return event.eventType == RACEventTypeCompleted; }] map:^id(id value) { return NSLocalizedString(@&quot;Thanks&quot;, nil); }]; }]; RACSignal*failedMessageSource = [[self.subscribeCommand.errors subscribeOn:[RACSchedulermainThreadScheduler]] map:^id(NSError *error) { return NSLocalizedString(@&quot;Error :(&quot;, nil); }]; RAC(self,statusMessage) = [RACSignal merge:@[startedMessageSource, completedMessageSource, failedMessageSource]]; } - (RACCommand *)subscribeCommand { if(!_subscribeCommand) { @weakify(self); _subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal signalBlock:^RACSignal *(id input) { @strongify(self); return [SubscribeViewModel postEmail:self.email]; }]; } return _subscribeCommand; } + (RACSignal *)postEmail:(NSString *)email{ AFHTTPRequestOperationManager*manager = [AFHTTPRequestOperationManager manager]; manager.requestSerializer= [AFJSONRequestSerializer new]; NSDictionary*body = @{@&quot;email&quot;: email ?: @&quot;&quot;}; return [[[manager rac_POST:kSubscribeURL parameters:body] logError] replayLazily]; } - (RACSignal *)emailValidSignal { if(!_emailValidSignal) { _emailValidSignal= [RACObserve(self, email) map:^id(NSString *email) { return@([email isValidEmail]); }]; } return _emailValidSignal; } @end 替换Delegate，直接使用RACSubjectRAC内存管理RAC会维护一个全局的信号集合，一个或多于一个订阅者就可用，所有订阅者都被移除了，信号就被释放了。 RAC需要注意的内存问题宏定义12345678910111213141516- (void)viewDidLoad{ [super viewDidLoad]; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { //1 MTModel *model = [[MTModel alloc] init]; // MTModel有一个名为的title的属性 [subscriber sendNext:model]; [subscriber sendCompleted]; return nil; }]; self.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) { //2 return RACObserve(model, title); }]; [self.flattenMapSignal subscribeNext:^(id x) { //3 NSLog(@&quot;subscribeNext - %@&quot;, x); }];} 上面的RACObserve会引起引用不释放的问题，通过RACObserve的定义来看看，里面会对self进行持有。 12345678#define RACObserve(TARGET, KEYPATH) \\ ({ \\ _Pragma(&quot;clang diagnostic push&quot;) \\ _Pragma(&quot;clang diagnostic ignored \\&quot;-Wreceiver-is-weak\\&quot;&quot;) \\ __weak id target_ = (TARGET); \\ [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\ _Pragma(&quot;clang diagnostic pop&quot;) \\ }) Subject对subject进行map这样的操作，这时就需要sendCompleted 1234567891011121314- (void)viewDidLoad { [super viewDidLoad]; RACSubject *subject = [RACSubject subject]; [subject.rac_willDeallocSignal subscribeCompleted:^{ NSLog(@&quot;subject dealloc&quot;); }]; [[subject map:^id(NSNumber *value) { return @([value integerValue] * 3); }] subscribeNext:^(id x) { NSLog(@&quot;next = %@&quot;, x); }]; [subject sendNext:@1]; } 但是为什么signal进行map操作，不sendCompleted而不会内存泄漏呢。因为调到bind的比如map、filter、merge、combineLatest、flattenMap等操作如果是RACSubject这样会持有订阅者的信号会产生内存泄漏需要sendCompleted。可以先看看bind的实现 1234567891011121314151617181920- (RACSignal *)bind:(RACStreamBindBlock (^)(void))block { NSCParameterAssert(block != NULL); /* * -bind: should: * * 1. Subscribe to the original signal of values. * 2. Any time the original signal sends a value, transform it using the binding block. * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they&apos;re received. * 4. If the binding block asks the bind to terminate, complete the _original_ signal. * 5. When _all_ signals complete, send completed to the subscriber. * * If any signal sends an error at any point, send that to the subscriber. */ return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) { RACStreamBindBlock bindingBlock = block(); NSMutableArray *signals = [NSMutableArray arrayWithObject:self]; // 此处省略了80行代码 // ... }] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];} didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号，也就是订阅者持有了信号，如果是Subject那么这种信号又会持有订阅者，这样就形成了循环引用。 下面看看sendCompleted如何修复的内存泄漏 12345678910111213void (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) { BOOL removeDisposable = NO; @synchronized (signals) { [signals removeObject:signal]; //1 if (signals.count == 0) { [subscriber sendCompleted]; //2 [compoundDisposable dispose]; //3 } else { removeDisposable = YES; } } if (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; //4}; 从signals这个数组中移除传入的signal，也就是让订阅的signal不会持有subject这种信号。 还有replay这样的操作，因为这个方法返回的是一个RACReplaySubject 12345678910111213RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { [subscriber sendNext:@1]; [subscriber sendCompleted]; // 保证源信号发送完成 return nil;}];RACSignal *replaySignal = [signal replay]; // 这里返回的其实是一个RACReplaySubject[[replaySignal map:^id(NSNumber *value) { return @([value integerValue] * 3);}] subscribeNext:^(id x) { NSLog(@&quot;subscribeNext - %@&quot;, x);}]; 热信号冷信号 热信号是主动的，不订阅也能够按时发送。冷信号是被动的，只有订阅才会发送。 热信号可以有多个订阅者。冷信号只能够一对一，有不同订阅者，消息会从新完整发送。 RAC的API手册常见类RACSiganl 信号类。 RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法； RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法； RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例； RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法； RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。 RACSubscriber 订阅者RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来； RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察； RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象 RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。 RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送 RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能； RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值； RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅 RACTuple 元组类,类似NSArray,用来包装值.RACSequence RAC中的集合类RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。RACScheduler RAC中的队列，用GCD封装的。 RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器； RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务； RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务； RACSubscriptionScheduler ：一个只用来调度订阅的调度器。 常见用法 rac_signalForSelector : 代替代理 rac_valuesAndChangesForKeyPath: KVO rac_signalForControlEvents:监听事件 rac_addObserverForName 代替通知 rac_textSignal：监听文本框文字改变 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。 常见宏 RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定 RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。 @weakify(Obj)和@strongify(Obj) RACTuplePack ：把数据包装成RACTuple（元组类） RACTupleUnpack：把RACTuple（元组类）解包成对应的数据 RACChannelTo 用于双向绑定的一个终端 常用操作方法 flattenMap map 用于把源信号内容映射成新的内容。 concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值 filter:过滤信号，使用它可以获取满足条件的信号. ignore:忽略完某些值的信号. distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 take:从开始一共取N次的信号 takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号. takeUntil:(RACSignal *):获取信号直到某个信号执行完成 skip:(NSUInteger):跳过几个信号,不接受。 switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 doNext: 执行Next之前，会先执行这个Block doCompleted: 执行sendCompleted之前，会先执行这个Block timeout：超时，可以让一个信号在一定的时间后，自动报错。 interval 定时：每隔一段时间发出信号 delay 延迟发送next。 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. replay重放：当一个信号被多次订阅,反复播放内容 throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 UI - Category（常用汇总）rac_prepareForReuseSignal： 需要复用时用 相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView rac_buttonClickedSignal：点击事件触发信号 相关UI：UIActionSheet、UIAlertView rac_command：button类、刷新类相关命令替换 相关UI：UIBarButtonItem、UIButton、UIRefreshControl rac_signalForControlEvents: control event 触发 相关UI：UIControl rac_gestureSignal UIGestureRecognizer 事件处理信号 相关UI：UIGestureRecognizer rac_imageSelectedSignal 选择图片的信号 相关UI：UIImagePickerController rac_textSignal 相关UI：UITextField、UITextView 可实现双向绑定的相关API rac_channelForControlEvents: key: nilValue: 相关UI：UIControl类 rac_newDateChannelWithNilValue: 相关UI：UIDatePicker rac_newSelectedSegmentIndexChannelWithNilValue: 相关UI：UISegmentedControl rac_newValueChannelWithNilValue: 相关UI：UISlider、UIStepper rac_newOnChannel 相关UI：UISwitch rac_newTextChannel 相关UI：UITextField Foundation - Category （常用汇总）NSData rac_readContentsOfURL: options: scheduler: 比oc多出线程设置 NSDictionary rac_sequence rac_keySequence key 集合 rac_valueSequence value 集合 NSArray rac_sequence 信号集合 NSFileHandle rac_readInBackground 后台线程读取 NSInvocation rac_setArgument: atIndex: 设置参数 rac_argumentAtIndex 取某个参数 rac_returnValue 所关联方法的返回值 NSNotificationCenter rac_addObserverForName: object:注册通知 NSObject rac_willDeallocSignal 对象销毁时发动的信号 rac_description debug用 rac_observeKeyPath: options: observer: block:监听某个事件 rac_liftSelector: withSignals: 全部信号都next在执行 rac_signalForSelector: 代替某个方法 rac_signalForSelector:(SEL)selector fromProtocol:代替代理 NSString rac_keyPathComponents 获取一个路径所有的部分 rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分 rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分 rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用 rac_sequence NSURLConnection rac_sendAsynchronousRequest 发起异步请求 NSUserDefaults rac_channelTerminalForKey 用于双向绑定，此乃一 NSEnumerator rac_sequence NSIndexSet rac_sequence NSOrderedSet rac_sequence NSSet rac_sequence RAC图片版的API手册ReactiveCocoa Objective-C ReactiveCocoa Swift RXSwift 本文参考整理自 ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1 ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2 iOS的函数响应型编程 https://www.gitbook.com/book/kevinhm/functionalreactiveprogrammingonios/details ReactiveCocoa Essentials: Understanding and Using RACCommand https://codeblog.shape.dk/blog/2013/12/05/reactivecocoa-essentials-understanding-and-using-raccommand/ iOS ReactiveCocoa 最全常用API整理（可做为手册查询）https://www.cocoachina.com/ios/20160729/17236.html ReactiveCocoa和RXSwift速查表 https://valiantcat.com/2016/07/22/ReactiveCocoa和RXSwift速查表/ ReactiveCocoa中潜在的内存泄漏及解决方案https://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html?from=timeline&amp;isappinstalled=0 ming1016","link":"/program//ios-han/"},{"title":"iOS开发内存泄露修复","text":"一：写在前面请使用ARC！！！ 如果使用的第三方库不支持ARC机制，可以在target-&gt;build phase-&gt;compile sources中选择对应的源码文件并在气候加入-fno-objc-arc标示，如下图所示：如果你的应用对内存泄露比较敏感(长时间运行或者耗费较多内存),或者你对代码有洁癖无法忍受半点内存泄露，而你又没有大把的时间和精力取修复那些虚无缥缈的泄漏点，那么ARC将是你最好的选择，因为修复泄露bug实在是太坑爹了…如果你不习惯ARC，又或者你使用的SDK版本根本不支持ARC，那么，请看下文。 二：修复方法好，言归正传。 按我个人理解，修复内存泄露可分为三个阶段： 第一阶段：编码好的编码习惯可以杜绝大部分的内存泄露，具体操作规范可参见我的另一篇博客iOS编程内存管理小结，这也是杜绝内存泄露的最关键阶段。在本阶段多花一些力气放在精确的内存管理上，你将会在调试阶段节省下大把的用于修复泄露的时间与精力。所谓：磨刀不误砍柴工！ 第二阶段：静态分析说白了，静态分析就是使用Xcode自带的Analyze功能（Product-&gt; Analyze），对代码进行静态分析，对于内存泄露（Potential Memory Leak）, 未使用局部变量(dead store)，逻辑错误(Logic Flaws)以及API使用问题(API-usage)等明确的展示出来，如下图所示：dead store比较好处理，将从未使用的变量删掉即可。 Memory Leak的提示其实也比较好办，因为其提示已经足够详细，具体到了具体泄露的代码行。找到问题对症下药即可, 忘记release 的加上release，该放autorelease的地方加上auto release。有一个情况需要特别说明一下，见下面所示代码： 1234567891011[cpp] view plaincopy&lt;span style=&quot;font-size:12px;&quot;&gt;if （self.dataMember == nil) { self.dataMember = [[NSArray alloc] init]; }&lt;/span&gt; ``` 这段代码在Analyze的时候也提示有内存泄露，开始我没看出来，后来才发现，等号右边的临时变量却是是泄露了的。正确的写法应该如下所示： [cpp] view plaincopy if (self.dataMember == nil) { self.dataMember = [[[NSArray alloc] init] autorelease]; 12//或者 NSArray* temp = [[NSArray alloc] init]; self.dataMember = temp; [temp release]; } 我比较倾向于第二种写法，到处autorelease对内存占用和性能肯定会有多多少少的影响的。 使用Analyze找到的内存泄露点基本还是准确的，但比较坑人的是Anayze并不能找出所用的泄露点，即使某些极为明显的泄露点使用Analyze也无法分析出来。这时就需要终极大杀器：Instruments登场了。 ### 第三阶段：动态分析 Instruments是Xcode自带的一个强大的应用分析工具，其功能并不局限于内存泄露的分析上，内存占用、CPU使用率等都是其分析的对象，有兴趣的筒子可以仔细研究研究，对提高应用的质量大有益处。 使用Instruments分析内存泄露时，最好使用真机进行调试，笔者就碰到过同一份代码在模拟器上分析有泄露而实体机上就没有的情况，看来不同的CPU架构(x86 vs ARM)对内存的管理还是有一定影响的。 连接实体机到开发机，选择选择运行设备为设备，点击Products-&gt; Profile，经过编译后，会弹出如下对话框： ![](/post-images/1560760181109.png) 双击Leak, 进入如下界面： ![](/post-images/1560760207240.png) 上面的蓝色条状部分是内存占用情况，而下面的便是内存泄露情况，当下面的状态栏出现粉色条状物体时，恭喜你，泄露出现了... ![](/post-images/1560760246640.png) 如果运气比较好的话，下面的提示区域会明确的告诉你那个文件哪个函数有泄露出现，但...很多情况下，出现的只是下面这种无厘头的提示： ![](/post-images/1560760276890.png) 这是要闹那样... 当然，上面图中所示的为5.1.1系统中的一个bug，在tableview滚动的过程中会出现一些莫名其妙的泄露点，同样的代码在5.0.1中并不会出现上面的泄露问题。 但这种很难找到泄露根源的问题会很多，寻找这些问题需要耗费大量的时间与精力。 修复泄露有下面两种处理方法： A: 对于那些非常明显的提示，很简单，按图索骥，根据提示的代码文件函数和泄露的对象类型判断泄露类型进行修复。 B: 对于那些不是很明显的提示，例如提示的泄漏点是一个第三方的库或者某个lib，那么这时就需要回忆一下刚才什么操作之后导致了泄露，然后找到与刚刚的操作相关的代码，在分析泄露的类型，例如是NSString或者NSArray，根据泄露的数据类型来推测具体泄露的代码段。这需要那么一点点的灵感和运气... ## 三：总结 以我亲身精力来说，调泄露是很烦的一件事，花在上面的时间可能要比你预想的多得多。 所以，正如前面提到的，要么在编码过程中提高内存控制的精确性，要么就一劳永逸，直接使用ARC，要泄露去屎吧！","link":"/program//ios-neicun/"},{"title":"避免使用 GCD Global队列创建Runloop常驻线程","text":"本文对应 Demo 以及 Markdown 文件在仓库中，文中的错误可以提 PR 到这个文件，我会及时更改。 目录 避免使用 GCD Global队列创建Runloop常驻线程 GCD Global队列创建线程进行耗时操作的风险 避免使用 GCD Global 队列创建 Runloop 常驻线程 单一 Runloop 常驻线程 多个 Runloop 常驻线程 GCD Global队列创建线程进行耗时操作的风险先思考下如下几个问题： 新建线程的方式有哪些？各自的优缺点是什么？ dispatch_async 函数分发到全局队列一定会新建线程执行任务么？ 如果全局队列对应的线程池如果满了，后续的派发的任务会怎么处置？有什么风险？ 答案大致是这样的：dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层有一个的线程池，如果线程池满了，那么后续的任务会被 block 住，等待前面的任务执行完成，才会继续执行。如果线程池中的线程长时间不结束，后续堆积的任务会越来越多，此时就会存在 APP crash的风险。 比如： 12345678910111213- (void)dispatchTest1 { for (NSInteger i = 0; i&lt; 10000 ; i++) {dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [self dispatchTask:i]; }); }}- (void)dispatchTask:(NSInteger)index { //模拟耗时操作，比如DB,网络，文件读写等等 sleep(30); NSLog(@&quot;----:%ld&quot;,index);} 以上逻辑用真机测试会有卡死的几率，并非每次都会发生，但多尝试几次就会复现，伴随前后台切换，crash几率增大。 下面做一下分析： 参看 GCD 源码我们可以看到全局队列的相关源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 DISPATCH_NOINLINEstatic void_dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n){ dispatch_root_queue_context_t qc = dq-&gt;do_ctxt; uint32_t i = n; int r; _dispatch_debug_root_queue(dq, __func__); dispatch_once_f(&amp;_dispatch_root_queues_pred, NULL, _dispatch_root_queues_init);#if HAVE_PTHREAD_WORKQUEUES#if DISPATCH_USE_PTHREAD_POOL if (qc-&gt;dgq_kworkqueue != (void*)(~0ul))#endif { _dispatch_root_queue_debug(\"requesting new worker thread for global \" \"queue: %p\", dq);#if DISPATCH_USE_LEGACY_WORKQUEUE_FALLBACK if (qc-&gt;dgq_kworkqueue) { pthread_workitem_handle_t wh; unsigned int gen_cnt; do { r = pthread_workqueue_additem_np(qc-&gt;dgq_kworkqueue, _dispatch_worker_thread4, dq, &amp;wh, &amp;gen_cnt); (void)dispatch_assume_zero(r); } while (--i); return; }#endif // DISPATCH_USE_LEGACY_WORKQUEUE_FALLBACK#if HAVE_PTHREAD_WORKQUEUE_SETDISPATCH_NP if (!dq-&gt;dq_priority) { r = pthread_workqueue_addthreads_np(qc-&gt;dgq_wq_priority, qc-&gt;dgq_wq_options, (int)i); (void)dispatch_assume_zero(r); return; }#endif#if HAVE_PTHREAD_WORKQUEUE_QOS r = _pthread_workqueue_addthreads((int)i, dq-&gt;dq_priority); (void)dispatch_assume_zero(r);#endif return; }#endif // HAVE_PTHREAD_WORKQUEUES#if DISPATCH_USE_PTHREAD_POOL dispatch_pthread_root_queue_context_t pqc = qc-&gt;dgq_ctxt; if (fastpath(pqc-&gt;dpq_thread_mediator.do_vtable)) { while (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) { if (!--i) { return; } } } uint32_t j, t_count; // seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt; t_count = dispatch_atomic_load2o(qc, dgq_thread_pool_size, seq_cst); do { if (!t_count) { _dispatch_root_queue_debug(\"pthread pool is full for root queue: \" \"%p\", dq); return; } j = i &gt; t_count ? t_count : i; } while (!dispatch_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count, t_count - j, &amp;t_count, acquire)); pthread_attr_t *attr = &amp;pqc-&gt;dpq_thread_attr; pthread_t tid, *pthr = &amp;tid;#if DISPATCH_ENABLE_PTHREAD_ROOT_QUEUES if (slowpath(dq == &amp;_dispatch_mgr_root_queue)) { pthr = _dispatch_mgr_root_queue_init(); }#endif do { _dispatch_retain(dq); while ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) { if (r != EAGAIN) { (void)dispatch_assume_zero(r); } _dispatch_temporary_resource_shortage(); } } while (--j);#endif // DISPATCH_USE_PTHREAD_POOL} 对于执行的任务来说，所执行的线程具体是哪个线程，则是通过 GCD 的线程池（Thread Pool）来进行调度，正如Concurrent Programming: APIs and Challenges文章里给的示意图所示： 上面贴的源码，我们关注如下的部分： 其中有一个用来记录线程池大小的字段 dgq_thread_pool_size。这个字段标记着GCD线程池的大小。摘录上面源码的一部分： 123456789101112 uint32_t j, t_count;// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;t_count = dispatch_atomic_load2o(qc, dgq_thread_pool_size, seq_cst);do { if (!t_count) { _dispatch_root_queue_debug(\"pthread pool is full for root queue: \" \"%p\", dq); return; } j = i &gt; t_count ? t_count : i;} while (!dispatch_atomic_cmpxchgvw2o(qc, dgq_thread_pool_size, t_count, t_count - j, &amp;t_count, acquire)); 从源码中我们可以对应到官方文档 ：Getting the Global Concurrent Dispatch Queues里的说法： A concurrent dispatch queue is useful when you have multiple tasks that can run in parallel. A concurrent queue is still a queue in that it dequeues tasks in a first-in, first-out order; however, a concurrent queue may dequeue additional tasks before any previous tasks finish. The actual number of tasks executed by a concurrent queue at any given moment is variable and can change dynamically as conditions in your application change. Many factors affect the number of tasks executed by the concurrent queues, including the number of available cores, the amount of work being done by other processes, and the number and priority of tasks in other serial dispatch queues. 也就是说： 全局队列的底层是一个线程池，向全局队列中提交的 block，都会被放到这个线程池中执行，如果线程池已满，后续再提交 block 就不会再重新创建线程。这就是为什么 Demo 会造成卡顿甚至冻屏的原因。 避免使用 GCD Global 队列创建 Runloop 常驻线程在做网路请求时我们常常创建一个 Runloop 常驻线程用来接收、响应后续的服务端回执，比如NSURLConnection、AFNetworking等等，我们可以称这种线程为 Runloop 常驻线程。 正如上文所述，用 GCD Global 队列创建线程进行耗时操作是存在风险的。那么我们可以试想下，如果这个耗时操作变成了 runloop 常驻线程，会是什么结果？下面做一下分析： 先介绍下 Runloop 常驻线程的原理，在开发中一般有两种用法： 单一 Runloop 常驻线程：在 APP 的生命周期中开启了唯一的常驻线程来进行网络请求，常用于网络库，或者有维持长连接需求的库，比如： AFNetworking 、 SocketRocket。 多个 Runloop 常驻线程：每进行一次网络请求就开启一条 Runloop 常驻线程，这条线程的生命周期的起点是网络请求开始，终点是网络请求结束，或者网络请求超时。 单一 Runloop 常驻线程先说第一种用法： 以 AFNetworking 为例，AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }} + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} 多个 Runloop 常驻线程第二种用法，我写了一个小 Demo 来模拟这种场景， 我们模拟了一个场景：假设所有的网络请求全部超时，或者服务端根本不响应，然后网络库超时检测机制的做法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &quot;Foo.h&quot;@interface Foo() { NSRunLoop *_runloop; NSTimer *_timeoutTimer; NSTimeInterval _timeoutInterval; dispatch_semaphore_t _sem;}@end@implementation Foo- (instancetype)init { if (!(self = [super init])) { return nil; } _timeoutInterval = 1 ; _sem = dispatch_semaphore_create(0); // Do any additional setup after loading the view, typically from a nib. return self;}- (id)test { // 第一种方式： // NSThread *networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint0:) object:nil]; // [networkRequestThread start]; //第二种方式: dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) { [self networkRequestThreadEntryPoint0:nil]; }); dispatch_semaphore_wait(_sem, DISPATCH_TIME_FOREVER); return @(YES);}- (void)networkRequestThreadEntryPoint0:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;CYLTest&quot;]; _runloop = [NSRunLoop currentRunLoop]; [_runloop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; _timeoutTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(stopLoop) userInfo:nil repeats:NO]; [_runloop addTimer:_timeoutTimer forMode:NSRunLoopCommonModes]; [_runloop run];//在实际开发中最好使用这种方式来确保能runloop退出，做双重的保障[runloop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:(timeoutInterval+5)]]; }}- (void)stopLoop { CFRunLoopStop([_runloop getCFRunLoop]); dispatch_semaphore_signal(_sem);}@end 如果 123456for (int i = 0; i &lt; 300 ; i++) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(void) { [[Foo new] test]; NSLog(@&quot;🔴类名与方法名：%@（在第%@行），描述：%@&quot;, @(__PRETTY_FUNCTION__), @(__LINE__), @&quot;&quot;); }); } 以上逻辑用真机测试会有卡死的几率，并非每次都会发生，但多尝试几次就会复现，伴随前后台切换，crash几率增大。 其中我们采用了 GCD 全局队列的方式来创建常驻线程，因为在创建时可能已经出现了全局队列的线程池满了的情况，所以 GCD 派发的任务，无法执行，而且我们把超时检测的逻辑放进了这个任务中，所以导致的情况就是，有很多任务的超时检测功能失效了。此时就只能依赖于服务端响应来结束该任务（服务端响应能结束该任务的逻辑在 Demo 中未给出），但是如果再加之服务端不响应，那么任务就永远不会结束。后续的网络请求也会就此 block 住，造成 crash。 如果我们把 GCD 全局队列换成 NSThread 的方式，那么就可以保证每次都会创建新的线程。 注意：文章中只演示的是超时 cancel runloop 的操作，实际项目中一定有其他主动 cancel runloop 的操作，就比如网络请求成功或失败后需要进行cancel操作。代码中没有展示网络请求成功或失败后的 cancel 操作。 Demo 的这种模拟可能比较极端，但是如果你维护的是一个像 AFNetworking 这样的一个网络库，你会放心把创建常驻线程这样的操作交给 GCD 全局队列吗？因为整个 APP 是在共享一个全局队列的线程池，那么如果 APP 把线程池沾满了，甚至线程池长时间占满且不结束，那么 AFNetworking 就自然不能再执行任务了，所以我们看到，即使是只会创建一条常驻线程， AFNetworking 依然采用了 NSThread 的方式而非 GCD 全局队列这种方式。 注释：以下方法存在于老版本AFN 2.x 中。 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }} + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} 正如你所看到的，没有任何一个库会用 GCD 全局队列来创建常驻线程，而你也应该 避免使用 GCD Global 队列来创建 Runloop 常驻线程。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//GCD-Global/"},{"title":"iOS界面元素指南","text":"","link":"/program//ios-zhinan/"},{"title":"iOS计算App缓存的大小以及清理","text":"一、计算缓存1234567891011121314151617181920212223// 缓存大小- (CGFloat)folderSize{ CGFloat folderSize; //获取路径 NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES)firstObject]; //获取所有文件的数组 NSArray *files = [[NSFileManager defaultManager] subpathsAtPath:cachePath]; NSLog(@&quot;文件数：%ld&quot;,files.count); for(NSString *path in files) { NSString*filePath = [cachePath stringByAppendingString:[NSString stringWithFormat:@&quot;/%@&quot;,path]]; //累加 folderSize += [[NSFileManager defaultManager]attributesOfItemAtPath:filePath error:nil].fileSize; } //转换为M为单位 CGFloat sizeM = folderSize /1024.0/1024.0; return sizeM;} 二、清除缓存12345678910111213141516171819202122232425262728- (void)removeCache{ //===============清除缓存============== //获取路径 NSString*cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES)objectAtIndex:0]; //返回路径中的文件数组 NSArray*files = [[NSFileManager defaultManager]subpathsAtPath:cachePath]; NSLog(@&quot;文件数：%ld&quot;,[files count]); for(NSString *p in files){ NSError*error; NSString*path = [cachePath stringByAppendingString:[NSString stringWithFormat:@&quot;/%@&quot;,p]]; if([[NSFileManager defaultManager]fileExistsAtPath:path]) { BOOL isRemove = [[NSFileManager defaultManager]removeItemAtPath:path error:&amp;error]; if(isRemove) { NSLog(@&quot;清除成功&quot;); //这里发送一个通知给外界，外界接收通知，可以做一些操作（比如UIAlertViewController） }else{ NSLog(@&quot;清除失败&quot;); } } }}","link":"/program//ioshuancun/"},{"title":"iOS 友盟分享笔记","text":"1.下载友盟分享SDK2.将 UMSocial 文件拖入工程 (注:根据你需要分享的平台来添加，UMSocial -&gt; SocialLibraries 删除你不需要的平台，否则很占包体积,比如我只需要 QQ，Sina，WeChat)3.添加配置项目 Build Setting -&gt; Lingking -&gt; Other Linker Flags -ObjC ！！！如果没有设置，所有环境配置好之后，点击分享，UMShareUI 弹出的将没有平台头像配置依赖库 1234561) SystemConfiguration.framework CoreTelephony.framework ImageIO.framework libsqlite3.tbd libz.tbd libc++.tbd 4.设置ATS 找到Info.plist 右键，OpenAs SourceCode 添加一下(分别是，QQ，微信，微博)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;renren.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;sina.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.0&lt;/string&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;sina.com.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;sinaimg.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;sinajs.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;weibo.cn&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.0&lt;/string&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;weibo.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.0&lt;/string&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSThirdPartyExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 5.设置URLType 找到Info.plist 右键，OpenAs SourceCode 添加一下(分别是，QQ，微信，微博) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;key&gt;CFBundleURLTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLName&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;wb3921700954&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLName&lt;/key&gt; &lt;string&gt;weixin&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;wxdc1e388c3822c80b&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;tencent1105860513&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;QQ0x41EA17A1&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeRole&lt;/key&gt; &lt;string&gt;Editor&lt;/string&gt; &lt;key&gt;CFBundleURLSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;wendu.dsbridgedemo&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; 6.设置URLType 找到Info.plist 右键，OpenAs SourceCode 添加一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;linkedin&lt;/string&gt; &lt;string&gt;linkedin-sdk2&lt;/string&gt; &lt;string&gt;linkedin-sdk&lt;/string&gt; &lt;string&gt;wechat&lt;/string&gt; &lt;string&gt;weixin&lt;/string&gt; &lt;string&gt;sinaweibohd&lt;/string&gt; &lt;string&gt;sinaweibo&lt;/string&gt; &lt;string&gt;sinaweibosso&lt;/string&gt; &lt;string&gt;weibosdk&lt;/string&gt; &lt;string&gt;weibosdk2.5&lt;/string&gt; &lt;string&gt;mqqapi&lt;/string&gt; &lt;string&gt;mqq&lt;/string&gt; &lt;string&gt;mqqOpensdkSSoLogin&lt;/string&gt; &lt;string&gt;mqqconnect&lt;/string&gt; &lt;string&gt;mqqopensdkdataline&lt;/string&gt; &lt;string&gt;mqqopensdkgrouptribeshare&lt;/string&gt; &lt;string&gt;mqqopensdkfriend&lt;/string&gt; &lt;string&gt;mqqopensdkapi&lt;/string&gt; &lt;string&gt;mqqopensdkapiV2&lt;/string&gt; &lt;string&gt;mqqopensdkapiV3&lt;/string&gt; &lt;string&gt;mqqopensdkapiV4&lt;/string&gt; &lt;string&gt;mqzoneopensdk&lt;/string&gt; &lt;string&gt;wtloginmqq&lt;/string&gt; &lt;string&gt;wtloginmqq2&lt;/string&gt; &lt;string&gt;mqqwpa&lt;/string&gt; &lt;string&gt;mqzone&lt;/string&gt; &lt;string&gt;mqzonev2&lt;/string&gt; &lt;string&gt;mqzoneshare&lt;/string&gt; &lt;string&gt;wtloginqzone&lt;/string&gt; &lt;string&gt;mqzonewx&lt;/string&gt; &lt;string&gt;mqzoneopensdkapiV2&lt;/string&gt; &lt;string&gt;mqzoneopensdkapi19&lt;/string&gt; &lt;string&gt;mqzoneopensdkapi&lt;/string&gt; &lt;string&gt;mqqbrowser&lt;/string&gt; &lt;string&gt;mttbrowser&lt;/string&gt; &lt;string&gt;TencentWeibo&lt;/string&gt; &lt;string&gt;tencentweiboSdkv2&lt;/string&gt; &lt;string&gt;alipay&lt;/string&gt; &lt;string&gt;alipayshare&lt;/string&gt; &lt;string&gt;renrenios&lt;/string&gt; &lt;string&gt;renrenapi&lt;/string&gt; &lt;string&gt;renren&lt;/string&gt; &lt;string&gt;renreniphone&lt;/string&gt; &lt;string&gt;laiwangsso&lt;/string&gt; &lt;string&gt;yixin&lt;/string&gt; &lt;string&gt;yixinopenapi&lt;/string&gt; &lt;string&gt;yixinoauth&lt;/string&gt; &lt;string&gt;yixinfav&lt;/string&gt; &lt;string&gt;laiwangsso&lt;/string&gt; &lt;string&gt;instagram&lt;/string&gt; &lt;string&gt;whatsapp&lt;/string&gt; &lt;string&gt;line&lt;/string&gt; &lt;string&gt;tumblr&lt;/string&gt; &lt;string&gt;fbapi&lt;/string&gt; &lt;string&gt;fb-messenger-api&lt;/string&gt; &lt;string&gt;fbauth2&lt;/string&gt; &lt;string&gt;fbshareextension&lt;/string&gt; &lt;string&gt;kakao6d5e4ca98ba3b944020c2c90953318e9&lt;/string&gt; &lt;string&gt;kakaokompassauth&lt;/string&gt; &lt;string&gt;storykompassauth&lt;/string&gt; &lt;string&gt;kakaolink&lt;/string&gt; &lt;string&gt;kakaotalk-4.5.0&lt;/string&gt; &lt;string&gt;kakaostory-2.9.0&lt;/string&gt; &lt;string&gt;pinterestsdk.v1&lt;/string&gt; &lt;string&gt;dingtalk&lt;/string&gt; &lt;string&gt;dingtalk-open&lt;/string&gt; &lt;string&gt;evernote&lt;/string&gt; &lt;string&gt;en&lt;/string&gt; &lt;string&gt;enx&lt;/string&gt; &lt;string&gt;evernotecid&lt;/string&gt; &lt;string&gt;evernotemsg&lt;/string&gt; &lt;string&gt;youdaonote&lt;/string&gt; &lt;string&gt;ynotedictfav&lt;/string&gt; &lt;string&gt;com.youdao.note.todayViewNote&lt;/string&gt; &lt;string&gt;ynotesharesdk&lt;/string&gt; &lt;string&gt;gplus&lt;/string&gt; &lt;string&gt;pocket&lt;/string&gt; &lt;string&gt;readitlater&lt;/string&gt; &lt;string&gt;pocket-oauth-v1&lt;/string&gt; &lt;string&gt;fb131450656879143&lt;/string&gt; &lt;string&gt;en-readitlater-5776&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterPro3&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterPro&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterProAlpha&lt;/string&gt; &lt;string&gt;com.ideashower.ReadItLaterProEnterprise&lt;/string&gt; &lt;string&gt;vk&lt;/string&gt; &lt;string&gt;vk-share&lt;/string&gt; &lt;string&gt;vkauthorize&lt;/string&gt; &lt;/array&gt; 接下来可以快乐的commond + b 了初始化 在Appdelegate.m中 ，导入头文件#import &lt;UMSocialCore/UMSocialCore.h&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//建议抽成一个单独的方法，别在一个函数里面执行太多的东西- (void)initUMShareSdk{ //打开日志 [[UMSocialManager defaultManager] openLog:YES]; // 打开图片水印 //[UMSocialGlobal shareInstance].isUsingWaterMark = YES; // 获取友盟social版本号 UMSocialLogInfo(@&quot;UMeng social version: %@&quot;, [UMSocialGlobal umSocialSDKVersion]); //设置友盟appkey [[UMSocialManager defaultManager] setUmSocialAppkey:@“your UMKey”]; //设置微信的appKey和appSecret [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_WechatSession appKey:@&quot;wxdc1e388c3822c80b&quot; appSecret:@&quot;3baf1193c85774b3fd9d18447d76cab0&quot; redirectURL:@&quot;https://zhonfan.com&quot;]; /* * 添加某一平台会加入平台下所有分享渠道，如微信：好友、朋友圈、收藏，QQ：QQ和QQ空间 * 以下接口可移除相应平台类型的分享，如微信收藏，对应类型可在枚举中查找 */ //[[UMSocialManager defaultManager] removePlatformProviderWithPlatformTypes:@[@(UMSocialPlatformType_WechatFavorite)]]; // 设置分享到QQ互联的appID // U-Share SDK为了兼容大部分平台命名，统一用appKey和appSecret进行参数设置，而QQ平台仅需将appID作为U-Share的appKey参数传进即可。 [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_QQ appKey:@&quot;1105860513&quot;/*设置QQ平台的appID*/ appSecret:nil redirectURL:@&quot;https://zhonfan.com&quot;]; //设置新浪的appKey和appSecret [[UMSocialManager defaultManager] setPlaform:UMSocialPlatformType_Sina appKey:@&quot;3921700954&quot; appSecret:@&quot;04b48b094faeb16683c32669824ebdad&quot; redirectURL:@&quot;https://zhonfan.com&quot;];}//#define __IPHONE_10_0 100000#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; 100000- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey, id&gt; *)options{ BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url]; if (!result) { // 其他如支付等SDK的回调 } return result;}#endif- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation{ BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url]; if (!result) { // 其他如支付等SDK的回调 } return result;}- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url{ BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url]; if (!result) { // 其他如支付等SDK的回调 } return result;} OK AppDelegate设置完成，接下来是如何调用12345/** 分享 @param obj obj 可为本地图片(UIImage类型),网络图片,(NSString类型,因为只能上传https的图片，所以内部使用SDWebImageManager，SDWebImage第三方库的一个类，使用这类进行图片下载处理) */- (void)shareWithObj:(id)obj; 使用这个分类进行处理，建议以后遇到类似的，继承或者分类，隔离一下","link":"/program//iosyoumeng/"},{"title":"iOS静态库","text":"回顾下iOS静态库 【.a 和framework】 一、什么是库？库是共享程序代码的方式。 库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。iOS中的静态库有 .a 和 .framework两种形式；动态库有.dylib 和 .framework 形式，后来.dylib动态库又被苹果替换成.tbd的形式。 二、静态库与动态库的区别？静态库： 链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。 动态库： 链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。[ios暂时只允许使用系统动态库]； 静态库和动态库是相对编译期和运行期的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；而动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入，因为在程序运行期间还需要动态库的存在。总结：同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。 三、iOS里静态库形式？.a和.framework 四、iOS里动态库形式？.dylib和.framework 五、framework为什么既是静态库又是动态库？系统的.framework是动态库，我们自己建立的.framework是静态库。 六、a与.framework有什么区别？.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。 .a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。 .a + .h + sourceFile = .framework。 建议用.framework. 七、为什么要使用静态库？方便共享代码，便于合理使用。 实现iOS程序的模块化。可以把固定的业务模块化成静态库。 和别人分享你的代码库，但不想让别人看到你代码的实现。 开发第三方sdk的需要。 八、制作静态库时的几点注意：1注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。 2图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。 3category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。 4如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。 九、创建.a静态库第一步，新建工程。一般使用工程名就使用库的名称，比如我这里用LIB来创建静态库，我的工程名就取名为LIB，创建的.a静态库就是LIB.a。 第二步，删除.m文件，保留.h文件， 一般静态库都有一个总的.h文件，方便外部导入头文件。然后导入需要打包的源文件。 第三步，先用真机，编译一次，再用模拟器编译一次。就可以生成.a文件（必须先用真机要不然，不能生成）。 第四步，Xcode生成的.a文件默认没有导出.h文件。需要自己添加。 第五步，导出Products静态库的配置（其实不用设置此步骤，如果真机编译的话，生成导出的时候系统默认会变成Releasse[但是模拟器不会（如果不改这里 得需要把Debug设置为NO）]） 注意：如果第五步中，不将Build Configuration改为Release,则打包出来的静态库会存于【Debug-iphoneos】和【Debug-iphonesimulator】两个文件夹下。我们一般都使用Release模式，因为程序最终发布之后是Release版的，所以静态库也是在Release模式下使用。 第六步，合成模拟器的架构【默认：模拟器编译只会生成对应的1种架构，真机编译会合成两种架构】 如果第六步这里，设置为YES，那么编译出来的.a静态库就只包含当前设备的架构。 举个例子：如果我们选择iPhone 5模拟器【Command+B】编译，则编译出来的.a静态库只能用iPhone4s5模拟器跑程序， 用iPhone5s6plus，则会报找不到x86_64的libFMDB库。 设置为 NO 之后，【Command+B】不管选择哪个【模拟器】，则都会把【386 : 32位架构 4S ~ 5】【x86_64 : 64位架构 5S ~ 现在的机型】的架构都打包合并。 【注】【真机】不设置 [Build Active Architecture Only] 也默认会自动合并的armv7 和amr64架构 。但是 armv7s架构被苹果放弃了，真机要想合并armv7s的话需要进行如下操作再编译。（其实没必要设置这个） 第七步，合并架构【真机和模拟器】 真机和模拟器合并: lipo -create 静态库1.a（路径） 静态库2.a（路径） -output 新静态库.a 第八步，资源包的问题 静态库的资源, 都应该放到后缀为.bundle的文件夹中 –&gt; 避免文件与本地文件重名被覆盖, 导致加载资源文件出错【注：要加载bundel路径】 静态库打包时, 并不会打包资源文件 –&gt; 需要手动拖出去 一. 经典报错: 找不到符号在XX架构上 Undefined symbols for architecture x86_64(armv7/armv7s/amr64/i386) 二. 架构的分类 1、模拟器架构: 2种 i386 : 32位架构 4S ~ 5 x86_64 : 64位架构 5S ~ 现在的机型 2、真机架构: 3种 armv7 : 32位架构 3GS ~ 4S armv7s: 特殊的架构 5 ~ 5C (此架构有问题, 有的程序变得更快, 有的程序变得更慢) amr64 : 64位架构 5S ~ 现在的机型 64位/32位: 内存寻址不同 三. 如何查看静态库架构 找到Products文件夹, 如果.a文件是黑色, 右键打开 到 Products文件夹 终端中 lipo -info Generic iOS Device编译出来的OS可用, 有2种架构:armv7/ arm64 （不包含armv7s: 特殊的架构） iPhone6S模拟器编译出来的: x86_64 iPhone4S模拟器编译出来的: i386 (不设置Build Active Architecture Only的情况下真机编译2种架构, 模拟器编译:对应的1种架构) 四. 合成架构 一般来说, 只需要前两步即可 模拟器架构的合成: Target –&gt; Build Settings –&gt; Build Active Architecture Only(是否只编译当前架构) –&gt; Debug 改为NO(改为NO, 模拟器就可以直接合成2种架构) 真机和模拟器合并: lipo -create 静态库1.a 静态库2.a -output 新静态库.a armv7s这个架构, 在2014年10月份的xcode版本更新中, 取消了默认导出此架构. 可以不用支持此架构. 如果要支持, 需要手动添加3个架构. 五. Debug和Release版本 一般来说, 我们应该发布的是release版本. debug:调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢 release: 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉 六. 到底要不要合成多个架构 真机和模拟器合成的好处: 调试会非常方便, 缺点是体积会变大(一种架构就占用一部分体积). 真机和模拟器不合成的好处:体积小, 缺点是调试稍显麻烦. 七. 资源包的问题 静态库的资源, 都应该放到后缀为.bundle的文件夹中 –&gt; 避免文件重名被覆盖, 导致加载资源文件出错 静态库打包时, 并不会打包资源文件 –&gt; 需要手动拖出去 十、创建framework静态库第一步、新建工程。一般使用工程名就使用库的名称 第二步、导入需要打包的资源文件，同时把资源文件需要外界访问的.h文件导入到系统推荐的.h中 第三步、真机，模拟器编译一下。可能会需要输入AppleID 。导出的文件没有包含.h 第四步、导出.h 第五步、可以查看一下 没合并模拟器架构之前包含几个同.a（可跳过此步）(真机包含两个，模拟器包含一个) 第六步、合成架构【同.a五六步详细看上边】 第七步，合并架构【真机和模拟器】【注意 合并之后的动态/静态库要与原来的名称一致。不然用的时候编译报错】 第八步、动态库变静态库【默认是动态】好处是将来使用时不需要设置添加动态库（也就是下边的方法） 最后步、 Framework制作后, 默认是动态库. 使用时, 需要设置一下: Tarteg –&gt; General –&gt; Embedded Binaries –&gt; 需要添加对应的动态库 【注意 要是制作的时候更改为静态库的话，就不用执行此方法】 谢谢。 原文链接👇","link":"/program/apple/framework1/"},{"title":"UIMenuController","text":"","link":"/program//UIMenuController/"},{"title":"iPhone开发者选项","text":"iOS上的开发者选项，这个功能从iOS系统刚开始时就已经存在了。想要打开这个功能，我们需要满足一定的条件，首先你需要将iPhone和一台Mac电脑相连接，然后在Mac上打开Xcode开发工具，此时你iPhone的设置里就会出现“开发者”这个选项了。 步骤： 1、用数据线连接iPhone和mac2、打开xcode，选择Xcode -&gt; Windows-&gt;Devices ,如图：3、选择自己的手机，右键单击选择Show Provisioning Profiles…，如图：4、在弹窗中的列表中查看，是否有开发者证书，如果没有，就点击“+”，添加开发者证书，完成后点击“Done”。如图： 5、关闭窗口，查看手机“设置”中，“开发者”已经默默的躺在那里了。。。 iOS上的开发者选项完全是为软件开发者服务的 Instruments可以理解为是一个日志记录工具，可以记录下电量和网络的使用情况，利用Xcode可以导出这些日志。 Network Link Conditioner是模拟网络，可以让用户模拟不同的网络连接和带宽，可供Mac和iOS开发者测试自己的程序在不同网络环境下的表现。 还有其他选项像是IDA广告测试、广告刷新率测试、媒体服务测试、欧盟音量限制测试等内容。 援引 iPhone iOS9系统中 设置－&gt;开发者 对应的翻译 iPhone中如何打开“开发者”选项","link":"/program//iphone/"},{"title":"深入剖析-JavaScriptCore","text":"前言最近开始涉及 JS 的解析和处理工作，所以专门研究了下这块。特别是动态类型的处理以及不同引擎对于平台无关的字节码的设计和处理会有很大的帮助。 JavaScriptCore 介绍JavaScriptCore 是 JavaScript 引擎，通常会被叫做虚拟机，专门设计来解释和执行 JavaScript 代码。最开始的 JavaScriptCore 是从 KJS（KDE 的 JavaScript 引擎）以及 PCRE 正则表达式的基础上开发的，是基于抽象语法树的解释器。2008 年重写了，叫做 SquirrelFish，后来是 SquirrelFish Extreme，又叫 Nitro。目前 JavaScript 引擎还有 Google 的 V8 ，Mozilla 的 SpiderMonkey。 JavaScriptCore 还能够在 Objective-C 程序中来执行 JavaScript 的代码，也可以在 JavaScript 环境中插入自定义对象。 JavaScriptCore 全貌下面是解析 JavaScript 源码解析编译的详细流程图： 主要模块 Lexer：词法分析器，生成 tokens，大部分代码都在 parser/Lexer.cpp 里。 Parser：语法分析，基于 Lexer 的 tokens 生成语法树。手写了个 recusive descent parser 递归下降解析器，代码主要在 parser/Parser.cpp 里。 LLInt：Low Level Interpreter 执行 Parser 生成的 Byte code。代码在 llint/ 里，使用汇编，在 offlineasm/ 里，可以编译为 x86 和 ARMv7 的汇编和 C 代码。LLInt 希望达成除了词法和语法分析外零启动消耗，同时遵守用 JIT 在调用，堆栈和起存器的约定。 Baseline JIT：实时编译，性能不好用这个。在函数调用了 6 次，或者某段代码循环了大于100次会被触发。BaseLine JIT 的代码在 jit/ 里。BaseLine JIT 还对几乎所有堆的访问执行了复杂的多态内联高速缓存（Polymorphic inline caches）。多态内联缓存是 Smalltalk 社区优化动态分发的一个经典技术。 DFG JIT：低延迟优化 JIT，更差性能就用这个生成更优化的机器码来执行。在函数被调用了60次或者代码循环了1000次会触发。在 LLInt 和 Baseline JIT 中会收集一些包括最近参数，堆以及返回值中的数据等轻量级的性能信息，方便 DFG 进行类型判断。先获取类型信息可以减少大量的类型检查，推测失败 DFG 会取消优化，也叫 OSR exit。取消可以是同步的也可以是异步的。取消后会回到 Baseline JIT，退回一定次数会进行重新优化，收集更多统计信息，看情况再次调用 DFG。重新优化使用的是指数式回退策略应对一些怪异的代码。DFG 代码在 dfg/ 里。 FTL：高吞吐量优化 JIT，全称 Faster Than Light，DFG 高层优化配合 B3 底层优化。以前全称是 Fourth Tier LLVM 底层优化使用的是 LLVM。B3 对 LLVM 做了裁剪，对 JavaScriptCore 做了特性处理，B3 IR 的接口和 LLVM IR 很类似。B3 对 LLVM 的替换主要是考虑减少内存开销，LLVM 主要是针对编译器，编译器在这方面优化动力必然没有 JIT 需求高。B3 IR 将指针改成了更紧凑的整数来表示引用关系。不可变的常用的信息使用固定大小的结构来表示，其它的都放到另外的地方。紧凑的数据放到数组中，更多的数组更少的链表。这样形成的 IR 更省内存。Filip Pizlo 主导的这个改动，DFG JIT 也是他弄的，为了能够更多的减少内存上的开销，他利用在 DFG 里已经做的 InsertionSet 将 LLVM IR 里的 def-use 干掉了，大概思路是把单向链表里批量插入新 IR 节点先放到 InsertionSet 里，在下次遍历 IR 时再批量插入。Filip Pizlo 还把 DFG 里的 UpsilonValue 替代 LLVM SSA 组成部分。B3 后面会把 LLVM 的寄存器分配算法 Greedy 一直到 B3 中。 执行速度的对比：相对速度，越高表示越好。 更多的说明可以参看 WebKit 官网 JavaScriptCore 的 Wiki 首页部分：https://trac.webkit.org/wiki/JavaScriptCore 主要的源码目录结构 API：JavaScriptCore 对外的接口类 assembler：不同 CPU 的汇编生成，比如 ARM 和 X86 b3：ftl 里的 Backend bytecode：字节码的内容，比如类型和计算过程 bytecompiler：编译字节码 Configurations：Xcode 的相关配置 Debugger：用于测试脚本的程序 dfg：DFG JIT 编译器 disassembler：反汇编 heap：运行时的堆和垃圾回收机制 ftl：第四层编译 interpreter：解释器，负责解析执行 ByteCode jit：在运行时将 ByteCode 转成机器码，动态及时编译。 llint：Low Level Interpreter，编译四层里的第一层，负责解释执行低效字节码 parser：词法语法分析，构建语法树 profiler：信息收集，能收集函数调用频率和消耗时间。 runtime：运行时对于 js 的全套操作。 wasm：对 WebAssembly 的实现。 yarr：Yet Another Regex Runtime，运行时正则表达式的解析 JavaScriptCore 与 WebCoreScriptController 会调用 JavaScriptCore 的 evaluate 和 checkSyntax 两个接口。DOM 节点的 JSBindings 通过回溯到 JSC::JSNonFinalObject 实现和 JavaScriptCore 的绑定。 VM 是 JavaScript 的 Runtime 环境。GlobalObject 是全剧对象，负责管理执行环境和 Object 的。ExecState 是执行脚本的对象，由 GlobalObject 管理的，负责记录脚本执行上下文。 接口执行脚本，创建一个 ProgramExecutable 对象来表示要执行的脚本负责编译成 ByteCode，调用 Interpreter 执行这个 ByteCode。 Binding 是 WebCore 为 JavaScriptCore 提供的封装层。这一层的定义可以在这里找到：https://trac.webkit.org/wiki/WebKitIDL。WebKit 参照的是 W3C Web IDL https://www.w3.org/TR/WebIDL-1/。 使用 IDL 定义接口规范，WebKit 使用一组 perl 脚本来转换 IDL，初始脚本是 generate-binding.pl。生成接口与 DOM 组件关联是通过 JSNode 来的。执行脚本和 Frame 的 setDocument 会更新 document 对象到 JavaScriptCore，通过 JSDomWindowBase::updateDocument 更新到 JSC::Heap 里。 词法语法分析词法和语法分析程序 JavaScriptCore 是自己编写的。词法分析会把文本理解成很多 token，比如 a = 5; 就会被识别成下面这些 token，VARIABLE EQUAL CONSTANT END。然后通过语法分析，输出语法树。 需要先设计好 Node，Node 的类关系图如下：举个包含加和乘的 statement 是如何组成 AST 的 1o.x * o.x + o.y * o.y heap 代表的是可见数据，pure 代表的是抽象说明。 下面看看 Object 的构造 1234var o = new Object();o.f = 1;o.g = 2;o.h = 3; 接下来看看 function 的 123456function foo(o) { if (o.f &amp;&amp; o.f() == 42) print(&quot;hello&quot;); if (o.g &amp;&amp; o.g() == 63) print(&quot;bye&quot;);} 还有些其它的 parser 比如 Esprima 提供了一个在线 demo 可以在线 Parser。实现的代码在这里：https://github.com/jquery/esprima/tree/master/src 主要使用的是递归下降和运算符优先级混合式来做的 parser。 我在 HTN （https://github.com/ming1016/HTN）项目中做了个 js 的 AST 的 builder：https://github.com/ming1016/HTN/tree/master/Sources/Core/JavaScript 分词和语法树生成使用的是状态机处理递归下降。 WebKit 的性能目录里有用 ES6 标准实现的 ECMA-55 BASIC 这个词法语法分析的测试。代码在：https://trac.webkit.org/browser/trunk/PerformanceTests/ARES-6/Basic?rev=211697 程序会被表示成树，每个节点都有与其相关的代码，这些代码都可以递归的调用树中的子节点。Basic 的节点的结构是这样子的： 1{evaluate: Basic.NumberPow, left: primary, right: parsePrimary()} Basic 是以不那么常见的方式使用生成器的，比如多个生成器函数，很多 yield points 和递归生成器调用。Basic 也有 for-of，类，Map 和 WeakMap。所以上的测试 ES6 程序通过 js 写的程序帮助理解 ES6 的解析过程。 代码到 JIT 的过程ProgramExecutable 的初始化会生成 Lexer，Parser 和字节码。入口是从 JS Binding 那层里调用 ScriptController::evaluateInWorld 进来，这个方法里的参数 sourceCode 就是 js 的代码的来源，方法内通过调用 runtime/Completion.cpp 里的方法 evaluate 来进入 executeProgram 方法的。总的来说 ProgramExecutable 主要是把代码编成字节码，Interpreter 是来执行字节码的。 1JSValue result = vm.interpreter-&gt;executeProgram(source, exec, thisObj); executeProgram 方法将源码生成 ProgramExecutable 这个对象。 1ProgramExecutable* program = ProgramExecutable::create(callFrame, source); 这个对象里有 StringView 对象，program-&gt;source().view() 这样就可以对源码进行操作了。在那之前会先判断下是否这段 js 代码仅仅只是一个 JSON 对象，如果是就地按照 JSON 对象处理，不然就按照普通的 js 代码来处理。 普通处理会先编译成字节码，过程是先初始化全局属性： 1JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope); 处理的结果都会记录在 callFrame 里。主要是通过 JSGlobalObject 这个对象的 addFunction 和 addVar 方法记录 Parser 出那些在全局空间的那些 let，const 和 class 的全局属性，或者 var，let 和 const 的全局变量。 接下来会创建一个 codeBlock： 123456789ProgramCodeBlock* codeBlock; { CodeBlock* tempCodeBlock; JSObject* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock); EXCEPTION_ASSERT(throwScope.exception() == reinterpret_cast&lt;Exception*&gt;(error)); if (UNLIKELY(error)) return checkedReturn(error); codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock); } 这里 ProgramExecutable 会通过 prepareForExecution 方法里调用 prepareForExecutionImpl 来创建一个新的 CodeBlock。 123456789101112131415CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);resultCodeBlock = codeBlock;EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);if (UNLIKELY(!codeBlock)) return exception;if (Options::validateBytecode()) codeBlock-&gt;validate();if (Options::useLLInt()) setupLLInt(vm, codeBlock);else setupJIT(vm, codeBlock);installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind()); 这里看到，如果 Options 是指定 LLInt 的话就会调 setupLLInt 方法去设置这个 codeBlock，不然就通过 JIT 来。LLInt 在 LLIntSlowPaths.cpp 里通过 C 函数封装了 LowLevelInterpreter.asm 里的执行指令的汇编。触发 JIT 优化是通过热点探测方法，LLInt 会在字节码的 loop_hint 循环计数和 ret 函数返回指令的时候进行统计，结果保存在 ExcutionCounter 里。当函数或循环体执行一定次数时，通过 checkIfThresholdCrossedAndSet 方法得到布尔值结果来决定是否用 JIT 编译。 CodeBlock 有 GlobalCode，EvalCode，FunctionCode，ModuleCode 这些类型，用于 LLInt 和 JIT。编译后的 ByteCode 会存在 UnlinkedCodeBlock 里。 分层编译总的来说 JavaScriptCore 是采用了类型推测和分层编译的思想，解析成字节码后 LLInt 的作用就是让 js 代码能够早点执行，由于解释的效率不高，所以达到一定条件可以并行的通过 Baseline JIT 编译成更高效的字节码来解释，如果到了更加容易使得 LLInt 解释效率差的情况就会并行使用 DFG JIT ，DFG 编译的结果也有代表 On stack replacement 的 osrExitSites 数组，这样的字节码的解释性能会更好，如果假设解释失败还可以再回到 Baseline，也不会有什么问题。启用 FTL 的条件就更高了，可能函数调用了好几万次也都不会开启。 分层编译的主要思想是先把源码解释成一种内部的表示也就是字节码，将其中使用率高的字节码转成汇编代码，汇编代码可以由 CPU 直接执行来最大程度的提高性能。 LLInt，Baseline JIT 和 DFG 三者会同时运行。可以在 jsc.cpp 里添加日志观察他们的工作状态 箭头指示的是堆栈替换 on-stack replacement，简称 OSR。这个技术可以将执行转移到任何 statement 的地方。OSR 可以不管执行引擎是什么都在去解析字节码状态，并且能够重构它去让其它引擎继续执行，OSR entry 是进入更高层优化，OSR exit 是降至低层。LLInt 到 Baseline JIT 时 OSR 只需要跳转到相应的机器代码地址就行，因为 Baseline JIT 每个指令边界上的所有变量的表示和 LLInt 是一样的。进入 DFG JIT 就会复杂些，DFG 通过将函数控制流图当作多个进入点，一个是函数函数启动入口一个是循环的入口。 如果每个函数都用像 DFG JIT 来优化那么消耗太大，这就类似每次运行就来个完整的源码编译成本地应用那样。如果每个语句都只执行一次，那么 JIT 编译就会比 LLInt 是时间要长，如果执行的次数越多，那么 LLInt 这种解释方式就会比编译方式要差，LLInt 的大部分时间都消耗在分派下个字节码指令的操作上了。 DFG JIT全称 data flow graph JIT 数据流图 JIT。是一种推测优化的技术。会开始对一个类型做出一个能够对性能好的假设，先编译一个版本，如果后面发现假设不对就会跳转回原先代码，称为 Speculation failure。DFG 是并发编译器，DFG pipeline 的每个部分都是同时运行的，包括字节码解析和分析。 上图是 DFG JIT 的优化 pipeline。开始 DFG 会把字节码转成 DFG CPS 格式，这个格式会描述变量和临时数据之间的数据流关系。再用分析信息来推测类型，通过推测的类型减少类型的检查。接着进行传统的编译器方面的优化，最后编译器通过 DFG CPS 格式直接生成机器码。 DFG JIT 会将字节码解析成 SSA 形式，按执行路径收集类型信息。会使用 inlining 和 value profiling 等一些静态分析技术。类型推导把 value profile 里的常用的类型作为后面用的类型来预测，在 SpeculatedType.h 里定义里一些数据类型，符合 Data-flow analysis 规范，具体实现在 DFGPredictionPropagationPhase.cpp 里。Baseline JIT 次数超过一定数量就会生成一个新的类型，可能会触发 DFG 也可能会让 Baseline JIT 再执行几次。 DFG 的 register allocator 中汇编程序使用的是二地址，不用 op dest, src1, src2 这样三地址形式，只需要 op src1, src2 这样的二地址形式，结果存在第一个操作数里。 DFG JIT 将低效字节码转成更优化的高效形式。DFG 结合传统编译器的优化，比如寄存器的分配，控制流图的简化，公共子表达式消除，死代码消除和稀疏条件常量传播等。但是正儿八经的编译器是需要知道变量类型和堆里面的对象的结构的，这样才能更好的优化。DFG JIT 使用的是 LLInt 和 Baseline JIT 里分析出的变量类型来推断的。比如下面的例子 123function plusThe(x) { return x + 1; } 这里的 x 从代码上看是看不出类型的，它可能是字符串也可能是 integer 或者 double。LLInt 和 Baseline JIT 会从函数参数或者来自堆的读取来收集每个变量的值信息。DFG 不会一开始就编译 plusThe 这个函数，它会等到这个函数被执行了很多次，让 LLInt 和 Baseline JIT 尽可能的把类型信息收集全。根据这些信息来假设一个类型，一个确定的类型会节省空间和执行时间。如果假设的检查失败，就通过 OSR 把执行转移到 Baseline JIT 上。 FTL JITDFG JIT 可以优化 long-running 运行的代码性能，但是会影响 short-running 的程序，DFG 编译的时间和 DFG 生成代码的质量相比较来说还是过大。想让 DFG 生成更好的代码都会降低代码速度，还会增加 shorter-running 代码的延迟。DFG 不可能同时成为低延迟优化和 high-throughput 代码编译器。这时就需要再多一层来做较重的优化，同时让 DFG 保持自己的轻体重，使得 longer-running 和 shorter-running 代码能够保持平衡。新的一层 FTL 实际上是 DFG Backend 的替换。会先在 DFG 的 JavaScript 函数表示转换为静态单一指派（SSA） 格式上做些 JavaScript 特性的优化。接着把 DFG IR 转换成 FTL 里用到的 B3 的 IR。最后生成机器码。 DFG 的机器代码生成器很快，但没有低级优化。对这块的优化采用先转成 SSA 形式，执行比如自动执行循环不变量代码来提高执行速率的循环不变量代码移动（loop-invariant code motion）的优化技术，这些优化完成后就可以 straight-forward linear 和 一对多（DFG SSA 的每个指令都可以产生）的转换为也基于 SSA 的没有 JavaScript 语言特性的 B3 的 IR。总的来说过程就是把源码生成字节码，接着变成 DFG CPS IR，再就是 DFG SSA IR，最后成 B3 的 IR，JavaScript 的动态性就是在这些过程中一步步被消除掉的。 代码在 LLInt，Baseline JIT 和 DFG JIT 运行一段时间才会调用 FTL。FTL 在并发线程中会从它们那收集分析信息。short-running 代码是不会导致 FTL 编译的，一般超过10毫秒的函数会触发 FTL 编译。 FTL 通过并发编译减小对启动速度的影响。 FTL Backend B3B3 的全称 Bare Bones Backend，实现了大吞吐量同时缩短总体 FTL 编译时间。B3 的 IR 是一个低级别的中间表示，低级别意味着需要大量内存去表示每个函数，大量的内存意味着编译器在分析函数时需要扫描大量内存。B3 有两个 IR，一个叫 B3 IR 另一个机器级别的叫 Assembly IR，简称 Air。这两个 IR 的目标是代表低级操作，同时能最大限度的减少分析代码所需要的内存访问。达到这个目标需要减少 IR 对象整体大小，减少表示典型操作的 IR 对象数量，减少 IR 的 pointer chasing，最后时减少 IR 的总数。 B3 转换成 Air 会通过执行反向贪婪模式匹配来巧妙地针对每个 B3 操作选择正确的 Air 序列。具体的实现可以参看 B3LowerToAir.cpp 的代码。 下面来看看 B3 IR 的所做的优化。 Strength reduction：主要包括控制流程图的简化，常量合并，消除死代码，剪除整数溢出的检查，还有其它简化规则。实现文件是 B3ReduceStrength.cpp。 Flow-sensitive 常量合并：在 B3FoldPathConstants.cpp 文件里。 全局共用子表达式消除：实现文件 B3EliminateCommonSubexpressions.cpp。 Tail duplication：B3DuplicateTails.cpp SSA 修正：B3FixSSA.cpp 优化常量实际的位置：B3MoveConstants.cpp Air 里做的优化包括去除死代码，控制流图的简化以及修正部分寄存器 stalls 和溢出代码症状。Air 最重要的优化是寄存器分配。 B3 的动态语言支持靠的是 Patchpoints，还有一半功劳是操作码的 Check family，用来实现栈上替换，即 OSR。JavaScript 是种动态语言，没有可以快速执行的类型和操作，FTL JIT 就使用推测行为方式把这些操作转换成快速代码。 Air 在寄存器分配器的选择上使用了经典的图形着色寄存器分配器，叫迭代寄存器合并，简称 IRC。 类型分析Web Inspector 工具是 WebKit 里提供的调试工具，通过这个工具可以很好的观察哪些函数甚至哪些条件执行了或者没有执行。最重要的是可以直观的观察变量类型，还能够跟踪值的继承链。JavaScript 是动态类型语言，任何变量都可以是任何类型，表达式可以有任何类型，函数可以返回任何类型等等。由于不能立刻得到类型就没法确定地址字节大小，需要在运行时去反复推断。静态语言就不一样，一开始明确了类型，比如目标平台 int 类型占用4个字节，它对应的对象是个地址，偏移量是0，访问 int 时需要将对象地址加上4个字节。所以语言解释系统只要用数组和位移来存变量和方法地址就行了，这样几个机器语言的指令就可以对其执行各种操作。 下面来个例子： 123456789let x = 3;print(x);x = [&quot;These&quot;, &quot;is&quot;, &quot;array with string&quot;];print(x);const justReturn = (x) =&gt; { return x; };justReturn(10);justReturn([1, 2, 3]);justReturn(&quot;I am bad!&quot;); JavaScript 没有类型限制，语法不错就没问题，如果是静态类型语言的话就没法像上面的例子一样把数组赋给数字类型的变量。在 Type Profiler 中会显示类型名为 String? 和 Integer? 这样后面跟着问号符号的表示，这是在有多个不同类型被分配给相同变量，函数参数传递和函数返回时发生的。查看时可以看到所有这些被收集的类型的信息。 那么 JavaScriptCore 是如何分析变量类型的呢？先看段 js 代码： 123function add(x, y) { return x + y;} 对应的字节码： 12345function add: 10 m_instructions; 3 parameter(s); 1 variable(s)[ 0] enter [ 1] get_scope loc0[ 3] add loc1, arg1, arg2[ 8] ret loc1 下面看看开启了 Type Profiler 后的字节码是什么样的： 12345678910111213141516function add: 40 m_instructions; 3 parameter(s); 1 variable(s)[ 0] enter [ 1] get_scope loc0// 分析函数参数[ 3] op_profile_type arg1 [ 9] op_profile_type arg2// 分析 add 表达式的操作数[15] op_profile_type arg1[21] op_profile_type arg2[27] add loc1, arg1, arg2// 分析返回语句，收集这个函数的返回类型信息[32] op_profile_type loc1[38] ret loc1 下面是进入 DFG 时转换成 DFG IR 的代码： 1234567891011121314151617181920210: SetArgument(this)1: SetArgument(arg1)2: SetArgument(arg2)3: JSConstant(JS|PureInt, Undefined)4: MovHint(@3, loc0)5: SetLocal(@3, loc0)6: JSConstant(JS|PureInt, Weak:Cell: 0x10f458ca0 Function)7: JSConstant(JS|PureInt, Weak:Cell: 0x10f443800 GlobalScopeObject)8: MovHint(@7, loc0)9: SetLocal(@7, loc0)10: GetLocal(JS|MustGen|PureInt, arg1)11: ProfileType(@10)12: GetLocal(JS|MustGen|PureInt, arg2)13: ProfileType(@12)14: ProfileType(@10)15: ProfileType(@12)16: ValueAdd(@10, @12, JS|MustGen|PureInt)17: MovHint(@16, loc1)18: SetLocal(@16, loc1)19: ProfileType(@16)20: Return(@16) 现在还有很多 ProfileType，这些操作会有很大的消耗，DFG 会推测参数类型是整数，接下来会在这个假设下将 ProfileType 的那些操作移除掉。 12345678910111: SetArgument(arg1)2: SetArgument(arg2)3: JSConstant(JS|PureInt, Undefined)4: MovHint(@3, loc0)7: JSConstant(JS|PureInt, Weak:Cell: 0x10f443800 GlobalScopeObject)8: MovHint(@7, loc0)10: GetLocal(@1, arg1)12: GetLocal(@2, arg2)16: ArithAdd(Int32:@10, Int32:@12)17: MovHint(@16, loc1)20: Return(@16) 在对类型的处理上 V8 使用了一个结合 C++ 使用类和偏移位置思想的隐藏类来解决通过字符串匹配找属性的算法。做法是将有相同属性名和属性值的对象保存在同一个组的隐藏类里，这些属性在隐藏类里有着同样的偏移值，这样这个组里的对象能够共用这个隐藏类的信息。访问属性的过程是得到隐藏类的地址，根据属性名得到偏移值，通过偏移值和隐藏类地址得到属性地址。那么这个过程是否可以加速呢？答案是肯定的，通过 Inline Cache 缓存之前查找结果来减少方法和属性的哈希表查找时间。当一个对象或属性类型出现多种时缓存就会不断更新，V8 就会退到先前按照哈希表查找的方式来。 指令集架构JavaScriptCore 是基于寄存器的虚拟机 register-based VM。这种实现方式不用频繁入栈，出栈和三地址的指令集，所以效率高，但移植性弱点。 基于寄存器指令集架构三地址和二地址的指令集，基本都是使用基于寄存器的架构来实现的，要求除了 load 和 store 外的运算指令的源都要是寄存器。 下面的代码 1i = a + b; 上面这句转换成机器指令样子 1add i, a, b 这样的形式就是三地址指令，很多的代码都是这样的二元运算然后再赋值，三地址正好可以分配两地址给二元运算的两个源，剩下一个地址给赋值目标。ARM 处理器的主要指令集就是三地址的。那么二地址是怎么处理的呢？将上面的代码换成下面的样子： 12i += a;i += b; 机器指令形式就变成 12add i, aadd i, b 这样一个源同时也作为赋值目标，X86 系列的处理器就是采用的二地址。 有了二地址和三地址，那么有一地址么。 12add aadd b 这就是一地址，只有操作源，那么目标呢？目标 i 是隐藏目标，这种运算的目标称为累加器的专用寄存器，运算都是依赖更新累加器的状态来完成。 基于栈指令集架构那么零地址呢？JVM 就是采用的这种。那么就先看下一段 JAVA 代码： 12345678class QuickCalculate { byte onePlusOne() { byte x = 1; byte y = 1; byte z = (byte) (x + y); return z; } } 转换成字节码： 1234567891011iconst_1 // Push 整数常量1istore_1 // Pop 到局部变量1，相当于 byte x = 1; 这句iconst_1 // 再 Push 整数常量1 istore_2 // Pop 到局部变量2，相当于 byte y = 1; 这句iload_1 // Push x，这时 x 已经作为整数存在局部变量1里。iload_2 // Push y，这时 y 已经作为整数存在局部变量1里。iadd // 执行加操作，栈顶就变成了 x + y，结果为一个整数int2byte // 将整数转化成字节，结果还是占32位istore_3 // Pop 到局部变量3里，byte z = (byte)(x + y)iload_3 // Push z 的值使之可以被返回ireturn // 返回结果，return z 整个过程我放到了注释里。可以看到零地址形式的指令集就是基于栈架构的。这种架构的优势是可以用更少的空间存更多的指令，所以空间不是很富足时这种架构是可取的，不过零地址要完成一件事会比基于寄存器指令架构的二地址，三地址指令要多很多指令，执行效率还会低。 指令集架构演化和比较JavaScriptCore 采用 SquirrleFish 之前的解释器他们都是树遍历式的，解释器会递归遍历树，在遍历树上的每个节点的操作都是根据解释其每个字节点返回的值来的。这种操作即不是基于栈也不是基于寄存器。举个例子 1i = x + y * z 按 AST 的后序遍历，最上面的 = 符号依赖子节点 + 符号节点返回的值，+ 符号依赖 x 节点和 * 符号节点的值，依此递归下去，这样最开始获取到值的就是最低一级的运算，在这个例子里就是 y 和 z 的运算的结果返回给 * 符号节点。这种就是典型的后序遍历。CRuby 1.9 之前也是用的这种方式解释执行的。 赋值符号 = 符号的左侧叫做左值，右侧的值叫做右值。左值也可能是复杂的表达式，比如数组或者结构体。根据求值顺序，对于二元运算的节点，是先遍历左子节点的。所以当左值是复杂表达式需要计算时是会优先进行计算的。再看个左值是数组的例子： 12345678public class LeftFirstTest { public static void main(String[] args) { int[] arr = new int[1]; int x = 3; int y = 5; arr[0] = x + y; }} arr[0] = x + y; 对应的字节码： 12345678910// 左值，数组下标aload_1 iconst_0 // 右值iload_2 // xiload_3 // yiadd iastore // 赋值符号节点进行赋值 可以看到左值是先计算的。 从树遍历到基于栈的解释，实际上是一个将 AST 树打平的过程。方法是后序遍历 AST 时使用 Reverse Polish Notation 这种后缀记法生成一个序列，成为一个线性结构，后面再解释执行这个操作序列。 JVM 是 Java 语言的虚机。Android 也是用的 Java 语言，那么它的虚机也是 JVM 吗？答案是否定的，Android 使用的虚机叫 Dalvik VM，这款虚机在很多设计上都与 JVM 兼容，字节码是二地址和三地址并用的方式，是基于寄存器的架构。Dalvik VM 用在移动端为了能够更加高效，开始就没有顾及太多可移植性，这样基于寄存器架构的优势就能够更好的发挥出来了。想更多了解 Dalvik VM 可以通过 Dan Bornstein 做的一个 Dalvik 的实现原理的演讲 Dalvik VM Internals。 JVM 和 Dalvik VM 的主要区别是后者字节码指令数量和内存更少。JVM 每个线程有一个 Java 栈用来记录方法调用的 activation record，每调用一个方法就会分配一个新栈帧，方法返回就 Pop 出栈帧。每个栈帧会有局部变量区，istore 这样的指令用来移动局部变量和参数到局部变量区。每个栈帧还会有求值栈，这个栈用来存储求值的中间结果和调用其他方法的参数等，使用 iconst 这样的指令来进行数据的移动，还可以通过 iadd，imul 这样的指令在求值栈中 Pop 出值进行求值，然后再把结果 Push 到栈里。 Dalvik VM 的每个线程有程序计数器和调用栈，方法的调用和 JVM 一样是会分配一个新的帧，不同的是 Dalvik VM 使用的是虚拟寄存器来替代 JVM 里的局部变量区和求值栈。方法调用会有一组自己的虚拟寄存器，常用的是 v0 - v15，有些指令可以使用 v0 - v255。只在虚拟寄存器中进行指令操作，数据移动少多了，保存局部变量的存储单元也会少很多。Dalvik VM 的寄存器每次方法调用会一组自己的，不过在 X86 架构中寄存器是全局的，这样 X86 需要考虑 calling converntion，就是需要保护一些寄存器的状态，在调用时需要处理这些，而 Dalvik VM 调用完方法后，那些寄存器值会恢复成调用前的可以很好的避免这样的问题。 V8 没有中间的字节码，而是直接编译 JavaScript 生成机器码。不过在内部也用了表达式栈来简化代码生成，在编译过程中使用虚拟栈帧来记录局部变量和栈的状态。生成代码的过程中会有窥孔优化用来去除多余的入栈和出栈，把栈操作转成寄存器操作，生成的代码看起来就和基于寄存器的代码类似了。 这就有个疑问了，零地址要做多次入栈和出栈操作，执行效率低，那么为什么还会有虚拟机比如 JVM 字节码还要用零地址形式呢？ 像 X86 刚开始时的寄存器很多不是通用寄存器，由于让编译器去决定程序里那么多的变量该怎么装到寄存器里，那些应该应该映射到一个寄存器，哪些应该换出，这并不容易，JVM 采用零指令这种堆栈结构的原因就是不信任编译器的寄存器分配，所以使用堆栈结构，这样就可以避开寄存器分配这样的难题。不过后来 IBM 公开了他们的图染色寄存器分配算法，这样编译器的分配能力得到了很大的进步，所以现在都是编译器来主导寄存器分配。 很多主流高级语言虚拟机（high-level language virtual machine，简称 HLL VM）比如 JVM，CPython 都采用的基于栈的架构。这样做主要是因为不用考虑临时变量分配空间，只需要求值栈来做，这样的编译器更容易实现。还有就是可以更容易在硬件较差的机器上运行，前面也讲到基于栈这种架构指令对于存储空间的要求更少。最后就是考虑移植，复杂指令计算机（Complex Instruction Set Computer，简称 CISC）的通用寄存器比较少，32位只有8个32位通用寄存器。精简指令集计算机（Reduced Instruction Set Computer，简称 RISC）通用寄存器数量会多些，32位有16个寄存器。源架构寄存器数量通常和实际机器通用寄存器数量不一致而实现映射麻烦，基于栈架构里是没有通用寄存器的，实现虚机时可以就可以很容易自由的分配实际机器寄存器，移植起来自然也就容易多了。 处理器来说多是基于寄存器架构的，但是对于虚机来说，由于基于栈架构需要执行更多的 load 或 store 这样的指令，这样 Instruction dispatch 的次数和内存访问的次数会更多，所以基于寄存器的架构在虚机里同样也更优些，这也是为什么对于闭环的苹果来说会在 JavaScriptCore 的虚机里采用性能更好的基于寄存器的架构，而不去顾及移植性。 JavaScript各大引擎的介绍各个 JavaScript 引擎介绍： SpiderMonkey：用于 Mozilla Firefox，是最早的 JavaScript 引擎，基于栈的字节码。Parser 使用的手写纯递归下降式。 KJS：KDE 的引擎，用于 Konqueror 浏览器。树遍历解释器。Parser 使用的是 bison。 Rhino：使用 Java编写，开发源码，也是 Mozilla 的，相当于 Java 版的 SpiderMonkey，当时的想法是想把 JavaScript 做成服务端的脚本语言来用。Parser 是手写的纯递归下降式 rhino/src/org/mozilla/javascript/Parser.java 。 Chakra：也叫 JScript 微软的 Internet Explorer 和 Microsoft Edge 在使用。 JavaScriptCore：苹果开发的开源 JavaScript 引擎，用在 Safari 等浏览器中。Safari 是带有 JIT 的 JavaScriptCore 的，而 UIWebView 是没有的。 V8：Google 开发的开源引擎，用于 Chrome。Parser 使用的是手写纯递归下降加运算符优先级混合式。V8 使用了 2-pass，会先收集一些上下文信息增加预测的准确性。V8 开始时是不用字节码会直接编译成机器码，Dart VM 也是这样设计的，他们一个问题的回答 Why didn’t Google build a bytecode VM targetable by multiple languages including Dart? 同样适用于 V8。不过 V8 5.9 启用了 Ignition 字节码解释器，自此几大 JS 引擎都用了字节码。启用字节码的考虑主要是希望能够减少机器码对内存空间的占用。由于机器码占用的空间也很大，所以不好都缓存下来，不然内存和磁盘都吃不消，序列化和反序列化时间都太长，这样每次编译的机器码都不是完整的只会缓存最外的一层，如果代码最外层包了一层，启动代码每次都是不同的调用就会每次都编译，会导致缓存没有作用。由于字节码通过比较好的设计后能够做到比机器码紧凑，这样引入 Ignition 后内存明显的下降了。TurboFan 再对 Ignition 字节码来进行解释。 各个引擎之间通用技术根据下面关键子去查找，可以了解更多的相关的虚机技术。 源码到中间代码 Recusive-descent parser：递归下降式 parser Operator precedence parser：运算符优先级 parser Deferred parser：延迟 parser 中间代码到目标代码 Tiered compilation：多层编译 Background compilation：后台编译 Type feedback：类型反馈 Type specialization：类型特化 SSA-form IR：静态单赋值形式 ming1016","link":"/program//javascriptcore/"},{"title":"iOS基础集合类","text":"NSArray##排序 逆序，array.reverseObjectEnumerator.allObjects 数组中是字符串对象排序首选sortedArrayUsingSelector: 12NSArray *array = @[@&quot;John Appleseed&quot;, @&quot;Tim Cook&quot;, @&quot;Hair Force One&quot;, @&quot;Michael Jurewitz&quot;];NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)]; 存储内容是数字 12NSArray *numbers = @[@9, @5, @11, @3, @1];NSArray *sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)]; 使用函数指针sortedArrayHint排序 12345- (NSData *)sortedArrayHint;- (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator context:(void *)context;- (NSArray *)sortedArrayUsingFunction:(NSInteger (*)(id, id, void *))comparator context:(void *)context hint:(NSData *)hint; 基于block的排序方法 123- (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;- (NSArray *)sortedArrayWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr; 性能比较selector最快 1Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms]. 更快的二分查找 123456789101112typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) { NSBinarySearchingFirstEqual = (1UL &lt;&lt; 8), NSBinarySearchingLastEqual = (1UL &lt;&lt; 9), NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),};- (NSUInteger)indexOfObject:(id)obj inSortedRange:(NSRange)r options:(NSBinarySearchingOptions)opts usingComparator:(NSComparator)cmp;//Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms] 枚举 使用indexesOfObjectsWithOptions:passingTest: 12345NSIndexSet *indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) { return testObj(obj);}];NSArray *filteredArray = [randomArray objectsAtIndexes:indexes]; 传统的枚举 123456NSMutableArray *mutableArray = [NSMutableArray array];for (id obj in randomArray) { if (testObj(obj)) { [mutableArray addObject:obj]; }} block方式枚举 123456NSMutableArray *mutableArray = [NSMutableArray array];[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) { if (testObj(obj)) { [mutableArray addObject:obj]; }}]; 通过下标objectAtIndex: 1234567NSMutableArray *mutableArray = [NSMutableArray array];for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) { id obj = randomArray[idx]; if (testObj(obj)) { [mutableArray addObject:obj]; }} 使用比较传统的学院派NSEnumerator 12345678NSMutableArray *mutableArray = [NSMutableArray array];NSEnumerator *enumerator = [randomArray objectEnumerator];id obj = nil;while ((obj = [enumerator nextObject]) != nil) { if (testObj(obj)) { [mutableArray addObject:obj]; }} 使用predicate 123NSArray *filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary *bindings) { return testObj(obj);}]]; 各个方法枚举时间参考，indexesOfObjectsWithOptions在开启了并发枚举的情况下比NSFastEnumeration快一倍。 枚举方法 / 时间 [ms] 10.000.000 elements 10.000 elements indexesOfObjects:, concurrent 1844.73 2.25 NSFastEnumeration (for in) 3223.45 3.21 indexesOfObjects: 4221.23 3.36 enumerateObjectsUsingBlock: 5459.43 5.43 objectAtIndex: 5282.67 5.53 NSEnumerator 5566.92 5.75 filteredArrayUsingPredicate: 6466.95 6.31 NSDictionary性能同样数目的值，NSDictionary比NSArray要花费多得多的内存空间 排序使用NSArray的排序方法将键数组排序为新的对象 1234- (NSArray *)keysSortedByValueUsingSelector:(SEL)comparator;- (NSArray *)keysSortedByValueUsingComparator:(NSComparator)cmptr;- (NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts usingComparator:(NSComparator)cmptr; 枚举 keysOfEntriesWithOptions:passingTest:，可并行 123456789NSSet *matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrentpassingTest:^BOOL(id key, id obj, BOOL *stop){ return testObj(obj);}];NSArray *keys = matchingKeys.allObjects;NSArray *values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values forKeys:keys]; getObjects:andKeys: 枚举，基于c数组 1234567891011NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];id __unsafe_unretained objects[numberOfEntries];id __unsafe_unretained keys[numberOfEntries];[randomDict getObjects:objects andKeys:keys];for (int i = 0; i &lt; numberOfEntries; i++) { id obj = objects[i]; id key = keys[i]; if (testObj(obj)) { mutableDictionary[key] = obj; }} block枚举 123456NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) { if (testObj(obj)) { mutableDictionary[key] = obj; }}]; NSFastEnumeration 1234567NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];for (id key in randomDict) { id obj = randomDict[key]; if (testObj(obj)) { mutableDictionary[key] = obj; }} NSEnumeration 123456789NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];NSEnumerator *enumerator = [randomDict keyEnumerator];id key = nil;while ((key = [enumerator nextObject]) != nil) { id obj = randomDict[key]; if (testObj(obj)) { mutableDictionary[key] = obj; }} 各个方法枚举时间参考 枚举方法 / 时间 [ms] 50.000 elements 1.000.000 elements keysOfEntriesWithOptions:, concurrent 16.65 425.24 getObjects:andKeys: 30.33 798.49 keysOfEntriesWithOptions: 30.59 856.93 enumerateKeysAndObjectsUsingBlock: 36.33 882.93 NSFastEnumeration 41.20 1043.42 NSEnumeration 42.21 1113.08 ming1016","link":"/program//ji-chu-ji-he-lei/"},{"title":"检测iOS的APP性能的一些方法","text":"首先如果遇到应用卡顿或者因为内存占用过多时一般使用Instruments里的来进行检测。但对于复杂情况可能就需要用到子线程监控主线程的方式来了，下面我对这些方法做些介绍： Time Profiler可以查看多个线程里那些方法费时过多的方法。先将右侧Hide System Libraries打上勾，这样能够过滤信息。然后在Call Tree上会默认按照费时的线程进行排序，单个线程中会也会按照对应的费时方法排序，选择方法后能够通过右侧Heaviest Stack Trace里双击查看到具体的费时操作代码，从而能够有针对性的优化，而不需要在一些本来就不会怎么影响性能的地方过度优化。 Allocations这里可以对每个动作的前后进行Generations，对比内存的增加，查看使内存增加的具体的方法和代码所在位置。具体操作是在右侧Generation Analysis里点击Mark Generation，这样会产生一个Generation，切换到其他页面或一段时间产生了另外一个事件时再点Mark Generation来产生一个新的Generation，这样反复，生成多个Generation，查看这几个Generation会看到Growth的大小，如果太大可以点进去查看相应占用较大的线程里右侧Heaviest Stack Trace里查看对应的代码块，然后进行相应的处理。 Leak可以在上面区域的Leaks部分看到对应的时间点产生的溢出，选择后在下面区域的Statistics&gt;Allocation Summary能够看到泄漏的对象，同样可以通过Stack Trace查看到具体对应的代码区域。 开发时需要注意如何避免一些性能问题NSDateFormatter通过Instruments的检测会发现创建NSDateFormatter或者设置NSDateFormatter的属性的耗时总是排在前面，如何处理这个问题呢，比较推荐的是添加属性或者创建静态变量，这样能够使得创建初始化这个次数降到最低。还有就是可以直接用C，或者这个NSData的Category来解决https://github.com/samsoffes/sstoolkit/blob/master/SSToolkit/NSData%2BSSToolkitAdditions.m UIImage这里要主要是会影响内存的开销，需要权衡下imagedNamed和imageWithContentsOfFile，了解两者特性后，在只需要显示一次的图片用后者，这样会减少内存的消耗，但是页面显示会增加Image IO的消耗，这个需要注意下。由于imageWithContentsOfFile不缓存，所以需要在每次页面显示前加载一次，这个IO的操作也是需要考虑权衡的一个点。 页面加载如果一个页面内容过多，view过多，这样将长页面中的需要滚动才能看到的那个部分视图内容通过开启新的线程同步的加载。 优化首次加载时间通过Time Profier可以查看到启动所占用的时间，如果太长可以通过Heaviest Stack Trace找到费时的方法进行改造。 监控卡顿的方法还有种方法是在程序里去监控性能问题。可以先看看这个Demo，地址https://github.com/ming1016/DecoupleDemo。 这样在上线后可以通过这个程序将用户的卡顿操作记录下来，定时发到自己的服务器上，这样能够更大范围的收集性能问题。众所周知，用户层面感知的卡顿都是来自处理所有UI的主线程上，包括在主线程上进行的大计算，大量的IO操作，或者比较重的绘制工作。如何监控主线程呢，首先需要知道的是主线程和其它线程一样都是靠NSRunLoop来驱动的。可以先看看CFRunLoopRun的大概的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445int32_t __CFRunLoopRun(){ __CFRunLoopDoObservers(KCFRunLoopEntry); do { __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); //这里开始到kCFRunLoopBeforeWaiting之间处理时间是感知卡顿的关键地方 __CFRunLoopDoBlocks(); __CFRunLoopDoSource0(); //处理UI事件 //GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); //休眠前 __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); //等待msg mach_port_t wakeUpPort = SleepAndWaitForWakingUpPorts(); //等待中 //休眠后，唤醒 __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); //定时器唤醒 if (wakeUpPort == timerPort) __CFRunLoopDoTimers(); //异步处理 else if (wakeUpPort == mainDispatchQueuePort) __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() //UI，动画 else __CFRunLoopDoSource1(); //确保同步 __CFRunLoopDoBlocks(); } while (!stop &amp;&amp; !timeout); //退出RunLoop __CFRunLoopDoObservers(CFRunLoopExit);} 根据这个RunLoop我们能够通过CFRunLoopObserverRef来度量。用GCD里的dispatch_semaphore_t开启一个新线程，设置一个极限值和出现次数的值，然后获取主线程上在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting再到kCFRunLoopAfterWaiting两个状态之间的超过了极限值和出现次数的场景，将堆栈dump下来，最后发到服务器做收集，通过堆栈能够找到对应出问题的那个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ MyClass *object = (__bridge MyClass*)info; object-&gt;activity = activity;}static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info){ SMLagMonitor *lagMonitor = (__bridge SMLagMonitor*)info; lagMonitor-&gt;runLoopActivity = activity; dispatch_semaphore_t semaphore = lagMonitor-&gt;dispatchSemaphore; dispatch_semaphore_signal(semaphore);}- (void)endMonitor { if (!runLoopObserver) { return; } CFRunLoopRemoveObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); CFRelease(runLoopObserver); runLoopObserver = NULL;}- (void)beginMonitor { if (runLoopObserver) { return; } dispatchSemaphore = dispatch_semaphore_create(0); //Dispatch Semaphore保证同步 //创建一个观察者 CFRunLoopObserverContext context = {0,(__bridge void*)self,NULL,NULL}; runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); //将观察者添加到主线程runloop的common模式下的观察中 CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes); //创建子线程监控 dispatch_async(dispatch_get_global_queue(0, 0), ^{ //子线程开启一个持续的loop用来进行监控 while (YES) { long semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, 30*NSEC_PER_MSEC)); if (semaphoreWait != 0) { if (!runLoopObserver) { timeoutCount = 0; dispatchSemaphore = 0; runLoopActivity = 0; return; } //两个runloop的状态，BeforeSources和AfterWaiting这两个状态区间时间能够检测到是否卡顿 if (runLoopActivity == kCFRunLoopBeforeSources || runLoopActivity == kCFRunLoopAfterWaiting) { //出现三次出结果 if (++timeoutCount &lt; 3) { continue; } //将堆栈信息上报服务器的代码放到这里 } //end activity }// end semaphore wait timeoutCount = 0; }// end while }); } 有时候造成卡顿是因为数据异常，过多，或者过大造成的，亦或者是操作的异常出现的，这样的情况可能在平时日常开发测试中难以遇到，但是在真实的特别是用户受众广的情况下会有人出现，这样这种收集卡顿的方式还是有价值的。 堆栈dump的方法第一种是直接调用系统函数获取栈信息，这种方法只能够获得简单的信息，没法配合dSYM获得具体哪行代码出了问题，类型也有限。这种方法的主要思路是signal进行错误信号的获取。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940static int s_fatal_signals[] = { SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP, SIGTERM, SIGKILL,};static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);void UncaughtExceptionHandler(NSException *exception) { NSArray *exceptionArray = [exception callStackSymbols]; //得到当前调用栈信息 NSString *exceptionReason = [exception reason]; //非常重要，就是崩溃的原因 NSString *exceptionName = [exception name]; //异常类型}void SignalHandler(int code){ NSLog(@&quot;signal handler = %d&quot;,code);}void InitCrashReport(){ //系统错误信号捕获 for (int i = 0; i &lt; s_fatal_signal_num; ++i) { signal(s_fatal_signals[i], SignalHandler); } //oc未捕获异常的捕获 NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);}int main(int argc, char * argv[]) { @autoreleasepool { InitCrashReport(); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 使用PLCrashReporter的话出的报告看起来能够定位到问题代码的具体位置了。 123456NSData *lagData = [[[PLCrashReporter alloc] initWithConfiguration:[[PLCrashReporterConfig alloc] initWithSignalHandlerType:PLCrashReporterSignalHandlerTypeBSD symbolicationStrategy:PLCrashReporterSymbolicationStrategyAll]] generateLiveReport];PLCrashReport *lagReport = [[PLCrashReport alloc] initWithData:lagData error:NULL];NSString *lagReportString = [PLCrashReportTextFormatter stringValueForCrashReport:lagReport withTextFormat:PLCrashReportTextFormatiOS];//将字符串上传服务器NSLog(@&quot;lag happen, detail below: \\n %@&quot;,lagReportString); 下面是测试Demo里堆栈里的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722016-03-28 14:59:26.922 HomePageTest[4803:201212] INFO: Reveal Server started (Protocol Version 25).2016-03-28 14:59:27.134 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:29.262 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:30.865 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:32.115 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:33.369 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:34.832 HomePageTest[4803:201212] 费时测试2016-03-28 14:59:34.836 HomePageTest[4803:201615] lag happen, detail below: Incident Identifier: 73BEF9D2-EBE3-49DF-B95B-7392635631A3CrashReporter Key: TODOHardware Model: x86_64Process: HomePageTest [4803]Path: /Users/daiming/Library/Developer/CoreSimulator/Devices/444AAB95-C393-45CC-B5DC-0FB8611068F9/data/Containers/Bundle/Application/9CEE3A3A-9469-44F5-8112-FF0550ED8009/HomePageTest.app/HomePageTestIdentifier: com.xiaojukeji.HomePageTestVersion: 1.0 (1)Code Type: X86-64Parent Process: debugserver [4805]Date/Time: 2016-03-28 06:59:34 +0000OS Version: Mac OS X 9.2 (15D21)Report Version: 104Exception Type: SIGTRAPException Codes: TRAP_TRACE at 0x10aee6f79Crashed Thread: 2Thread 0:0 libsystem_kernel.dylib 0x000000010ec6b206 __semwait_signal + 101 libsystem_c.dylib 0x000000010e9f2b9e usleep + 542 HomePageTest 0x000000010aedf934 -[TestTableView configCell] + 8203 HomePageTest 0x000000010aee5c89 -[testTableViewController observeValueForKeyPath:ofObject:change:context:] + 6014 Foundation 0x000000010b9c2564 NSKeyValueNotifyObserver + 3475 Foundation 0x000000010b9c178f NSKeyValueDidChange + 4666 Foundation 0x000000010b9bf003 -[NSObject(NSKeyValueObservingPrivate) _changeValueForKey:key:key:usingBlock:] + 11767 Foundation 0x000000010ba1d35f _NSSetObjectValueAndNotify + 2618 HomePageTest 0x000000010aec9c26 -[DCTableView tableView:cellForRowAtIndexPath:] + 2629 UIKit 0x000000010c872e43 -[UITableView _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + 76610 UIKit 0x000000010c872f7b -[UITableView _createPreparedCellForGlobalRow:willDisplay:] + 7411 UIKit 0x000000010c847a39 -[UITableView _updateVisibleCellsNow:isRecursive:] + 299612 UIKit 0x000000010c87c01c -[UITableView _performWithCachedTraitCollection:] + 9213 UIKit 0x000000010c862edc -[UITableView layoutSubviews] + 22414 UIKit 0x000000010c7d04a3 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 70315 QuartzCore 0x000000010c49a59a -[CALayer layoutSublayers] + 14616 QuartzCore 0x000000010c48ee70 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 36617 QuartzCore 0x000000010c48ecee _ZN2CA5Layer28layout_and_display_if_neededEPNS_11TransactionE + 2418 QuartzCore 0x000000010c483475 _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 27719 QuartzCore 0x000000010c4b0c0a _ZN2CA11Transaction6commitEv + 48620 QuartzCore 0x000000010c4bf9f4 _ZN2CA7Display11DisplayLink14dispatch_itemsEyyy + 57621 CoreFoundation 0x000000010e123c84 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 2022 CoreFoundation 0x000000010e123831 __CFRunLoopDoTimer + 108923 CoreFoundation 0x000000010e0e5241 __CFRunLoopRun + 193724 CoreFoundation 0x000000010e0e4828 CFRunLoopRunSpecific + 48825 GraphicsServices 0x0000000110479ad2 GSEventRunModal + 16126 UIKit 0x000000010c719610 UIApplicationMain + 17127 HomePageTest 0x000000010aee0fdf main + 11128 libdyld.dylib 0x000000010e92b92d start + 1Thread 1:0 libsystem_kernel.dylib 0x000000010ec6bfde kevent64 + 101 libdispatch.dylib 0x000000010e8e6262 _dispatch_mgr_init + 0Thread 2 Crashed:0 HomePageTest 0x000000010b04a445 -[PLCrashReporter generateLiveReportWithThread:error:] + 6321 HomePageTest 0x000000010aee6f79 __28-[SMLagMonitor beginMonitor]_block_invoke + 4252 libdispatch.dylib 0x000000010e8d6e5d _dispatch_call_block_and_release + 123 libdispatch.dylib 0x000000010e8f749b _dispatch_client_callout + 84 libdispatch.dylib 0x000000010e8dfbef _dispatch_root_queue_drain + 18295 libdispatch.dylib 0x000000010e8df4c5 _dispatch_worker_thread3 + 1116 libsystem_pthread.dylib 0x000000010ec2f68f _pthread_wqthread + 11297 libsystem_pthread.dylib 0x000000010ec2d365 start_wqthread + 13Thread 3:0 libsystem_kernel.dylib 0x000000010ec6b6de __workq_kernreturn + 101 libsystem_pthread.dylib 0x000000010ec2d365 start_wqthread + 13Thread 4:0 libsystem_kernel.dylib 0x000000010ec65386 mach_msg_trap + 101 CoreFoundation 0x000000010e0e5b64 __CFRunLoopServiceMachPort + 2122 CoreFoundation 0x000000010e0e4fbf __CFRunLoopRun + 12953 CoreFoundation 0x000000010e0e4828 CFRunLoopRunSpecific + 4884 WebCore 0x0000000113408f65 _ZL12RunWebThreadPv + 4695 libsystem_pthread.dylib 0x000000010ec2fc13 _pthread_body + 1316 libsystem_pthread.dylib 0x000000010ec2fb90 _pthread_body + 07 libsystem_pthread.dylib 0x000000010ec2d375 thread_start + 13Thread 5:0 libsystem_kernel.dylib 0x000000010ec6b6de __workq_kernreturn + 101 libsystem_pthread.dylib 0x000000010ec2d365 start_wqthread + 13Thread 6:0 libsystem_kernel.dylib 0x000000010ec6b6de __workq_kernreturn + 101 libsystem_pthread.dylib 0x000000010ec2d365 start_wqthread + 13Thread 7:0 libsystem_kernel.dylib 0x000000010ec6b6de __workq_kernreturn + 101 libsystem_pthread.dylib 0x000000010ec2d365 start_wqthread + 13Thread 2 crashed with X86-64 Thread State: rip: 0x000000010b04a445 rbp: 0x0000700000093da0 rsp: 0x0000700000093b10 rax: 0x0000700000093b70 rbx: 0x0000700000093cb0 rcx: 0x0000000000001003 rdx: 0x0000000000000000 rdi: 0x000000010b04a5ca rsi: 0x0000700000093b40 r8: 0x0000000000000014 r9: 0x0000000000000000 r10: 0x000000010ec65362 r11: 0x0000000000000246 r12: 0x00007fdaf5800940 r13: 0x0000000000000000 r14: 0x0000000000000009 r15: 0x0000700000093b90 rflags: 0x0000000000000202 cs: 0x000000000000002b fs: 0x0000000000000000 gs: 0x0000000000000000 Binary Images: 0x10aebb000 - 0x10b0a5fff +HomePageTest x86_64 &lt;13a9b9abded0364fb42e65847b3acbbb&gt; /Users/daiming/Library/Developer/CoreSimulator/Devices/444AAB95-C393-45CC-B5DC-0FB8611068F9/data/Containers/Bundle/Application/9CEE3A3A-9469-44F5-8112-FF0550ED8009/HomePageTest.app/HomePageTest 0x10b2a1000 - 0x10b2c8fff dyld_sim x86_64 &lt;0bf161d7efa93cbeae2b84f9a70fc853&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/dyld_sim 0x10b30d000 - 0x10b314fff libBacktraceRecording.dylib x86_64 &lt;604a2e49cf2f39f7883b37336adb402e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libBacktraceRecording.dylib 0x10b31b000 - 0x10b31ffff libViewDebuggerSupport.dylib x86_64 &lt;3d54d318b67735e5874c72a20317b523&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.2.sdk/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib 0x10b326000 - 0x10b337fff libz.1.dylib x86_64 &lt;a603371a88ff3f8e86de61d7443888a9&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libz.1.dylib 0x10b33d000 - 0x10b5b9fff CFNetwork x86_64 &lt;cda8332f7c2836df98f216a6802a990a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CFNetwork.framework/CFNetwork 0x10b791000 - 0x10b93dfff CoreGraphics x86_64 &lt;291e992b6a4e3362823863313d3850b4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreGraphics.framework/CoreGraphics 0x10b9b9000 - 0x10bc35fff Foundation x86_64 &lt;0bbf69fb34a63fa3a540ec4ce375212c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Foundation.framework/Foundation 0x10be29000 - 0x10c173fff ImageIO x86_64 &lt;28325a1c347230ada3e8c4dc833ef05a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/ImageIO.framework/ImageIO 0x10c23c000 - 0x10c300fff MobileCoreServices x86_64 &lt;40a78b7dfb1e31fc85d0d98657f979c6&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices 0x10c382000 - 0x10c4fdfff QuartzCore x86_64 &lt;b9ff29d64f6e306ea01703ae4cd10f29&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/QuartzCore.framework/QuartzCore 0x10c5b9000 - 0x10c625fff Security x86_64 &lt;5c3df729a91c365ba314108c0b668df6&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Security.framework/Security 0x10c67b000 - 0x10c6c4fff SystemConfiguration x86_64 &lt;cfa2c5a5c2123d80a230892aedce7ece&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/SystemConfiguration.framework/SystemConfiguration 0x10c6f4000 - 0x10d3ccfff UIKit x86_64 &lt;b5c879e5e265364da6b695d7bb4ef462&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/UIKit 0x10dc38000 - 0x10df9afff libobjc.A.dylib x86_64 &lt;1643ada50eaa3d938654df70ddca4045&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libobjc.A.dylib 0x10e075000 - 0x10e076fff libSystem.dylib x86_64 &lt;3deb27f2e0b5314abf0a8880e3d52560&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libSystem.dylib 0x10e07c000 - 0x10e3e2fff CoreFoundation x86_64 &lt;f47aa9b1fe6e3472928e6622ec331f1f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation 0x10e54b000 - 0x10e6e3fff MapKit x86_64 &lt;2acdf735086f3e5897a4520417957aab&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/MapKit.framework/MapKit 0x10e807000 - 0x10e80bfff libcache.dylib x86_64 &lt;8fe45f989f2e3ccaaf0b2a5fdb2d0177&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libcache.dylib 0x10e810000 - 0x10e81bfff libcommonCrypto.dylib x86_64 &lt;45b23c8e43993a6b93f9ba749105bed3&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libcommonCrypto.dylib 0x10e828000 - 0x10e82ffff libcompiler_rt.dylib x86_64 &lt;c4852a1cdd6736168b91a75b50f2b65e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libcompiler_rt.dylib 0x10e837000 - 0x10e83efff libcopyfile.dylib x86_64 &lt;4be0e6ca0b3a313c97901d33d3ea75a8&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libcopyfile.dylib 0x10e845000 - 0x10e8bcfff libcorecrypto.dylib x86_64 &lt;34495822e7913cdbbb141c083740b04e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libcorecrypto.dylib 0x10e8d5000 - 0x10e902fff libdispatch.dylib x86_64 &lt;04d9590852903114af8e9de07daac6d4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/introspection/libdispatch.dylib 0x10e929000 - 0x10e92bfff libdyld.dylib x86_64 &lt;236c574a79e73e1abf19e1cbc04ac582&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libdyld.dylib 0x10e932000 - 0x10e932fff liblaunch.dylib x86_64 &lt;6fa06587ed1a3b5d99234a093f8d5b7e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/liblaunch.dylib 0x10e938000 - 0x10e93dfff libmacho.dylib x86_64 &lt;1e351755db163b5c82fdb47b354fcb51&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libmacho.dylib 0x10e943000 - 0x10e944fff libremovefile.dylib x86_64 &lt;a69be47eef3f35aebbd6eb19688a9dfa&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libremovefile.dylib 0x10e949000 - 0x10e960fff libsystem_asl.dylib x86_64 &lt;34369616ac8339a8b4ee9d1a7df0ba0f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_asl.dylib 0x10e96d000 - 0x10e96efff libsystem_blocks.dylib x86_64 &lt;61456881d96432178fff58643863c59e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_blocks.dylib 0x10e974000 - 0x10e9fcfff libsystem_c.dylib x86_64 &lt;fc0dde24a78d39ca848ac937d5903386&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_c.dylib 0x10ea24000 - 0x10ea26fff libsystem_configuration.dylib x86_64 &lt;c09c551d48d0371daaf79132e6c7ab73&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_configuration.dylib 0x10ea2d000 - 0x10ea2ffff libsystem_containermanager.dylib x86_64 &lt;e0dc470e6ba2349097410f280fe09ed4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_containermanager.dylib 0x10ea34000 - 0x10ea35fff libsystem_coreservices.dylib x86_64 &lt;40b277d390db3e7ea6b50de8a9279786&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_coreservices.dylib 0x10ea3b000 - 0x10ea51fff libsystem_coretls.dylib x86_64 &lt;55dc52c450e83eb5b4d26dbe24018539&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_coretls.dylib 0x10ea5d000 - 0x10ea65fff libsystem_dnssd.dylib x86_64 &lt;d5c0910695913a799ffffb6cf4653c00&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_dnssd.dylib 0x10ea6c000 - 0x10ea8ffff libsystem_info.dylib x86_64 &lt;f3ab2fc36ae332ab86398880e4325938&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_info.dylib 0x10eaa2000 - 0x10eaa3fff libsystem_sim_kernel.dylib x86_64 &lt;3402a54a835033c997e9fc27db24d85b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_sim_kernel.dylib 0x10eaa9000 - 0x10ead6fff libsystem_m.dylib x86_64 &lt;67570d2171683e96b77aeeda269b8bcb&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_m.dylib 0x10eade000 - 0x10eafafff libsystem_malloc.dylib x86_64 &lt;bd202b02a72d329999d6307a1aa14482&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_malloc.dylib 0x10eb04000 - 0x10eb5efff libsystem_network.dylib x86_64 &lt;a850352b5da23be89939b2652af84160&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_network.dylib 0x10eb92000 - 0x10eb9cfff libsystem_notify.dylib x86_64 &lt;d55e395a67f9350f9058866e3c7665f0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_notify.dylib 0x10eba5000 - 0x10eba7fff libsystem_sim_platform.dylib x86_64 &lt;3fe0d2367d073f7088330d74f4e48829&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_sim_platform.dylib 0x10ebad000 - 0x10ebadfff libsystem_sim_pthread.dylib x86_64 &lt;1e18f800d5ed31dcb0746cabc31ab297&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_sim_pthread.dylib 0x10ebb2000 - 0x10ebb5fff libsystem_sandbox.dylib x86_64 &lt;6ccd8c991b093603b0c721dbc3536f5b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_sandbox.dylib 0x10ebbc000 - 0x10ebccfff libsystem_trace.dylib x86_64 &lt;75d0d4effb95381db5dd2d32a54da7fe&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libsystem_trace.dylib 0x10ebdb000 - 0x10ebe1fff libunwind.dylib x86_64 &lt;072cea349492300fb68c39c751845ede&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libunwind.dylib 0x10ebe8000 - 0x10ec0efff libxpc.dylib x86_64 &lt;3e9ae1639a9535d3ba2c2e7144498580&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/system/libxpc.dylib 0x10ec2c000 - 0x10ec35fff libsystem_pthread.dylib x86_64 &lt;327cecd0b88131538fcc4fd4818b7f16&gt; /usr/lib/system/libsystem_pthread.dylib 0x10ec43000 - 0x10ec4bfff libsystem_platform.dylib x86_64 &lt;d3a27e107f083603acc87a92b2c04bab&gt; /usr/lib/system/libsystem_platform.dylib 0x10ec54000 - 0x10ec72fff libsystem_kernel.dylib x86_64 &lt;9ceb6c3b1caf3c32a9fd93bc72cbcea1&gt; /usr/lib/system/libsystem_kernel.dylib 0x10ec88000 - 0x10ecb1fff libc++abi.dylib x86_64 &lt;81525def7b933f8296838959fa4ce98d&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libc++abi.dylib 0x10ecc0000 - 0x10ed13fff libc++.1.dylib x86_64 &lt;889b6cbf910536c89fae86374f07e767&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libc++.1.dylib 0x10ed67000 - 0x10ed7cfff libMobileGestalt.dylib x86_64 &lt;05d34bd9e19d306c885605aecafe9893&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libMobileGestalt.dylib 0x10edb3000 - 0x10ee0efff IOKit x86_64 &lt;853021f275723ee4b9fc0684bbee030b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit 0x10ee40000 - 0x10ef3afff libsqlite3.dylib x86_64 &lt;22bfc8d7f5f632919b01fdc883e24d26&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libsqlite3.dylib 0x10ef52000 - 0x10f041fff libxml2.2.dylib x86_64 &lt;cbe1fcf1d9b63516b8fa96cb45841d40&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libxml2.2.dylib 0x10f077000 - 0x10f27efff libicucore.A.dylib x86_64 &lt;5c7ce20d3b0f3cd2b19e2c8d4cae9147&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libicucore.A.dylib 0x10f341000 - 0x10f351fff libbsm.0.dylib x86_64 &lt;7f09d0545ae037119f611768227b64b3&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libbsm.0.dylib 0x10f359000 - 0x10f359fff Accelerate x86_64 &lt;1b1483eeaea537a09ee40b3b8faf8acb&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Accelerate 0x10f35c000 - 0x10f81afff vImage x86_64 &lt;00f092dc41ec3f8e852efd7ce1efb1e2&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vImage.framework/vImage 0x10f875000 - 0x10f875fff vecLib x86_64 &lt;cdfef7cd1b45390e81e561db4c07b35f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/vecLib 0x10f878000 - 0x10f981fff libvDSP.dylib x86_64 &lt;ddafe8e5e10e33389a7a08c67895c980&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libvDSP.dylib 0x10f98e000 - 0x10fd90fff libLAPACK.dylib x86_64 &lt;39f724015fda3ef298579cd38168b4e0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libLAPACK.dylib 0x10fdc0000 - 0x10ff80fff libBLAS.dylib x86_64 &lt;3d2d6842f59035d795247d6bf77503ca&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libBLAS.dylib 0x10ff9f000 - 0x11003afff libvMisc.dylib x86_64 &lt;6716692bfaaf33a29d95873d7c93e570&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libvMisc.dylib 0x110044000 - 0x11005afff libLinearAlgebra.dylib x86_64 &lt;6880200dcd1d3e53a92e388887919970&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libLinearAlgebra.dylib 0x110063000 - 0x110073fff libSparseBLAS.dylib x86_64 &lt;e8069ab282f0344780f5286fc2b9e2c4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accelerate.framework/Frameworks/vecLib.framework/libSparseBLAS.dylib 0x11007b000 - 0x110099fff libextension.dylib x86_64 &lt;9f870091398d38fa8138b45d528cc7f2&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libextension.dylib 0x1100ba000 - 0x1100e5fff libarchive.2.dylib x86_64 &lt;6349fcc5aa9d3103b49c8813f0c14f4b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libarchive.2.dylib 0x1100f0000 - 0x11010bfff libCRFSuite.dylib x86_64 &lt;512e912e804033d980f0141de864a82a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libCRFSuite.dylib 0x110116000 - 0x110117fff liblangid.dylib x86_64 &lt;31a81762a91b36d2a3210ca0bf929fa4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/liblangid.dylib 0x11011c000 - 0x11012afff libbz2.1.0.dylib x86_64 &lt;dc78bdfa5cb0386e97b09dedeeb048f8&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libbz2.1.0.dylib 0x110130000 - 0x11014afff liblzma.5.dylib x86_64 &lt;7a19c9a4e7b930b7a32c9ab778b9bcd4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/liblzma.5.dylib 0x110152000 - 0x1101dffff AppleJPEG x86_64 &lt;e0884d4cdfd63a3b91f54a9c5b5e0b8d&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AppleJPEG.framework/AppleJPEG 0x11023f000 - 0x110379fff CoreText x86_64 &lt;c28657f25ac837b4ab950f78e41e5d90&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreText.framework/CoreText 0x11041f000 - 0x110438fff CoreVideo x86_64 &lt;1869a884854b346bbd06dfafaf765470&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreVideo.framework/CoreVideo 0x11044f000 - 0x11045bfff OpenGLES x86_64 &lt;2e82c1d6cd293127b14be85f3f78c983&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/OpenGLES 0x110468000 - 0x110468fff FontServices x86_64 &lt;d57462a3c6c83a47850e8b5c208b54cc&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FontServices.framework/FontServices 0x11046d000 - 0x110481fff GraphicsServices x86_64 &lt;c351fe76be413e44a3b13d3160497f31&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/GraphicsServices.framework/GraphicsServices 0x110499000 - 0x11057bfff libFontParser.dylib x86_64 &lt;b506fe2b071c3a32bb95aa79ad96eb01&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FontServices.framework/libFontParser.dylib 0x110634000 - 0x11063efff libGFXShared.dylib x86_64 &lt;dad95c8768613142bf18ce4551145a6e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/libGFXShared.dylib 0x110646000 - 0x11068bfff libGLImage.dylib x86_64 &lt;cfe342e9fad03b839d345841c94f3b7b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/libGLImage.dylib 0x110695000 - 0x110697fff libCVMSPluginSupport.dylib x86_64 &lt;3927944c0d263f9aaa026dcc0d5e38e0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/libCVMSPluginSupport.dylib 0x11069d000 - 0x1106a5fff libCoreVMClient.dylib x86_64 &lt;ef6b47d7dda13f92945569e78548a759&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/libCoreVMClient.dylib 0x1106ae000 - 0x111371fff libLLVMContainer.dylib x86_64 &lt;15f2b50ec12c3b5eaf42159df72376df&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/OpenGLES.framework/libLLVMContainer.dylib 0x1116b8000 - 0x11179cfff UIFoundation x86_64 &lt;b2d0e3aedc8c3c66a901b7dafeaa1e2f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/UIFoundation.framework/UIFoundation 0x111810000 - 0x11181afff UserNotificationServices x86_64 &lt;bdff2d68e1bc3f3ab83e6516f3b34c6c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/UserNotificationServices.framework/UserNotificationServices 0x11182c000 - 0x111862fff FrontBoardServices x86_64 &lt;236f3bdbd0eb3e48b084acea42cb321f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FrontBoardServices.framework/FrontBoardServices 0x1118af000 - 0x1118f7fff BaseBoard x86_64 &lt;1a7979a63f5f30678004145f1c1fed0a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/BaseBoard.framework/BaseBoard 0x111948000 - 0x111a05fff CoreUI x86_64 &lt;ae1a6a3eb7ef3da0803688d9d2bdafa8&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/CoreUI.framework/CoreUI 0x111afd000 - 0x111decfff VideoToolbox x86_64 &lt;d818deb4d5b036f795eeeaf3bdf58617&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/VideoToolbox.framework/VideoToolbox 0x111e6a000 - 0x111e78fff MobileAsset x86_64 &lt;1c6c8a87693839d3918dd9e78d72e26e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/MobileAsset.framework/MobileAsset 0x111e88000 - 0x111ea7fff BackBoardServices x86_64 &lt;6db39b59eb313174836d9e7906fdb212&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/BackBoardServices.framework/BackBoardServices 0x111ed0000 - 0x1120a4fff CoreImage x86_64 &lt;7271d38b9e593543a956c13c5de5da6a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreImage.framework/CoreImage 0x1121f6000 - 0x11221bfff DictionaryServices x86_64 &lt;e317ebfeb1a734b3979053d75e497fad&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/DictionaryServices.framework/DictionaryServices 0x11223f000 - 0x112263fff SpringBoardServices x86_64 &lt;cc1a9a762b8b35faa95392b3e4622d4d&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/SpringBoardServices.framework/SpringBoardServices 0x112292000 - 0x1122d9fff AppSupport x86_64 &lt;b9622cb94ded38e08a59224510d859cb&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AppSupport.framework/AppSupport 0x112315000 - 0x112345fff TextInput x86_64 &lt;07de88f839b330af910590041812bb64&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/TextInput.framework/TextInput 0x112384000 - 0x112469fff WebKitLegacy x86_64 &lt;0c79980d94183ccb93144bc9eabcb6ae&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/WebKitLegacy.framework/WebKitLegacy 0x112529000 - 0x1135f4fff WebCore x86_64 &lt;67d6527a7ceb3c8fa85ce85c2bf38119&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/WebCore.framework/WebCore 0x113eec000 - 0x113fc6fff ProofReader x86_64 &lt;53554e5080083c5ea16438704ba83695&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ProofReader.framework/ProofReader 0x113ffc000 - 0x114006fff libAccessibility.dylib x86_64 &lt;17a037a4c93b3bb8ae12e830128e6d99&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libAccessibility.dylib 0x114019000 - 0x114070fff PhysicsKit x86_64 &lt;f93aa95b8d5133219d236f0a02b9b038&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/PhysicsKit.framework/PhysicsKit 0x11409c000 - 0x1140a6fff AssertionServices x86_64 &lt;3a58c83f614530a59403e96edba2b0e6&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AssertionServices.framework/AssertionServices 0x1140b9000 - 0x1144f0fff FaceCore x86_64 &lt;7971b628d43231a08f14ea7c4e2138b0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FaceCore.framework/FaceCore 0x114708000 - 0x11478dfff CoreMedia x86_64 &lt;dd9a55e018b8319d92fe4b2b0c9bd52f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreMedia.framework/CoreMedia 0x1147f7000 - 0x114850fff ColorSync x86_64 &lt;0681057f0a74363fa8d20aa7862c1e7b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ColorSync.framework/ColorSync 0x114872000 - 0x114874fff SimulatorClient x86_64 &lt;c2f2a63c1b7e384982099a98992c7721&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/SimulatorClient.framework/SimulatorClient 0x11487b000 - 0x1148c8fff CoreAudio x86_64 &lt;794b0ba43f1a3790b617f3fb253debeb&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreAudio.framework/CoreAudio 0x1148ec000 - 0x1148f0fff AggregateDictionary x86_64 &lt;b1bee24fe8e838d389075db856f7702b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/AggregateDictionary.framework/AggregateDictionary 0x1148f8000 - 0x114921fff libxslt.1.dylib x86_64 &lt;6c42a533a8703a36ad402b99fbf0f73c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libxslt.1.dylib 0x11492e000 - 0x114945fff libmarisa.dylib x86_64 &lt;e3ddc2ae594e3eb894dd994528a10deb&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libmarisa.dylib 0x114952000 - 0x114f13fff JavaScriptCore x86_64 &lt;c5c9fbe108973d42ad1ea2015d805490&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore 0x115091000 - 0x11537cfff AudioToolbox x86_64 &lt;28b1b9057fdf37dcb669386be1820c5c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AudioToolbox.framework/AudioToolbox 0x1154b2000 - 0x1154b7fff TCC x86_64 &lt;7a73d618505938a6a1fadda3aaf0f88c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/TCC.framework/TCC 0x1154c0000 - 0x11554efff LanguageModeling x86_64 &lt;6fd4f9ff9e393b1a87ab68a9df224e8d&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/LanguageModeling.framework/LanguageModeling 0x115564000 - 0x115575fff libcmph.dylib x86_64 &lt;a056b047f15a3df085065ed5f0368f16&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libcmph.dylib 0x11557e000 - 0x115670fff libiconv.2.dylib x86_64 &lt;192bd7fdc2943f0ea17b88dbdbc3329b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libiconv.2.dylib 0x115680000 - 0x115685fff MediaAccessibility x86_64 &lt;6e41f0c55b703cb2825e200350469a58&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/MediaAccessibility.framework/MediaAccessibility 0x115691000 - 0x115769fff AddressBookUI x86_64 &lt;58a5a1b2d8b63e62bc4671df5cec5596&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AddressBookUI.framework/AddressBookUI 0x11583e000 - 0x115f69fff VectorKit x86_64 &lt;36ef06e69448347b973f84f4486ecac2&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/VectorKit.framework/VectorKit 0x1161f1000 - 0x116268fff AddressBook x86_64 &lt;d4d77496b2443bcc9b8476c7c6a9cc79&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AddressBook.framework/AddressBook 0x1162bf000 - 0x11631ffff CoreLocation x86_64 &lt;a099137b2feb30ad82864ccda12993f2&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreLocation.framework/CoreLocation 0x116342000 - 0x1167a0fff GeoServices x86_64 &lt;ef3a5a767f7c3c81b7653763382ae25b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/GeoServices.framework/GeoServices 0x116aeb000 - 0x116afbfff ProtocolBuffer x86_64 &lt;e840436419f43a6b8cc22daff981f66e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ProtocolBuffer.framework/ProtocolBuffer 0x116b0d000 - 0x116b93fff Contacts x86_64 &lt;7e411c617cb53ad1b43f91e18de6fcb0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Contacts.framework/Contacts 0x116c4c000 - 0x116d4ffff ContactsUI x86_64 &lt;425fe9f6c9463295991786b39850b851&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/ContactsUI.framework/ContactsUI 0x116e35000 - 0x116e41fff IntlPreferences x86_64 &lt;b71be9b2f9e33eafab9a301e47a8e6fa&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/IntlPreferences.framework/IntlPreferences 0x116e4f000 - 0x116e6afff PlugInKit x86_64 &lt;c3066f229d413a048da42f603c2e9b43&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/PlugInKit.framework/PlugInKit 0x116e85000 - 0x116ebbfff Accounts x86_64 &lt;1f649ba6d7a33bc6b8b2eb93799ab4ee&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/Accounts.framework/Accounts 0x116eed000 - 0x117069fff AVFoundation x86_64 &lt;904190b56923390191dea51a838bd14f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AVFoundation.framework/AVFoundation 0x1171ef000 - 0x1171f3fff CommunicationsFilter x86_64 &lt;ff85c618e7e63fada07316f1b9c8d1fc&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/CommunicationsFilter.framework/CommunicationsFilter 0x1171f9000 - 0x11721efff DataAccessExpress x86_64 &lt;e3eb7c5fb6b13a95810d4cfcdead074a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/DataAccessExpress.framework/DataAccessExpress 0x117242000 - 0x117300fff ManagedConfiguration x86_64 &lt;b66ed9c2ab553fd981e95750598ba938&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ManagedConfiguration.framework/ManagedConfiguration 0x117399000 - 0x1173d3fff CoreSpotlight x86_64 &lt;98bf6cfb785735eebf190db4b1c3ae64&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreSpotlight.framework/CoreSpotlight 0x117416000 - 0x117434fff vCard x86_64 &lt;9055c75785e4395d8996060255c1631b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/vCard.framework/vCard 0x117463000 - 0x11748cfff ContactsFoundation x86_64 &lt;63f515588ea93a06a063e73787d7d15c&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ContactsFoundation.framework/ContactsFoundation 0x1174cb000 - 0x117735fff CoreData x86_64 &lt;e358a02dacfd3e31a9992b6b7ea9e7c5&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreData.framework/CoreData 0x117854000 - 0x117856fff OAuth x86_64 &lt;732d326fd0983422aa6a09ea1938e7d7&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/OAuth.framework/OAuth 0x11785c000 - 0x117875fff libcompression.dylib x86_64 &lt;1823f7e097263ccd8b713df4f4788903&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libcompression.dylib 0x11787d000 - 0x1179c1fff MobileSpotlightIndex x86_64 &lt;6c81b940503b3f7e9a0bfd40658b5fdf&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/MobileSpotlightIndex.framework/MobileSpotlightIndex 0x117a0b000 - 0x117a0ffff ParsecSubscriptionServiceSupport x86_64 &lt;dcfd384db24a3ab5991d224a4824301f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ParsecSubscriptionServiceSupport.framework/ParsecSubscriptionServiceSupport 0x117a18000 - 0x117cabfff libmecabra.dylib x86_64 &lt;9f9feceeace7387aaa81ec59d0c3f9b1&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libmecabra.dylib 0x117d33000 - 0x117d38fff ConstantClasses x86_64 &lt;2f5266d656843f3c822dc0d2fd6aaa8e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/ConstantClasses.framework/ConstantClasses 0x117d41000 - 0x117d4cfff libChineseTokenizer.dylib x86_64 &lt;8d393ad002733693a63608ded180c4c4&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libChineseTokenizer.dylib 0x117d5b000 - 0x117dcdfff libAVFAudio.dylib x86_64 &lt;97ad418fb598389fb2c4115f634a61c7&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/AVFoundation.framework/libAVFAudio.dylib 0x117e29000 - 0x1180e3fff MediaToolbox x86_64 &lt;5587701cabc23ff0b1fd6d81d0309789&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/MediaToolbox.framework/MediaToolbox 0x1181ef000 - 0x118223fff Celestial x86_64 &lt;4cd1941e81a43e3e9ef4bee37a0ee762&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/Celestial.framework/Celestial 0x118274000 - 0x118275fff BTLEAudioController x86_64 &lt;a629490c2a8d3f48ba051bc19ee1d3da&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/BTLEAudioController.framework/BTLEAudioController 0x11827b000 - 0x1182dffff IMFoundation x86_64 &lt;5243547afc7834479cb6434788543d2f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/IMFoundation.framework/IMFoundation 0x11832a000 - 0x118336fff CommonUtilities x86_64 &lt;13c0b53f0c9d37a2915f0793fe809a9f&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/CommonUtilities.framework/CommonUtilities 0x118343000 - 0x118374fff libtidy.A.dylib x86_64 &lt;0e2291591e4b3f25881e6c4a98bb38e0&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libtidy.A.dylib 0x118385000 - 0x118394fff CacheDelete x86_64 &lt;e35e427c786c35429fac8b60b27650a7&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/CacheDelete.framework/CacheDelete 0x1183a2000 - 0x1183c4fff PersistentConnection x86_64 &lt;e9fd98bc5ac739bfb4f4979f159fc2cd&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/PersistentConnection.framework/PersistentConnection 0x1183ea000 - 0x1183f1fff DataMigration x86_64 &lt;e0a5b78e95763ff9874c17198d2ab6f7&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/DataMigration.framework/DataMigration 0x1183fd000 - 0x118471fff CoreTelephony x86_64 &lt;4cb6c821e0da3386848cdf10650ba48a&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreTelephony.framework/CoreTelephony 0x1184d9000 - 0x1184dffff libcupolicy.dylib x86_64 &lt;3b9f4709f1b139adb3630698596f4755&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libcupolicy.dylib 0x1184e9000 - 0x118520fff libTelephonyUtilDynamic.dylib x86_64 &lt;bdfdb334207d3deba45c9f2ceafd28fe&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libTelephonyUtilDynamic.dylib 0x11855e000 - 0x11857efff CoreBluetooth x86_64 &lt;5cb697ee9e803be689662c722d23792b&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreBluetooth.framework/CoreBluetooth 0x11ac19000 - 0x11ac21fff libMobileGestaltExtensions.dylib x86_64 &lt;f9379481b6703400a6affe719472b1e1&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libMobileGestaltExtensions.dylib 0x11ac7e000 - 0x11ac80fff libCGXType.A.dylib x86_64 &lt;a9d3ce5c71e1342b8837a140f26d1dcc&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreGraphics.framework/Resources/libCGXType.A.dylib 0x11ac8c000 - 0x11acb3fff libRIP.A.dylib x86_64 &lt;4fa5309d6dea38f1af4b8d1b3f33654e&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CoreGraphics.framework/Resources/libRIP.A.dylib 0x11ae05000 - 0x11ae10fff libGSFontCache.dylib x86_64 &lt;f24b9a1cdbe43bcfae632fc165171473&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/FontServices.framework/libGSFontCache.dylib 0x11bf53000 - 0x11bf7afff CoreServicesInternal x86_64 &lt;3f769739c15c3968a37853f346b0a862&gt; /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/PrivateFrameworks/CoreServicesInternal.framework/CoreServicesInternal2016-03-28 14:59:35.586 HomePageTest[4803:201212] 费时测试 ming1016","link":"/program//jian-ce/"},{"title":"iOS开发之用户登陆信息存储","text":"我们开发App的时候,常常涉及到用户登陆,那么就会涉及到用户信息的存储和用户的登陆状态 大致信息存储分为三种方式 一.单例模式，登陆后把用户数据存储在单例对象我通常是存在AppDelegate,存在这里的好处是,用户数据的生命周期与app运行周期相同,如果app关闭或者闪退,下次开启app就是未登陆状态,以下是部分关键代码 12345678910111213//AppDelegate.h文件#import &quot;User.h&quot;@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@property (strong, nonatomic) User *user;+(AppDelegate*)APP;@end//AppDelegate.m文件 这里只是增加了个方便的类方法而@implementation AppDelegate+(AppDelegate*)APP{ return (AppDelegate*)[[UIApplication sharedApplication] delegate];}- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions User 实体123456789101112131415161718192021#import &quot;BaseModel.h&quot;@interface User : BaseModel@property (strong, nonatomic) NSString *userID;@property (strong, nonatomic) NSString *userName;@property (strong, nonatomic) NSString *passdword;@property (strong, nonatomic) NSString *cellPhone;+ (NSURLSessionDataTask *)login:(NSDictionary *)paramDic Success:(void (^)(NSDictionary *result))success Failure:(void (^)(NSError *error))failue;@end- (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; if (![AppDelegate APP].user) { LoginViewController *login = [[LoginViewController alloc]init]; [self presentViewController:login animated:YES completion:nil]; } } 在RootViewController(一般都是app的第一个界面即可)中判断是否存在user对象,如果存在即登陆,可以获取user实体中的各种信息,如果不存在即未登陆,弹出登录框,登陆后赋值user对象 12345678910- (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; if (![AppDelegate APP].user) { LoginViewController *login = [[LoginViewController alloc]init]; [self presentViewController:login animated:YES completion:nil]; } } 登陆界面,登陆成功赋值user对象12345678910111213- (IBAction)loginTouched:(id)sender {//网络请求... [User login:@{@&quot;password&quot;:self.password.text, @&quot;cellphone&quot;:self.username.text} Success:^(NSDictionary *result) { [AppDelegate APP].user = [[User alloc]init]; [AppDelegate APP].user.cellphone = self.username.text; [AppDelegate APP].user.password = self.password.text;//如果登陆后反回的result是需要存的数据,确保User model中有对应的结构,之后利用JsonModel(https://github.com/icanzilb/JSONModel)等框架直接进行转换比如 [AppDelegate APP].user = [[User alloc] initWithDictionary:result error:nil]; } Failure:^(NSError *error) { }];} 这样就可以在任意类中[AppDelegate APP].user.cellphone 取类似数据了 二. NSUserDefaults .数据存储后可以关闭app后依然存在,只有卸载App 或者手动删除, 数据才会消失(注:NSUserDefaults存储的数据其实就是存储在了一个.plist文件中,任何人把设备连接电脑后都可以找到对应文件看见存储的原文内容,除非你存的时候加了密,所以NSUserDefaults之用来存储不是很重要的数据,比如用户名等) 接着第一种方法登陆的过程,如果我想登陆一次后记录用户的用户名,并且其他数据还是随着app生命周期,那么只需写入NSUserDefaults即可,记得不要忘了[userDefaults synchronize] 123456789101112131415161718- (IBAction)loginTouched:(id)sender {//网络请求... [User login:@{@&quot;password&quot;:self.password.text, @&quot;cellphone&quot;:self.username.text} Success:^(NSDictionary *result) { [AppDelegate APP].user = [[User alloc]init]; [AppDelegate APP].user.cellphone = self.username.text; [AppDelegate APP].user.password = self.password.text;//如果登陆后反回的result是需要存的数据,确保User model中有对应的结构,之后利用JsonModel(https://github.com/icanzilb/JSONModel)等框架直接进行转换比如 [AppDelegate APP].user = [[User alloc] initWithDictionary:result error:nil]; NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setObject:self.username.text forKey:@&quot;KEY_USER_NAME&quot;]; [userDefaults synchronize]; } Failure:^(NSError *error) { }];} 关闭app后,从新进入app,想读取这个数据只需要任意类中,即可获得存下的数据 12NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];NSString *username = [userDefaults objectForKey:@&quot;KEY_USER_NAME&quot;]; 三.钥匙串，数据可以删除app后依然存在,钥匙串由操作系统保护并且存储后的数据是比较安全的,长用来存储一些密码,私钥如果想存储用户的密码,当然可以存在NSUserDefaults中,但是直接存到 plist 里显然是不负责任的 用ios的 Security.framework 就可以实现钥匙串的访问、读写 这里我借助第三方开源库SSKeychain(https://github.com/soffes/sskeychain)与NSUserDefaults配合使用进行示例,如果想用原生方法自行学习 以下是User实体新增的三个类方法 用于操作信息 12345678910111213141516171819202122//清除数据+ (void)logoutAccount{ NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSString *username = [userDefaults objectForKey:@&quot;KEY_USER_NAME&quot;]; [SSKeychain deletePasswordForService:@&quot;KEY_KEYCHAIN_SERVICE&quot; account:username]; [userDefaults removeObjectForKey:@&quot;KEY_USER_NAME&quot;]; [userDefaults synchronize];}//获取 任意位置调用+ (void)getAccount:(void (^)(NSString *username,NSString *password))block{ NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; NSString *username = [userDefaults objectForKey:@&quot;KEY_USER_NAME&quot;]; NSString *password = [SSKeychain passwordForService:@&quot;KEY_KEYCHAIN_SERVICE&quot; account:username]; block(username?:@&quot;&quot;,password?:@&quot;&quot;);}//保存方法 登陆成功后调用+ (void)saveAccount:(NSString *)name andPassword:(NSString *)password { NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; [userDefaults setObject:name forKey:@&quot;KEY_USER_NAME&quot;]; [userDefaults synchronize]; [SSKeychain setPassword:password forService:@&quot;KEY_KEYCHAIN_SERVICE&quot; account:name];} 还是登陆的例子 1234567891011- (IBAction)loginTouched:(id)sender {//网络请求... [User login:@{@&quot;password&quot;:self.password.text, @&quot;cellphone&quot;:self.username.text} Success:^(NSDictionary *result) { [User saveAccount:self.username.text andPassword:self.password.text]; } Failure:^(NSError *error) { }];} 四. Cookie 结合 NSUserDefaults当你访问一个网站时，NSURLRequest都会帮你主动记录下来你访问的站点设置的Cookie，如果 Cookie 存在的话，会把这些信息放在 NSHTTPCookieStorage 容器中共享，当你下次再访问这个站点时，NSURLRequest会拿着上次保存下来了的Cookie继续去请求 1.如果服务器设置了失效时间Cookie 会被持久化到文件中，kill掉后系统自动保存，下次启动app会自动加载.binarycookies中的Cookies，以下是一条Cookie输出1&lt;NSHTTPCookie version:0 name:&quot;TestCookie&quot; value:&quot;my+cookie+value&quot; expiresDate:2016-04-08 09:31:09 +0000 created:2016-04-08 09:30:49 +0000 sessionOnly:FALSE domain:&quot;api.skyfox.org&quot; path:&quot;/&quot; isSecure:FALSE&gt; 2.如果没设置Cookie失效时间并且，，kill掉后系统不会自动保存Cookie，如果想持久化Cookie 模仿浏览器存住Cookie，使用NSUserDefaults存下即可,以下是一条Cookie输出1&lt;NSHTTPCookie version:0 name:&quot;TestCookie&quot; value:&quot;my+cookie+value&quot; expiresDate:(null) created:2016-04-08 09:33:34 +0000 sessionOnly:TRUE domain:&quot;api.skyfox.org&quot; path:&quot;/&quot; isSecure:FALSE&gt; 以下是关键代码 123456789101112131415//合适的时机保存Cookie- (void)saveCookies{ NSData *cookiesData = [NSKeyedArchiver archivedDataWithRootObject: [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]]; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject: cookiesData forKey: @&quot;org.skyfox.cookie&quot;]; [defaults synchronize];}//合适的时机加载Cookie 一般都是app刚刚启动的时候- (void)loadCookies{ NSArray *cookies = [NSKeyedUnarchiver unarchiveObjectWithData: [[NSUserDefaults standardUserDefaults] objectForKey: @&quot;org.skyfox.cookie&quot;]]; NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage]; for (NSHTTPCookie *cookie in cookies){ [cookieStorage setCookie: cookie]; }} Cookie详解：ios htttp网络请求cookie的读取与写入(NSHTTPCookieStorage)写在最后至于还有什么写文件，NSCoder归档等方式就不说了，不怎么常用和实用 天狐博客","link":"/program//login/"},{"title":"Objc Runtime ","text":"概述Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里https://www.opensource.apple.com/source/objc4/可以下到苹果维护的开源代码，GNU也有一个开源的runtime版本，他们都努力的保持一致。苹果官方的Runtime编程指南 Runtime函数Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现Objective-C中一样的功能。苹果官方文档https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html 里有详细的Runtime函数文档。 Class和Object基础数据结构Classobjc/runtime.h中objc_class结构体的定义如下： 12345678910111213141516struct objc_class {Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE; // 父类const char *name OBJC2_UNAVAILABLE; // 类名long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif} OBJC2_UNAVAILABLE; objc_ivar_list和objc_method_list的定义 1234567891011121314151617181920//objc_ivar_list结构体存储objc_ivar数组列表struct objc_ivar_list { int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;} OBJC2_UNAVAILABLE;//objc_method_list结构体存储着objc_method的数组列表struct objc_method_list { struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;} objc_object与idobjc_object是一个类的实例结构体，objc/objc.h中objc_object是一个类的实例结构体定义如下： 12345struct objc_object {Class isa OBJC_ISA_AVAILABILITY;};typedef struct objc_object *id; 向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。 objc_cacheobjc_class结构体中的cache字段用于缓存调用过的method。cache指针指向objc_cache结构体，这个结构体的定义如下 12345struct objc_cache {unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; //指定分配缓存bucket的总数。runtime使用这个字段确定线性查找数组的索引位置unsigned int occupied OBJC2_UNAVAILABLE; //实际占用缓存bucket总数Method buckets[1] OBJC2_UNAVAILABLE; //指向Method数据结构指针的数组，这个数组的总数不能超过mask+1，但是指针是可能为空的，这就表示缓存bucket没有被占用，数组会随着时间增长。}; Meta Classmeta class是一个类对象的类，当向对象发消息，runtime会在这个对象所属类方法列表中查找发送消息对应的方法，但当向类发送消息时，runtime就会在这个类的meta class方法列表里查找。所有的meta class，包括Root class，Superclass，Subclass的isa都指向Root class的meta class，这样能够形成一个闭环。 12345678910111213141516171819202122232425262728void TestMetaClass(id self, SEL _cmd) { NSLog(@&quot;This objcet is %p&quot;, self); NSLog(@&quot;Class is %@, super class is %@&quot;, [self class], [self superclass]); Class currentClass = [self class]; // for (int i = 0; i &lt; 4; i++) { NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass); //通过objc_getClass获得对象isa，这样可以回溯到Root class及NSObject的meta class，可以看到最后指针指向的是0x0和NSObject的meta class类地址一样。 currentClass = objc_getClass((__bridge void *)currentClass); } NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]); NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, objc_getClass((__bridge void *)[NSObject class]));}@implementation Test- (void)ex_registerClassPair { Class newClass = objc_allocateClassPair([NSError class], &quot;TestClass&quot;, 0); class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, &quot;v@:&quot;); objc_registerClassPair(newClass); id instance = [[newClass alloc] initWithDomain:@&quot;some domain&quot; code:0 userInfo:nil]; [instance performSelector:@selector(testMetaClass)];}@end 运行结果 123456782014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b02014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b02014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x02014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x02014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x02014-10-20 22:57:07.353 mountain[1303:41490] NSObject&apos;s class is 0xe100002014-10-20 22:57:07.354 mountain[1303:41490] NSObject&apos;s meta class is 0x0 举个例子 1234567891011121314151617@interface Sark : NSObject@end@implementation Sark@endint main(int argc, const char * argv[]) { @autoreleasepool { BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); } return 0;}//输出2014-11-05 14:45:08.474 Test[9412:721945] 1 0 0 0 先看看isKindOfClass和isMemberOfClass在Object.mm中的实现 12345678910111213- (BOOL)isKindOf:aClass{ Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;}- (BOOL)isMemberOf:aClass{ return isa == (Class)aClass;} res1中，可以从isKindOfClass看出NSObject class的isa第一次会指向NSObject的Meta Class，接着Super class时会NSObject的Meta Class根据前面讲的闭环可以知道是会指到NSObject class，这样res1的bool值就是真了。 res2的话因为是isMemberOf就只有一次，那么是NSObject的Meta Class和NSObject class不同返回的bool值就是false了。 res3第一次是Sark Meta Class，第二次super class 后就是NSObject Meta Class了，返回也是false res4是Sark Meta Class，所以返回也是false 类与对象操作函数runtime有很多的函数可以操作类和对象。类相关的是class为前缀，对象相关操作是objc或object_为前缀。 类相关操作函数name12// 获取类的类名const char * class_getName ( Class cls ); super_class和meta-class12345// 获取类的父类Class class_getSuperclass ( Class cls );// 判断给定的Class是否是一个meta classBOOL class_isMetaClass ( Class cls ); instance_size12// 获取实例大小size_t class_getInstanceSize ( Class cls ); 成员变量(ivars)及属性12345678910111213141516171819202122232425//成员变量操作函数// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class cls, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types ); //这个只能够向在runtime时创建的类添加成员变量// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); //必须使用free()来释放这个数组//属性操作函数// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class cls, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount ); methodLists123456789101112131415161718192021// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types ); //和成员变量不同的是可以为类动态添加方法。如果有同名会返回NO，修改的话需要使用method_setImplementation// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel ); objc_protocol_list12345678// 添加协议BOOL class_addProtocol ( Class cls, Protocol *protocol );// 返回类是否实现指定的协议BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );// 返回类实现的协议列表Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount ); version12345// 获取版本号int class_getVersion ( Class cls );// 设置版本号void class_setVersion ( Class cls, int version ); 实例通过实例来消化下上面的那些函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142//-----------------------------------------------------------// MyClass.h@interface MyClass : NSObject &lt;NSCopying, NSCoding&gt;@property (nonatomic, strong) NSArray *array;@property (nonatomic, copy) NSString *string;- (void)method1;- (void)method2;+ (void)classMethod1;@end//-----------------------------------------------------------// MyClass.m#import &quot;MyClass.h&quot;@interface MyClass () {NSInteger _instance1;NSString * _instance2;}@property (nonatomic, assign) NSUInteger integer;- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;@end@implementation MyClass+ (void)classMethod1 {}- (void)method1 { NSLog(@&quot;call method method1&quot;);}- (void)method2 {}- (void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 { NSLog(@&quot;arg1 : %ld, arg2 : %@&quot;, arg1, arg2);}@end//-----------------------------------------------------------// main.h#import &quot;MyClass.h&quot;#import &quot;MySubClass.h&quot;#import &lt;objc/runtime.h&gt;int main(int argc, const char * argv[]) { @autoreleasepool { MyClass *myClass = [[MyClass alloc] init]; unsigned int outCount = 0; Class cls = myClass.class; // 类名 NSLog(@&quot;class name: %s&quot;, class_getName(cls)); NSLog(@&quot;==========================================================&quot;); // 父类 NSLog(@&quot;super class name: %s&quot;, class_getName(class_getSuperclass(cls))); NSLog(@&quot;==========================================================&quot;); // 是否是元类 NSLog(@&quot;MyClass is %@ a meta-class&quot;, (class_isMetaClass(cls) ? @&quot;&quot; : @&quot;not&quot;)); NSLog(@&quot;==========================================================&quot;); Class meta_class = objc_getMetaClass(class_getName(cls)); NSLog(@&quot;%s&apos;s meta-class is %s&quot;, class_getName(cls), class_getName(meta_class)); NSLog(@&quot;==========================================================&quot;); // 变量实例大小 NSLog(@&quot;instance size: %zu&quot;, class_getInstanceSize(cls)); NSLog(@&quot;==========================================================&quot;); // 成员变量 Ivar *ivars = class_copyIvarList(cls, &amp;outCount); for (int i = 0; i &lt; outCount; i++) { Ivar ivar = ivars[i]; NSLog(@&quot;instance variable&apos;s name: %s at index: %d&quot;, ivar_getName(ivar), i); } free(ivars); Ivar string = class_getInstanceVariable(cls, &quot;_string&quot;); if (string != NULL) { NSLog(@&quot;instace variable %s&quot;, ivar_getName(string)); } NSLog(@&quot;==========================================================&quot;); // 属性操作 objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount); for (int i = 0; i &lt; outCount; i++) { objc_property_t property = properties[i]; NSLog(@&quot;property&apos;s name: %s&quot;, property_getName(property)); } free(properties); objc_property_t array = class_getProperty(cls, &quot;array&quot;); if (array != NULL) { NSLog(@&quot;property %s&quot;, property_getName(array)); } NSLog(@&quot;==========================================================&quot;); // 方法操作 Method *methods = class_copyMethodList(cls, &amp;outCount); for (int i = 0; i &lt; outCount; i++) { Method method = methods[i]; NSLog(@&quot;method&apos;s signature: %s&quot;, method_getName(method)); } free(methods); Method method1 = class_getInstanceMethod(cls, @selector(method1)); if (method1 != NULL) { NSLog(@&quot;method %s&quot;, method_getName(method1)); } Method classMethod = class_getClassMethod(cls, @selector(classMethod1)); if (classMethod != NULL) { NSLog(@&quot;class method : %s&quot;, method_getName(classMethod)); } NSLog(@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @&quot;&quot; : @&quot; not&quot;); IMP imp = class_getMethodImplementation(cls, @selector(method1)); imp(); NSLog(@&quot;==========================================================&quot;); // 协议 Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount); Protocol * protocol; for (int i = 0; i &lt; outCount; i++) { protocol = protocols[i]; NSLog(@&quot;protocol name: %s&quot;, protocol_getName(protocol)); } NSLog(@&quot;MyClass is%@ responsed to protocol %s&quot;, class_conformsToProtocol(cls, protocol) ? @&quot;&quot; : @&quot; not&quot;, protocol_getName(protocol)); NSLog(@&quot;==========================================================&quot;); } return 0;} 输出结果 12345678910111213141516171819202122232425262728293031323334353637383940412014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass&apos;s meta-class is MyClass2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 482014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable&apos;s name: _instance1 at index: 02014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable&apos;s name: _instance2 at index: 12014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable&apos;s name: _array at index: 22014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable&apos;s name: _string at index: 32014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable&apos;s name: _integer at index: 42014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property&apos;s name: array2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property&apos;s name: string2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property&apos;s name: integer2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method&apos;s signature: method12014-10-22 19:41:37.464 RuntimeTest[3189:156810] method&apos;s signature: method22014-10-22 19:41:37.464 RuntimeTest[3189:156810] method&apos;s signature: method3WithArg1:arg2:2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: integer2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: setInteger:2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: array2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: string2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: setString:2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method&apos;s signature: setArray:2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method&apos;s signature: .cxx_destruct2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method12014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod12014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method12014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ====================================== 动态创建类和对象动态创建类12345678// 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 使用实例 12345678910111213141516Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);objc_property_attribute_t type = {&quot;T&quot;, &quot;@\\&quot;NSString\\&quot;&quot;};objc_property_attribute_t ownership = { &quot;C&quot;, &quot;&quot; };objc_property_attribute_t backingivar = { &quot;V&quot;, &quot;_ivar1&quot;};objc_property_attribute_t attrs[] = {type, ownership, backingivar};class_addProperty(cls, &quot;property2&quot;, attrs, 3);objc_registerClassPair(cls);id instance = [[cls alloc] init];[instance performSelector:@selector(submethod1)];[instance performSelector:@selector(method1)]; 输出 122014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 12014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1 动态创建对象12345678// 创建类实例id class_createInstance ( Class cls, size_t extraBytes ); //会在heap里给类分配内存。这个方法和+alloc方法类似。// 在指定位置创建类实例id objc_constructInstance ( Class cls, void *bytes ); // 销毁类实例void * objc_destructInstance ( id obj ); //不会释放移除任何相关引用 测试下效果 123456//可以看出class_createInstance和alloc的不同id theObject = class_createInstance(NSString.class, sizeof(unsigned));id str1 = [theObject init];NSLog(@&quot;%@&quot;, [str1 class]);id str2 = [[NSString alloc] initWithString:@&quot;test&quot;];NSLog(@&quot;%@&quot;, [str2 class]); 输出结果 122014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString2014-10-23 12:46:50.781 RuntimeTest[4039:89088] __NSCFConstantString 实例操作函数这些函数是针对创建的实例对象的一系列操作函数。 整个对象操作的函数1234// 返回指定对象的一份拷贝id object_copy ( id obj, size_t size );// 释放指定对象占用的内存id object_dispose ( id obj ); 应用场景 12345//把a转换成占用更多空间的子类bNSObject *a = [[NSObject alloc] init];id newB = object_copy(a, class_getInstanceSize(MyClass.class));object_setClass(newB, MyClass.class);object_dispose(a); 对象实例变量进行操作的函数12345678910// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value ); 对对象类操作123456// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls ); 获取类定义12345678910111213// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name ); 演示如何使用 123456789101112131415int numClasses;Class * classes = NULL;numClasses = objc_getClassList(NULL, 0);if (numClasses &gt; 0) { classes = malloc(sizeof(Class) * numClasses); numClasses = objc_getClassList(classes, numClasses); NSLog(@&quot;number of classes: %d&quot;, numClasses); for (int i = 0; i &lt; numClasses; i++) { Class cls = classes[i]; NSLog(@&quot;class name: %s&quot;, class_getName(cls)); } free(classes);} 结果如下： 1234567891011122014-10-23 16:20:52.589 RuntimeTest[8437:188589] number of classes: 12822014-10-23 16:20:52.589 RuntimeTest[8437:188589] class name: DDTokenRegexp2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: _NSMostCommonKoreanCharsKeySet2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: OS_xpc_dictionary2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSFileCoordinator2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSAssertionHandler2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: PFUbiquityTransactionLogMigrator2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSNotification2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSKeyValueNilSetEnumerator2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: OS_tcp_connection_tls_session2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: _PFRoutines......还有大量输出 成员变量与属性基础数据类型Ivar实例变量类型，指向objc_ivar结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。 12345678910typedef struct objc_ivar *Ivar;struct objc_ivar {char *ivar_name OBJC2_UNAVAILABLE; // 变量名char *ivar_type OBJC2_UNAVAILABLE; // 变量类型int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef __LP64__int space OBJC2_UNAVAILABLE;#endif} objc_property_t属性类型，指向objc_property结构体 1typedef struct objc_property *objc_property_t; 通过class_copyPropertyList和protocol_copyPropertyList方法获取类和协议的属性 12objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 示例 1234567891011121314151617181920212223242526272829@interface Lender : NSObject { float alone;}@property float alone;@end//获取属性列表id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);//查找属性名称const char *property_getName(objc_property_t property)//通过给出的名称来在类和协议中获取属性的引用objc_property_t class_getProperty(Class cls, const char *name)objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)//发掘属性名称和@encode类型字符串const char *property_getAttributes(objc_property_t property)//从一个类中获取它的属性id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount, i;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);for (i = 0; i &lt; outCount; i++) { objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\\n&quot;, property_getName(property), property_getAttributes(property));} objc_property_attribute_t也是结构体，定义属性的attribute 1234typedef struct { const char *name; // 特性名 const char *value; // 特性值} objc_property_attribute_t; 示例下面代码会编译出错，Runtime Crash还是正常输出 1234567891011121314151617181920212223242526272829303132@interface Sark : NSObject@property (nonatomic, copy) NSString *name;@end@implementation Sark- (void)speak{ NSLog(@&quot;my name is %@&quot;, self.name);}@end@interface Test : NSObject@end@implementation Test- (instancetype)init{ self = [super init]; if (self) { id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak]; } return self;}@endint main(int argc, const char * argv[]) { @autoreleasepool { [[Test alloc] init]; } return 0;}//结果正常输出2014-11-07 14:08:25.698 Test[1097:57255] my name is obj为指向Sark Class的指针，相当于Sark的实例对象但是还是不一样，根据objc_msgSend流程，obj指针能够在方法列表中找到speak方法，所以运行正常。 为了得到self.name能够输出的原因，可以加入调试代码 123456789101112131415161718192021222324252627282930313233343536- (void)speak{ unsigned int numberOfIvars = 0; Ivar *ivars = class_copyIvarList([self class], &amp;numberOfIvars); for(const Ivar *p = ivars; p &lt; ivars+numberOfIvars; p++) { Ivar const ivar = *p; ptrdiff_t offset = ivar_getOffset(ivar); const char *name = ivar_getName(ivar); NSLog(@&quot;Sark ivar name = %s, offset = %td&quot;, name, offset); } NSLog(@&quot;my name is %p&quot;, &amp;_name); NSLog(@&quot;my name is %@&quot;, *(&amp;_name));}@implementation Test- (instancetype)init{ self = [super init]; if (self) { NSLog(@&quot;Test instance = %@&quot;, self); void *self2 = (__bridge void *)self; NSLog(@&quot;Test instance pointer = %p&quot;, &amp;self2); id cls = [Sark class]; NSLog(@&quot;Class instance address = %p&quot;, cls); void *obj = &amp;cls; NSLog(@&quot;Void *obj = %@&quot;, obj); [(__bridge id)obj speak]; } return self;}@end//输出2014-11-11 00:56:02.464 Test[10475:1071029] Test instance = 2014-11-11 00:56:02.464 Test[10475:1071029] Test instance pointer = 0x7fff5fbff7c82014-11-11 00:56:02.465 Test[10475:1071029] Class instance address = 0x1000023c82014-11-11 00:56:02.465 Test[10475:1071029] Void *obj = 2014-11-11 00:56:02.465 Test[10475:1071029] Sark ivar name = _name, offset = 82014-11-11 00:56:02.465 Test[10475:1071029] my name is 0x7fff5fbff7c82014-11-11 00:56:02.465 Test[10475:1071029] my name is Sark中Propertyname会被转换成ivar到类的结构里，runtime会计算ivar的地址偏移来找ivar的最终地址，根据输出可以看出Sark class的指针地址加上ivar的偏移量正好跟Test对象指针地址。 关联对象关联对象是在运行时添加的类似成员。 123456//将一个对象连接到其它对象static char myKey;objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);//获取一个新的关联的对象id anObject = objc_getAssociatedObject(self, &amp;myKey);//使用objc_removeAssociatedObjects函数移除一个关联对象 实例演示关联对象使用 1234567891011121314151617181920212223242526272829//动态的将一个Tap手势操作连接到任何UIView中。- (void)setTapActionWithBlock:(void (^)(void))block{ UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey); if (!gesture) { gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)]; [self addGestureRecognizer:gesture]; //将创建的手势对象和block作为关联对象 objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN); } objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);}//手势识别对象的target和action- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture{ if (gesture.state == UIGestureRecognizerStateRecognized) { void(^action)(void) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey); if (action) { action(); } }} 成员变量和属性的操作方法成员变量123456// 获取成员变量名const char * ivar_getName ( Ivar v );// 获取成员变量类型编码const char * ivar_getTypeEncoding ( Ivar v );// 获取成员变量的偏移量ptrdiff_t ivar_getOffset ( Ivar v ); Associated Objects123456789101112131415// 设置关联对象void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );// 获取关联对象id objc_getAssociatedObject ( id object, const void *key );// 移除关联对象void objc_removeAssociatedObjects ( id object );//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。enum { OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403}; 属性12345678// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 实例两个接口同样数据不同的字段名处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface MyObject: NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, copy) NSString * status;@end//返回字典数据有不同的字段名，一般是写两个方法，但是如果灵活用runtime只用写一个方法@{@&quot;name1&quot;: &quot;张三&quot;, @&quot;status1&quot;: @&quot;start&quot;}@{@&quot;name2&quot;: &quot;张三&quot;, @&quot;status2&quot;: @&quot;end&quot;}//定义一个映射字典（全局）static NSMutableDictionary *map = nil;@implementation MyObject+ (void)load{map = [NSMutableDictionary dictionary];map[@&quot;name1&quot;] = @&quot;name&quot;;map[@&quot;status1&quot;] = @&quot;status&quot;;map[@&quot;name2&quot;] = @&quot;name&quot;;map[@&quot;status2&quot;] = @&quot;status&quot;;}@end//不同字段映射到MyObject相同属性上- (void)setDataWithDic:(NSDictionary *)dic{ [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) { NSString *propertyKey = [self propertyForKey:key]; if (propertyKey) { objc_property_t property = class_getProperty([self class], [propertyKey UTF8String]); // TODO: 针对特殊数据类型做处理 NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; ... [self setValue:obj forKey:propertyKey]; } }];} Method和消息Method和消息的基础数据类型SEL选择器表示一个方法的selector的指针，可以理解为Method中的ID类型 123456typedef struct objc_selector *SEL;//objc_selector编译时会根据每个方法名字参数序列生成唯一标识SEL sel1 = @selector(method1);NSLog(@&quot;sel : %p&quot;, sel1);输出2014-10-30 18:40:07.518 RuntimeTest[52734:466626] sel : 0x100002d72 获取SEL的三个方法： sel_registerName函数 Objective-C编译器提供的@selector() NSSelectorFromString()方法 IMP是函数指针，指向方法的首地址，通过SEL快速得到对应IMP，这时可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下 1id (*IMP)(id, SEL, ...) Method用于表示类定义中的方法 1234567typedef struct objc_method *Method;struct objc_method { SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; //是个char指针，存储着方法的参数类型和返回值类型 IMP method_imp OBJC2_UNAVAILABLE; // 方法实现，函数指针} Method相关操作函数Method1234567891011121314151617181920212223242526// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名，希望获得方法明的C字符串，使用sel_getName(method_getName(method))SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); Method的SEL12345678// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); Method调用流程消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。 12//这个函数将消息接收者和方法名作为基础参数。消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行，没找到就在分发列表里查找方法的selector，没找到就通过objc_msgSend结构体中指向父类的指针找到父类，然后在父类分发列表找，直到root class（NSObject）。objc_msgSend(receiver, selector, arg1, arg2, ...) 编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。如果是传递给超类就会调用带super的函数，如果返回是数据结构而不是一个值就会调用带stret的函数。在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。 举个例子，NSStringFromClass([self class])和NSStringFromClass([super class])输出都是self的类名。原因如下 调用[self class]的时候先调用objc_msgSend，发现self没有class这个方法，然后用objc_msgSendSuper就去父类找，还是没有，继续用objc_msgSendSuper到NSObject里找，结果找到了，查找NSObject中class方法的runtime源码会发现它会返回self，所以[self class]会返回self本身。同理[super class]相对前者就是少了objc_msgSend这一步，最后也会找到NSObject根类里的class方法，自然结果也是返回了self。 Method中的接收消息对象参数和方法选择器参数在Method中使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入的同时还有方法选择器。 获取Method地址使用NSObject提供的methodForSelector:方法可以获得Method的指针，通过指针调用实现代码。 123456void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); Method转发如果使用[object message]调用方法，object无法响应message时就会报错。用performSelector…调用就要等到运行时才确定是否能接受，不能才崩溃。 1234//先调用respondsToSelector:来判断一下if ([self respondsToSelector:@selector(method)]) { [self performSelector:@selector(method)];} Method转发机制分为三步： 动态方法解析1234567891011void functionForMethod1(id self, SEL _cmd) { NSLog(@&quot;%@, %p&quot;, self, _cmd);}+ (BOOL)resolveInstanceMethod:(SEL)sel { NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) { class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); } return [super resolveInstanceMethod:sel];} 可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性 123456789101112131415161718//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。可以通过重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法和类方法实现。最后用class_addMethod完成添加特定方法实现的操作@dynamic propertyName;//void dynamicMethodIMP(id self, SEL _cmd) { // implementation ....}@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL{ if (aSEL == @selector(resolveThisMethodDynamically)) { //v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; } return [super resolveInstanceMethod:aSEL];}@end 重定向接收者如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector{ if(aSelector == @selector(mysteriousMethod:)){ return alternateObject; } return [super forwardingTargetForSelector:aSelector];} 使用这个方法通常在对象内部，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344@interface SUTRuntimeMethodHelper : NSObject- (void)method2;@end@implementation SUTRuntimeMethodHelper- (void)method2 { NSLog(@&quot;%@, %p&quot;, self, _cmd);}@end#pragma mark -@interface SUTRuntimeMethod () { SUTRuntimeMethodHelper *_helper;}@end@implementation SUTRuntimeMethod+ (instancetype)object { return [[self alloc] init];}- (instancetype)init { self = [super init]; if (self != nil) { _helper = [[SUTRuntimeMethodHelper alloc] init]; } return self;}- (void)test { [self performSelector:@selector(method2)];}- (id)forwardingTargetForSelector:(SEL)aSelector { NSLog(@&quot;forwardingTargetForSelector&quot;); NSString *selectorString = NSStringFromSelector(aSelector); // 将消息转发给_helper来处理 if ([selectorString isEqualToString:@&quot;method2&quot;]) { return _helper; } return [super forwardingTargetForSelector:aSelector];}@end 最后进行转发如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法 1234//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。- (void)forwardInvocation:(NSInvocation *)anInvocation//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 范例 12345678910111213141516- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) { if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) { signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; } } return signature;}- (void)forwardInvocation:(NSInvocation *)anInvocation { if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:_helper]; }} 转发和多继承转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。 Message消息的参考文章 Message forwarding https://mikeash.com/pyblog/friday-qa-2009-03-27-objective-c-message-forwarding.html Objective-c messaging https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objective-c-messaging.html The faster objc_msgSend https://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html Method Swizzling是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。 使用method swizzling需要注意的问题 Swizzling应该总在+load中执行：Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载 Swizzling应该总是在dispatch_once中执行：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。 Selector，Method和Implementation：这几个之间关系可以这样理解，一个类维护一个运行时可接收的消息分发表，分发表中每个入口是一个Method，其中key是一个特定的名称，及SEL，与其对应的实现是IMP即指向底层C函数的指针。 举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); //通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); //如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。 if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } });}#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated { [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, self);}@end method_exchangeImplementations做的事情和如下代码是一样的 1234IMP imp1 = method_getImplementation(m1);IMP imp2 = method_getImplementation(m2);method_setImplementation(m1, imp2);method_setImplementation(m2, imp1); 另一种Method Swizzling的实现 123456789101112131415- (void)replacementReceiveMessage:(const struct BInstantMessage *)arg1 { NSLog(@&quot;arg1 is %@&quot;, arg1); [self replacementReceiveMessage:arg1];}+ (void)load { SEL originalSelector = @selector(ReceiveMessage:); SEL overrideSelector = @selector(replacementReceiveMessage:); Method originalMethod = class_getInstanceMethod(self, originalSelector); Method overrideMethod = class_getInstanceMethod(self, overrideSelector); if (class_addMethod(self, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) { class_replaceMethod(self, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, overrideMethod); }} 这里有几个关于Method Swizzling的资源可以参考 How do I implement method swizzling? https://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling Method Swizzling https://nshipster.com/method-swizzling/ What are the Dangers of Method Swizzling in Objective C? https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c JRSwizzle https://github.com/rentzsch/jrswizzle Protocol和Category基础数据类型Category指向分类的结构体的指针 123456789typedef struct objc_category *Category;struct objc_category { char *category_name OBJC2_UNAVAILABLE; // 分类名 char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表，Meta Class方法列表的子集 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表} Category里面的方法加载过程，objc源码中找到objc-os.mm，函数_objc_init就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，_read_images开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。下面是加载代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Discover categories.for (EACH_HEADER) { category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) { category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) { // Category&apos;s target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) { _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); } continue; } // Process this category. // First, register the category with its target class. // Then, rebuild the class&apos;s method lists (etc) if // the class is realized. BOOL classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) { remethodizeClass(cls); classExists = YES; } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, cls-&gt;nameForLogging(), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); } } if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) { addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) { remethodizeClass(cls-&gt;ISA()); } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, cls-&gt;nameForLogging(), cat-&gt;name); } } }}//调用remethodizeClass方法，在其实现里调用attachCategoryMethodsstatic voidattachCategoryMethods(Class cls, category_list *cats, bool flushCaches){ if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); bool isMeta = cls-&gt;isMetaClass(); method_list_t **mlists = (method_list_t **) _malloc_internal(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; BOOL fromBundle = NO; while (i--) { method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta); if (mlist) { mlists[mcount++] = mlist; fromBundle |= cats-&gt;list[i].fromBundle; } } attachMethodLists(cls, mlists, mcount, NO, fromBundle, flushCaches); _free_internal(mlists);} 示例，下面的代码会编译错误，Runtime Crash还是会正常输出 12345678910111213141516171819@interface NSObject (Sark)+ (void)foo;@end@implementation NSObject (Sark)- (void)foo{ NSLog(@&quot;IMP: -[NSObject(Sark) foo]&quot;);}@endint main(int argc, const char * argv[]) { @autoreleasepool { [NSObject foo]; [[NSObject new] foo]; } return 0;}//结果，正常输出结果如下2014-11-06 13:11:46.694 Test[14872:1110786] IMP: -[NSObject(Sark) foo]2014-11-06 13:11:46.695 Test[14872:1110786] IMP: -[NSObject(Sark) foo] objc runtime加载后NSObject的Sark Category被加载，头文件+(void)foo没有IMP，只会出现一个warning。被加到Class的Method list里的方法只有-(void)foo，Meta Class的方法列表里没有。 执行[NSObject foo]时，会在Meta Class的Method list里找，找不着就继续往super class里找，NSObject Meta Clas的super class是NSObject本身，这时在NSObject的Method list里就有foo这个方法了，能够正常输出。 执行[[NSObject new] foo]就简单的多了，[NSObject new]生成一个实例，实例的Method list是有foo方法的，于是正常输出。 ProtocolProtocol其实就是一个对象结构体 1typedef struct objc_object Protocol; 操作函数Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。 123456789101112131415161718192021222324252627282930313233343536373839404142@interface RuntimeCategoryClass : NSObject- (void)method1;@end@interface RuntimeCategoryClass (Category)- (void)method2;@end@implementation RuntimeCategoryClass- (void)method1 {}@end@implementation RuntimeCategoryClass (Category)- (void)method2 {}@end#pragma mark -NSLog(@&quot;测试objc_class中的方法列表是否包含分类中的方法&quot;);unsigned int outCount = 0;Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);for (int i = 0; i &lt; outCount; i++) { Method method = methodList[i]; const char *name = sel_getName(method_getName(method)); NSLog(@&quot;RuntimeCategoryClass&apos;s method: %s&quot;, name); if (strcmp(name, sel_getName(@selector(method2)))) { NSLog(@&quot;分类方法method2在objc_class的方法列表中&quot;); }}//输出2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&apos;s method: method22014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&apos;s method: method12014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中 Runtime提供了Protocol的一系列函数操作，函数包括 123456789101112131415161718192021222324252627282930// 返回指定的协议Protocol * objc_getProtocol ( const char *name );// 获取运行时所知道的所有协议的数组Protocol ** objc_copyProtocolList ( unsigned int *outCount );// 创建新的协议实例Protocol * objc_allocateProtocol ( const char *name );// 在运行时中注册新创建的协议void objc_registerProtocol ( Protocol *proto ); //创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。// 为协议添加方法void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );// 添加一个已注册的协议到协议中void protocol_addProtocol ( Protocol *proto, Protocol *addition );// 为协议添加属性void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );// 返回协议名const char * protocol_getName ( Protocol *p );// 测试两个协议是否相等BOOL protocol_isEqual ( Protocol *proto, Protocol *other );// 获取协议中指定条件的方法的方法描述数组struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );// 获取协议中指定方法的方法描述struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );// 获取协议中的属性列表objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );// 获取协议的指定属性objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );// 获取协议采用的协议Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );// 查看协议是否采用了另一个协议BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other ); Blockruntime中一些支持block操作的函数 12345678// 创建一个指针函数的指针，该函数调用时会调用特定的blockIMP imp_implementationWithBlock ( id block );// 返回与IMP(使用imp_implementationWithBlock创建的)相关的blockid imp_getBlock ( IMP anImp );// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝BOOL imp_removeBlock ( IMP anImp ); 测试代码 1234567891011121314151617@interface MyRuntimeBlock : NSObject@end@implementation MyRuntimeBlock@endIMP imp = imp_implementationWithBlock(^(id obj, NSString *str) { NSLog(@&quot;%@&quot;, str);});class_addMethod(MyRuntimeBlock.class, @selector(testBlock:), imp, &quot;v@:@&quot;);MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];[runtime performSelector:@selector(testBlock:) withObject:@&quot;hello world!&quot;];//结果2014-11-09 14:03:19.779 [1172:395446] hello world! Runtime的应用获取系统提供的库相关信息主要函数 12345678// 获取所有加载的Objective-C框架和动态库的名称const char ** objc_copyImageNames ( unsigned int *outCount );// 获取指定类所在动态库const char * class_getImageName ( Class cls );// 获取指定库或框架中所有类的类名const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount ); 通过这些函数就能够获取某个类所有的库，以及某个库中包含哪些类 123456789101112131415161718192021NSLog(@&quot;获取指定类所在动态库&quot;);NSLog(@&quot;UIView&apos;s Framework: %s&quot;, class_getImageName(NSClassFromString(@&quot;UIView&quot;)));NSLog(@&quot;获取指定库或框架中所有类的类名&quot;);const char ** classes = objc_copyClassNamesForImage(class_getImageName(NSClassFromString(@&quot;UIView&quot;)), &amp;outCount);for (int i = 0; i &lt; outCount; i++) { NSLog(@&quot;class name: %s&quot;, classes[i]);}//结果2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库2014-11-08 12:57:32.690 [747:184013] UIView&apos;s Framework: /System/Library/Frameworks/UIKit.framework/UIKit2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters...... 对App的用户行为进行追踪就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。 1234567891011121314151617181920212223242526272829303132333435363738//先定义一个类别，添加要Swizzled的方法@implementation UIViewController (Logging)- (void)swizzled_viewDidAppear:(BOOL)animated{ // call original implementation [self swizzled_viewDidAppear:animated]; // Logging [Logging logWithEventName:NSStringFromClass([self class])];}//接下来实现swizzle方法@implementation UIViewController (Logging)void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) { // the method might not exist in the class, but in its superclass Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // class_addMethod will fail if original method already exists BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // the method doesn’t exist and we just added one if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); }}//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉@implementation UIViewController (Logging)+ (void)load{ swizzleMethod([self class], @selector(viewDidAppear:), @selector(swizzled_viewDidAppear:));}//更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。void (gOriginalViewDidAppear)(id, SEL, BOOL);void newViewDidAppear(UIViewController *self, SEL _cmd, BOOL animated){ // call original implementation gOriginalViewDidAppear(self, _cmd, animated); // Logging [Logging logWithEventName:NSStringFromClass([self class])];}+ (void)load{ Method originalMethod = class_getInstanceMethod(self, @selector(viewDidAppear:)); gOriginalViewDidAppear = (void *)method_getImplementation(originalMethod); if(!class_addMethod(self, @selector(viewDidAppear:), (IMP) newViewDidAppear, method_getTypeEncoding(originalMethod))) { method_setImplementation(originalMethod, (IMP) newViewDidAppear); }} 通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做Cross Cutting Concernshttps://en.wikipedia.org/wiki/Cross-cutting_concern 用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫Aspect Oriented Programming https://en.wikipedia.org/wiki/Aspect-oriented_programming 目前有些第三方库可以很方便的使用AOP，比如Aspects https://github.com/steipete/Aspects 这里是使用Aspects的范例https://github.com/okcomp/AspectsDemoming1016","link":"/program//objc-runtime/"},{"title":"大话Socket","text":"要了解Socket首先要了解 TCP，他们两个的关系可以说是： Socket 是抽象出来的使用 TCP/UDP 的概念模型，屏蔽掉了晦涩的底层协议的实现，是一个接口。 最近看到了一张如此详细的 TCP 三次握手和四次挥手，打印一张放工位！摘自《图解网络硬件》249页 图5-11 《TCP的三次握手》所谓的X、X+1、Y、Y+1对应于你收到了没、我收到了、你收到’我收到’没、我收到了不用回了,为什么用+1表示呢？那是因为前两个指的是一个人，后两个指的是一个人。四组是三个连接，每个连接的序号依次是X、Y、Z。 TCP的连接过程就像两个人的对话： 想象一下，每次这俩儿人聊天，都要像下面这样一来一回三次，接下来他们才能【好好聊天了。。。】真是有点“作”。。。 我是客户端，树懒是服务端，演示三次握手、数据传输步骤其实有个问题，为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 而这一设计，主要是因为“服务器不是你想关就能关”。。。 比如说两个热恋中的人正在QQ上发送一个传mp4格式的文件， A说，我要下QQ了， B说：我知道了，你下吧。 A说，那我关了，（想关） 但是当A尝试关闭QQ的时候，QQ弹窗说“正在传输文件，传输完成后自动关闭QQ？” 这时候A对B说，呀，正在传东西，等传完了，我就关吧。（不能关） B说：行。既然关不掉，不行再聊会儿呗？ A：聊吧。。。传完了啊，下了啊（传输结束了–能关） B：下吧。我也下了。。。 就是多了一个Finish报文。 或者简单点表示是这样的：图片演示了四次挥手，与三次握手相比，只多了一个被动方确认自身任务Finish的动作。总结下相关的函数： 创建套接字 1Socket(af,type,protocol) 建立地址和套接字的联系 1bind(sockid, local addr, addrlen) 服务器端侦听客户端的请求 1listen( Sockid ,quenlen) 建立服务器/客户端的连接 (面向连接TCP） 客户端请求连接 1Connect(sockid, destaddr, addrlen) 服务器端等待从编号为Sockid的Socket上接收客户连接请求 1newsockid=accept(Sockid，Clientaddr, paddrlen) 发送/接收数据 面向连接： 12send(sockid, buff, bufflen) recv( ) 面向无连接： 12sendto(sockid,buff,…,addrlen) recvfrom( ) 释放套接字 1close(sockid) 至于为什么是三次握手，而不是二次握手，还有四次握手，可以看看下面的类比： 三次握手 二次握手 四次握手 参考：知乎 三次握手的对话，也挺像这个的，哈哈： A: How are you? B: I’m fine, thanks,and you? A: I’m fine too. Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//socket/"},{"title":"深入剖析 iOS 性能优化","text":"问题种类时间复杂度在集合里数据量小的情况下时间复杂度对于性能的影响看起来微乎其微。但如果某个开发的功能是一个公共功能，无法预料调用者传入数据的量时，这个复杂度的优化显得非常重要了。 上图列出了各种情况的时间复杂度，比如高效的排序算法一般都是 O(n log n)。接下来看看下图： 图中可以看出 O(n) 是个分水岭，大于它对于性能就具有很大的潜在影响，如果是个公共的接口一定要加上说明，自己调用也要做到心中有数。当然最好是通过算法优化或者使用合适的系统接口方法，权衡内存消耗争取通过空间来换取时间。 下面通过集合里是否有某个值来举个例子： 1234567891011121314151617181920//O(1)return array[idx] == value;//O(n)for (int i = 0; i &lt; count; i++) { if (array[i] == value) { return YES; }}return NO;//O(n2) 找重复的值for (int i = 0; i &lt; count; i++) { for (int j = 0; j &lt; count; j++) { if ( i != j &amp;&amp; array[i] == array[j]) { return YES; } }}return NO; 那么 OC 里几种常用集合对象提供的接口方法时间复杂度是怎么样的。 NSArray / NSMutableArray首先我们发现他们是有排序，并允许重复元素存在的，那么这么设计就表明了集合存储没法使用里面的元素做 hash table 的 key 进行相关的快速操作，。所以不同功能接口方法性能是会有很大的差异。 containsObject:，containsObject:，indexOfObject*，removeObject: 会遍历里面元素查看是否与之匹对，所以复杂度等于或大于 O(n) objectAtIndex:，firstObject:，lastObject:，addObject:，removeLastObject: 这些只针对栈顶栈底操作的时间复杂度都是 O(1) indexOfObject:inSortedRange:options:usingComparator: 使用的是二分查找，时间复杂度是 O(log n) NSSet / NSMutableSet / NSCountedSet这些集合类型是无序没有重复元素。这样就可以通过 hash table 进行快速的操作。比如 addObject:, removeObject:, containsObject: 都是按照 O(1) 来的。需要注意的是将数组转成 Set 时会将重复元素合成一个，同时失去排序。 NSDictionary / NSMutableDictionary和 Set 差不多，多了键值对应。添加删除和查找都是 O(1) 的。需要注意的是 Keys 必须是符合 NSCopying。 containsObject 方法在数组和 Set 里不同的实现在数组中的实现 123456789101112131415161718192021- (BOOL) containsObject: (id)anObject{ return ([self indexOfObject: anObject] != NSNotFound);}- (NSUInteger) indexOfObject: (id)anObject{ unsigned c = [self count]; if (c &gt; 0 &amp;&amp; anObject != nil) { unsigned i; IMP get = [self methodForSelector: oaiSel]; BOOL (*eq)(id, SEL, id) = (BOOL (*)(id, SEL, id))[anObject methodForSelector: eqSel]; for (i = 0; i &lt; c; i++) if ((*eq)(anObject, eqSel, (*get)(self, oaiSel, i)) == YES) return i; } return NSNotFound;} 可以看到会遍历所有元素在查找到后才进行返回. 接下来可以看看 containsObject 在 Set 里的实现： 1234567891011121314151617- (BOOL) containsObject: (id)anObject{ return (([self member: anObject]) ? YES : NO);}//在 GSSet,m 里有对 member 的实现- (id) member: (id)anObject{ if (anObject != nil) { GSIMapNode node = GSIMapNodeForKey(&amp;map, (GSIMapKey)anObject); if (node != 0) { return node-&gt;key.obj; } } return nil;} 找元素时是通过键值方式从 map 映射表里取出，因为 Set 里元素是唯一的，所以可以 hash 元素对象作为 key 达到快速获取值的目的。 用 GCD 来做优化我们可以通过 GCD 提供的方法来将一些需要耗时操作放到非主线程上做，使得 App 能够运行的更加流畅响应更快。但是使用 GCD 时需要注意避免可能引起线程爆炸和死锁的情况，还有非主线程处理任务也不是万能的，如果一个处理需要消耗大量内存或者大量CPU操作 GCD 也没法帮你，只能通过将处理进行拆解分步骤分时间进行处理才比较妥当。 异步处理事件 上图是最典型的异步处理事件的方法 需要耗时长的任务 将 GCD 的 block 通过 dispatch_block_create_with_qos_class 方法指定队列的 QoS 为 QOS_CLASS_UTILITY。这种 QoS 系统会针对大的计算，I/O，网络以及复杂数据处理做电量优化。 避免线程爆炸 使用串行队列 使用 NSOperationQueues 的并发限制方法 NSOperationQueue.maxConcurrentOperationCount 举个例子，下面的写法就比较危险，可能会造成线程爆炸和死锁 1234for (int i = 0; i &lt; 999; i++) { dispatch_async(q, ^{...});}dispatch_barrier_sync(q, ^{}); 那么怎么能够避免呢？首先可以使用 dispatch_apply 1dispatch_apply(999, q, ^(size_t i){...}); 或者使用 dispatch_semaphore 1#define CONCURRENT_TASKS 4sema = dispatch_semaphore_create(CONCURRENT_TASKS);for (int i = 0; i &lt; 999; i++){ dispatch_async(q, ^{ dispatch_semaphore_signal(sema); }); dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);} GCD 相关 Crash 日志管理线程问题 1234Thread 1:: Dispatch queue: com.apple.libdispatch-manager0 libsystem_kernel.dylib 0x00007fff8967e08a kevent_qos + 101 libdispatch.dylib 0x00007fff8be05811 _dispatch_mgr_invoke + 2512 libdispatch.dylib 0x00007fff8be05465 _dispatch_mgr_thread + 52 线程闲置时 1234Thread 6:0 libsystem_kernel.dylib 0x00007fff8967d772 __workq_kernreturn + 101 libsystem_pthread.dylib 0x00007fff8fd317d9 _pthread_wqthread + 12832 libsystem_pthread.dylib 0x00007fff8fd2ed95 start_wqthread + 13 线程活跃时 12345678910Thread 3 Crashed:: Dispatch queue: &lt;queue name&gt;&lt;my code&gt;7 libdispatch.dylib 0x07fff8fcfd323 _dispatch_call_block_and_release8 libdispatch.dylib 0x07fff8fcf8c13 _dispatch_client_callout + 89 libdispatch.dylib 0x07fff8fcfc365 _dispatch_queue_drain + 110010 libdispatch.dylib 0x07fff8fcfdecc _dispatch_queue_invoke + 20211 libdispatch.dylib 0x07fff8fcfb6b7 _dispatch_root_queue_drain + 46312 libdispatch.dylib 0x07fff8fd09fe4 _dispatch_worker_thread3 + 9113 libsystem_pthread.dylib 0x07fff93c17637 _pthread_wqthread + 72914 libsystem_pthread.dylib 0x07fff93c1540d start_wqthread + 13 主线程闲置时 12345678910Thread 0 Crashed:: Dispatch queue: com.apple.main-thread0 libsystem_kernel.dylib 0x00007fff906614de mach_msg_trap + 101 libsystem_kernel.dylib 0x00007fff9066064f mach_msg + 552 com.apple.CoreFoundation 0x00007fff9a8c1eb4 __CFRunLoopServiceMachPort3 com.apple.CoreFoundation 0x00007fff9a8c137b __CFRunLoopRun + 13714 com.apple.CoreFoundation 0x00007fff9a8c0bd8 CFRunLoopRunSpecific + 296...10 com.apple.AppKit 0x00007fff8e823c03 -[NSApplication run] + 59411 com.apple.AppKit 0x00007fff8e7a0354 NSApplicationMain + 183212 com.example 0x00000001000013b4 start + 52 主队列 123456789101112131415Thread 0 Crashed:: Dispatch queue: com.apple.main-thread&lt;my code&gt;12 com.apple.Foundation 0x00007fff931157e8 __NSBLOCKOPERATION_IS_CALLING_OUT_TO_A_BLOCK__ + 713 com.apple.Foundation 0x00007fff931155b5 -[NSBlockOperation main] + 914 com.apple.Foundation 0x00007fff93114a6c -[__NSOperationInternal _start:] + 65315 com.apple.Foundation 0x00007fff93114543 __NSOQSchedule_f + 18416 libdispatch.dylib 0x00007fff935d6c13 _dispatch_client_callout + 817 libdispatch.dylib 0x00007fff935e2cbf _dispatch_main_queue_callback_4CF + 86118 com.apple.CoreFoundation 0x00007fff8d9223f9 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__19 com.apple.CoreFoundation 0x00007fff8d8dd68f __CFRunLoopRun + 215920 com.apple.CoreFoundation 0x00007fff8d8dcbd8 CFRunLoopRunSpecific + 296...26 com.apple.AppKit 0x00007fff999a1bd3 -[NSApplication run] + 59427 com.apple.AppKit 0x00007fff9991e324 NSApplicationMain + 183228 libdyld.dylib 0x00007fff9480f5c9 start + 1 I/O 性能优化I/O 是性能消耗大户，任何的 I/O 操作都会使低功耗状态被打破，所以减少 I/O 次数是这个性能优化的关键点，为了达成这个目下面列出一些方法。 将零碎的内容作为一个整体进行写入 使用合适的 I/O 操作 API 使用合适的线程 使用 NSCache 做缓存能够减少 I/O NSCache 达到如图的目的为何不直接用字典来做呢？NSCache 具有字典的所有功能，同时还有如下的特性： 自动清理系统占用内存 NSCache 是线程安全 -(void)cache:(NSCache *)cache willEvictObject:(id)obj; 缓存对象将被清理时的回调 evictsObjectsWithDiscardedContent 可以控制是否清理 那么 NSCache是如何做到这些特性的呢？ 接下来学习下 NSCache 是如何做的。首先 NSCache 是会持有一个 NSMutableDictionary。 1234567891011@implementation NSCache- (id) init{ if (nil == (self = [super init])) { return nil; } _objects = [NSMutableDictionary new]; _accesses = [NSMutableArray new]; return self;} 需要设计一个 Cached 对象结构来保存一些额外的信息 12345678910@interface _GSCachedObject : NSObject{ @public id object; //cache 的值 NSString *key; //设置 cache 的 key int accessCount; //保存访问次数，用于自动清理 NSUInteger cost; //setObject:forKey:cost: BOOL isEvictable; //线程安全}@end 在 Cache 读取的时候会对 _accesses 数组的添加删除通过 isEvictable 布尔值来保证线程安全操作。使用 Cached 对象里的 accessCount 属性进行 +1 操作为后面自动清理的条件判断做准备。具体实现如下： 1234567891011121314151617- (id) objectForKey: (id)key{ _GSCachedObject *obj = [_objects objectForKey: key]; if (nil == obj) { return nil; } if (obj-&gt;isEvictable) //保证添加删除操作线程安全 { // 将 obj 移到 access list 末端 [_accesses removeObjectIdenticalTo: obj]; [_accesses addObject: obj]; } obj-&gt;accessCount++; _totalAccesses++; return obj-&gt;object;} 在每次 Cache 添加时会先去检查是否自动清理，会创建一个 Cached 对象将 key，object，cost 等信息记录下添加到 _accesses 数组和 _objects 字典里。 123456789101112131415161718192021222324- (void) setObject: (id)obj forKey: (id)key cost: (NSUInteger)num{ _GSCachedObject *oldObject = [_objects objectForKey: key]; _GSCachedObject *newObject; if (nil != oldObject) { [self removeObjectForKey: oldObject-&gt;key]; } [self _evictObjectsToMakeSpaceForObjectWithCost: num]; newObject = [_GSCachedObject new]; // Retained here, released when obj is dealloc&apos;d newObject-&gt;object = RETAIN(obj); newObject-&gt;key = RETAIN(key); newObject-&gt;cost = num; if ([obj conformsToProtocol: @protocol(NSDiscardableContent)]) { newObject-&gt;isEvictable = YES; [_accesses addObject: newObject]; } [_objects setObject: newObject forKey: key]; RELEASE(newObject); _totalCost += num;} 那么上面提到的自动清理内存的方法是如何实现的呢？既然是自动清理必定需要有触发时机和进入清理的条件判断，触发时机一个是发生在添加 Cache 内容时，一个是发生在内存警告时。条件判断代码如下： 12345678// cost 在添加新 cache 值时指定的 cost// _costLimit 是 totalCostLimit 属性值if (_costLimit &gt; 0 &amp;&amp; _totalCost + cost &gt; _costLimit){ spaceNeeded = _totalCost + cost - _costLimit;}// 只有当 cost 大于人工限制时才会清理// 或者 cost 设置为0不进行人工干预if (count &gt; 0 &amp;&amp; (spaceNeeded &gt; 0 || count &gt;= _countLimit)) 所以 NSCache 的 totalCostLimit 的值会和每次 Cache 添加的 cost 之和对比，超出限制必然触发内存清理。 清理时会对经常访问的 objects 不清理，主要是通过 _totalAccesses 和总数获得平均访问频率，如果那个对象的访问次数是小于平均值的才需要清理。 1234//_totalAccesses 所有的值的访问都会 +1NSUInteger averageAccesses = (_totalAccesses / count * 0.2) + 1;//accessCount 每次 obj 取值时会 +1if (obj-&gt;accessCount &lt; averageAccesses &amp;&amp; obj-&gt;isEvictable) 在清理之前还需要一些准备工作，包括标记 Cached 对象的 isEvictable 防止后面有不安全的线程操作。将满足条件的清理 objects 放到清理数组里，如果空间释放足够就不用再把更多的 objects 加到清理数组里了，最后遍历清理数组进行逐个清理即可。 12345678910111213141516NSUInteger cost = obj-&gt;cost;obj-&gt;cost = 0;// 不会被再次清除obj-&gt;isEvictable = NO;// 添加到 remove list 里if (_evictsObjectsWithDiscardedContent){ [evictedKeys addObject: obj-&gt;key];}_totalCost -= cost;// 如果已经释放了足够空间就不用后面操作了if (cost &gt; spaceNeeded){ break;}spaceNeeded -= cost; 在清理时会执行回调内容，这样如果有些缓存数据需要持续化存储可以在回调里进行处理。 123456789101112- (void) removeObjectForKey: (id)key{ _GSCachedObject *obj = [_objects objectForKey: key]; if (nil != obj) { [_delegate cache: self willEvictObject: obj-&gt;object]; _totalAccesses -= obj-&gt;accessCount; [_objects removeObjectForKey: key]; [_accesses removeObjectIdenticalTo: obj]; }} 完整的实现可以查看 GNUstep Base 的 NSCache.m 文件。 下面可以看看 NSCache 在 SDWebImage 的运用是怎么样的： 1234567891011121314151617- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key { return [self.memCache objectForKey:key];}- (UIImage *)imageFromDiskCacheForKey:(NSString *)key { // 检查 NSCache 里是否有 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) { return image; } // 从磁盘里读 UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) { NSUInteger cost = SDCacheCostForImage(diskImage); [self.memCache setObject:diskImage forKey:key cost:cost]; } return diskImage;} 可以看出利用 NSCache 自动释放内存的特点将图片都放到 NSCache 里这样在内存不够用时可以自动清理掉不常用的那些图片，在读取 Cache 里内容时如果没有被清理会直接返回图片数据，清理了的话才会执行 I/O 从磁盘读取图片，通过这种方式能够利用空间减少磁盘操作，空间也能够更加有效的控制释放。 控制 App 的 Wake 次数通知，VoIP，定位，蓝牙等都会使设备从 Standby 状态唤起。唤起这个过程会有比较大的消耗，应该避免频繁发生。通知方面主要要在产品层面多做考虑。定位方面，下面可以看看定位的一些 API 看看它们对性能的不同影响，便于考虑采用合适的接口。 连续的位置更新 1[locationManager startUpdatingLocation] 这个方法会时设备一直处于活跃状态。 延时有效定位 1[locationManager allowDeferredLocationUpdatesUntilTraveled: timeout:] 高效节能的定位方式，数据会缓存在位置硬件上。适合于跑步应用应该都采用这种方式。 重大位置变化 1[locationManager startMonitoringSignificantLocationChanges] 会更节能，对于那些只有在位置有很大变化的才需要回调的应用可以采用这种，比如天气应用。 区域监测 1[locationManager startMonitoringForRegion:(CLRegion *)] 也是一种节能的定位方式，比如在博物馆里按照不同区域监测展示不同信息之类的应用比较适合这种定位。 经常访问的地方 1// Start monitoringlocationManager.startMonitoringVisits()// Stop monitoring when no longer neededlocationManager.stopMonitoringVisits() 总的来说，不要轻易使用 startUpdatingLocation() 除非万不得已，尽快的使用 stopUpdatingLocation() 来结束定位还用户一个节能设备。 内存对于性能的影响首先 Reclaiming 内存是需要时间的，突然的大量内存需求是会影响响应的。 如何预防这些性能问题，需要刻意预防么坚持下面几个原则争取在编码阶段避免一些性能问题。 优化计算的复杂度从而减少 CPU 的使用 在应用响应交互的时候停止没必要的任务处理 设置合适的 QoS 将定时器任务合并，让 CPU 更多时候处于 idle 状态 那么如果写需求时来不及注意这些问题做不到预防的话，可以通过自动化代码检查的方式来避免这些问题吗？ 如何检查根据这些问题在代码里查，写工具或用工具自动化查？虽然可以，但是需要考虑的情况太多，现有工具支持不好，自己写需要考虑的点太多需要花费太长的时间，那么什么方式会比较好呢？ 通过监听主线程方式来监察首先用 CFRunLoopObserverCreate 创建一个观察者里面接受 CFRunLoopActivity 的回调，然后用 CFRunLoopAddObserver 将观察者添加到 CFRunLoopGetMain() 主线程 Runloop 的 kCFRunLoopCommonModes 模式下进行观察。 接下来创建一个子线程来进行监控，使用 dispatch_semaphore_wait 定义区间时间，标准是 16 或 20 微秒一次监控的话基本可以把影响响应的都找出来。监控结果的标准是根据两个 Runloop 的状态 BeforeSources 和 AfterWaiting 在区间时间是否能检测到来判断是否卡顿。 如何打印堆栈信息，保存现场打印堆栈整体思路是获取线程的信息得到线程的 state 从而得到线程里所有栈的指针，根据这些指针在 符号表里找到对应的描述即符号化解析，这样就能够展示出可读的堆栈信息。具体实现是怎样的呢？下面详细说说： 获取线程的信息这里首先是要通过 task_threads 取到所有的线程， 12345thread_act_array_t threads; //int 组成的数组比如 thread[1] = 5635mach_msg_type_number_t thread_count = 0; //mach_msg_type_number_t 是 int 类型const task_t this_task = mach_task_self(); //int//根据当前 task 获取所有线程kern_return_t kr = task_threads(this_task, &amp;threads, &amp;thread_count); 遍历时通过 thread_info 获取各个线程的详细信息 12345678910111213141516SMThreadInfoStruct threadInfoSt = {0};thread_info_data_t threadInfo;thread_basic_info_t threadBasicInfo;mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX;if (thread_info((thread_act_t)thread, THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) { threadBasicInfo = (thread_basic_info_t)threadInfo; if (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) { threadInfoSt.cpuUsage = threadBasicInfo-&gt;cpu_usage / 10; threadInfoSt.userTime = threadBasicInfo-&gt;system_time.microseconds; }}uintptr_t buffer[100];int i = 0;NSMutableString *reStr = [NSMutableString stringWithFormat:@&quot;Stack of thread: %u:\\n CPU used: %.1f percent\\n user time: %d second\\n&quot;, thread, threadInfoSt.cpuUsage, threadInfoSt.userTime]; 获取线程里所有栈的信息可以通过 thread_get_state 得到 machine context 里面包含了线程栈里所有的栈指针。 1234_STRUCT_MCONTEXT machineContext; //线程栈里所有的栈指针//通过 thread_get_state 获取完整的 machineContext 信息，包含 thread 状态信息mach_msg_type_number_t state_count = smThreadStateCountByCPU();kern_return_t kr = thread_get_state(thread, smThreadStateByCPU(), (thread_state_t)&amp;machineContext.__ss, &amp;state_count); 创建一个栈结构体用来保存栈的数据 123456789101112131415161718//为通用回溯设计结构支持栈地址由小到大，地址里存储上个栈指针的地址typedef struct SMStackFrame { const struct SMStackFrame *const previous; const uintptr_t return_address;} SMStackFrame;SMStackFrame stackFrame = {0};//通过栈基址指针获取当前栈帧地址const uintptr_t framePointer = smMachStackBasePointerByCPU(&amp;machineContext);if (framePointer == 0 || smMemCopySafely((void *)framePointer, &amp;stackFrame, sizeof(stackFrame)) != KERN_SUCCESS) { return @&quot;Fail frame pointer&quot;;}for (; i &lt; 32; i++) { buffer[i] = stackFrame.return_address; if (buffer[i] == 0 || stackFrame.previous == 0 || smMemCopySafely(stackFrame.previous, &amp;stackFrame, sizeof(stackFrame)) != KERN_SUCCESS) { break; }} 符号化符号化主要思想就是通过栈指针地址减去 Slide 地址得到 ASLR 偏移量，通过这个偏移量可以在 __LINKEDIT segment 查找到字符串和符号表的位置。具体代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394info-&gt;dli_fname = NULL;info-&gt;dli_fbase = NULL;info-&gt;dli_sname = NULL;info-&gt;dli_saddr = NULL;//根据地址获取是哪个 imageconst uint32_t idx = smDyldImageIndexFromAddress(address);if (idx == UINT_MAX) { return false;}/* Header ------------------ Load commands Segment command 1 -------------| Segment command 2 | ------------------ | Data | Section 1 data |segment 1 &lt;----| Section 2 data | &lt;----| Section 3 data | &lt;----| Section 4 data |segment 2 Section 5 data | ... | Section n data | *//*----------Mach Header---------*///根据 image 的序号获取 mach_headerconst struct mach_header* machHeader = _dyld_get_image_header(idx);//返回 image_index 索引的 image 的虚拟内存地址 slide 的数量，如果 image_index 超出范围返回0//动态链接器加载 image 时，image 必须映射到未占用地址的进程的虚拟地址空间。动态链接器通过添加一个值到 image 的基地址来实现，这个值是虚拟内存 slide 数量const uintptr_t imageVMAddressSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx);/*-----------ASLR 的偏移量---------*///https://en.wikipedia.org/wiki/Address_space_layout_randomizationconst uintptr_t addressWithSlide = address - imageVMAddressSlide;//根据 Image 的 Index 来获取 segment 的基地址//段定义Mach-O文件中的字节范围以及动态链接器加载应用程序时这些字节映射到虚拟内存中的地址和内存保护属性。 因此，段总是虚拟内存页对齐。 片段包含零个或多个节。const uintptr_t segmentBase = smSegmentBaseOfImageIndex(idx) + imageVMAddressSlide;if (segmentBase == 0) { return false;}//info-&gt;dli_fname = _dyld_get_image_name(idx);info-&gt;dli_fbase = (void*)machHeader;/*--------------Mach Segment-------------*///地址最匹配的symbolconst nlistByCPU* bestMatch = NULL;uintptr_t bestDistance = ULONG_MAX;uintptr_t cmdPointer = smCmdFirstPointerFromMachHeader(machHeader);if (cmdPointer == 0) { return false;}//遍历每个 segment 判断目标地址是否落在该 segment 包含的范围里for (uint32_t iCmd = 0; iCmd &lt; machHeader-&gt;ncmds; iCmd++) { const struct load_command* loadCmd = (struct load_command*)cmdPointer; /*----------目标 Image 的符号表----------*/ //Segment 除了 __TEXT 和 __DATA 外还有 __LINKEDIT segment，它里面包含动态链接器的使用的原始数据，比如符号，字符串和重定位表项。 //LC_SYMTAB 描述了 __LINKEDIT segment 内查找字符串和符号表的位置 if (loadCmd-&gt;cmd == LC_SYMTAB) { //获取字符串和符号表的虚拟内存偏移量。 const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPointer; const nlistByCPU* symbolTable = (nlistByCPU*)(segmentBase + symtabCmd-&gt;symoff); const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff; for (uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) { //如果 n_value 是0，symbol 指向外部对象 if (symbolTable[iSym].n_value != 0) { //给定的偏移量是文件偏移量，减去 __LINKEDIT segment 的文件偏移量获得字符串和符号表的虚拟内存偏移量 uintptr_t symbolBase = symbolTable[iSym].n_value; uintptr_t currentDistance = addressWithSlide - symbolBase; //寻找最小的距离 bestDistance，因为 addressWithSlide 是某个方法的指令地址，要大于这个方法的入口。 //离 addressWithSlide 越近的函数入口越匹配 if ((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) { bestMatch = symbolTable + iSym; bestDistance = currentDistance; } } } if (bestMatch != NULL) { //将虚拟内存偏移量添加到 __LINKEDIT segment 的虚拟内存地址可以提供字符串和符号表的内存 address。 info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddressSlide); info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx); if (*info-&gt;dli_sname == &apos;_&apos;) { info-&gt;dli_sname++; } //所有的 symbols 的已经被处理好了 if (info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == 3) { info-&gt;dli_sname = NULL; } break; } } cmdPointer += loadCmd-&gt;cmdsize;} 需要注意的地方需要注意的是这个程序有消耗性能的地方 thread get state。这个也会被监控检查出，所以可以过滤掉这样的堆栈信息。 够获取更多信息的方法获取更多信息比如全层级方法调用和每个方法消耗的时间，那么这样做的好处在哪呢？ 可以更细化的测量时间消耗，找到耗时方法，更快的交互操作能使用户体验更好，下面是一些可以去衡量的场景： 响应能力 按钮点击 手势操作 Tab 切换 vc 的切换和转场 可以给优化定个目标，比如滚动和动画达到 60fps，响应用户操作在 100ms 内完成。然后逐个检测出来 fix 掉。 如何获取到更多信息呢？ 通过 hook objc_msgSend 方法能够获取所有被调用的方法，记录深度就能够得到方法调用的树状结构，通过执行前后时间的记录能够得到每个方法的耗时，这样就能获取一份完整的性能消耗信息了。 hook c 函数可以使用 facebook 的 fishhook， 获取方法调用树状结构可以使用 InspectiveC，下面对于他们的实现详细介绍一下： 获取方法调用树结构首先设计两个结构体，CallRecord 记录调用方法详细信息，包括 obj 和 SEL 等，ThreadCallStack 里面需要用 index 记录当前调用方法树的深度。有了 SEL 再通过 NSStringFromSelector 就能够取得方法名，有了 obj 通过 object_getClass 能够得到 Class 再用 NSStringFromClass 就能够获得类名。 123456789101112131415161718192021// Shared structures.typedef struct CallRecord_ { id obj; //通过 object_getClass 能够得到 Class 再通过 NSStringFromClass 能够得到类名 SEL _cmd; //通过 NSStringFromSelector 方法能够得到方法名 uintptr_t lr; int prevHitIndex; char isWatchHit;} CallRecord;typedef struct ThreadCallStack_ { FILE *file; char *spacesStr; CallRecord *stack; int allocatedLength; int index; int numWatchHits; int lastPrintedIndex; int lastHitIndex; char isLoggingEnabled; char isCompleteLoggingEnabled;} ThreadCallStack; 存储读取 ThreadCallStackpthread_setspecific() 可以将私有数据设置在指定线程上，pthread_getspecific() 用来读取这个私有数据，利用这个特性可以就可以将 ThreadCallStack 的数据和该线程绑定在一起，随时进行数据的存取。代码如下： 12345678910111213141516171819202122static inline ThreadCallStack * getThreadCallStack() { ThreadCallStack *cs = (ThreadCallStack *)pthread_getspecific(threadKey); //读取 if (cs == NULL) { cs = (ThreadCallStack *)malloc(sizeof(ThreadCallStack));#ifdef MAIN_THREAD_ONLY cs-&gt;file = (pthread_main_np()) ? newFileForThread() : NULL;#else cs-&gt;file = newFileForThread();#endif cs-&gt;isLoggingEnabled = (cs-&gt;file != NULL); cs-&gt;isCompleteLoggingEnabled = 0; cs-&gt;spacesStr = (char *)malloc(DEFAULT_CALLSTACK_DEPTH + 1); memset(cs-&gt;spacesStr, &apos; &apos;, DEFAULT_CALLSTACK_DEPTH); cs-&gt;spacesStr[DEFAULT_CALLSTACK_DEPTH] = &apos;\\0&apos;; cs-&gt;stack = (CallRecord *)calloc(DEFAULT_CALLSTACK_DEPTH, sizeof(CallRecord)); //分配 CallRecord 默认空间 cs-&gt;allocatedLength = DEFAULT_CALLSTACK_DEPTH; cs-&gt;index = cs-&gt;lastPrintedIndex = cs-&gt;lastHitIndex = -1; cs-&gt;numWatchHits = 0; pthread_setspecific(threadKey, cs); //保存数据 } return cs;} 记录方法调用深度因为要记录深度，而一个方法的调用里会有更多的方法调用，所以方法的调用写两个方法分别记录开始 pushCallRecord 和记录结束的时刻 popCallRecord，这样才能够通过在开始时对深度加一在结束时减一。 1234567891011121314151617181920//开始时static inline void pushCallRecord(id obj, uintptr_t lr, SEL _cmd, ThreadCallStack *cs) { int nextIndex = (++cs-&gt;index); //增加深度 if (nextIndex &gt;= cs-&gt;allocatedLength) { cs-&gt;allocatedLength += CALLSTACK_DEPTH_INCREMENT; cs-&gt;stack = (CallRecord *)realloc(cs-&gt;stack, cs-&gt;allocatedLength * sizeof(CallRecord)); cs-&gt;spacesStr = (char *)realloc(cs-&gt;spacesStr, cs-&gt;allocatedLength + 1); memset(cs-&gt;spacesStr, &apos; &apos;, cs-&gt;allocatedLength); cs-&gt;spacesStr[cs-&gt;allocatedLength] = &apos;\\0&apos;; } CallRecord *newRecord = &amp;cs-&gt;stack[nextIndex]; newRecord-&gt;obj = obj; newRecord-&gt;_cmd = _cmd; newRecord-&gt;lr = lr; newRecord-&gt;isWatchHit = 0;}//结束时static inline CallRecord * popCallRecord(ThreadCallStack *cs) { return &amp;cs-&gt;stack[cs-&gt;index--]; //减少深度} 在 objc_msgSend 前后插入执行方法最后是 hook objc_msgSend 需要在调用前和调用后分别加入 pushCallRecord 和 popCallRecord。因为需要在调用后这个时机插入一个方法，而且不可能编写一个保留未知参数并跳转到 c 中任意函数指针的函数，那么这就需要用到汇编来做到。 下面针对 arm64 进行分析，arm64 有31个64 bit 的整数型寄存器，用 x0 到 x30 表示，主要思路就是先入栈参数，参数寄存器是 x0 - x7，对于objc_msgSend方法来说 x0 第一个参数是传入对象，x1 第二个参数是选择器 _cmd。 syscall 的 number 会放到 x8 里。然后交换寄存器中，将用于返回的寄存器 lr 移到 x1 里。先让 pushCallRecord 能够执行，再执行原始的 objc_msgSend，保存返回值，最后让 popCallRecord 能执行。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static void replacementObjc_msgSend() { __asm__ volatile ( // sp 是堆栈寄存器，存放栈的偏移地址，每次都指向栈顶。 // 保存 {q0-q7} 偏移地址到 sp 寄存器 &quot;stp q6, q7, [sp, #-32]!\\n&quot; &quot;stp q4, q5, [sp, #-32]!\\n&quot; &quot;stp q2, q3, [sp, #-32]!\\n&quot; &quot;stp q0, q1, [sp, #-32]!\\n&quot; // 保存 {x0-x8, lr} &quot;stp x8, lr, [sp, #-16]!\\n&quot; &quot;stp x6, x7, [sp, #-16]!\\n&quot; &quot;stp x4, x5, [sp, #-16]!\\n&quot; &quot;stp x2, x3, [sp, #-16]!\\n&quot; &quot;stp x0, x1, [sp, #-16]!\\n&quot; // 交换参数. &quot;mov x2, x1\\n&quot; &quot;mov x1, lr\\n&quot; &quot;mov x3, sp\\n&quot; // 调用 preObjc_msgSend，使用 bl label 语法。bl 执行一个分支链接操作，label 是无条件分支的，是和本指令的地址偏移，范围是 -128MB 到 +128MB &quot;bl __Z15preObjc_msgSendP11objc_objectmP13objc_selectorP9RegState_\\n&quot; &quot;mov x9, x0\\n&quot; &quot;mov x10, x1\\n&quot; &quot;tst x10, x10\\n&quot; // 读取 {x0-x8, lr} 从保存到 sp 栈顶的偏移地址读起 &quot;ldp x0, x1, [sp], #16\\n&quot; &quot;ldp x2, x3, [sp], #16\\n&quot; &quot;ldp x4, x5, [sp], #16\\n&quot; &quot;ldp x6, x7, [sp], #16\\n&quot; &quot;ldp x8, lr, [sp], #16\\n&quot; // 读取 {q0-q7} &quot;ldp q0, q1, [sp], #32\\n&quot; &quot;ldp q2, q3, [sp], #32\\n&quot; &quot;ldp q4, q5, [sp], #32\\n&quot; &quot;ldp q6, q7, [sp], #32\\n&quot; &quot;b.eq Lpassthrough\\n&quot; // 调用原始 objc_msgSend。使用 blr xn 语法。blr 除了从指定寄存器读取新的 PC 值外效果和 bl 一样。xn 是通用寄存器的64位名称分支地址，范围0到31 &quot;blr x9\\n&quot; // 保存 {x0-x9} &quot;stp x0, x1, [sp, #-16]!\\n&quot; &quot;stp x2, x3, [sp, #-16]!\\n&quot; &quot;stp x4, x5, [sp, #-16]!\\n&quot; &quot;stp x6, x7, [sp, #-16]!\\n&quot; &quot;stp x8, x9, [sp, #-16]!\\n&quot; // 保存 {q0-q7} &quot;stp q0, q1, [sp, #-32]!\\n&quot; &quot;stp q2, q3, [sp, #-32]!\\n&quot; &quot;stp q4, q5, [sp, #-32]!\\n&quot; &quot;stp q6, q7, [sp, #-32]!\\n&quot; // 调用 postObjc_msgSend hook. &quot;bl __Z16postObjc_msgSendv\\n&quot; &quot;mov lr, x0\\n&quot; // 读取 {q0-q7} &quot;ldp q6, q7, [sp], #32\\n&quot; &quot;ldp q4, q5, [sp], #32\\n&quot; &quot;ldp q2, q3, [sp], #32\\n&quot; &quot;ldp q0, q1, [sp], #32\\n&quot; // 读取 {x0-x9} &quot;ldp x8, x9, [sp], #16\\n&quot; &quot;ldp x6, x7, [sp], #16\\n&quot; &quot;ldp x4, x5, [sp], #16\\n&quot; &quot;ldp x2, x3, [sp], #16\\n&quot; &quot;ldp x0, x1, [sp], #16\\n&quot; &quot;ret\\n&quot; &quot;Lpassthrough:\\n&quot; // br 无条件分支到寄存器中的地址 &quot;br x9&quot; );} 记录时间的方法为了记录耗时，这样就需要在 pushCallRecord 和 popCallRecord 里记录下时间。下面列出一些计算一段代码开始到结束的时间的方法 第一种： NSDate 微秒 1234NSDate* tmpStartData = [NSDate date];//some code need caculatedouble deltaTime = [[NSDate date] timeIntervalSinceDate:tmpStartData];NSLog(@&quot;cost time: %f s&quot;, deltaTime); 第二种：clock_t 微秒clock_t计时所表示的是占用CPU的时钟单元 1234clock_t start = clock();//some code need caculateclock_t end = clock();NSLog(@&quot;cost time: %f s&quot;, (double)(end - start)/CLOCKS_PER_SEC); 第三种：CFAbsoluteTime 微秒 1234CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();//some code need caculateCFAbsoluteTime end = CFAbsoluteTimeGetCurrent();NSLog(@&quot;cost time = %f s&quot;, end - start); //s 第四种：CFTimeInterval 纳秒 12345678910CFTimeInterval start = CACurrentMediaTime();//some code need caculateCFTimeInterval end = CACurrentMediaTime();NSLog(@&quot;cost time: %f s&quot;, end - start);```第五种：mach_absolute_time 纳秒```objcuint64_t start = mach_absolute_time ();//some code need caculateuint64_t end = mach_absolute_time ();uint64_t elapsed = 1e-9 *(end - start); 最后两种可用，本质区别NSDate 或 CFAbsoluteTimeGetCurrent() 返回的时钟时间将会会网络时间同步，从时钟 偏移量的角度。mach_absolute_time() 和 CACurrentMediaTime() 是基于内建时钟的。选择一种，加到 pushCallRecord 和 popCallRecord 里，相减就能够获得耗时。 如何 hook msgsend 方法那么 objc_msgSend 这个 c 方法是如何 hook 到的呢。首先了解下 dyld 是通过更新 Mach-O 二进制的 __DATA segment 特定的部分中的指针来邦定 lazy 和 non-lazy 符号，通过确认传递给 rebind_symbol 里每个符号名称更新的位置就可以找出对应替换来重新绑定这些符号。下面针对关键代码进行分析： 遍历 dyld首先是遍历 dyld 里的所有的 image，取出 image header 和 slide。注意第一次调用时主要注册 callback。 12345678if (!_rebindings_head-&gt;next) { _dyld_register_func_for_add_image(_rebind_symbols_for_image);} else { uint32_t c = _dyld_image_count(); for (uint32_t i = 0; i &lt; c; i++) { _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i)); }} 找出符号表相关 Command接下来需要找到符号表相关的 command，包括 linkedit segment command，symtab command 和 dysymtab command。方法如下： 123456789101112131415161718segment_command_t *cur_seg_cmd;segment_command_t *linkedit_segment = NULL;struct symtab_command* symtab_cmd = NULL;struct dysymtab_command* dysymtab_cmd = NULL;uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) { cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) { if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) { linkedit_segment = cur_seg_cmd; } } else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) { symtab_cmd = (struct symtab_command*)cur_seg_cmd; } else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) { dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; }} 获得 base 和 indirect 符号表1234567// Find base symbol/string table addressesuintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);// Get indirect symbol table (array of uint32_t indices into symbol table)uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); 进行方法替换有了符号表和传入的方法替换数组就可以进行符号表访问指针地址的替换，具体实现如下： 12345678910111213141516171819202122232425262728uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) { uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) { continue; } uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; char *symbol_name = strtab + strtab_offset; if (strnlen(symbol_name, 2) &lt; 2) { continue; } struct rebindings_entry *cur = rebindings; while (cur) { for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) { if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) { if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) { *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; } indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; goto symbol_loop; } } cur = cur-&gt;next; }symbol_loop:; 统计方法调用频次在一些应用场景会有一些频繁的方法调用，有些方法的调用实际上是没有必要的，但是首先是需要将那些频繁调用的方法找出来这样才能够更好的定位到潜在的会造成性能浪费的方法使用。这些频繁调用的方法要怎么找呢？ 大致的思路是这样，基于上面章节提到的记录方法调用深度的方案，将每个调用方法的路径保存住，调用相同路径的相同方法调用一次加一记录在数据库中，最后做一个视图按照调用次数的排序即可找到调用频繁的那些方法。下图是完成后展示的效果： 接下来看看具体实现方式 设计方法调用频次记录的结构在先前时间消耗的 model 基础上增加路径，频次等信息 123456789@property (nonatomic, strong) NSString *className; //类名@property (nonatomic, strong) NSString *methodName; //方法名@property (nonatomic, assign) BOOL isClassMethod; //是否是类方法@property (nonatomic, assign) NSTimeInterval timeCost; //时间消耗@property (nonatomic, assign) NSUInteger callDepth; //Call 层级@property (nonatomic, copy) NSString *path; //路径@property (nonatomic, assign) BOOL lastCall; //是否是最后一个 Call@property (nonatomic, assign) NSUInteger frequency; //访问频次@property (nonatomic, strong) NSArray &lt;SMCallTraceTimeCostModel *&gt; *subCosts; 拼装方法路径在遍历 SMCallTrace 记录的方法 model 和 遍历方法子方法时将路径拼装好，记录到数据库中 12345678910111213141516171819for (SMCallTraceTimeCostModel *model in arr) { //记录方法路径 model.path = [NSString stringWithFormat:@&quot;[%@ %@]&quot;,model.className,model.methodName]; [self appendRecord:model to:mStr];}+ (void)appendRecord:(SMCallTraceTimeCostModel *)cost to:(NSMutableString *)mStr { [mStr appendFormat:@&quot;%@\\n path%@\\n&quot;,[cost des],cost.path]; if (cost.subCosts.count &lt; 1) { cost.lastCall = YES; } //记录到数据库中 [[[SMLagDB shareInstance] increaseWithClsCallModel:cost] subscribeNext:^(id x) {}]; for (SMCallTraceTimeCostModel *model in cost.subCosts) { //记录方法的子方法的路径 model.path = [NSString stringWithFormat:@&quot;%@ - [%@ %@]&quot;,cost.path,model.className,model.methodName]; [self appendRecord:model to:mStr]; }} 记录方法调用频次数据库创建数据库这里的 lastcall 是记录是否是最后一个方法的调用，展示时只取最后一个方法即可，因为也会有完整路径可以知道父方法和来源方法。 12345678910111213141516171819_clsCallDBPath = [PATH_OF_DOCUMENT stringByAppendingPathComponent:@&quot;clsCall.sqlite&quot;];if ([[NSFileManager defaultManager] fileExistsAtPath:_clsCallDBPath] == NO) { FMDatabase *db = [FMDatabase databaseWithPath:_clsCallDBPath]; if ([db open]) { /* cid: 主id fid: 父id 暂时不用 cls: 类名 mtd: 方法名 path: 完整路径标识 timecost: 方法消耗时长 calldepth: 层级 frequency: 调用次数 lastcall: 是否是最后一个 call */ NSString *createSql = @&quot;create table clscall (cid INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, fid integer, cls text, mtd text, path text, timecost integer, calldepth integer, frequency integer, lastcall integer)&quot;; [db executeUpdate:createSql]; }} 添加记录添加记录时需要先检查数据库里是否有相同路径的同一个方法调用，这样可以给 frequency 字段加一已达到记录频次的目的。 12345678910111213141516FMResultSet *rsl = [db executeQuery:@&quot;select cid,frequency from clscall where path = ?&quot;, model.path];if ([rsl next]) { //有相同路径就更新路径访问频率 int fq = [rsl intForColumn:@&quot;frequency&quot;] + 1; int cid = [rsl intForColumn:@&quot;cid&quot;]; [db executeUpdate:@&quot;update clscall set frequency = ? where cid = ?&quot;, @(fq), @(cid)];} else { //没有就添加一条记录 NSNumber *lastCall = @0; if (model.lastCall) { lastCall = @1; } [db executeUpdate:@&quot;insert into clscall (cls, mtd, path, timecost, calldepth, frequency, lastcall) values (?, ?, ?, ?, ?, ?, ?)&quot;, model.className, model.methodName, model.path, @(model.timeCost), @(model.callDepth), @1, lastCall];}[db close];[subscriber sendCompleted]; 检索记录检索时注意按照调用频次字段进行排序即可。 123456789101112131415FMResultSet *rs = [db executeQuery:@&quot;select * from clscall where lastcall=? order by frequency desc limit ?, 50&quot;,@1, @(page * 50)];NSUInteger count = 0;NSMutableArray *arr = [NSMutableArray array];while ([rs next]) { SMCallTraceTimeCostModel *model = [self clsCallModelFromResultSet:rs]; [arr addObject:model]; count ++;}if (count &gt; 0) { [subscriber sendNext:arr];} else { [subscriber sendError:nil];}[subscriber sendCompleted];[db close]; 找出 CPU 使用大的线程堆栈在前面检测卡顿打印的堆栈里提到使用 thread_info 能够获取到各个线程的 cpu 消耗，但是 cpu 不在主线程即使消耗很大也不一定会造成卡顿导致卡顿检测无法检测出更多 cpu 消耗的情况，所以只能通过轮询监控各线程里的 cpu 使用情况，对于超过标准值比如70%的进行记录来跟踪定位出耗电的那些方法。下图是列出 cpu 过载时的堆栈记录的展示效果： 有了前面的基础，实现起来轻松多了 12345678910111213141516171819202122232425262728//轮询检查多个线程 cpu 情况+ (void)updateCPU { thread_act_array_t threads; mach_msg_type_number_t threadCount = 0; const task_t thisTask = mach_task_self(); kern_return_t kr = task_threads(thisTask, &amp;threads, &amp;threadCount); if (kr != KERN_SUCCESS) { return; } for (int i = 0; i &lt; threadCount; i++) { thread_info_data_t threadInfo; thread_basic_info_t threadBaseInfo; mach_msg_type_number_t threadInfoCount = THREAD_INFO_MAX; if (thread_info((thread_act_t)threads[i], THREAD_BASIC_INFO, (thread_info_t)threadInfo, &amp;threadInfoCount) == KERN_SUCCESS) { threadBaseInfo = (thread_basic_info_t)threadInfo; if (!(threadBaseInfo-&gt;flags &amp; TH_FLAGS_IDLE)) { integer_t cpuUsage = threadBaseInfo-&gt;cpu_usage / 10; if (cpuUsage &gt; 70) { //cup 消耗大于 70 时打印和记录堆栈 NSString *reStr = smStackOfThread(threads[i]); //记录数据库中 [[[SMLagDB shareInstance] increaseWithStackString:reStr] subscribeNext:^(id x) {}]; NSLog(@&quot;CPU useage overload thread stack：\\n%@&quot;,reStr); } } } }} Demo工具已整合到先前做的 GCDFetchFeed 里。 子线程检测主线程卡顿使用的话在需要开始检测的地方添加 [[SMLagMonitor shareInstance] beginMonitor]; 即可。 需要检测所有方法调用的用法就是在需要检测的地方调用 [SMCallTrace start]; 就可以了，不检测打印出结果的话调用 stop 和 save 就好了。这里还可以设置最大深度和最小耗时检测来过滤不需要看到的信息。 方法调用频次使用可以在需要开始统计的地方加上 [SMCallTrace startWithMaxDepth:3]; 记录时使用 [SMCallTrace stopSaveAndClean]; 记录到到数据库中同时清理内存的占用。可以 hook VC 的 viewWillAppear 和 viewWillDisappear，在 appear 时开始记录，在 disappear 时记录到数据库同时清理一次。结果展示的 view controller 是 SMClsCallViewController，push 出来就能够看到列表结果。 资料WWDC WWDC 2013 224 Designing Code for Performance WWDC 2013 408 Optimizing Your Code Using LLVM WWDC 2013 712 Energy Best Practices WWDC 2014 710 writing energy efficient code part 1 WWDC 2014 710 writing energy efficient code part 2 WWDC 2015 230 performance on ios and watchos WWDC 2015 707 achieving allday battery life WWDC 2015 708 debugging energy issues WWDC 2015 718 building responsive and efficient apps with gcd WWDC 2016 406 optimizing app startup time WWDC 2016 719 optimizing io for performance and battery life WWDC 2017 238 writing energy efficient apps WWDC 2017 706 modernizing grand central dispatch usage","link":"/program//pou-xi/"},{"title":"UICollectionView","text":"Layout Objects使用UICollectionViewFlowLayout类进行具体的布局实现，类的官方文档说明：https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewFlowLayout_class/Reference/Reference.html#//apple_ref/occ/cl/UICollectionViewFlowLayout,进一步定制可参考官方这个文档：https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/CollectionViewPGforIOS/UsingtheFlowLayout/UsingtheFlowLayout.html#//apple_ref/doc/uid/TP40012334-CH3-SW4 Cells和其它Viewcollection view管理者cells，supplementary views和decoration views cells：和tableview的cell类似。 Supplementary views：相当于tableview的section header和footer views，不同的是数量和位置由布局控制 Decoration views：装饰用 基于内容的布局计算自定义布局子类重写的方法可以参考官方文档：https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionViewLayout_class/Reference/Reference.html collectionViewContentSize1234567891011- (CGSize)collectionViewContentSize{ //不能水平滚动 CGFloat contentWidth = self.collectionView.bounds.size.width; //垂直滚动显示完整数据 CGFloat contentHeight = DayHeaderHeight + (HeightPerHour * HoursPerDay); CGSize contentSize = CGSizeMake(contentWidth, contentHeight); return contentSize;} 布局中最重要的方法layoutAttributesForElementsInRect:12345678910111213141516171819202122232425262728293031- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect{ NSMutableArray *layoutAttributes = [NSMutableArray array]; // Cells // We call a custom helper method -indexPathsOfItemsInRect: here // which computes the index paths of the cells that should be included // in rect. NSArray *visibleIndexPaths = [self indexPathsOfItemsInRect:rect]; for (NSIndexPath *indexPath in visibleIndexPaths) { UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForItemAtIndexPath:indexPath]; [layoutAttributes addObject:attributes]; } // Supplementary views NSArray *dayHeaderViewIndexPaths = [self indexPathsOfDayHeaderViewsInRect:rect]; for (NSIndexPath *indexPath in dayHeaderViewIndexPaths) { UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForSupplementaryViewOfKind:@“DayHeaderView&quot; atIndexPath:indexPath]; [layoutAttributes addObject:attributes]; } NSArray *hourHeaderViewIndexPaths = [self indexPathsOfHourHeaderViewsInRect:rect]; for (NSIndexPath *indexPath in hourHeaderViewIndexPaths) { UICollectionViewLayoutAttributes *attributes = [self layoutAttributesForSupplementaryViewOfKind:@&quot;HourHeaderView&quot;atIndexPath:indexPath]; [layoutAttributes addObject:attributes]; } return layoutAttributes;} layoutAttributesForItemAtIndexPath:123456789- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath{ CalendarDataSource *dataSource = self.collectionView.dataSource; id event = [dataSource eventAtIndexPath:indexPath]; UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; attributes.frame = [self frameForEvent:event]; return attributes;} shouldInvalidateLayoutForBoundsChange:12345678- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds{ CGRect oldBounds = self.collectionView.bounds; if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) { return YES; } return NO;} 插入，删除和布局间切换的动画插入，删除 initialLayoutAttributesForAppearingItemAtIndexPath: initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath: initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath: finalLayoutAttributesForDisappearingItemAtIndexPath: finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath: finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:发送setCollectionViewLayout:animated:消息，collection view会为cells在新布局参数，动态将每个cell从旧变到新。 范例 自定义布局范例：https://github.com/objcio/issue-3-collection-view-layouts","link":"/program//uicollectionview/"},{"title":"UIView","text":"视图层级UIView有三个基类：UIResponder，UIView和UIControl。 UIResponder：是UIView的父类。responder处理触摸，手势，远程控制事件。UIApplication和UIViewController也是UIResponder的子类。 UIView：处理绘制和触摸时间。 UIControl：有target/action模式。button，Date pickers，文本框都是。 渲染避免使用drawRect:在CPU上做渲染，如果希望使用GPU渲染就使用现有的视图构建自定义视图。如果要实现一个带边框的圆形头像 1234567- (void)setupView{ self.clipsToBounds = YES; self.layer.cornerRadius = self.bounds.size.width / 2; self.layer.borderWidth = 3; self.layer.borderColor = [UIColor darkGrayColor].CGColor;} 渲染速度比较 OpenGL -&gt; Core Image -&gt; Core Graphics 自定义交互响应触摸，可以使用重写更加底层的touchesBegan，touchesMoved和touchesEnded方法。还可以使用其它不同的方法来解决比如target action，代理，block，KVO或通知 Target action：最方便的做法，也是最学院派的。 1234567891011121314[self sendActionsForControlEvents:UIControlEventValueChanged];//如果一个view controller管理这个视图- (void)setupPieChart{ [self.pieChart addTarget:self action:@selector(updateSelection:) forControlEvents:UIControlEventValueChanged];}- (void)updateSelection:(id)sender{ NSLog(@&quot;%@&quot;, self.pieChart.selectedSector);} 使用代理12345678910111213141516[self.delegate pieChart:self didSelectSector:self.selectedSector];//在view controller中代码@interface MyViewController &lt;PieChartDelegate&gt;...- (void)setupPieChart{ self.pieChart.delegate = self;}- (void)pieChart:(PieChart*)pieChart didSelectSector:(PieChartSector*)sector{ // 处理区块} 使用Block12345678910111213141516171819202122232425@interface PieChart : UIControl@property (nonatomic,copy) void(^selectionHandler)(PieChartSection* selectedSection);@end//在执行之前检查下block是否被赋值，未被赋值的block会崩if (self.selectionHandler != NULL) { self.selectionHandler(self.selectedSection);}//可以把相关的代码整合在view controller中- (void)setupPieChart{ self.pieChart.selectionHandler = ^(PieChartSection* section) { // 处理区块 }}//避免引用循环__weak id weakSelf = self;self.pieChart.selectionHandler = ^(PieChartSection* section) { MyViewController* strongSelf = weakSelf; [strongSelf handleSectionChange:section];} 使用KVO12345678910111213self.selectedSegment = theNewSelectedSegment;- (void)setupPieChart{ [self.pieChart addObserver:self forKeyPath:@&quot;selectedSegment&quot; options:0 context:NULL];}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context{ if(object == self.pieChart &amp;&amp; [keyPath isEqualToString:@&quot;selectedSegment&quot;]) { // 处理改变 }}//在viewWillDisappear：或dealloc中移除观察者。 使用通知1234567891011121314151617181920212223242526//头文件中extern NSString* const SelectedSegmentChangedNotification;//实现的文件中NSString* const SelectedSegmentChangedNotification = @&quot;selectedSegmentChangedNotification&quot;;...- (void)notifyAboutChanges{ [[NSNotificationCenter defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:self];}//现在订阅通知，在view controller中实现- (void)setupPieChart{ [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(segmentChanged:) name:SelectedSegmentChangedNotification object:self.pieChart];}...- (void)segmentChanged:(NSNotification*)note{}//注意在合适的地方退订通知 ming1016","link":"/program//uiview/"},{"title":"移动端网络请求优化之 IP 测速排序方案","text":"IP 测速排序方案 1. IP 测速排序方案的目的无论是从 Local DNS 解析域名，获取到 IP 列表，还是从第三方的 DNS 解析服务中，获取到域名对应的 IP 列表。我们获得多个 IP 后，总是想选取一个最优的 IP 使用，本文主要探讨如何在客户端探测 IP 的连接性以及连接速度，保证返回可用性最好的IP，以达到“IP优选”的目的。 2. 新浪开源的 httpdns 的 sdk 里的测速逻辑新浪开源一个 HTTPDNSLib ，里面包含了测速逻辑，GitHub地址如下： 《HTTPDNSLib-for-iOS》 《HTTPDNSLib》 3. IP 测试实现原理使用 linux socket connect 和 select 函数实现的。 基于以下原理： 即使套接口是非阻塞的。如果连接的服务器在同一台主机上，那么在调用connect 建立连接时，连接通常会立即建立成功，我们必须处理这种情况。 源自Berkeley的实现(和Posix.1g)有两条与select 和非阻塞IO相关的规则：A. 当连接建立成功时，套接口描述符变成可写；B. 当连接出错时，套接口描述符变成既可读又可写。 详细的测速实现如下，原理参考注释： 以 iOS 实现为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//#define CYL_SOCKET_CONNECT_TIMEOUT 10 //单位秒//#define CYL_SOCKET_CONNECT_TIMEOUT_RTT 600000//10分钟 单位毫秒- (int)testSpeedOf:(NSString *)ip port:(int16_t)port { NSString *oldIp = ip; //request time out float rtt = 0.0; //sock：将要被设置或者获取选项的套接字。 int s = 0; struct sockaddr_in saddr; saddr.sin_family = AF_INET; // MARK: - 设置端口，这里需要根据需要自定义，默认是80端口。 saddr.sin_port = htons(port); saddr.sin_addr.s_addr = inet_addr([ip UTF8String]); //saddr.sin_addr.s_addr = inet_addr(&quot;1.1.1.123&quot;); if( (s=socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { NSLog(@&quot;ERROR:%s:%d, create socket failed.&quot;,__FUNCTION__,__LINE__); return 0; } NSDate *startTime = [NSDate date]; NSDate *endTime; //为了设置connect超时 把socket设置称为非阻塞 int flags = fcntl(s, F_GETFL,0); fcntl(s,F_SETFL, flags | O_NONBLOCK); //对于阻塞式套接字，调用connect函数将激发TCP的三次握手过程，而且仅在连接建立成功或者出错时才返回； //对于非阻塞式套接字，如果调用connect函数会之间返回-1（表示出错），且错误为EINPROGRESS，表示连接建立，建立启动但是尚未完成； //如果返回0，则表示连接已经建立，这通常是在服务器和客户在同一台主机上时发生。 int i = connect(s,(struct sockaddr*)&amp;saddr, sizeof(saddr)); if(i == 0) { //建立连接成功，返回rtt时间。 因为connect是非阻塞，所以这个时间就是一个函数执行的时间，毫秒级，没必要再测速了。 close(s); return 1; } struct timeval tv; int valopt; socklen_t lon; tv.tv_sec = CYL_SOCKET_CONNECT_TIMEOUT; tv.tv_usec = 0; fd_set myset; FD_ZERO(&amp;myset); FD_SET(s, &amp;myset); // MARK: - 使用select函数，对套接字的IO操作设置超时。 /** select函数 select是一种IO多路复用机制，它允许进程指示内核等待多个事件的任何一个发生，并且在有一个或者多个事件发生或者经历一段指定的时间后才唤醒它。 connect本身并不具有设置超时功能，如果想对套接字的IO操作设置超时，可使用select函数。 **/ int maxfdp = s+1; int j = select(maxfdp, NULL, &amp;myset, NULL, &amp;tv); if (j == 0) { NSLog(@&quot;INFO:%s:%d, test rtt of (%@) timeout.&quot;,__FUNCTION__,__LINE__, oldIp); rtt = CYL_SOCKET_CONNECT_TIMEOUT_RTT; close(s); return rtt; } if (j &lt; 0) { NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__); rtt = 0; close(s); return rtt; } /** 对于select和非阻塞connect，注意两点： [1] 当连接成功建立时，描述符变成可写； [2] 当连接建立遇到错误时，描述符变为即可读，也可写，遇到这种情况，可调用getsockopt函数。 **/ lon = sizeof(int); //valopt 表示错误信息。 // MARK: - 测试核心逻辑，连接后，获取错误信息，如果没有错误信息就是访问成功 /*! * //getsockopt函数可获取影响套接字的选项，比如SOCKET的出错信息 * (get socket option) */ getsockopt(s, SOL_SOCKET, SO_ERROR, (void*)(&amp;valopt), &amp;lon); //如果有错误信息： if (valopt) { NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__); rtt = 0; } else { endTime = [NSDate date]; rtt = [endTime timeIntervalSinceDate:startTime] * 1000; } close(s); return rtt;} 注意：当出现错误的时候测试结果是速度是0，所以排序时不能简单地按照值大小排序，可以先删除速度为0的结果，或者将速度为零重置为超时时间，比如上面的 CYL_SOCKET_CONNECT_TIMEOUT_RTT 。避免错误IP为0，结果排序后排在前面。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0","link":"/program//ip/"},{"title":"iOS字符串 ","text":"搜索在一个字符串中搜索子字符串 最灵活的方法 1- (NSRange)rangeOfString:(NSString *)aString options:(NSStringCompareOptions)mask range:(NSRange)searchRange locale:(NSLocale *)locale 格式化字符串 3个方法 123-initWithFormat:-initWithFormat:arguments:+stringWithFormat: 整数 可以同时工作在32位和64位的 123uint64_t p = 2305843009213693951;NSString *s = [NSString stringWithFormat:@&quot;The ninth Mersenne prime is %llu&quot;, (unsigned long long) p];// &quot;The ninth Mersenne prime is 2305843009213693951&quot; Modifier d, i o, u, x, X hh signed char unsigned char h short unsigned short (none) int unsigned int l(ell) long unsigned long j intmax_t uintmax_t t ptrdiff_t z size_t * 转换规则 12345int m = -150004021;uint n = 150004021U;NSString *s = [NSString stringWithFormat:@&quot;d:%d i:%i o:%o u:%u x:%x X:%X&quot;, m, m, n, n, n, n];// &quot;d:-150004021 i:-150004021 o:1074160465 u:150004021 x:8f0e135 X:8F0E135&quot;//o是八进制 设置最小字段宽度和最小数字位数 123456int m = 42;NSString *s = [NSString stringWithFormat:@&quot;&apos;%4d&apos; &apos;%-4d&apos; &apos;%+4d&apos; &apos;%4.3d&apos; &apos;%04d&apos;&quot;, m, m, m, m, m];// &quot;[ 42] [42 ] [ +42] [ 042] [0042]&quot;m = -42;NSString *s = [NSString stringWithFormat:@&quot;&apos;%4d&apos; &apos;%-4d&apos; &apos;%+4d&apos; &apos;%4.3d&apos; &apos;%04d&apos;&quot;, m, m, m, m, m];// &quot;[ -42] [-42 ] [ -42] [-042] [-042]&quot; %p可打印指针，和%#x不同的是它可以同时在32位和64位执行 浮点数 使用%f和%g 12345double v[5] = {12345, 12, 0.12, 0.12345678901234, 0.0000012345678901234};NSString *s = [NSString stringWithFormat:@&quot;%g %g %g %g %g&quot;, v[0], v[1], v[2], v[3], v[4]];// &quot;12345 12 0.12 0.123457 1.23457e-06&quot;NSString *s = [NSString stringWithFormat:@&quot;%f %f %f %f %f&quot;, v[0], v[1], v[2], v[3], v[4]];// &quot;12345.000000 12.000000 0.120000 0.123457 0.000001&quot; 多行文字 使用\\n来 12345NSString *limerick = @&quot;A lively young damsel named Menzies\\n&quot;@&quot;Inquired: «Do you know what this thenzies?»\\n&quot;@&quot;Her aunt, with a gasp,\\n&quot;@&quot;Replied: &quot;It&apos;s a wasp,\\n&quot;@&quot;And you&apos;re holding the end where the stenzies.\\n&quot;; 等价写法 1NSString *limerick = @&quot;A lively young damsel named Menzies\\nInquired: «Do you know what this thenzies?»\\nHer aunt, with a gasp,\\nReplied: &quot;It&apos;s a wasp,\\nAnd you&apos;re holding the end where the stenzies.\\n&quot;; 更简洁的方法 1NSString * string = @&quot;The man &quot; @&quot;who knows everything &quot; @&quot;learns nothing&quot; @&quot;.&quot;; 替换字符串 NSMutableString的四个方法 1234-deleteCharactersInRange:-insertString:atIndex:-replaceCharactersInRange:withString:-replaceOccurrencesOfString:withString:options:range: NSString的方法 123-stringByReplacingOccurrencesOfString:withString:-stringByReplacingOccurrencesOfString:withString:options:range:-stringByReplacingCharactersInRange:withString: NSMutableString不会创建新字符串，性能会好点 1234567NSMutableString *string; // 假设我们已经有了一个名为 string 的字符串// 现在要去掉它的一个前缀，做法如下:NSString *prefix = @&quot;WeDon’tWantThisPrefix&quot;NSRange r = [string rangeOfString:prefix options:NSAnchoredSearch range:NSMakeRange(0, string.length) locale:nil];if (r.location != NSNotFound) { [string deleteCharactersInRange:r];} 连接字符串12NSArray *names = @[&quot;Hildr&quot;, @&quot;Heidrun&quot;, @&quot;Gerd&quot;, @&quot;Guðrún&quot;, @&quot;Freya&quot;, @&quot;Nanna&quot;, @&quot;Siv&quot;, @&quot;Skaði&quot;, @&quot;Gróa&quot;];NSString *result = [names componentsJoinedByString:@&quot;, &quot;]; 字符串解析正则表达式12345678910NSError *error = nil;NSString *pattern = @&quot;(\\\\w+) = #(\\\\p{Hex_Digit}{6})&quot;;NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:patternoptions:0error:&amp;error];NSTextCheckingResult *result = [expression firstMatchInString:stringoptions:0range:NSMakeRange(0, string.length)];NSString *key = [string substringWithRange:[result rangeAtIndex:1]];NSString *value = [string substringWithRange:[result rangeAtIndex:2]]; 将字符串分解成数组，使用componentsSeparatedByString:这个方法，或者enumerateSubstringsInRange:options:usingBlock:。如果是按照行来进行分解可以使用option这个参数传NSStringEnumerationByLines 12345678910111213141516171819NSString *input = @“backgroundColor = #ff0000textColor = #0000ff&quot;NSString *pattern = @&quot;(\\\\w+) = #([\\\\da-f]{6})&quot;;NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:patternoptions:0error:NULL];NSArray *lines = [input componentsSeparatedByCharactersInSet:[NSCharacterSet newlineCharacterSet]];NSMutableDictionary *result = [NSMutableDictionary dictionary];for (NSString *line in lines) { NSTextCheckingResult *textCheckingResult = [expression firstMatchInString:line options:0 range:NSMakeRange(0, line.length)]; NSString* key = [line substringWithRange:[textCheckingResult rangeAtIndex:1]]; NSString* value = [line substringWithRange:[textCheckingResult rangeAtIndex:2]]; result[key] = value;}return result; 扫描 NSScanner 12345678910111213141516171819202122NSScanner *scanner = [NSScanner scannerWithString:string];//默认情况下，扫描器会跳过所有空格符和换行符。但这里我们只希望跳过空格符scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet];//定义一个十六进制字符集NSCharacterSet *hexadecimalCharacterSet =[NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789abcdefABCDEF&quot;];NSMutableDictionary *result = [NSMutableDictionary dictionary];while (!scanner.isAtEnd) { NSString *key = nil; NSString *value = nil; NSCharacterSet *letters = [NSCharacterSet letterCharacterSet]; BOOL didScan = [scanner scanCharactersFromSet:letters intoString:&amp;key] &amp;&amp; [scanner scanString:@&quot;=&quot; intoString:NULL] &amp;&amp; [scanner scanString:@&quot;#&quot; intoString:NULL] &amp;&amp; [scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:&amp;value] &amp;&amp; value.length == 6; result[key] = value; [scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:NULL]; // 继续扫描下一行}return result; 解析器 设计一个能够用(100,0,255)或者#ff0000这样的字符来定义颜色的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (NSDictionary *)parse:(NSString *)string error:(NSError **)error{ self.scanner = [NSScanner scannerWithString:string]; self.scanner.charactersToBeSkipped = [NSCharacterSet whitespaceCharacterSet]; NSMutableDictionary *result = [NSMutableDictionary dictionary]; NSCharacterSet *letters = [NSCharacterSet letterCharacterSet] while (!self.scanner.isAtEnd) { NSString *key = nil; UIColor *value = nil; BOOL didScan = [self.scanner scanCharactersFromSet:letters intoString:&amp;key] &amp;&amp; [self.scanner scanString:@&quot;=&quot; intoString:NULL] &amp;&amp; [self scanColor:&amp;value]; result[key] = value; [self.scanner scanCharactersFromSet:[NSCharacterSet newlineCharacterSet] intoString:NULL]; // 继续扫描下一行 }}- (BOOL)scanColor:(UIColor **)out{ return [self scanHexColorIntoColor:out] || [self scanTupleColorIntoColor:out];}//扫描设置#ff0000这样的- (BOOL)scanHexColorIntoColor:(UIColor **)out{ NSCharacterSet *hexadecimalCharacterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;0123456789abcdefABCDEF&quot;]; NSString *colorString = NULL; if ([self.scanner scanString:@&quot;#&quot; intoString:NULL] &amp;&amp; [self.scanner scanCharactersFromSet:hexadecimalCharacterSet intoString:&amp;colorString] &amp;&amp; colorString.length == 6) { *out = [UIColor colorWithHexString:colorString]; return YES; } return NO;}- (BOOL)scanTupleColorIntoColor:(UIColor **)out{ NSInteger red, green, blue = 0; BOOL didScan = [self.scanner scanString:@&quot;(&quot; intoString:NULL] &amp;&amp; [self.scanner scanInteger:&amp;red] &amp;&amp; [self.scanner scanString:@&quot;,&quot; intoString:NULL] &amp;&amp; [self.scanner scanInteger:&amp;green] &amp;&amp; [self.scanner scanString:@&quot;,&quot; intoString:NULL] &amp;&amp; [self.scanner scanInteger:&amp;blue] &amp;&amp; [self.scanner scanString:@&quot;)&quot; intoString:NULL]; if (didScan) { *out = [UIColor colorWithRed:(CGFloat)red/255. green:(CGFloat)green/255. blue:(CGFloat)blue/255. alpha:1]; return YES; } else { return NO; }} 符号化处理先进星扫描，使用NSScanner来解析这个表达式 12myView.left = otherView.right * 2 + 10viewController.view.centerX + myConstant &lt;= self.view.centerX 1234567891011121314151617181920212223242526272829303132NSScanner *scanner = [NSScanner scannerWithString:contents];NSMutableArray *tokens = [NSMutableArray array];while (![scanner isAtEnd]) { for (NSString *operator in @[@&quot;=&quot;, @&quot;+&quot;, @&quot;*&quot;, @&quot;&gt;=&quot;, @&quot;&lt;=&quot;, @&quot;.&quot;]) { if ([scanner scanString:operator intoString:NULL]) { [tokens addObject:operator]; } }}//接下来识别非符号的只包含字母的stringNSString *result = nil;if ([scanner scanCharactersFromSet:[NSCharacterSet letterCharacterSet] intoString:&amp;result]) { [tokens addObject:result];}//NSScanner有scanDouble:来扫描doubledouble doubleResult = 0;if ([scanner scanDouble:&amp;doubleResult]) { [tokens addObject:@(doubleResult)];}//完成后用将需要解析的表达式放入试试NSString* example = @&quot;myConstant = 100\\n&quot; @&quot;\\nmyView.left = otherView.right * 2 + 10\\n&quot; @&quot;viewController.view.centerX + myConstant &lt;= self.view.centerX&quot;;NSArray *result = [self.scanner tokenize:example];NSArray *expected = @[@&quot;myConstant&quot;, @&quot;=&quot;, @100, @&quot;myView&quot;, @&quot;.&quot;, @&quot;left&quot;, @&quot;=&quot;, @&quot;otherView&quot;, @&quot;.&quot;, @&quot;right&quot;, @&quot;*&quot;, @2, @&quot;+&quot;, @10, @&quot;viewController&quot;, @&quot;.&quot;, @&quot;view&quot;, @&quot;.&quot;, @&quot;centerX&quot;, @&quot;+&quot;, @&quot;myConstant&quot;, @&quot;&lt;=&quot;, @&quot;self&quot;, @&quot;.&quot;, @&quot;view&quot;, @&quot;.&quot;, @&quot;centerX&quot;];XCTAssertEqualObjects(result, expected); 进行语法解析，需要语法分析库描述我们的语言。下面代码就是为那个布局约束语言写的解析语法，用的扩展的巴科斯范式EBNF写法： 12345678constraint = expression comparator expressioncomparator = &quot;=&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot;expression = keyPath &quot;.&quot; attribute addMultiplier addConstantkeyPath = identifier | identifier &quot;.&quot; keyPathattribute = &quot;left&quot; | &quot;right&quot; | &quot;top&quot; | &quot;bottom&quot; | &quot;leading&quot; | &quot;trailing&quot; | &quot;width&quot; | &quot;height&quot; | &quot;centerX&quot; | &quot;centerY&quot; | &quot;baseline&quot;addMultiplier = &quot;*&quot; atomaddConstant = &quot;+&quot; atomatom = number | identifier 还有很多Objective-C的语法解析，更多的可以在CocoaPods上找到：https://cocoapods.org/?q=parse。比较好的就是CoreParse，地址：https://github.com/beelsebob/CoreParse，但是需要使用它支持的语法。下面就是CoreParse支持的格式： 12345678910111213NSString* grammarString = [@[ @&quot;Atom ::= num@&apos;Number&apos; | ident@&apos;Identifier&apos;;&quot;, @&quot;Constant ::= name@&apos;Identifier&apos; &apos;=&apos; value@&lt;Atom&gt;;&quot;, @&quot;Relation ::= &apos;=&apos; | &apos;&gt;=&apos; | &apos;&lt;=&apos;;&quot;, @&quot;Attribute ::= &apos;left&apos; | &apos;right&apos; | &apos;top&apos; | &apos;bottom&apos; | &apos;leading&apos; | &apos;trailing&apos; | &apos;width&apos; | &apos;height&apos; | &apos;centerX&apos; | &apos;centerY&apos; | &apos;baseline&apos;;&quot;, @&quot;Multiplier ::= &apos;*&apos; num@&apos;Number&apos;;&quot;, @&quot;AddConstant ::= &apos;+&apos; num@&apos;Number&apos;;&quot;, @&quot;KeypathAndAttribute ::= &apos;Identifier&apos; &apos;.&apos; &lt;AttributeOrRest&gt;;&quot;, @&quot;AttributeOrRest ::= att@&lt;Attribute&gt; | &apos;Identifier&apos; &apos;.&apos; &lt;AttributeOrRest&gt;;&quot;, @&quot;Expression ::= &lt;KeypathAndAttribute&gt; &lt;Multiplier&gt;? &lt;AddConstant&gt;?;&quot;, @&quot;LayoutConstraint ::= lhs@&lt;Expression&gt; rel@&lt;Relation&gt; rhs@&lt;Expression&gt;;&quot;, @&quot;Rule ::= &lt;Atom&gt; | &lt;LayoutConstraint&gt;;&quot;,] componentsJoinedByString:@&quot;\\n&quot;]; 一个规则匹配后解析器就找到同样名称的类 1234567- (id)parser:(CPParser *)parser didProduceSyntaxTree:(CPSyntaxTree *)syntaxTree NSString *ruleName = syntaxTree.rule.name; if ([ruleName isEqualToString:@&quot;Attribute&quot;]) { return self.layoutAttributes[[[syntaxTree childAtIndex:0] keyword]]; }...} 完整的解析器代码在：https://github.com/objcio/issue-9-string-parsing。里面有个解析类可以用来解析复杂的布局约束，如下： 1viewController.view.centerX + 20 &lt;= self.view.centerX * 0.5 可以得到如下结果，方便转换成NSLayoutConstraint对象 123456789(&lt;Expression: self.keyPath=(viewController, view), self.attribute=9, self.multiplier=1, self.constant=20&gt;-1&lt;Expression: self.keyPath=(self, view), self.attribute=9, self.multiplier=0.5, self.constant=0&gt;) 字符串的渲染UILabel label默认显示一行，如果设置numberOfLines为大于1的话可以显示指定行数，如果设置为0，则多少行都显示 attributedText属性可以显示富文本 label的font,textColor,textAlignment,shadowColor和shadowOffset属性可以改变外观。 改变程序内所有Label的风格，可以使用[UILabel appearance]方法 UITextField text field只限于单行 UITextfield实现了UITextInputTraits协议，这个协议需要指定键盘外观和操作等细节。比如显示什么键盘和返回按键响应等 可以通过设置左右辅助视图，或者设置背景来自定义输入框风格了。 UITextView 相比较UITextField，它能够处理多行文本 可以使用定制Text Kit，官方文档：https://developer.apple.com/Library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html 可以为layout manager，text container或text storage自定义行为或替换自定义子类。 在iOS7之前是基于WebKit的功能少，之后会有很多不同具体可以参考这两篇文章：Peter的https://petersteinberger.com/blog/2014/fixing-uitextview-on-ios-7/，Brent的https://inessential.com/2014/01/07/uitextview_the_solution TableView中显示动态文本Table view的Delegate有个方法用来计算高度：tableView:heightForRowAtIndexPath:。自定义一个UITableViewCell的子类 1234567- (void)layoutSubviews{ [super layoutSubviews]; self.textLabel.frame = CGRectInset(self.bounds, MyTableViewCellInset, MyTableViewCellInset);} 计算真实高度需要使用boundingRectWithSize:options:context: 这个方法 123456789101112- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{ CGFloat labelWidth = self.tableView.bounds.size.width - MyTableViewCellInset*2; NSAttributedString *text = [self attributedBodyTextAtIndexPath:indexPath]; NSStringDrawingOptions options = NSStringDrawingUsesLineFragmentOrigin | NSStringDrawingUsesFontLeading; CGRect boundingRect = [text boundingRectWithSize:CGSizeMake(labelWidth, CGFLOAT_MAX) options:options context:nil]; return (CGFloat) (ceil(boundingRect.size.height) + MyTableViewCellInset*2);} 使用Text Kit和NSAttributedString进行布局先设置attributes 123456789101112CGFloat const fontSize = 15;NSMutableDictionary *body1stAttributes = [NSMutableDictionary dictionary];body1stAttributes[NSFontAttributeName] = [UIFont fontWithName:@&quot;BodoniSvtyTwoITCTT-Book&quot;size:fontSize];NSMutableParagraphStyle *body1stParagraph = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];body1stParagraph.alignment = NSTextAlignmentJustified;body1stParagraph.minimumLineHeight = fontSize + 3;body1stParagraph.maximumLineHeight = body1stParagraph.minimumLineHeight;body1stParagraph.hyphenationFactor = 0.97;body1stAttributes[NSParagraphStyleAttributeName] = body1stParagraph; 这里字体为BodoniSvtyTwoITCTT，如果需要查看更多字体可以使用 +[UIFont familyNames]这个方法。为了得到字体的名字，可以使用 +[UIFont fontNamesForFamilyName:]。接下来创建段落的属性 12345NSMutableDictionary *bodyAttributes = [body1stAttributes mutableCopy];NSMutableParagraphStyle *bodyParagraph = [bodyAttributes[NSParagraphStyleAttributeName] mutableCopy];bodyParagraph.firstLineHeadIndent = fontSize;bodyAttributes[NSParagraphStyleAttributeName] = bodyParagraph; 装饰段落风格，使用装饰字体将文本居中对齐，装饰字符的前后加上空白段落 12345678NSMutableDictionary *ornamentAttributes = [NSMutableDictionary dictionary];ornamentAttributes[NSFontAttributeName] = [UIFont fontWithName:@&quot;BodoniOrnamentsITCTT&quot; size:36];NSMutableParagraphStyle *ornamentParagraph = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];ornamentParagraph.alignment = NSTextAlignmentCenter;ornamentParagraph.paragraphSpacingBefore = fontSize;ornamentParagraph.paragraphSpacing = fontSize;ornamentAttributes[NSParagraphStyleAttributeName] = ornamentParagraph; 显示数字表格table，表格布局示例 123456789101112NSCharacterSet *decimalTerminator = [NSCharacterSet characterSetWithCharactersInString:decimalFormatter.decimalSeparator];NSTextTab *decimalTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentCenter location:100 options:@{NSTabColumnTerminatorsAttributeName:decimalTerminator}];NSTextTab *percentTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentRight location:200 options:nil];NSMutableParagraphStyle *tableParagraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];tableParagraphStyle.tabStops = @[decimalTab, percentTab]; 显示列表的属性设置如下 12345678910NSMutableDictionary *listAttributes = [bodyAttributes mutableCopy];NSMutableParagraphStyle *listParagraph = [listAttributes[NSParagraphStyleAttributeName] mutableCopy];listParagraph.headIndent = fontSize * 3;listParagraph.firstLineHeadIndent = fontSize;NSTextTab *listTab = [[NSTextTab alloc] initWithTextAlignment:NSTextAlignmentNatural location:fontSize * 3 options:nil];listParagraph.tabStops = @[listTab];listAttributes[NSParagraphStyleAttributeName] = listParagraph; 字符串本地化 使用NSLocalizedString，可查看文章《字符串本地化》：（中文）（英文） ming1016","link":"/program//ios-string/"},{"title":"Flutter的环境配置 for Mac","text":"前言最近Flutter已经疯狂的刷屏了各个技术博客、技术网站，完全有一统天下的气势。所以最近也决定开始尝尝鲜，从零开始一步步的来探索Flutter的世界。就从环境搭建开始，记录一下自己探索Flutter的过程。 安装Flutter首先我们可以在Flutter官网上面看到一些配置环境的步骤。这里就直接开干了，走起。 1、配置HomeBrew我们在去配置Flutter的环境之前，需要先检查一下HomeBrew是不是最新的。 1$ brew update 如果没有brew的话，可以去HomeBrew官网自行下载。这里就不赘述了，这里如果重新下载的话，看到下面的打印信息就说明下载完毕了。 2、下载SDK接下来就是去官网下载SDK了。注意，这里下载SDK有两种方法： 一是直接git clone -b beta https://github.com/flutter/flutter.git下载 二是自己在官网下载下来，如下图 这里我两种方法都试过了一遍，第一种方法实在是太慢了，在经历了耗费一个半小时下载到94%，最后提示失败了的过程之后，我决定还是用第二种方法，整个过程只用了3分钟的样子，相当满意。下载完之后，是一个名字叫flutter_macos_v1.5.4-hotfix.2-stable.zip的压缩包。 然后我们解压这个zip包，把解压出来的flutter文件放到根目录下即可。 3、配置环境变量因为Flutter的SDK中包含了很多的命令行工具。我们就需要配置环境变量，所以我直接就安装到了根目录下了。 配置镜像 因为Flutter在运行的时候，就需要去官网下载一些需要的资源，但是因为天国特色的wall的原因，我们就需要镜像服务器，这个在官网上面有写的很明白，而且这是一个临时的镜像，后面还要以官网的镜像地址为准。 我们跳转到根目录 1cd ~ 就能找到这个.bash_profile隐藏文件，我们用vim打开这个文件 1vim ~/.bash_profile 然后需要输入就把A键按一下进入编辑模式，把下面三个环境变量配置进去 123export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/Users/xueliheng/flutter/bin:$PATH 注意下，第三个环境变量这里/Users/xueliheng/是我的根目录，然后/flutter/是我们刚刚解压的的zip包里面的flutter文件夹。上面两个环境变量是两个镜像地址，上文中也有说过。 接着shift+：然后输入wq保存并退出vim。输入如下命令： 1source ~/.bash_profile 最后我们就可以验证一下flutter环境有没有配置成功了。输入： 1flutter -h 看到如下如的打印信息就是配置成功了 4、配置Android Studio如果没有下载Android Studio的话，就去官网去下载一下。 我们用flutter doctor命令去检查一下flutter的环境配置，我们可以看到如下打印 这里的每个✗都是我们要去解决的问题。不过他有告诉你应该怎么做。比如第一个提示： 12[✗] Android toolchain - develop for Android devices ✗ Unable to locate Android SDK. 这就是让你去下载Android Studio。我们在下载完成之后，打开AS让他去下载一些应该下载的东西。 如果这里有提示你 12[✗] Android toolchain - develop for Android devices (Android SDK version 24.0.2) ✗ Flutter requires Android SDK 28 and the Android BuildTools 28.0.3 这就是在提示让你去升级一下SDK，然后命令如下 1&quot;/Users/xueliheng/Library/Android/sdk/tools/bin/sdkmanager&quot; &quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot; 注意一下，这个地方的升级是需要”科学上网“的，如果有的小伙伴没有这个条件的话，我这边百度云上面给大家准备了一个链接，提取码: e48c，大家可以下载下来。下载下来之后解压到/Users/Library/Android/这个文件夹。把原先的SDK直接覆盖就行了，就已经是最新的SDK了。 接下来我们配置一下安卓的环境变量，还是在根目录下找到.bash_profile文件，并在其中添加四个环境变量 1234export ANDROID_HOME=~/Library/Android/sdkexport PATH=${PATH}:${ANDROID_HOME}/emulatorexport PATH=${PATH}:${ANDROID_HOME}/toolsexport PATH=${PATH}:${ANDROID_HOME}/platform-tools 分别是： 安卓sdk的路径 安卓的模拟器路径 安卓tools路径 安卓平台工具 接下来我们再用flutter doctor检查的时候，显示的信息如下图 意思就是让我们去下载iOS的相关环境，我们先暂时放放，下面还有一个关于Android Studio的没有解决完 12✗ Flutter plugin not installed; this adds Flutter specific functionality.✗ Dart plugin not installed; this adds Dart specific functionality. 这个就是缺少Flutter插件的意思，那么我们就去AS里面去配置一下好了。打开AS的Preferences，点击Plugins，在搜索栏中输入flutter，找到相应的插件，然后Install。当跳出安装Dart插件的提示界面时，记得点击Yes进行安装。安装完毕之后restart IDE重启AS。 重启之后就能看到多了一个这个东西 我们再用flutter doctor检测一下 现在终于ok了。我们看到[✓]Android Studio说明，安卓的环境基本上配置成功，接下来我们就配置一下安卓的模拟器就好了。 5、安卓模拟器配置在AS中找到模拟器配置如下图并选择 接着就创建设备，选择设备 选择系统 最后点击下载就完成了。 6、配置iOS环境我们配置完了安卓的环境，再来flutter doctor检测一下。 情况是这样的。目前1.5.4版本的Flutter需要匹配新版本的Xcode10.2.1。按照他提示的来试试，提示我Xcode版本太低了，需要升级Xcode 更新到最新的之后，继续走下面的步骤依旧会报错。那么我们可以试试下面的这个办法： 123456$ brew link pkg-config$ brew install --HEAD usbmuxd$ brew unlink usbmuxd$ brew link usbmuxd$ brew install --HEAD libimobiledevice$ brew install ideviceinstaller 这些执行完之后执行一下flutter doctor 最后还真是没错，全部配置完成了！那么我们就把iOS的也配置完毕了。 7、VSCode的使用VSCode上面使用的话，就简单多了，这里我就简答的赘述一下。 只需要将Dart和Flutter插件都下载下来 然后command+shift+p输入flutter，选择Flutter：New Project 输入要创建的项目的名称和存放项目的地址。如果提示需要指明flutter的SDK的路径，那就选择根目录那个经过解压得来的flutter的文件夹就好了。 接下来是这样一个界面 接下来我们选择View-&gt;Start Debugging来运行项目。 当然这个过程需要你把Xcode的模拟器打开。运行完之后就能看到这个界面，也就是你的第一个Flutter工程啦！ 8、Hot reload的使用我们打开lib/main.dart文件，然后在其中找到 1You have pushed the button this many times: 并把这个改为 1You have clicked the button this many times: 那么我们就能看到界面上多了一个小闪电 我们现在如果command+s保存一下更改的话，就能很快的在模拟器上面看到相应的更改，不需要再重新去编译一边。这一点简直是太棒了！解决了iOS开发者一个大痛点啊！！！ 结语至此，flutter的环境搭建工作基本上就进行完毕了，整个过程大概耗时接近2个小时，这期间包括采坑、查资料、下载、科学上网…等等很蛋疼的事情。当然网速基本上是最大的障碍，浪费了很多的时间。所以也是需要一定的耐心来完成的。 后面的文章也会持续的更新，最近有点懈怠，OpenGL系列的文章有点拖更的节奏，这个后面会补起来。Flutter我也才刚刚接手，也是慢慢的来采坑，也会以此来记录自己的学习经历，也希望能多多跟大家交流。 再次我附上自己的邮箱coderspr1nghall@gmail.com欢迎讨论交流。 原文链接👇","link":"/program/flutter/"},{"title":"再谈iOS静态库","text":"1.现在桌面创建文件夹 SHTestSDk 2.打开Xcode,创建一个workspace 流程: Xcode—File—New—Workspace 快捷键 :command +N = 创建项目 3.把创建好的添加到 文件名为 SHTestSDK 里面 图1: 图2: 图3:创建成功效果 1、打开SHTestSDK.xcworkspace文件，创建project 图4: 图5: 图6: 图7: 图8:成功效果图 图9: 图10: 图11:成功效果图 1.这里创建一个SHView类，继承于UIView，简单的重写了初始化方法，设置了颜色 图12: 2.设置Build Setting参数 将Build Active Architecture only设置为NO, 图13: 3.设置Build Setting参数 在Architectures下增加armv7s 图14: 4.设置Headers，将要公开的头文件拖到Public下，要隐藏的放到Private或Project下，隐藏的头文件不能被引用,效果图: 图15: 5.在SHTestSDK.h(必须是公开的，否则无法引用)中将所有要公开的.h引入 6.创建一个Aggregare 图16: 图17: 7.嵌入脚本，选中刚刚创建的Aggregare,然后选中右侧的Build Phases,点击左边的+号，选择New Run Script Phases 图18: 图19: 8.下面把这段脚本复制进去（格式不要错，格式错编译不通过） 1234567891011121314151617181920212223242526# Sets the target folders and the final framework product.# 如果工程名称和Framework的Target名称不一样的话，要自定义FMKNAME# 例如: FMK_NAME = &quot;MyFramework&quot;FMK_NAME=${PROJECT_NAME}# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_DIR=${SRCROOT}/Products/${FMK_NAME}.framework# Working dir will be deleted after the framework creation.WRK_DIR=buildDEVICE_DIR=${WRK_DIR}/Release-iphoneos/${FMK_NAME}.frameworkSIMULATOR_DIR=${WRK_DIR}/Release-iphonesimulator/${FMK_NAME}.framework# -configuration ${CONFIGURATION}# Clean and Building both architectures.xcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphoneos clean buildxcodebuild -configuration &quot;Release&quot; -target &quot;${FMK_NAME}&quot; -sdk iphonesimulator clean build# Cleaning the oldest.if [ -d &quot;${INSTALL_DIR}&quot; ]thenrm -rf &quot;${INSTALL_DIR}&quot;fimkdir -p &quot;${INSTALL_DIR}&quot;cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create &quot;${DEVICE_DIR}/${FMK_NAME}&quot; &quot;${SIMULATOR_DIR}/${FMK_NAME}&quot; -output &quot;${INSTALL_DIR}/${FMK_NAME}&quot;rm -r &quot;${WRK_DIR}&quot;open &quot;${INSTALL_DIR}&quot; 图20:效果图: 9.最后编译，command + B，编译通过在finder中找到framework，拷贝出来 图21: 图22:效果图 1.把打包好的framework拖到demo里面 图23: 2.使用SDK，运行demo 图24: 图25:效果图: 注意:以上功能就是SDK 和 demo 相关联好了. 1.修改下面SDK中的代码，运行demo就是修改后的效果，然后就可以愉快的在这个工程里面开发调试SDK了，如果我把MyView的颜色设置为yellow，再去运行demo，看一下效果 图26: 原文链接👇","link":"/program/apple/framework2/"},{"title":"深入剖析-iOS-编译-Clang---LLVM","text":"前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。 Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。 iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。 swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。 LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。 LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。 LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。 这里是 Clang 官方详细文档： Welcome to Clang’s documentation! — Clang 4.0 documentation 这篇是对 LLVM 架构的一个概述： The Architecture of Open Source Applications 将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 《linkers and loaders》 这本书就知道了。 编译流程在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。 12345678910111213#import &lt;Foundation/Foundation.h&gt;#define DEFINEEight 8int main(){ @autoreleasepool { int eight = DEFINEEight; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:”starming”]; int rank = eight + six; NSLog(@“%@ rank %d”, site, rank); } return 0;} 在命令行输入 1clang -ccc-print-phases main.m 可以看到编译源文件需要的几个不同的阶段 12345670: input, “main.m”, objective-c1: preprocessor, {0}, objective-c-cpp-output2: compiler, {1}, ir3: backend, {2}, assembler4: assembler, {3}, object5: linker, {4}, image6: bind-arch, “x86_64”, {5}, image 这样能够了解到过程和重要的信息。查看oc的c实现可以使用如下命令 1clang -rewrite-objc main.m 查看操作内部命令，可以使用 -### 命令 1clang -### main.m -o main 想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。 1clang -E main.m 执行完后可以看到文件 1234567891011121314# 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3# 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3# 2 “main.m” 2int main(){ @autoreleasepool { int eight = 8; int six = 6; NSString* site = [[NSString alloc] initWithUTF8String:”starming”]; int rank = eight + six; NSLog(@“%@ rank %d”, site, rank); } return 0;} 这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。 “#define” “#include” “#indef” 注释 “#pragma” 预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。 1clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。 1clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。 1clang -S -fobjc-arc -emit-llvm main.m -o main.ll 这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： Writing an LLVM Pass — LLVM 5 documentation 。 1clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。 如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。 1clang -emit-llvm -c main.m -o main.bc 生成汇编 1clang -S -fobjc-arc main.m -o main.s 生成目标文件 1clang -fmodules -c main.m -o main.o 生成可执行文件，这样就能够执行看到输出结果 12345clang main.o -o main执行./main输出starming rank 14 下面是完整步骤： 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 Clang 编译 .m 文件在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。 具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。 1CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler 接下来对会更新工作路径，同时设置 PATH 123cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods export LANG=en_US.US-ASCII export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin” 接下来就是实际的编译命令 1clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o clang 命令参数 12345678910-x 编译语言比如objective-c-arch 编译的架构，比如arm7-f 以-f开头的。-W 以-W开头的，可以通过这些定制编译警告-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本-I 把编译信息写入指定的辅助文件-F 需要的Framework-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件-o 编译结果 构建 Target编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息： 123456789101112131415Create product structureProcess product packagingRun custom shell script ‘Check Pods Manifest.lock’Compile … 各个项目中的.m文件Link /Users/… 路径Copy … 静态文件Compile asset catalogsCompile Storyboard file …Process info.plistLink StoryboardsRun custom shell script ‘Embed Pods Frameworks’Run custom shell script ‘Copy Pods Resources’…Touch GCDFetchFeed.appSign GCDFetchFeed.app 从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。 Target 在 Build 过程的控制在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。 Build Phases构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。 在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。 build phase 还会把静态资源拷贝到 bundle 里。 可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。 Build Rules指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。 Build Settings在 build 的过程中各个阶段的选项的设置。 pbxproj工程文件build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值 1rootObject = 3EE311301C4E1F0800103FA3 /* Project object */; 然后根据这个 ID 找到 main 工程的定义。 12345/* Begin PBXProject section */ 3EE311301C4E1F0800103FA3 /* Project object */ = { isa = PBXProject; …/* End PBXProject section */ 在 targets 里会指向各个 taget 的定义 12345targets = ( 3EE311371C4E1F0800103FA3 /* GCDFetchFeed */, 3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */, 3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,); 顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下： 12345678910111213141516171819203EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = { isa = PBXNativeTarget; buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” buildPhases = ( 9527AA01F4AAE11E18397E0C /* Check Pods st.lock */, 3EE311341C4E1F0800103FA3 /* Sources */, 3EE311351C4E1F0800103FA3 /* Frameworks */, 3EE311361C4E1F0800103FA3 /* Resources */, C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks DD33A716222617FAB49F1472 /* Copy Pods Resources ); buildRules = ( ); dependencies = ( ); name = GCDFetchFeed; productName = GCDFetchFeed; productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */; productType = “com.apple.product-type.application”;}; 这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。 接下来详细的看看 Clang 所做的事情吧。 Clang Static Analyzer静态代码分析可以在 llvm/clang/ Source Tree - Woboq Code Browser 上查看 Clang 的代码。 Youtube上一个教程：The Clang AST - a Tutorial - YouTubeCMU关于llvm的教案 https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/ 静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 TokensKind.def 里有 Clang 定义的所有 Token。Token 可以分为以下几类 关键字：语法中的关键字，if else while for 等。 标识符：变量名 字面量：值，数字，字符串 特殊符号：加减乘除等符号 通过下面的命令可以输出所有 token 和所在文件具体位置 123clang -fmodules -E -Xclang -dump-tokens main.m``` 结果如下 annot_module_include ‘#import &lt;Fo’ Loc=main.m:2:1int ‘int’ [StartOfLine] Loc=main.m:5:1identifier ‘main’ [LeadingSpace] Loc=main.m:5:5l_paren ‘(‘ Loc=main.m:5:9r_paren ‘)’ Loc=main.m:5:10l_brace ‘{‘ [LeadingSpace] Loc=main.m:5:12at ‘@‘ [StartOfLine] [LeadingSpace] Loc=main.m:6:5identifier ‘autoreleasepool’ Loc=main.m:6:6l_brace ‘{‘ [LeadingSpace] Loc=main.m:6:22identifier ‘NSString’ [StartOfLine] [LeadingSpace] Loc=main.m:7:9star ‘*’ [LeadingSpace] Loc=main.m:7:18identifier ‘a’ Loc=main.m:7:19equal ‘=‘ [LeadingSpace] Loc=main.m:7:21at ‘@‘ [LeadingSpace] Loc=main.m:7:23string_literal ‘”aaa”’ Loc=main.m:7:24semi ‘;’ Loc=main.m:7:29identifier ‘NSLog’ [StartOfLine] [LeadingSpace] Loc=main.m:8:9l_paren ‘(‘ Loc=main.m:8:14at ‘@‘ Loc=main.m:8:15string_literal ‘”hi %@“’ Loc=main.m:8:16comma ‘,’ Loc=main.m:8:23identifier ‘a’ Loc=main.m:8:24r_paren ‘)’ Loc=main.m:8:25semi ‘;’ Loc=main.m:8:26r_brace ‘}’ [StartOfLine] [LeadingSpace] Loc=main.m:9:5return ‘return’ [StartOfLine] [LeadingSpace] Loc=main.m:10:5numeric_constant ‘0’ [LeadingSpace] Loc=main.m:10:12semi ‘;’ Loc=main.m:10:13r_brace ‘}’ [StartOfLine] Loc=main.m:11:1eof ‘’ Loc=main.m:11:2 1234567可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=&lt;main.m:11:1&gt; 这个样的具体位置。接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。打印语法树的命令 clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 1输出结果 TranslationUnitDecl 0x7fa80f018ad0 &lt;&gt; |-TypedefDecl 0x7fa80f018fc8 &lt;&gt; implicit int128_t ‘int128’| -BuiltinType 0x7fa80f018d20 ‘__int128’ |-TypedefDecl 0x7fa80f019028 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t ‘unsigned __int128’ |-BuiltinType 0x7fa80f018d40 ‘unsigned int128’|-TypedefDecl 0x7fa80f0190b8 &lt;&gt; implicit SEL ‘SEL *’| -PointerType 0x7fa80f019080 ‘SEL *’ |-BuiltinType 0x7fa80f018f30 ‘SEL’|-TypedefDecl 0x7fa80f019198 &lt;&gt; implicit id ‘id’| -ObjCObjectPointerType 0x7fa80f019140 ‘id’ imported |-ObjCObjectType 0x7fa80f019110 ‘id’ imported|-TypedefDecl 0x7fa80f019278 &lt;&gt; implicit Class ‘Class’| -ObjCObjectPointerType 0x7fa80f019220 ‘Class’ |-ObjCObjectType 0x7fa80f0191f0 ‘Class’|-ObjCInterfaceDecl 0x7fa80f0192c8 &lt;&gt; implicit Protocol|-TypedefDecl 0x7fa80f019618 &lt;&gt; implicit __NSConstantString ‘struct __NSConstantString_tag’| -RecordType 0x7fa80f019430 ‘struct __NSConstantString_tag’ |-Record 0x7fa80f019390 ‘NSConstantString_tag’|-TypedefDecl 0x7fa80f0196a8 &lt;&gt; implicit builtin_ms_va_list ‘char *’| -PointerType 0x7fa80f019670 ‘char *’ |-BuiltinType 0x7fa80f018b60 ‘char’|-TypedefDecl 0x7fa80f047978 &lt;&gt; implicit __builtin_va_list ‘struct __va_list_tag [1]’| -ConstantArrayType 0x7fa80f047920 ‘struct __va_list_tag [1]’ 1 |-RecordType 0x7fa80f0197a0 ‘struct __va_list_tag’| `-Record 0x7fa80f0196f8 ‘va_list_tag’|-ImportDecl 0x7fa80f0486b0 main.m:2:1 col:1 implicit Foundation|-FunctionDecl 0x7fa80f048738 &lt;line:5:1, line:11:1&gt; line:5:5 main ‘int ()’| -CompoundStmt 0x7fa80f393998 &lt;col:12, line:11:1&gt; | |-ObjCAutoreleasePoolStmt 0x7fa80f393950 &lt;line:6:5, line:9:5&gt; | |-CompoundStmt 0x7fa80f393928 &lt;line:6:22, line:9:5&gt;| | |-DeclStmt 0x7fa80f3a3b38 &lt;line:7:9, col:29&gt;| | | -VarDecl 0x7fa80f3a3580 &lt;col:9, col:24&gt; col:19 used a ‘NSString *’ cinit | | |-ObjCStringLiteral 0x7fa80f3a3648 &lt;col:23, col:24&gt; ‘NSString ’| | | -StringLiteral 0x7fa80f3a3618 &lt;col:24&gt; ‘char [4]’ lvalue “aaa” | |-CallExpr 0x7fa80f3938c0 &lt;line:8:9, col:25&gt; ‘void’| | |-ImplicitCastExpr 0x7fa80f3938a8 col:9 ‘void ()(id, …)’ | | | -DeclRefExpr 0x7fa80f3a3b50 &lt;col:9&gt; ‘void (id, …)’ Function 0x7fa80f3a3670 ‘NSLog’ ‘void (id, …)’ | | |-ImplicitCastExpr 0x7fa80f3938f8 &lt;col:15, col:16&gt; ‘id’:’id’ &lt;BitCast&gt; | | |-ObjCStringLiteral 0x7fa80f393800 &lt;col:15, col:16&gt; ‘NSString *’| | | -StringLiteral 0x7fa80f3a3bb8 &lt;col:16&gt; ‘char [6]’ lvalue “hi %@“ | |-ImplicitCastExpr 0x7fa80f393910 col:24 ‘NSString *’ | | -DeclRefExpr 0x7fa80f393820 &lt;col:24&gt; ‘NSString *’ lvalue Var 0x7fa80f3a3580 ‘a’ ‘NSString *’ |-ReturnStmt 0x7fa80f393980 &lt;line:10:5, col:12&gt;| -IntegerLiteral 0x7fa80f393960 &lt;col:12&gt; ‘int’ 0- 12345TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker debug.ConfigDumper Dump config tabledebug.DumpCFG Display Control-Flow Graphsdebug.DumpCallGraph Display Call Graphdebug.DumpCalls Print calls as they are traversed by the enginedebug.DumpDominators Print the dominance tree for a given CFGdebug.DumpLiveVars Print results of live variable analysisdebug.DumpTraversal Print branch conditions as they are traversed by the enginedebug.ExprInspection Check the analyzer’s understanding of expressionsdebug.Stats Emit warnings with analyzer statisticsdebug.TaintTest Mark tainted symbols as such.debug.ViewCFG View Control-Flow Graphs using GraphVizdebug.ViewCallGraph View Call Graph using GraphVizdebug.ViewExplodedGraph View Exploded Graphs using GraphViz 1234567891011这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：https://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf 在clang里的具体实现代码可以查看这两个文件 [MemRegion.h](https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html)和 [RegionStore.cpp](https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html) 。下面举个简单例子看看 clang static analyzer 是如何对源码进行模拟的。 int main(){ int a; int b = 10; a = b; return a;} 1对应的 AST 以及 CFG #————————AST————————— clang -cc1 -ast-dumpTranslationUnitDecl 0xc75b450 &lt;&gt; |-TypedefDecl 0xc75b740 &lt;&gt; implicit __builtin_va_list ‘char *’-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt; |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt; | -VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’ |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt; |-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit | `-IntegerLiteral 0xc75b8c0 col:10 ‘int’ 10 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘ | |-DeclRefExpr 0xc75b8e8 col:2 ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’ | -ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt; |-DeclRefExpr 0xc75b900 col:6 ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt; `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt; `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’#————————CFG————————— clang -cc1 -analyze -analyzer-checker=debug.DumpCFGint main() [B2 (ENTRY)] Succs (1): B1 [B1] 1: int a; 2: 10 3: int b = 10; 4: b 5: [B1.4] (ImplicitCastExpr, LValueToRValue, int) 6: a 7: [B1.6] = [B1.5] 8: a 9: [B1.8] (ImplicitCastExpr, LValueToRValue, int) 10: return [B1.9]; Preds (1): B2 Succs (1): B0 [B0 (EXIT)] Preds (1): B1 1234567891011121314151617181920212223242526272829303132CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。官方 AST 相关文档* https://clang.llvm.org/docs/Tooling.html* https://clang.llvm.org/docs/IntroductionToTheClangAST.html* https://clang.llvm.org/docs/RAVFrontendAction.html* https://clang.llvm.org/docs/LibTooling.html* https://clang.llvm.org/docs/LibASTMatchers.html静态检查的一些库以及使用方法* [FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub](https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0)# CodeGen 生成 IR 代码将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。这个过程中还会跟 runtime 桥接。* 各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。* Non-Fragile ABI 合成 OBJC_IVAR_$_ 偏移值常量。* ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。* strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。* @synthesize 的处理。* 生成 block_layout 数据结构* __block 和 __weak* _block_invoke* ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。## IR 结构下面是刚才生成的 main.ll 中间代码文件。 ; ModuleID = ‘main.c’source_filename = “main.c”target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”target triple = “x86_64-apple-macosx10.12.0” @.str = private unnamed_addr constant [16 x i8] c”Please input a:\\00”, align 1@.str.1 = private unnamed_addr constant [3 x i8] c”%d\\00”, align 1@.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\\00”, align 1@.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\\00”, align 1 ; Function Attrs: nounwind ssp uwtabledefine i32 @main() #0 { %1 = alloca i32, align 4 %2 = alloca i32, align 4 %3 = bitcast i32* %1 to i8* call void @llvm.lifetime.start(i64 4, i8* %3) #3 %4 = bitcast i32* %2 to i8* call void @llvm.lifetime.start(i64 4, i8* %4) #3 %5 = tail call i32 (i8, …) @printf(i8 getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0)) %6 = call i32 (i8, …) @scanf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1) %7 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0)) %8 = call i32 (i8, …) @scanf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2) %9 = load i32, i32* %1, align 4, !tbaa !2 %10 = load i32, i32* %2, align 4, !tbaa !2 %11 = add nsw i32 %10, %9 %12 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11) call void @llvm.lifetime.end(i64 4, i8* %4) #3 call void @llvm.lifetime.end(i64 4, i8* %3) #3 ret i32 0} ; Function Attrs: argmemonly nounwinddeclare void @llvm.lifetime.start(i64, i8* nocapture) #1 ; Function Attrs: nounwinddeclare i32 @printf(i8* nocapture readonly, …) #2 ; Function Attrs: nounwinddeclare i32 @scanf(i8* nocapture readonly, …) #2 ; Function Attrs: argmemonly nounwinddeclare void @llvm.lifetime.end(i64, i8* nocapture) #1 attributes #0 = { nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” }attributes #1 = { argmemonly nounwind }attributes #2 = { nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” }attributes #3 = { nounwind } !llvm.module.flags = !{!0}!llvm.ident = !{!1} !0 = !{i32 1, !”PIC Level”, i32 2}!1 = !{!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”}!2 = !{!3, !3, i64 0}!3 = !{!”int”, !4, i64 0}!4 = !{!”omnipotent char”, !5, i64 0}!5 = !{!”Simple C/C++ TBAA”} 123456789101112131415161718LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。‘通过下面的 IR 结构图能够更好的理解 IR 的整体结构。![](https://github.com/ming1016/study/blob/master/pic/deeply-analyse-llvm08.png?raw=true)图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。IR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。## LLVM IR 优化使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上 int i = 0;while (i &lt; 10) { i++; printf(“%d”,i);} 1对应的 IR 代码是 %call4 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1) %call4.1 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2) %call4.2 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3) %call4.3 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4) %call4.4 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5) %call4.5 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6) %call4.6 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7) %call4.7 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8) %call4.8 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9) %call4.9 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10) 123可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？我们改成100后，再次生成 IR 可以看到 IR 变成了这样： br label %while.body while.body: ; preds = %while.body, %entry %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ] %inc = add nuw nsw i32 %i.010, 1 %call4 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc) %exitcond = icmp eq i32 %inc, 100 br i1 %exitcond, label %while.end, label %while.body while.end: ; preds = %while.body %2 = load i32, i32* %a, align 4, !tbaa !2 %3 = load i32, i32* %b, align 4, !tbaa !2 %add = add nsw i32 %3, %2 %call5 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add) call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3 call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3 ret i32 0} 123456789101112这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：* @ - 代表全局变量* % - 代表局部变量* alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。* i32：- i 是几这个整数就会占几位，i32就是32位4字节* align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。* Load - 读出，store 写入* icmp - 两个整数值比较，返回布尔值* br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto* indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的* label - 代码标签 br label %while.body 1如上面表述，br 会选择跳向 while.body 定义的这个标签。这个标签里可以看到 %exitcond = icmp eq i32 %inc, 100 br i1 %exitcond, label %while.end, label %while.body 1234567这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。## SSALLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。那么看看加法这个操作的相关的 IR 代码 %2 = load i32, i32* %a, align 4, !tbaa !2%3 = load i32, i32* %b, align 4, !tbaa !2%add = add nsw i32 %3, %2 12加法对应的指令是 BinaryOperator::CreateAdd(Value *V1, Value *V2, const Twine &amp;Name) 12两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码 class Value { void addUse(Use &amp;U) { U.addToList(&amp;UseList); } // …}; class Use { Value Val; Use *Next; PointerIntPair&lt;Use *, 2, PrevPtrTag&gt; Prev; // …}; void Use::set(Value V) { if (Val) removeFromList(); Val = V; if (V) V-&gt;addUse(this);} Value *Use::operator=(Value *RHS) { set(RHS); return RHS;} class User : public Value { template &lt;int Idx, typename U&gt; static Use &amp;OpFrom(const U that) { return Idx &lt; 0 ? OperandTraits::op_end(const_cast&lt;U&gt;(that))[Idx] : OperandTraits::op_begin(const_cast&lt;U*&gt;(that))[Idx]; } template Use &amp;Op() { return OpFrom(this); } template const Use &amp;Op() const { return OpFrom(this); } // …}; class Instruction : public User, public ilist_node_with_parent&lt;Instruction, BasicBlock&gt; { // …}; class BinaryOperator : public Instruction { /// Construct a binary instruction, given the opcode and the two /// operands. Optionally (if InstBefore is specified) insert the instruction /// into a BasicBlock right before the specified instruction. The specified /// Instruction is allowed to be a dereferenced end iterator. /// static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2, const Twine &amp;Name = Twine(), Instruction *InsertBefore = nullptr); // …}; BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2, Type *Ty, const Twine &amp;Name, Instruction *InsertBefore) : Instruction(Ty, iType, OperandTraits::op_begin(this), OperandTraits::operands(this), InsertBefore) { Op&lt;0&gt;() = S1; Op&lt;1&gt;() = S2; init(iType); setName(Name);} BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2, const Twine &amp;Name, Instruction *InsertBefore) { assert(S1-&gt;getType() == S2-&gt;getType() &amp;&amp; “Cannot create binary operator with two operands of differing type!”); return new BinaryOperator(Op, S1, S2, S1-&gt;getType(), Name, InsertBefore);} 1234567891011121314151617181920212223242526272829303132从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。LLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。这里可以进行 lli 解释执行 LLVM IR。llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。llvm-mc 还可以直接生成 object 文件。# Clang CFE动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。* LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。* The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。* The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。* Precompiled Headers - Clang 支持预编译 headers 的两个实现。* The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。* The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。* The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。* The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。## libclanglibclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下先写个 libclang 的程序来解析源码 int main(int argc, char *argv[]) { CXIndex Index = clang_createIndex(0, 0); CXTranslationUnit TU = clang_parseTranslationUnit(Index, 0, argv, argc, 0, 0, CXTranslationUnit_None); for (unsigned I = 0, N = clang_getNumDiagnostics(TU); I != N; ++I) { CXDiagnostic Diag = clang_getDiagnostic(TU, I); CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions()); fprintf(stderr, “%s\\n”, clang_getCString(String)); clang_disposeString(String); } clang_disposeTranslationUnit(TU); clang_disposeIndex(Index); return 0;} 12再写个有问题的 c 程序 struct List { /*/ };int sum(union List *L) { / … */ } 1234567891011运行了语法检查后会出现提示信息```bashlist.c:2:9: error: use of &apos;List&apos; with tag type that does not match previous declarationint sum(union List *Node) {^~~~~structlist.c:1:8: note: previous use is herestruct List {^ 下面我们看看诊断过程，显示几个核心诊断方法诊断出问题 enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag); CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag); CXString clang_getDiagnosticSpelling(CXDiagnostic Diag); 接着进行高亮显示，最后提供两个提示修复的方法 unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);* CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,CXSourceRange *ReplacementRange); 我们先遍历语法树的节点。源 c 程序如下 12345678910struct List { int Data; struct List *Next;};int sum(struct List *Node) { int result = 0; for (; Node; Node = Node-&gt;Next) result = result + Node-&gt;Data; return result;} 先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。 CXCursor 会统一 AST 的节点，规范包含的信息 代码所在位置和长度 名字和符号解析 类型 子节点 举个 CXCursor 分析例子 1234struct List { int Data; struct List *Next;}; CXCursor 的处理过程如下 12345678910111213//Top-level cursor Cclang_getCursorKind(C) == CXCursor_StructDeclclang_getCursorSpelling(C) == &quot;List&quot; //获取名字字符串clang_getCursorLocation(C) //位置clang_getCursorExtent(C) //长度clang_visitChildren(C, ...); //访问子节点//Reference cursor Rclang_getCursorKind(R) == CXCursor_TypeRef clang_getCursorSpelling(R) == &quot;List&quot;clang_getCursorLocation(R)clang_getCursorExtent(R)clang_getCursorReferenced(R) == C //指向C Driver动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。 Driver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。 相关源代码在这里：clang/tools/driver/driver.cpp 整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个 driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。 1234567891011121314151617181920212223242526272829303132int main(int argc_, const char **argv_) { llvm::sys::PrintStackTraceOnErrorSignal(argv_[0]); llvm::PrettyStackTraceProgram X(argc_, argv_); llvm::llvm_shutdown_obj Y; // Call llvm_shutdown() on exit. if (llvm::sys::Process::FixupStandardFileDescriptors()) return 1; SmallVector&lt;const char *, 256&gt; argv; llvm::SpecificBumpPtrAllocator&lt;char&gt; ArgAllocator; std::error_code EC = llvm::sys::Process::GetArgumentVector( argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator); if (EC) { llvm::errs() &lt;&lt; &quot;error: couldn&apos;t get arguments: &quot; &lt;&lt; EC.message() &lt;&lt; &apos;\\n&apos;; return 1; } llvm::InitializeAllTargets(); std::string ProgName = argv[0]; std::pair&lt;std::string, std::string&gt; TargetAndMode = ToolChain::getTargetAndModeFromProgramName(ProgName); llvm::BumpPtrAllocator A; llvm::StringSaver Saver(A); //省略 ... // If we have multiple failing commands, we return the result of the first // failing command. return Res;} Driver 的工作流程图在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344 Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags); SetInstallDir(argv, TheDriver, CanonicalPrefixes); insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv, SavedStrings); SetBackdoorDriverOutputsFromEnvVars(TheDriver); std::unique_ptr&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv)); int Res = 0; SmallVector&lt;std::pair&lt;int, const Command *&gt;, 4&gt; FailingCommands; if (C.get()) Res = TheDriver.ExecuteCompilation(*C, FailingCommands); // Force a crash to test the diagnostics. if (::getenv(&quot;FORCE_CLANG_DIAGNOSTICS_CRASH&quot;)) { Diags.Report(diag::err_drv_force_crash) &lt;&lt; &quot;FORCE_CLANG_DIAGNOSTICS_CRASH&quot;; // Pretend that every command failed. FailingCommands.clear(); for (const auto &amp;J : C-&gt;getJobs()) if (const Command *C = dyn_cast&lt;Command&gt;(&amp;J)) FailingCommands.push_back(std::make_pair(-1, C)); } for (const auto &amp;P : FailingCommands) { int CommandRes = P.first; const Command *FailingCommand = P.second; if (!Res) Res = CommandRes; // If result status is &lt; 0, then the driver command signalled an error. // If result status is 70, then the driver command reported a fatal error. // On Windows, abort will return an exit code of 3. In these cases, // generate additional diagnostic information if possible. bool DiagnoseCrash = CommandRes &lt; 0 || CommandRes == 70;#ifdef LLVM_ON_WIN32 DiagnoseCrash |= CommandRes == 3;#endif if (DiagnoseCrash) { TheDriver.generateCompilationDiagnostics(*C, *FailingCommand); break; } } 可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到 1#include &quot;clang/Driver/Compilation.h&quot; 根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Compilation { /// The original (untranslated) input argument list. llvm::opt::InputArgList *Args; /// The driver translated arguments. Note that toolchains may perform their /// own argument translation. llvm::opt::DerivedArgList *TranslatedArgs; /// The driver we were created by. const Driver &amp;TheDriver; /// The default tool chain. const ToolChain &amp;DefaultToolChain; ... /// The list of actions. This is maintained and modified by consumers, via /// getActions(). ActionList Actions; /// The root list of jobs. JobList Jobs; ...public: ... const Driver &amp;getDriver() const { return TheDriver; } const ToolChain &amp;getDefaultToolChain() const { return DefaultToolChain; } ... ActionList &amp;getActions() { return Actions; } const ActionList &amp;getActions() const { return Actions; } ... JobList &amp;getJobs() { return Jobs; } const JobList &amp;getJobs() const { return Jobs; } void addCommand(std::unique_ptr&lt;Command&gt; C) { Jobs.addJob(std::move(C)); } ... /// ExecuteCommand - Execute an actual command. /// /// \\param FailingCommand - For non-zero results, this will be set to the /// Command which failed, if any. /// \\return The result code of the subprocess. int ExecuteCommand(const Command &amp;C, const Command *&amp;FailingCommand) const; /// ExecuteJob - Execute a single job. /// /// \\param FailingCommands - For non-zero results, this will be a vector of /// failing commands and their associated result code. void ExecuteJobs( const JobList &amp;Jobs, SmallVectorImpl&lt;std::pair&lt;int, const Command *&gt;&gt; &amp;FailingCommands) const; ...}; 通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下： Parse看完完整的 Driver 流程后，我们就先从 Parse 开始说起。 Parse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。 下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd 这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。 Driver 层会解析我们传入的 -I Option 参数。 -x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。 1clang -x c++ main.cpp 通过报错信息可以看出一些链接错误 因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了 1clang -x c++ -lc++ main.cpp 那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。 只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。 这点可以通过 driver.cpp 源码来看，在 main() 函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。 123456789101112131415if (MarkEOLs &amp;&amp; argv.size() &gt; 1 &amp;&amp; StringRef(argv[1]).startswith(&quot;-cc1&quot;)) MarkEOLs = false; llvm::cl::ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs); // 处理 -cc1 集成工具 auto FirstArg = std::find_if(argv.begin() + 1, argv.end(), [](const char *A) { return A != nullptr; }); if (FirstArg != argv.end() &amp;&amp; StringRef(*FirstArg).startswith(&quot;-cc1&quot;)) { // 如果 -cc1 来自 response file, 移除 EOL sentinels if (MarkEOLs) { auto newEnd = std::remove(argv.begin(), argv.end(), nullptr); argv.resize(newEnd - argv.begin()); } return ExecuteCC1Tool(argv, argv[1] + 4); } 如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数 1234567891011static int ExecuteCC1Tool(ArrayRef&lt;const char *&gt; argv, StringRef Tool) { void *GetExecutablePathVP = (void *)(intptr_t) GetExecutablePath; if (Tool == &quot;&quot;) return cc1_main(argv.slice(2), argv[0], GetExecutablePathVP); if (Tool == &quot;as&quot;) return cc1as_main(argv.slice(2), argv[0], GetExecutablePathVP); // 拒绝未知工具 llvm::errs() &lt;&lt; &quot;error: unknown integrated tool &apos;&quot; &lt;&lt; Tool &lt;&lt; &quot;&apos;\\n&quot;; return 1;} 最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。 下面看看有哪些解析 Args 的方法 ParseAnalyzerArgs - 解析出静态分析器 option ParseMigratorArgs - 解析 Migrator option ParseDependencyOutputArgs - 解析依赖输出 option ParseCommentArgs - 解析注释 option ParseFileSystemArgs - 解析文件系统 option ParseFrontendArgs - 解析前端 option ParseTargetArgs - 解析目标 option ParseCodeGenArgs - 解析 CodeGen 相关的 option ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option parseSanitizerKinds - 解析 Sanitizer Kinds ParsePreprocessorArgs - 解析预处理的 option ParsePreprocessorOutputArgs - 解析预处理输出的 option PipelinePipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。 这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。 在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。 使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。 Action12345678910111213141516/// BuildActions - Construct the list of actions to perform for the /// given arguments, which are only done for a single architecture. /// /// \\param C - The compilation that is being built. /// \\param Args - The input arguments. /// \\param Actions - The list to store the resulting actions onto. void BuildActions(Compilation &amp;C, llvm::opt::DerivedArgList &amp;Args, const InputList &amp;Inputs, ActionList &amp;Actions) const; /// BuildUniversalActions - Construct the list of actions to perform /// for the given arguments, which may require a universal build. /// /// \\param C - The compilation that is being built. /// \\param TC - The default host tool chain. void BuildUniversalActions(Compilation &amp;C, const ToolChain &amp;TC, const InputList &amp;BAInputs) const; 上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法 1234567891011void Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args, const InputList &amp;Inputs, ActionList &amp;Actions) const { llvm::PrettyStackTraceString CrashInfo(&quot;Building compilation actions&quot;); if (!SuppressMissingInputWarning &amp;&amp; Inputs.empty()) { Diag(clang::diag::err_drv_no_input_files); return; } Arg *FinalPhaseArg; phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg); 接着跟 getFinalPhase 这个方法。 123456789101112131415161718192021222324252627282930// -{E,EP,P,M,MM} only run the preprocessor. if (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) || (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) || (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) || (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) { FinalPhase = phases::Preprocess; // -{fsyntax-only,-analyze,emit-ast} only run up to the compiler. } else if ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) || (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) || (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) || (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) || (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) || (PhaseArg = DAL.getLastArg(options::OPT__migrate)) || (PhaseArg = DAL.getLastArg(options::OPT__analyze, options::OPT__analyze_auto)) || (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) { FinalPhase = phases::Compile; // -S only runs up to the backend. } else if ((PhaseArg = DAL.getLastArg(options::OPT_S))) { FinalPhase = phases::Backend; // -c compilation only runs up to the assembler. } else if ((PhaseArg = DAL.getLastArg(options::OPT_c))) { FinalPhase = phases::Assemble; // Otherwise do everything. } else FinalPhase = phases::Link; 看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。 下面列下一些编译器的前端 Action，大家可以一个个用着玩。 InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E RewriteIncludesAction - 预处理 DumpTokensAction - 打印token，option 是 -dump-tokens DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts ASTDeclListAction - 打印 AST 节点，option 是 -ast-list ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view AnalysisAction - 运行静态分析引擎，option 是 -analyze EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc MigrateSourceAction - 代码迁移，option 是 -migrate BindBind 主要是与工具链 ToolChain 交互根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。 通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果 可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。 TranslateTranslate 就是把相关的参数对应到不同平台上不同的工具。 Jobs从创建 Jobs 的方法 12345678910/// BuildJobsForAction - Construct the jobs to perform for the action \\p A and /// return an InputInfo for the result of running \\p A. Will only construct /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once. InputInfo BuildJobsForAction(Compilation &amp;C, const Action *A, const ToolChain *TC, StringRef BoundArch, bool AtTopLevel, bool MultipleArchs, const char *LinkingOutput, std::map&lt;std::pair&lt;const Action *, std::string&gt;, InputInfo&gt; &amp;CachedResults, Action::OffloadKind TargetDeviceOffloadKind) const; 可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。 Execute在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码： 12345// Set up response file names for each command, if necessary for (auto &amp;Job : C.getJobs()) setUpResponseFiles(C, Job); C.ExecuteJobs(C.getJobs(), FailingCommands); 能够看到 Jobs 准备好了后就要开始 Excute 他们。 Execute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。 Clang Attributes以 attribute(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法： attribute((format(NSString, F, A))) 格式化字符串可以查看 NSLog 的用法 12345678910FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;// Marks APIs which format strings by taking a format string and optional varargs as arguments#if !defined(NS_FORMAT_FUNCTION) #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED) #define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A))) #else #define NS_FORMAT_FUNCTION(F,A) #endif#endif attribute((deprecated(s))) 版本弃用提示在编译过程中能够提示开发者该方法或者属性已经被弃用 12- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏 attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。 1- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”))); attribute((unavailable(…))) 方法不可用提示这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。 attribute((unused))没有被使用也不报警告 attribute((warn_unused_result))不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。 attribute((availability(swift, unavailable, message=_msg)))OC 的方法不能在 Swift 中使用。 attribute((cleanup(…))) 作用域结束时自动执行一个指定方法作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。 Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下： 1234567#define onExit \\ rac_keywordify \\ __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) { (*block)();} 这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用 123456789101112131415if (property != NULL) { rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property); if (attributes != NULL) { @onExit { free(attributes); }; BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type; BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”); BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0; BOOL isWeak = attributes-&gt;weak; shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol; } } 可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。 attribute((overloadable)) 方法重载能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数 1234567891011__attribute__((overloadable)) void printArgument(int number){ NSLog(@“Add Int %i”, number);}__attribute__((overloadable)) void printArgument(NSString *number){ NSLog(@“Add NSString %@“, number);}__attribute__((overloadable)) void printArgument(NSNumber *number){ NSLog(@“Add NSNumber %@“, number);} attribute((objc_designated_initializer)) 指定内部实现的初始化方法 如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。 如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。 attribute((objc_subclassing_restricted)) 指定不能有子类相当于 Java 里的 final 关键字，如果有子类继承就会出错。 attribute((objc_requires_super)) 子类继承必须调用 super声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。 attribute((const)) 重复调用相同数值参数优化返回用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。 attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。 通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。 Clang 警告处理先看看这个 1234#pragma clang diagnostic push#pragma clang diagnostic ignored “-Wdeprecated-declarations” sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];#pragma clang diagnostic pop 如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。 使用 libclang 来进行语法分析使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。 使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented. 。 写个 python 脚本来调用 clang 12345678910111213141516171819202122232425262728pip install clang#!/usr/bin/python# vim: set fileencoding=utf-8import clang.cindeximport asciitreeimport sysdef node_children(node): return (c for c in node.get_children() if c.location.file == sys.argv[1])def print_node(node): text = node.spelling or node.displayname kind = str(node.kind)[str(node.kind).index(‘.’)+1:] return ‘{} {}’.format(kind, text)if len(sys.argv) != 2: print(“Usage: dump_ast.py [header file name]”) sys.exit()clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)index = clang.cindex.Index.create()translation_unit = index.parse(sys.argv[1], [‘-x’, ‘objective-c’])print asciitree.draw_tree(translation_unit.cursor, lambda n: list(n.get_children()), lambda n: “%s (%s)” % (n.spelling or n.displayname, str(n.kind).split(“.”)[1])) 基于语法树的分析还可以针对字符串做加密。 LibTooling 对语法树完全的控制因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。 可以改变 clang 生成代码的方式。 增加更强的类型检查。 按照自己的定义进行代码的检查分析。 对源码做任意类型分析，甚至重写程序。 给 clang 添加一些自定义的分析，创建自己的重构器。 基于现有代码做出大量的修改。 基于工程生成相关图形或文档。 检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者 Swift 。 官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation 按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool. 可以直接 make 成一个二进制文件。 下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子 123@interface Observer+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;@end 123456789101112131415161718192021222324//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。virtual bool VisitObjCMessageExpr(ObjCMessageExpr *E) { if (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) { QualType ReceiverType = E-&gt;getClassReceiver(); Selector Sel = E-&gt;getSelector(); string TypeName = ReceiverType.getAsString(); string SelName = Sel.getAsString(); if (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) { Expr *Receiver = E-&gt;getArg(0)-&gt;IgnoreParenCasts(); ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(1)-&gt;IgnoreParenCasts()); Selector Sel = SelExpr-&gt;getSelector(); if (const ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) { ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl(); if (! decl-&gt;lookupInstanceMethod(Sel)) { errs() &lt;&lt; “Warning: class “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\\n”; SourceLocation Loc = E-&gt;getExprLoc(); PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc); errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\\n”; } } } } return true;} Clang Plugin通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools 动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库 clangtojs资源 - Lmsgsendnilself ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： Calling Conventions in Cocoa by sunnyxx bang 也有篇文章： 如何动态调用 C 函数 « bang’s blog 。 这三个方案作者都分别写了文章详细说明其实现方案。 JSPatch实现原理详解 « bang’s blog DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航 OCS——史上最疯狂的iOS动态化方案 - 简书 滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 《基于clang插件的一种iOS包大小瘦身方案》 那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。 官方 clang 的插件： External Clang Examples 收集一些如何使用 clang 库的例子：GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library 在 Xcode 中添加 clang 静态分析自定义 checks： Running the analyzer within Xcode 将 LLVM C 的 API 用 swift 来包装： GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1 LLVM Backend首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置： 接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明 CodeGen 阶段 Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph） Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列 SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的 Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上Prolog / Epilog 生成 确定所需堆栈大小：Machine Code 晚期优化：最后一次优化机会 Code Emission：输出代码，可以选择汇编或者二进制机器码。 SelectionDAG 构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点 优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出 Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到 指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr） 下图是 llc -view-isel-dags 状态下的 DAG 图： 查看 DAG 不同状态的说明如下： -view-dag-combine1-dags：可以显示没有被优化的 DAG -view-legalize-dags：合法化之前的 DAG -view-dag-cmobine2-dags：第二次优化前 -view-isel-dags：显示指令选择前的 DAG -view-sched-dags：在 Scheduler 之前 ISel 之后 -view-sunit-dags：可以显示 Scheduler 的依赖图 Register Allocation 寄存器分配寄存器在 LLVM 中的表达物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc 虚拟寄存器到物理寄存器的映射直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度 LLVM 自带的寄存器分配算法llc -regalloc=Greedy add.bc -o ln.s Fast - debug 默认，尽可能保存寄存器。 Basic - 增量分配 Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化 PBQP - 将寄存器分配描述成分区布尔二次规划 Code Emission下图详细表达了整个 Code Emission 的过程 Swift 编译流Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。 下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift 1print(“hi!”) 生成程序 12swiftc toy.swift./toy 生成检查 AST 1swiftc -dump-ast toy.swift 可以还原之前函数名 1swiftc -emit-silgen toy.swift | xcrun swift-demangle llvm ir 和汇编的生成 12swiftc -emit-ir toy.swiftswiftc -emit-assembly toy.swift 生成可执行的脚本 1xcrun -sdk macosx swiftc toy.swift -o toy 编译后生成的二进制内容 Link Map File在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容 Object files这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。 Sections这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 __TEXT 代码段和 __DATA 数据段两种。 SymbolsSymbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。 每次编译后生成的 dSYM 文件在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。 可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。 还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令 12export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developersymbolicatecrash appName.crash appName.app &gt; appName.log Mach-O 文件记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。 Mach-O 文件包含三个区域 Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等 Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。 Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。 Mach-O 文件的解析再通过一个例子来分析下：这次用 xcrun 来 1xcrun clang -v 先创建一个test.c的文件 1touch test.c 编辑里面的内容 12345678vi test.c#include &lt;stdio.h&gt;int main(int argc, char *argv[]){ printf(&quot;hi there!\\n&quot;); return 0;} 编译运行，没有起名默认为 a.out 12xcrun clang test.c./a.out a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码 1xcrun clang -S -o - test.c | open -f 输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行 1234.section __TEXT,__text,regular,pure_instructions.macosx_version_min 10, 12.globl _main.align 4, 0x90 .section 指令指定接下来执行哪一个段。 .globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。 .align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。 看看接下来的 main 函数头部部分 123456789101112_main: ## @main .cfi_startproc## BB#0: pushq %rbpLtmp0: .cfi_def_cfa_offset 16Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbpLtmp2: .cfi_def_cfa_register %rbp subq $32, %rsp _main 是函数开始的地址，二进制文件会有这个位置的引用。 .cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。 pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。 .cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。 movq %rsp, %rbp 把局部变量放到栈上。 subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。 再看看 printf() 1234567leaq L_.str(%rip), %raxmovl $0, -4(%rbp)movl %edi, -8(%rbp)movq %rsi, -16(%rbp)movq %rax, %rdimovb $0, %alcallq _printf leap 会将 L_.str 这个指针加载到 rax 寄存器里。可以看看 L_.str 的定义 12L_.str: ## @.str .asciz &quot;hi there\\n&quot; 这个就是我们代码文件里定义的那个字符串。 这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。 当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。 printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。 接下来看看返回和函数的结束 1234567xorl %ecx, %ecxmovl %eax, -20(%rbp) ## 4-byte Spillmovl %ecx, %eaxaddq $32, %rsppopq %rbpretq.cfi_endproc xorl %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。 函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。 接下来是字符串输出 12345 .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;hi there\\n&quot;.subsections_via_symbols 同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。 接下来通过 size 工具来看看 a.out 里的 section。 1xcrun size -x -l -m a.out 1234567891011121314Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0) Section __text: 0x34 (addr 0x100000f50 offset 3920) Section __stubs: 0x6 (addr 0x100000f84 offset 3972) Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980) Section __cstring: 0xa (addr 0x100000fa6 offset 4006) Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016) total 0xa6Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096) Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096) Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112) total 0x18Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)total 0x100003000 可以看出有四个 segment 和多个section。 在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。 __PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。 __TEXT segment 包含被执行的代码以只读和可执行的方式映射。 __text section 包含编译后的机器码。 __stubs 和 __stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。 __cstring 可执行文件中的字符串。 __const 不可变的常量。 __DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。 __nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 __la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。 __const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。 __bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。 __common 包含外部全局变量。例如在函数外定义 int i; __dyld 是section占位符，用于动态链接器。 更多 section 类型介绍可以查看苹果文档： OS X Assembler Reference 接下来用 otool 查看下 section 里的内容： 1xcrun otool -s __TEXT __text a.out 123456a.out:Contents of (__TEXT,__text) section0000000100000f50 55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 0000000100000f60 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 0000000100000f70 b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 0000000100000f80 c4 20 5d c3 这个返回的内容很难读，加个 - v 就可以查看反汇编代码了， -s __TEXT __text 有个缩写 -t 1xcrun otool -v -t a.out 12345678910111213141516171819a.out:(__TEXT,__text) section_main:0000000100000f50 pushq %rbp0000000100000f51 movq %rsp, %rbp0000000100000f54 subq $0x20, %rsp0000000100000f58 leaq 0x47(%rip), %rax0000000100000f5f movl $0x0, -0x4(%rbp)0000000100000f66 movl %edi, -0x8(%rbp)0000000100000f69 movq %rsi, -0x10(%rbp)0000000100000f6d movq %rax, %rdi0000000100000f70 movb $0x0, %al0000000100000f72 callq 0x100000f840000000100000f77 xorl %ecx, %ecx0000000100000f79 movl %eax, -0x14(%rbp)0000000100000f7c movl %ecx, %eax0000000100000f7e addq $0x20, %rsp0000000100000f82 popq %rbp0000000100000f83 retq 看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。 现在来看看可执行文件。 通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息： 1otool -v -h a.out 123Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flagsMH_MAGIC_64 X86_64 ALL LIB64 EXECUTE 15 1200 NOUNDEFS DYLDLINK TWOLEVEL PIE mach_header 结构体 123456789struct mach_header { uint32_t magic; cpu_type_t cputype; cpu_subtype_t cpusubtype; uint32_t filetype; uint32_t ncmds; uint32_t sizeofcmds; uint32_t flags;}; cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令 1otool -v -l a.out | open -f 加载命令结构体 12345678910111213struct segment_command { uint32_t cmd; uint32_t cmdsize; char segname[16]; uint32_t vmaddr; uint32_t vmsize; uint32_t fileoff; uint32_t filesize; vm_prot_t maxprot; vm_prot_t initprot; uint32_t nsects; uint32_t flags;}; 查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。 在加载命令里还是看看 __TEXT __text 的section的内容 12345678910111213Section sectname __text segname __TEXT addr 0x0000000100000f50 size 0x0000000000000034 offset 3920 align 2^4 (16) reloff 0 nreloc 0 type S_REGULARattributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS reserved1 0 reserved2 0 addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。 单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。Foo.h 1234567#import &lt;Foundation/Foundation.h&gt;@interface Foo : NSObject- (void)say;@end Foo.m 12345678910#import “Foo.h”@implementation Foo- (void)say{ NSLog(@“hi there again!\\n”);}@end SayHi.m 12345678910#import “Foo.h”int main(int argc, char *argv[]){ @autoreleasepool { Foo *foo = [[Foo alloc] init]; [foo say]; return 0; }} 先编译多个文件 12xcrun clang -c Foo.mxcrun clang -c SayHi.m 再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。 1xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation 逆向 Mach-O 文件需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。 Mobilesubstrate 提供了三个模块来方便开发。 MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。 MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook 放在这里就可以了。 Safe mode：类似安全模式，会禁用的改动。 先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。 当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。 这里有个实例，讲解如何通过逆向实现微信抢红包的插件： 【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB 入门文章可以看看这篇： MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub 玩出新花样： 黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog，作者另一篇文章： iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog dyld动态链接生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。 用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。 符号表会规定它们的符号，使用 nm 工具看看 1xcrun nm -nm SayHi.o 12345 (undefined) external _OBJC_CLASS_$_Foo (undefined) external _objc_autoreleasePoolPop (undefined) external _objc_autoreleasePoolPush (undefined) external _objc_msgSend0000000000000000 (__TEXT,__text) external _main OBJC_CLASS$_Foo 表示 Foo 的 OC 符号。 (undefined) external 表示未实现非私有，如果是私有就是 non-external。 external _main 表示 main() 函数，处理 0 地址，将要到 TEXT,text section 再看看 Foo 1xcrun nm -nm Foo.o 1234567891011 (undefined) external _NSLog (undefined) external _OBJC_CLASS_$_NSObject (undefined) external _OBJC_METACLASS_$_NSObject (undefined) external ___CFConstantStringClassReference (undefined) external __objc_empty_cache0000000000000000 (__TEXT,__text) non-external -[Foo say]0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo 因为 undefined 符号表示该文件类未实现的，所以在目标文件和 Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。 链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。 1xcrun nm -nm a.out 1234567891011121314 (undefined) external _NSLog (from Foundation) (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation) (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation) (undefined) external ___CFConstantStringClassReference (from CoreFoundation) (undefined) external __objc_empty_cache (from libobjc) (undefined) external _objc_autoreleasePoolPop (from libobjc) (undefined) external _objc_autoreleasePoolPush (from libobjc) (undefined) external _objc_msgSend (from libobjc) (undefined) external dyld_stub_binder (from libSystem)0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header0000000100000e90 (__TEXT,__text) external _main0000000100000f10 (__TEXT,__text) non-external -[Foo say]0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo 看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。 通过 otool 可以找到所需库在哪 1xcrun otool -L a.out 12345a.out: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) libSystem 里有很多我们熟悉的lib libdispatch：GCD libsystem_c：C语言库 libsystem_blocks：Block libcommonCrypto：加密，比如md5 dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。 打印什么库被加载了 1(export DYLD_PRINT_LIBRARIES=; ./a.out ) 12345dyld: loaded: /Users/didi/Downloads/./a.outdyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundationdyld: loaded: /usr/lib/libSystem.B.dylibdyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation… 数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。 动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： Dynamic Linking On OS X dyld 做了些什么事 kernel 做启动程序初始准备，开始由dyld负责。 基于非常简单的原始栈为 kernel 设置进程来启动自身。 使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。 立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。 为可执行文件运行静态初始化。 设置参数到可执行文件的 main 函数并调用它。 在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime 会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用 +load 方法。 在 mian 函数返回后运行 static terminator。 在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。 查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime RetVal/objc-runtime: objc runtime 706 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下： 1234560 +[someclass load]1 call_class_loads()2 ::call_load_methods3 ::load_images(const char *path __unused, const struct mach_header *mh)4 dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)11 _dyld_start 在 load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。 prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。 最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。 如果想了解 Cocoa 的 Fundation 库可以通过 GNUStep 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。 dyld 是开源的： GitHub - opensource-apple/dyld 还可以看看苹果的 WWDC 视频 WWDC 2016 Session 406 里讲解对启动进行优化。 这篇文章也不错： Dynamic Linking of Imported Functions in Mach-O - CodeProject LLVM 工具链获取 LLVM12345678910111213141516#先下载 LLVMsvn co https://llvm.org/svn/llvm-project/llvm/trunk llvm#在 LLVM 的 tools 目录下下载 Clangcd llvm/toolssvn co https://llvm.org/svn/llvm-project/cfe/trunk clang#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabicd ../projectssvn co https://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rtsvn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxxsvn co https://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi#在 Clang 的 tools 下安装 extra 工具cd ../tools/clang/toolssvn co https://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra 编译 LLVM123456789brew install gccbrew install cmakemkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=\"AArch64;X86\" -G \"Unix Makefiles\" ..make j8#安装make install#如果找不到标准库，Xcode 需要安装 xcode-select --install 1234#如果希望是 xcodeproject 方式 build 可以使用 -GXcodemkdir xcodeBuildcd xcodeBuildcmake -GXcode /path/to/llvm/source 在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。 LLVM 源码工程目录介绍 llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。 llvm/include/ - 导出的头文件。 llvm/lib/ - 主要源文件都在这里。 llvm/project/ - 创建自己基于 LLVM 的项目的目录。 llvm/test/ - 基于 LLVM 的回归测试，健全检察。 llvm/suite/ - 正确性，性能和基准测试套件。 llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。 llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。 lib 目录介绍 llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。 llvm/lib/AsmParser/ - 汇编语言解析器。 llvm/lib/Bitcode/ - 读取和写入字节码 llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。 llvm/lib/Transforms/ - IR-to-IR 程序的变换。 llvm/lib/Target/ - 对像 X86 这样机器的描述。 llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。 llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。 工具链命令介绍基本命令 llvm-as - 汇编器，将 .ll 汇编成字节码。 llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。 opt - 字节码优化器。 llc - 静态编译器，将字节码编译成汇编代码。 lli - 直接执行 LLVM 字节码。 llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。 llvm-ar - 字节码文件打包器。 llvm-lib - LLVM lib.exe 兼容库工具。 llvm-nm - 列出字节码和符号表。 llvm-config - 打印 LLVM 编译选项。 llvm-diff - 对两个进行比较。 llvm-cov - 输出 coverage infomation。 llvm-profdata - Profile 数据工具。 llvm-stress - 生成随机 .ll 文件。 llvm-symbolizer - 地址对应源码位置，定位错误。 llvm-dwarfdump - 打印 DWARF。 调试工具 bugpoint - 自动测试案例工具 llvm-extract - 从一个 LLVM 的模块里提取一个函数。 llvm-bcanalyzer - LLVM 字节码分析器。 开发工具 FileCheck - 灵活的模式匹配文件验证器。 tblgen - C++ 代码生成器。 lit - LLVM 集成测试器。 llvm-build - LLVM 构建工程时需要的工具。 llvm-readobj - LLVM Object 结构查看器。 Swift 编译官网： GitHub - apple/swift: The Swift Programming Languageswift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： Swift.org - Contributing 1234567891011121314151617181920212223242526#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录brew install cmake ninjamkdir swiftsourcecd swiftsource#clone 下 swift 源码git clone https://github.com/apple/swift.git#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个./swift/utils/update-checkout —clone#查看文件夹du -h -d 1#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。./swift/utils/build-script -x -R#更新./swift/utils/update-checkout./swift/utils/build-script -x -R#切到指定tag和分支#tag./swift/utils/update-checkout —tag swift-3.0-RELEASE#特定分支./swift/utils/update-checkout —scheme swift-3.0-branch swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： Swift.org - Source Code 其它编译工具js写的C++解释器JSCPP适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：https://c-smile.sourceforge.net/ 资料网址 https://llvm.org https://clang.llvm.org/ https://www.aosabook.org/en/llvm.html GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow LLVM Developers’ Metting ming1016","link":"/program//clang-llvm/"},{"title":"靠谱的iOS","text":"说明：面试题来源是微博@我就叫Sunny怎么了的这篇博文：《招聘一个靠谱的 iOS》，其中共55题，除第一题为纠错题外，其他54道均为简答题。 出题者简介： 孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。 答案为微博@iOS程序犭袁整理，未经出题者校对，如有纰漏，请向微博@iOS程序犭袁指正。 《招聘一个靠谱的iOS》面试题参考答案 风格纠错题1.1. 优化部分1.2. 硬伤部分 什么情况使用 weak 关键字，相比 assign 有什么不同？ 怎么用 copy 关键字？ 这个写法会出什么问题： @property (copy) NSMutableArray *array; 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @protocol 和 category 中如何使用 @property runtime 如何实现 weak 属性 @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？ weak属性需要在dealloc中置nil么？ @synthesize和@dynamic分别有什么作用？ ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？ 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？13.1. 对非集合类对象的copy操作13.2. 集合类对象的copy与mutableCopy @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？ 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ objc中向一个nil对象发送消息将会发生什么？ objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？ 什么时候会报unrecognized selector的异常？ 一个objc对象如何进行内存布局？（考虑有父类的情况） 一个objc对象的isa的指针指向什么？有什么作用？ 下面的代码输出什么？ 211234567891011@implementation Son : Father- (id)init{ self = [super init]; if (self) { NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); } return self;}@end runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法） 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？ objc中的类方法和实例方法有什么本质区别和联系？ _objc_msgForward 函数是做什么的，直接调用它将会发生什么？ runtime如何实现weak变量的自动置nil？ 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ runloop和线程有什么关系？ runloop的mode作用是什么？ 以+ scheduledTimerWithTimeInterval…的方式触发的timer 猜想runloop内部是如何实现的？ objc使用什么机制管理对象内存？ ARC通过什么方式帮助开发者管理内存？ 一个autorealese对象在什么时刻释放？ BAD_ACCESS在什么情况下出现？ 苹果是如何实现autoreleasepool的？ 使用block时什么情况会发生引用循环，如何解决？ 在block内如何修改block外部变量？ 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ GCD的队列（dispatch_queue_t）分哪两种类型？ 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图） dispatch_barrier_async的作用是什么？ 苹果为什么要废弃dispatch_get_current_queue？ 以下代码运行结果如何？ 44123456789- (void)viewDidLoad{ [super viewDidLoad]; NSLog(@&quot;1&quot;); dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;); }); NSLog(@&quot;3&quot;);} observer中需要实现哪个方法才能获得KVO回调？ 如何手动触发一个value的KVO 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？ KVC的keyPath中的集合运算符如何使用？ KVC和KVO的keyPath一定是属性么？ 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？ apple用什么方式实现对一个对象的KVO？ IBOutlet连出来的视图属性为什么可以被设置成weak? IB中User Defined Runtime Attributes如何使用？ 如何调试BAD_ACCESS错误 lldb（gdb）常用的调试命令？ 1. 风格纠错题修改完的代码： 修改方法有很多种，现给出一种做示例： 1234567891011121314151617181920// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 修改完的代码，这是第一种修改方法，后面会给出第二种修改方法typedef NS_ENUM(NSInteger, CYLSex) { CYLSexMan, CYLSexWoman};@interface CYLUser : NSObject&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readonly, assign) CYLSex sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;@end 下面对具体修改的地方，分两部分做下介绍：硬伤部分 和 优化部分。因为硬伤部分没什么技术含量，为了节省大家时间，放在后面讲，大神请直接看优化部分。 优化部分 enum 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，参见官方的 Adopting Modern Objective-C 一文： 12345//定义一个枚举 typedef NS_ENUM(NSInteger, CYLSex) { CYLSexMan, CYLSexWoman }; （仅仅让性别包含男和女可能并不严谨，最严谨的做法可以参考 这里 。） age 属性的类型：应避免使用基本类型，建议使用 Foundation 数据类型，对应关系如下： 1234int -&gt; NSIntegerunsigned -&gt; NSUIntegerfloat -&gt; CGFloat动画时间 -&gt; NSTimeInterval 同时考虑到 age 的特点，应使用 NSUInteger ，而非 int 。这样做的是基于64-bit 适配考虑，详情可参考出题者的博文《64-bit Tips》。 如果工程项目非常庞大，需要拆分成不同的模块，可以在类、typedef宏命名的时候使用前缀。 doLogIn方法不应写在该类中： 虽然LogIn的命名不太清晰，但笔者猜测是login的意思， （勘误：Login是名词，LogIn 是动词，都表示登陆的意思。见： Log in vs. login ）登录操作属于业务逻辑，观察类名 UserModel ，以及属性的命名方式，该类应该是一个 Model 而不是一个“ MVVM 模式下的 ViewModel ”： 无论是 MVC 模式还是 MVVM 模式，业务逻辑都不应当写在 Model 里：MVC 应在 C，MVVM 应在 VM。 （如果抛开命名规范，假设该类真的是 MVVM 模式里的 ViewModel ，那么 UserModel 这个类可能对应的是用户注册页面，如果有特殊的业务需求，比如： -logIn 对应的应当是注册并登录的一个 Button ，出现 -logIn 方法也可能是合理的。） doLogIn 方法命名不规范：添加了多余的动词前缀。请牢记： 如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 do，does 这种多余的关键字，动词本身的暗示就足够了。 应为 -logIn （注意： Login 是名词， LogIn 是动词，都表示登陆。 见 Log in vs. login ） -(id)initUserModelWithUserName: (NSString*)name withAge:(int)age;方法中不要用 with 来连接两个参数: withAge: 应当换为age:，age: 已经足以清晰说明参数的作用，也不建议用 andAge: ：通常情况下，即使有类似 withA:withB: 的命名需求，也通常是使用withA:andB: 这种命名，用来表示方法执行了两个相对独立的操作（从设计上来说，这时候也可以拆分成两个独立的方法），它不应该用作阐明有多个参数，比如下面的： 123456//错误，不要使用&quot;and&quot;来连接参数- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;//错误，不要使用&quot;and&quot;来阐明有多个参数- (instancetype)initWithName:(CGFloat)width andAge:(CGFloat)height;//正确，使用&quot;and&quot;来表示两个相对独立的操作- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag; 由于字符串值可能会改变，所以要把相关属性的“内存管理语义”声明为 copy 。(原因在下文有详细论述：用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？) “性别”(sex）属性的：该类中只给出了一种“初始化方法” (initializer)用于设置“姓名”(Name)和“年龄”(Age)的初始值，那如何对“性别”(Sex）初始化？ Objective-C 有 designated 和 secondary 初始化方法的观念。 designated 初始化方法是提供所有的参数，secondary 初始化方法是一个或多个，并且提供一个或者更多的默认参数来调用 designated 初始化方法的初始化方法。举例说明： 12345678910111213141516171819202122232425// .m文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong//@implementation CYLUser- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex { if(self = [super init]) { _name = [name copy]; _age = age; _sex = sex; } return self;}- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age { return [self initWithName:name age:age sex:nil];}@end 上面的代码中initWithName:age:sex: 就是 designated 初始化方法，另外的是 secondary 初始化方法。因为仅仅是调用类实现的 designated 初始化方法。 因为出题者没有给出 .m 文件，所以有两种猜测：1：本来打算只设计一个 designated 初始化方法，但漏掉了“性别”(sex）属性。那么最终的修改代码就是上文给出的第一种修改方法。2：不打算初始时初始化“性别”(sex）属性，打算后期再修改，如果是这种情况，那么应该把“性别”(sex）属性设为 readwrite 属性，最终给出的修改代码应该是： 123456789101112131415161718192021// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 第二种修改方法（基于第一种修改方法的基础上）typedef NS_ENUM(NSInteger, CYLSex) { CYLSexMan, CYLSexWoman};@interface CYLUser : NSObject&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readwrite, assign) CYLSex sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;@end .h 中暴露 designated 初始化方法，是为了方便子类化 （想了解更多，请戳–》 《禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）》。） 按照接口设计的惯例，如果设计了“初始化方法” (initializer)，也应当搭配一个快捷构造方法。而快捷构造方法的返回值，建议为 instancetype，为保持一致性，init 方法和快捷构造方法的返回类型最好都用 instancetype。 如果基于第一种修改方法：既然该类中已经有一个“初始化方法” (initializer)，用于设置“姓名”(Name)、“年龄”(Age)和“性别”(Sex）的初始值:那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。在本例中，仍需声明属性的“内存管理语义”。于是可以把属性的定义改成这样 123@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readonly, assign) CYLSex sex; 由于是只读属性，所以编译器不会为其创建对应的“设置方法”，即便如此，我们还是要写上这些属性的语义，以此表明初始化方法在设置这些属性值时所用的方式。要是不写明语义的话，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而且低效。 initUserModelWithUserName 如果改为 initWithName 会更加简洁，而且足够清晰。 UserModel 如果改为 User 会更加简洁，而且足够清晰。 UserSex如果改为Sex 会更加简洁，而且足够清晰。 第二个 @property 中 assign 和 nonatomic 调换位置。推荐按照下面的格式来定义属性 1@property (nonatomic, readwrite, copy) NSString *name; 属性的参数应该按照下面的顺序排列： 原子性，读写 和 内存管理。 这样做你的属性更容易修改正确，并且更好阅读。这在《禅与Objective-C编程艺术 &gt;》里有介绍。而且习惯上修改某个属性的修饰符时，一般从属性名从右向左搜索需要修动的修饰符。最可能从最右边开始修改这些属性的修饰符，根据经验这些修饰符被修改的可能性从高到底应为：内存管理 &gt; 读写权限 &gt;原子操作。 硬伤部分 在-和(void)之间应该有一个空格 enum 中驼峰命名法和下划线命名法混用错误：枚举类型的命名规则和函数的命名规则相同：命名时使用驼峰命名法，勿使用下划线命名法。 enum 左括号前加一个空格，或者将左括号换到下一行 enum 右括号后加一个空格 UserModel :NSObject 应为UserModel : NSObject，也就是:右侧少了一个空格。 @interface 与 @property 属性声明中间应当间隔一行。 两个方法定义之间不需要换行，有时为了区分方法的功能也可间隔一行，但示例代码中间隔了两行。 -(id)initUserModelWithUserName: (NSString*)name withAge:(int)age; 方法中方法名与参数之间多了空格。而且 - 与 (id) 之间少了空格。 -(id)initUserModelWithUserName: (NSString*)name withAge:(int)age; 方法中方法名与参数之间多了空格：(NSString*)name 前多了空格。 -(id)initUserModelWithUserName: (NSString*)name withAge:(int)age; 方法中 (NSString*)name,应为 (NSString *)name，少了空格。 doLogIn方法中的 `LogIn` 命名不清晰：笔者猜测是login的意思，应该是粗心手误造成的。 （勘误： `Login` 是名词， `LogIn` 是动词，都表示登陆的意思。见： [ ***Log in vs. login*** ](https://grammarist.com/spelling/log-in-login/)） 2. 什么情况使用 weak 关键字，相比 assign 有什么不同？什么情况使用 weak 关键字？ 在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》 不同点： weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或NSlnteger 等)的简单赋值操作。 assign 可以用非 OC 对象,而 weak 必须用于 OC 对象 3. 怎么用 copy 关键字？用途： NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary； block 也经常使用 copy 关键字，具体原因见官方文档：Objects Use Properties to Keep Track of Blocks： block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？ 12345678910@property (nonatomic, copy) NSString *userId;- (instancetype)initWithUserId:(NSString *)userId { self = [super init]; if (!self) { return nil; } _userId = [userId copy]; return self;} 下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。 该问题在下文中也有论述：用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 4. 这个写法会出什么问题： @property (copy) NSMutableArray *array;两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；2、使用了 atomic 属性会严重影响性能 ； 第1条的相关原因在下文中有论述《用@property声明的NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？》 以及上文《怎么用 copy 关键字？》也有论述。 比如下面的代码就会发生崩溃 123456// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 下面的代码就会发生崩溃@property (nonatomic, copy) NSMutableArray *mutableArray; 12345678// .m文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 下面的代码就会发生崩溃NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];self.mutableArray = array;[self.mutableArray removeObjectAtIndex:0]; 接下来就会奔溃： 1-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460 第2条原因，如下： 该属性使用了自旋锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。 在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。 一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。 因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。 5. 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤： 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议。该协议只有一个方法: 1- (id)copyWithZone:(NSZone *)zone; 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。 以第一题的代码为例： 1234567891011121314151617181920// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 修改完的代码typedef NS_ENUM(NSInteger, CYLSex) { CYLSexMan, CYLSexWoman};@interface CYLUser : NSObject&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readonly, assign) CYLSex sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;@end 然后实现协议中规定的方法： 1234567- (id)copyWithZone:(NSZone *)zone { CYLUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age sex:_sex]; return copy;} 但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码: 12345678910111213141516171819202122// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 以第一题《风格纠错题》里的代码为例typedef NS_ENUM(NSInteger, CYLSex) { CYLSexMan, CYLSexWoman};@interface CYLUser : NSObject&lt;NSCopying&gt;@property (nonatomic, readonly, copy) NSString *name;@property (nonatomic, readonly, assign) NSUInteger age;@property (nonatomic, readonly, assign) CYLSex sex;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;- (void)addFriend:(CYLUser *)user;- (void)removeFriend:(CYLUser *)user;@end // .m文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// .m文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong//@implementation CYLUser { NSMutableSet *_friends;}- (void)setName:(NSString *)name { _name = [name copy];}- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex { if(self = [super init]) { _name = [name copy]; _age = age; _sex = sex; _friends = [[NSMutableSet alloc] init]; } return self;}- (void)addFriend:(CYLUser *)user { [_friends addObject:user];}- (void)removeFriend:(CYLUser *)user { [_friends removeObject:user];}- (id)copyWithZone:(NSZone *)zone { CYLUser *copy = [[[self class] allocWithZone:zone] initWithName:_name age:_age sex:_sex]; copy-&gt;_friends = [_friends mutableCopy]; return copy;}- (id)deepCopy { CYLUser *copy = [[[self class] alloc] initWithName:_name age:_age sex:_sex]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;}@end 以上做法能满足基本的需求，但是也有缺陷： 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 【注：深浅拷贝的概念，在下文中有介绍，详见下文的：用@property声明的 NSString（或NSArray，NSDictionary）经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？】 在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法: 123456789- (id)deepCopy { CYLUser *copy = [[[self class] alloc] initWithName:_name age:_age sex:_sex]; copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES]; return copy;} 至于如何重写带 copy 关键字的 setter这个问题， 如果抛开本例来回答的话，如下： 1234- (void)setName:(NSString *)name { //[_name release]; _name = [name copy];} 不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？” 123456- (void)setName:(NSString *)name { if (_name != name) { //[_name release];//MRC _name = [name copy]; }} 这样真得高效吗？不见得！这种写法“看上去很美、很合理”，但在实际开发中，它更像下图里的做法： 克强总理这样评价你的代码风格： 我和总理的意见基本一致： 老百姓 copy 一下，咋就这么难？ 你可能会说： 之所以在这里做if判断 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。(在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。) 但是你有没有考虑过代价： 你每次调用 setX: 都会做 if 判断，这会让 setX: 变慢，如果你在 setX:写了一串复杂的 if+elseif+elseif+... 判断，将会更慢。 要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像： 12[a setX:x1];[a setX:x1]; //你确定你要这么干？与其在setter中判断，为什么不把代码写好？ 或者 1[a setX:[a x]]; //队友咆哮道：你在干嘛？！！ 不要在 setter 里进行像 if(_obj != newObj) 这样的判断。（该观点参考链接： How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure ） 什么情况会在 copy setter 里做 if 判断？例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样： 12345-(void)setSpeed:(int)_speed{ if(_speed &lt; 0) speed = 0; if(_speed &gt; 300) speed = 300; _speed = speed;} 回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”–copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。 那如何确保 name 被 copy？在初始化方法(initializer)中做： 1234567891011- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex { if(self = [super init]) { _name = [name copy]; _age = age; _sex = sex; _friends = [[NSMutableSet alloc] init]; } return self;} 6. @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的@property 的本质是什么？ @property = ivar + getter + setter; 下面解释下： “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。 “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示: 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。所以你也可以这么说： @property = getter + setter; 例如下面这个类： 1234@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end 上述代码写出来的类与下面这种写法等效： 123456@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end 更新： property在runtime中是objc_property_t定义如下: 1typedef struct objc_property *objc_property_t; 而objc_property是一个结构体，包括name和attributes，定义如下： 1234struct property_t { const char *name; const char *attributes;}; 而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下： 12345/// Defines a property attributetypedef struct { const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */} objc_property_attribute_t; 而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。 例如：我们定义一个string的property@property (nonatomic, copy) NSString *string;，通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为T@&quot;NSString&quot;,C,N,V_string 其中T就代表类型，可参阅Type Encodings，C就代表Copy，N代表nonatomic，V就代表对应的实例变量。 ivar、getter、setter 是如何生成并添加到这个类中的? “自动合成”( autosynthesis) 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字. 1234@implementation Person@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西 OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。 setter 与 getter 方法对应的实现函数 ivar_list ：成员变量列表 method_list ：方法列表 prop_list ：属性列表 也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转. 7. @protocol 和 category 中如何使用 @property 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性 category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数： objc_setAssociatedObject objc_getAssociatedObject 8. runtime 如何实现 weak 属性要实现 weak 属性，首先要搞清楚 weak 属性的特点： weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 那么 runtime 如何实现 weak 变量的自动置nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 （注：在下文的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到__weak引用的解除时间。） 先看下 runtime 里源码的实现： 12345678910111213141516171819202122232425262728293031323334/** * The internal structure stored in the weak references table. * It maintains and stores * a hash set of weak references pointing to an object. * If out_of_line==0, the set is instead a small inline array. */#define WEAK_INLINE_COUNT 4struct weak_entry_t { DisguisedPtr&lt;objc_object&gt; referent; union { struct { weak_referrer_t *referrers; uintptr_t out_of_line : 1; uintptr_t num_refs : PTR_MINUS_1; uintptr_t mask; uintptr_t max_hash_displacement; }; struct { // out_of_line=0 is LSB of one of these (don&apos;t care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; };};/** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement;}; 具体完整实现参照 objc/objc-weak.h 。 我们可以设计一个函数（伪代码）来表示上述机制： objc_storeWeak(&amp;a, b)函数： objc_storeWeak函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除， 你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。 在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。 而如果a是由 assign 修饰的，则：在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。 下面我们将基于objc_storeWeak(&amp;a, b)函数，使用伪代码模拟“runtime如何实现weak属性”： 12345678// 使用伪代码模拟：runtime如何实现weak属性// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong id obj1; objc_initWeak(&amp;obj1, obj);/*obj引用计数变为0，变量作用域结束*/ objc_destroyWeak(&amp;obj1); 下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释： 总体说来，作用是：通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。 下面分别介绍下方法的内部实现： objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。 12obj1 = 0；obj_storeWeak(&amp;obj1, obj); 也就是说： weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的） 然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。 objc_storeWeak(&amp;obj1, 0); 前面的源代码与下列源代码相同。 123456789// 使用伪代码模拟：runtime如何实现weak属性// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilongid obj1;obj1 = 0;objc_storeWeak(&amp;obj1, obj);/* ... obj的引用计数变为0，被置nil ... */objc_storeWeak(&amp;obj1, 0); objc_storeWeak 函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。 使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下： 如何让不使用weak修饰的@property，拥有weak的效果。 我们从setter方法入手： （注意以下的 cyl_runAtDealloc 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： CYLDeallocBlockExecutor ） 1234567- (void)setObject:(NSObject *)object{ objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN); [object cyl_runAtDealloc:^{ _object = nil; }];} 也就是有两个步骤： 在setter方法中做如下设置： 1objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN); 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime： 12345678//要销毁的目标对象id objectToBeDeallocated;//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。id objectWeWantToBeReleasedWhenThatHappens;objc_setAssociatedObject(objectToBeDeallocted, someUniqueKey, objectWeWantToBeReleasedWhenThatHappens, OBJC_ASSOCIATION_RETAIN); 知道了思路，我们就开始实现 cyl_runAtDealloc 方法，实现过程分两部分： 第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。 // .h文件 123456789101112// .h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。typedef void (^voidBlock)(void);@interface CYLBlockExecutor : NSObject- (id)initWithBlock:(voidBlock)block;@end // .m文件 1234567891011121314151617181920212223242526272829// .m文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。#import &quot;CYLBlockExecutor.h&quot;@interface CYLBlockExecutor() { voidBlock _block;}@implementation CYLBlockExecutor- (id)initWithBlock:(voidBlock)aBlock{ self = [super init]; if (self) { _block = [aBlock copy]; } return self;}- (void)dealloc{ _block ? _block() : nil;}@end 第二部分：核心代码：利用runtime实现cyl_runAtDealloc方法 123456789101112131415161718192021222324252627282930313233343536373839// CYLNSObject+RunAtDealloc.h文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 利用runtime实现cyl_runAtDealloc方法#import &quot;CYLBlockExecutor.h&quot;const void *runAtDeallocBlockKey = &amp;runAtDeallocBlockKey;@interface NSObject (CYLRunAtDealloc)- (void)cyl_runAtDealloc:(voidBlock)block;@end// CYLNSObject+RunAtDealloc.m文件// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// 利用runtime实现cyl_runAtDealloc方法#import &quot;CYLNSObject+RunAtDealloc.h&quot;#import &quot;CYLBlockExecutor.h&quot;@implementation NSObject (CYLRunAtDealloc)- (void)cyl_runAtDealloc:(voidBlock)block{ if (block) { CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block]; objc_setAssociatedObject(self, runAtDeallocBlockKey, executor, OBJC_ASSOCIATION_RETAIN); }}@end 使用方法：导入 1#import &quot;CYLNSObject+RunAtDealloc.h&quot; 然后就可以使用了： 12345NSObject *foo = [[NSObject alloc] init];[foo cyl_runAtDealloc:^{ NSLog(@&quot;正在释放foo!&quot;);}]; 如果对 cyl_runAtDealloc 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： CYLDeallocBlockExecutor 参考博文： Fun With the Objective-C Runtime: Run Code at Deallocation of Any Object 9. @property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？属性可以拥有的特质分为四类: 原子性— nonatomic 特质 在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。 读/写权限—readwrite(读写)、readonly (只读) 内存管理语义—assign、strong、 weak、unsafe_unretained、copy 方法名—getter=&lt;name&gt; 、setter=&lt;name&gt; getter=&lt;name&gt;的样式： 1@property (nonatomic, getter=isOn) BOOL on; （ `setter=`这种不常用，也不推荐使用。故不在这里给出写法。） setter=&lt;name&gt;一般用在特殊的情境下，比如： 在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。 这时你就可以使用下面的方式来避免编译器报错： 1@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy; 另外也可以用关键字进行特殊说明，来避免编译器报错： 12@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;- (NSString *)initBy __attribute__((objc_method_family(none))); 不常用的：nonnull,null_resettable,nullable 注意：很多人会认为如果属性具备 nonatomic 特质，则不使用“同步锁”。其实在属性设置方法中使用的是自旋锁，自旋锁相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy){ if (offset == 0) { object_setClass(self, newValue); return; } id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) { newValue = [newValue copyWithZone:nil]; } else if (mutableCopy) { newValue = [newValue mutableCopyWithZone:nil]; } else { if (*slot == newValue) return; newValue = objc_retain(newValue); } if (!atomic) { oldValue = *slot; *slot = newValue; } else { spinlock_t&amp; slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); } objc_release(oldValue);}void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) { bool copy = (shouldCopy &amp;&amp; shouldCopy != MUTABLE_COPY); bool mutableCopy = (shouldCopy == MUTABLE_COPY); reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);} 10. weak属性需要在dealloc中置nil么？不需要。 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理 即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil： 正如上文的：runtime 如何实现 weak 属性 中提到的： 我们模拟下 weak 的 setter 方法，应该如下： 1234567- (void)setObject:(NSObject *)object{ objc_setAssociatedObject(self, &quot;object&quot;, object, OBJC_ASSOCIATION_ASSIGN); [object cyl_runAtDealloc:^{ _object = nil; }];} 如果对 cyl_runAtDealloc 的实现原理有兴趣，可以看下我写的一个小库，可以使用 CocoaPods 在项目中使用： CYLDeallocBlockExecutor 也即: 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 11. @synthesize和@dynamic分别有什么作用？ @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var; @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。 @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。 12. ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？ 对应基本数据类型默认关键字是 atomic,readwrite,assign 对于普通的 Objective-C 对象 atomic,readwrite,strong 参考链接： Objective-C ARC: strong vs retain and weak vs assign Variable property attributes or Modifiers in iOS 13. 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性. copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。 举例说明： 定义一个以 strong 修饰的 array： 1@property (nonatomic ,readwrite, strong) NSArray *array; 然后进行下面的操作： 1234567891011NSArray *array = @[ @1, @2, @3, @4 ];NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];self.array = mutableArray;[mutableArray removeAllObjects];;NSLog(@&quot;%@&quot;,self.array);[mutableArray addObjectsFromArray:array];self.array = [mutableArray copy];[mutableArray removeAllObjects];;NSLog(@&quot;%@&quot;,self.array); 打印结果如下所示： 123456782015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] ()2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] ( 1, 2, 3, 4) （详见仓库内附录的 Demo。） 为了理解这种做法，首先要知道，两种情况： 对非集合类对象的 copy 与 mutableCopy 操作； 对集合类对象的 copy 与 mutableCopy 操作。 1. 对非集合类对象的copy操作：在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下： [immutableObject copy] // 浅复制 [immutableObject mutableCopy] //深复制 [mutableObject copy] //深复制 [mutableObject mutableCopy] //深复制 比如以下代码： 12NSMutableString *string = [NSMutableString stringWithString:@&quot;origin&quot;];//copyNSString *stringCopy = [string copy]; 查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作： 1[string appendString:@&quot;origion!&quot;] stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。所以， 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。 2、集合类对象的copy与mutableCopy集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子： 123NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];NSArray *copyArray = [array copy];NSMutableArray *mCopyArray = [array mutableCopy]; 查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子： 123NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];NSArray *copyArray = [array copy];NSMutableArray *mCopyArray = [array mutableCopy]; 查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论： 在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下： 1234[immutableObject copy] // 浅复制[immutableObject mutableCopy] //单层深复制[mutableObject copy] //单层深复制[mutableObject mutableCopy] //单层深复制 这个代码结论和非集合类的非常相似。 参考链接：iOS 集合的深复制与浅复制 14. @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？在回答之前先说明下一个概念： 实例变量 = 成员变量 ＝ ivar 这些说法，笔者下文中，可能都会用到，指的是一个东西。 正如Apple官方文档 You Can Customize Synthesized Instance Variable Names 所说： 如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。 1234@interface CYLPerson : NSObject @property NSString *firstName; @property NSString *lastName; @end 在上例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字: 1234@implementation CYLPerson @synthesize firstName = _myFirstName; @synthesize lastName = _myLastName; @end 上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。 总结下 @synthesize 合成实例变量的规则，有以下几点： 如果指定了成员变量的名称,会生成一个指定的名称的成员变量, 如果这个成员已经存在了就不再生成了. 如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说： 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量, 如果是 @synthesize foo = _foo; 就不会生成成员变量了. 假如 property 名为 foo，存在一个名为 _foo 的实例变量，那么还会自动合成新变量么？不会。如下图： 15. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？ 同时重写了 setter 和 getter 时 重写了只读属性的 getter 时 使用了 @dynamic 时 在 @protocol 中定义的所有属性 在 category 中定义的所有属性 重载的属性 当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。 除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 @dynamic 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。 因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 @synthesize 来手动合成 ivar。 其实，@synthesize 语法还有一个应用场景，但是不太建议大家使用： 可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字: 1234@implementation CYLPerson @synthesize firstName = _myFirstName; @synthesize lastName = _myLastName; @end 上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。 举例说明：应用场景： 12345678910111213141516171819202122232425262728293031323334353637//// .m文件// https://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)// https://github.com/ChenYilong// 打开第14行和第17行中任意一行，就可编译成功@import Foundation;@interface CYLObject : NSObject@property (nonatomic, copy) NSString *title;@end@implementation CYLObject { // NSString *_title;}//@synthesize title = _title;- (instancetype)init{ self = [super init]; if (self) { _title = @&quot;微博@iOS程序犭袁&quot;; } return self;}- (NSString *)title { return _title;}- (void)setTitle:(NSString *)title { _title = [title copy];}@end 结果编译器报错： 当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择： 要么如第14行：手动创建 ivar 要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。 更多信息，请戳- 》 When should I use @synthesize explicitly? 16. objc中向一个nil对象发送消息将会发生什么？在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用: 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如： 1Person * motherInlaw = [[aPerson spouse] mother]; 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。 具体原因如下： objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。 那么，为了方便理解这个内容，还是贴一个objc的源代码： 123456789101112131415161718// runtime.h（类在runtime中的定义）// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilongstruct objc_class { Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表 #endif } OBJC2_UNAVAILABLE; objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。 17. objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？具体原因同上题：该方法编译之后就是objc_msgSend()函数调用. 我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和objc_msgSend()函数之间有什么关系。 以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法， 1234567891011121314151617//// main.m// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong// Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.//#import &quot;CYLTest.h&quot;int main(int argc, char * argv[]) { @autoreleasepool { CYLTest *test = [[CYLTest alloc] init]; [test performSelector:(@selector(iOSinit))]; return 0; }} 在终端中输入 1clang -rewrite-objc main.m 就可以生成一个main.cpp的文件，在最低端（10万4千行左右） 我们可以看到大概是这样的： 1((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName(&quot;foo&quot;)); 也就是说： [obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));。 18. 什么时候会报unrecognized selector的异常？简单来说： 当调用该对象上某个方法,而该对象上没有实现这个方法的时候，可以通过“消息转发”进行解决。 简单的流程如下，在上一题中也提到过： objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。 objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会： Method resolution objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。 Fast forwarding 如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。 Normal forwarding 这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。 为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ _objc_msgForward_demo ”,可运行起来看看。 19. 一个objc对象如何进行内存布局？（考虑有父类的情况） 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中. 每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中） 成员变量的列表, 属性列表, 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。 每个 Objective-C 对象都有相同的结构，如下图所示： 翻译过来就是 Objective-C 对象的结构图 ISA指针 根类的实例变量 倒数第二层父类的实例变量 … 父类的实例变量 类的实例变量 根对象就是NSObject，它的superclass指针指向nil 类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。 如图: 20. 一个objc对象的isa的指针指向什么？有什么作用？指向他的类对象,从而可以找到对象上的方法 21. 下面的代码输出什么？ 1234567891011@implementation Son : Father- (id)init{ self = [super init]; if (self) { NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); } return self;}@end 答案： 都输出 Son NSStringFromClass([self class]) = Son NSStringFromClass([super class]) = Son这个题目主要是考察关于 Objective-C 中对 self 和 super 的理解。 我们都知道：self 是类的隐藏参数，指向当前调用方法的这个类的实例。那 super 呢？ 很多人会想当然的认为“ super 和 self 类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。 上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。 当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。 这也就是为什么说“不推荐在 init 方法中使用点语法”，如果想访问实例变量 iVar 应该使用下划线（ _iVar ），而非点语法（ self.iVar ）。 点语法（ self.iVar ）的坏处就是子类有可能覆写 setter 。假设 Person 有一个子类叫 ChenPerson，这个子类专门表示那些姓“陈”的人。该子类可能会覆写 lastName 属性所对应的设置方法： 12345678910111213141516171819202122232425262728293031323334353637383940//// ChenPerson.m// //// Created by https://github.com/ChenYilong on 15/8/30.// Copyright (c) 2015年 https://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.//#import &quot;ChenPerson.h&quot;@implementation ChenPerson@synthesize lastName = _lastName;- (instancetype)init{ self = [super init]; if (self) { NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class])); NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([super class])); } return self;}- (void)setLastName:(NSString*)lastName{ //设置方法一：如果setter采用是这种方式，就可能引起崩溃// if (![lastName isEqualToString:@&quot;陈&quot;])// {// [NSException raise:NSInvalidArgumentException format:@&quot;姓不是陈&quot;];// }// _lastName = lastName; //设置方法二：如果setter采用是这种方式，就可能引起崩溃 _lastName = @&quot;陈&quot;; NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;会调用这个方法,想一下为什么？&quot;);}@end 在基类 Person 的默认初始化方法中，可能会将姓氏设为空字符串。此时若使用点语法（ self.lastName ）也即 setter 设置方法，那么调用将会是子类的设置方法，如果在刚刚的 setter 代码中采用设置方法一，那么就会抛出异常， 为了方便采用打印的方式展示，究竟发生了什么，我们使用设置方法二。 如果基类的代码是这样的： 123456789101112131415161718192021222324252627282930//// Person.m// nil对象调用点语法//// Created by https://github.com/ChenYilong on 15/8/29.// Copyright (c) 2015年 https://weibo.com/luohanchenyilong/ 微博@iOS程序犭袁. All rights reserved.// #import &quot;Person.h&quot;@implementation Person- (instancetype)init{ self = [super init]; if (self) { self.lastName = @&quot;&quot;; //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, NSStringFromClass([self class])); //NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, self.lastName); } return self;}- (void)setLastName:(NSString*)lastName{ NSLog(@&quot;🔴类名与方法名：%s（在第%d行），描述：%@&quot;, __PRETTY_FUNCTION__, __LINE__, @&quot;根本不会调用这个方法&quot;); _lastName = @&quot;炎黄&quot;;}@end 那么打印结果将会是这样的： 123🔴类名与方法名：-[ChenPerson setLastName:]（在第36行），描述：会调用这个方法,想一下为什么？🔴类名与方法名：-[ChenPerson init]（在第19行），描述：ChenPerson🔴类名与方法名：-[ChenPerson init]（在第20行），描述：ChenPerson 我在仓库里也给出了一个相应的 Demo（名字叫：Demo_21题_下面的代码输出什么）。有兴趣可以跑起来看一下，主要看下他是怎么打印的，思考下为什么这么打印。 接下来让我们利用 runtime 的相关知识来验证一下 super 关键字的本质，使用clang重写命令: 1$ clang -rewrite-objc test.m 将这道题目中给出的代码被转化为: 123NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;))));NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(&quot;Son&quot;)) }, sel_registerName(&quot;class&quot;)))); 从上面的代码中，我们可以发现在调用 [self class] 时，会转化成 objc_msgSend函数。看下函数定义： 1id objc_msgSend(id self, SEL op, ...) 我们把 self 做为第一个参数传递进去。 而在调用 [super class]时，会转化成 objc_msgSendSuper函数。看下函数定义: 1id objc_msgSendSuper(struct objc_super *super, SEL op, ...) 第一个参数是 objc_super 这样一个结构体，其定义如下: 1234struct objc_super { __unsafe_unretained id receiver; __unsafe_unretained Class super_class;}; 结构体有两个成员，第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self 。第二个成员是记录当前类的父类是什么。 所以，当调用 ［self class] 时，实际先调用的是 objc_msgSend函数，第一个参数是 Son当前的这个实例，然后在 Son 这个类里面去找 - (Class)class这个方法，没有，去父类 Father里找，也没有，最后在 NSObject类中发现这个方法。而 - (Class)class的实现就是返回self的类别，故上述输出结果为 Son。 objc Runtime开源代码对- (Class)class方法的实现: 123- (Class)class { return object_getClass(self);} 而当调用 [super class]时，会转换成objc_msgSendSuper函数。第一步先构造 objc_super 结构体，结构体第一个成员就是 self 。第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)) , 实际该函数输出结果为 Father。 第二步是去 Father这个类里去找 - (Class)class，没有，然后去NSObject类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用， 此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son。 参考链接：微博@Chun_iOS的博文刨根问底Objective－C Runtime（1）－ Self &amp; Super 22. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现. 23. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？ 在ARC下不需要。 在MRC中,对于使用retain或copy策略的需要 。在MRC下也不需要 无论在MRC下还是ARC下均不需要。 2011年版本的Apple API 官方文档 - Associative References 一节中有一个MRC环境下的例子： 12345678910111213141516171819202122232425// 在MRC下，使用runtime Associate方法关联的对象，不需要在主对象dealloc的时候释放// https://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)// https://github.com/ChenYilong// 摘自2011年版本的Apple API 官方文档 - Associative References static char overviewKey; NSArray *array = [[NSArray alloc] initWithObjects:@&quot;One&quot;, @&quot;Two&quot;, @&quot;Three&quot;, nil];// For the purposes of illustration, use initWithFormat: to ensure// the string can be deallocatedNSString *overview = [[NSString alloc] initWithFormat:@&quot;%@&quot;, @&quot;First three numbers&quot;]; objc_setAssociatedObject ( array, &amp;overviewKey, overview, OBJC_ASSOCIATION_RETAIN); [overview release];// (1) overview valid[array release];// (2) overview invalid 文档指出 At point 1, the string overview is still valid because the OBJC_ASSOCIATION_RETAIN policy specifies that the array retains the associated object. When the array is deallocated, however (at point 2), overview is released and so in this case also deallocated. 我们可以看到，在[array release];之后，overview就会被release释放掉了。 既然会被销毁，那么具体在什么时间点？ 根据 WWDC 2011, Session 322 (第36分22秒) 中发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的 object_dispose() 方法中释放。 对象的内存销毁时间表，分四个步骤： // 对象的内存销毁时间表 // https://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁) // https://github.com/ChenYilong // 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 1. 调用 -release ：引用计数变为零 * 对象正在被销毁，生命周期即将结束. * 不能再有新的 __weak 弱引用， 否则将指向 nil. * 调用 [self dealloc] 2. 子类 调用 -dealloc * 继承关系中最底层的子类 在调用 -dealloc * 如果是 MRC 代码 则会手动释放实例变量们（iVars） * 继承关系中每一层的父类 都在调用 -dealloc 3. NSObject 调 -dealloc * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法 4. 调用 object_dispose() * 为 C++ 的实例变量们（iVars）调用 destructors * 为 ARC 状态下的 实例变量们（iVars） 调用 -release * 解除所有使用 runtime Associate方法关联的对象 * 解除所有 __weak 引用 * 调用 free()对象的内存销毁时间表：参考链接。 24. objc中的类方法和实例方法有什么本质区别和联系？类方法： 类方法是属于类对象的 类方法只能通过类对象调用 类方法中的self是类对象 类方法可以调用其他的类方法 类方法中不能访问成员变量 类方法中不能直接调用对象方法 实例方法： 实例方法是属于实例对象的 实例方法只能通过实例对象调用 实例方法中的self是实例对象 实例方法中可以访问成员变量 实例方法中直接调用实例方法 实例方法中也可以调用类方法(通过类名) 25. _objc_msgForward函数是做什么的，直接调用它将会发生什么？ _objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 我们可以这样创建一个_objc_msgForward对象： IMP msgForwardIMP = _objc_msgForward;在上篇中的《objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？》曾提到objc_msgSend在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。 Objective-C运行时是开源的，所以我们可以看到它的实现。打开 Apple Open Source 里Mac代码里的obj包 下载一个最新版本，找到 objc-runtime-new.mm，进入之后搜索_objc_msgForward。 里面有对_objc_msgForward的功能解释： 123456789101112/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don&apos;t want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/ 对 objc-runtime-new.mm文件里与_objc_msgForward有关的三个函数使用伪代码展示下： 1234567891011121314151617181920212223242526272829303132333435// objc-runtime-new.mm 文件里与 _objc_msgForward 有关的三个函数使用伪代码展示// Created by https://github.com/ChenYilong// Copyright (c) 微博@iOS程序犭袁(https://weibo.com/luohanchenyilong/). All rights reserved.// 同时，这也是 obj_msgSend 的实现过程id objc_msgSend(id self, SEL op, ...) { if (!self) return nil; IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op); imp(self, op, ...); //调用这个函数，伪代码...} //查找IMPIMP class_getMethodImplementation(Class cls, SEL sel) { if (!cls || !sel) return nil; IMP imp = lookUpImpOrNil(cls, sel); if (!imp) return _objc_msgForward; //_objc_msgForward 用于消息转发 return imp;} IMP lookUpImpOrNil(Class cls, SEL sel) { if (!cls-&gt;initialize()) { _class_initialize(cls); } Class curClass = cls; IMP imp = nil; do { //先查缓存,缓存没有时重建,仍旧没有则向父类查询 if (!curClass) break; if (!curClass-&gt;cache) fill_cache(cls, curClass); imp = cache_getImp(curClass, sel); if (imp) break; } while (curClass = curClass-&gt;superclass); return imp;} 虽然Apple没有公开_objc_msgForward的实现源码，但是我们还是能得出结论： _objc_msgForward是一个函数指针（和 IMP 的类型一样），是用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 在上篇中的《objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？》曾提到objc_msgSend在“消息传递”中的作用。在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。 为了展示消息转发的具体动作，这里尝试向一个对象发送一条错误的消息，并查看一下_objc_msgForward是如何进行转发的。 首先开启调试模式、打印出所有运行时发送的消息：可以在代码里执行下面的方法： 1(void)instrumentObjcMessageSends(YES); 因为该函数处于 objc-internal.h 内，而该文件并不开放，所以调用的时候先声明，目的是告诉编译器程序目标文件包含该方法存在，让编译通过 123OBJC_EXPORT voidinstrumentObjcMessageSends(BOOL flag)OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 或者断点暂停程序运行，并在 gdb 中输入下面的命令： 1call (void)instrumentObjcMessageSends(YES) 以第二种为例，操作如下所示： 之后，运行时发送的所有消息都会打印到/tmp/msgSend-xxxx文件里了。 终端中输入命令前往： 1open /private/tmp 可能看到有多条，找到最新生成的，双击打开 在模拟器上执行执行以下语句（这一套调试方案仅适用于模拟器，真机不可用，关于该调试方案的拓展链接： Can the messages sent to an object in Objective-C be monitored or printed out? ），向一个对象发送一条错误的消息： 12345678910111213141516171819//// main.m// CYLObjcMsgForwardTest//// Created by https://weibo.com/luohanchenyilong/.// Copyright (c) 2015年 微博@iOS程序犭袁. All rights reserved.//#import &lt;UIKit/UIKit.h&gt;#import &quot;AppDelegate.h&quot;#import &quot;CYLTest.h&quot;int main(int argc, char * argv[]) { @autoreleasepool { CYLTest *test = [[CYLTest alloc] init]; [test performSelector:(@selector(iOS程序犭袁))]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 你可以在/tmp/msgSend-xxxx（我这一次是/tmp/msgSend-9805）文件里，看到打印出来： 1234567891011121314+ CYLTest NSObject initialize+ CYLTest NSObject alloc- CYLTest NSObject init- CYLTest NSObject performSelector:+ CYLTest NSObject resolveInstanceMethod:+ CYLTest NSObject resolveInstanceMethod:- CYLTest NSObject forwardingTargetForSelector:- CYLTest NSObject forwardingTargetForSelector:- CYLTest NSObject methodSignatureForSelector:- CYLTest NSObject methodSignatureForSelector:- CYLTest NSObject class- CYLTest NSObject doesNotRecognizeSelector:- CYLTest NSObject doesNotRecognizeSelector:- CYLTest NSObject class 结合《NSObject官方文档》，排除掉 NSObject 做的事，剩下的就是_objc_msgForward消息转发做的几件事： 调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。 调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非nil。 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。 上面前4个方法均是模板方法，开发者可以override，由 runtime 来调用。最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的 也就是说_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法： resolveInstanceMethod:方法 (或 resolveClassMethod:)。 forwardingTargetForSelector:方法 methodSignatureForSelector:方法 forwardInvocation:方法 doesNotRecognizeSelector: 方法 为了能更清晰地理解这些方法的作用，git仓库里也给出了一个Demo，名称叫“ _objc_msgForward_demo ”,可运行起来看看。 下面回答下第二个问题“直接_objc_msgForward调用它将会发生什么？” 直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。 就好像跑酷，干得好，叫“耍酷”，干不好就叫“作死”。 正如前文所说： _objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 如何调用_objc_msgForward？_objc_msgForward隶属 C 语言，有三个参数 ： – _objc_msgForward参数 类型 1. 所属对象 id类型 2. 方法名 SEL类型 3. 可变参数 可变参数类型 首先了解下如何调用 IMP 类型的方法，IMP类型是如下格式： 为了直观，我们可以通过如下方式定义一个 IMP类型 ： 1typedef void (*voidIMP)(id, SEL, ...) 一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”， 如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend： “我没有在这个对象里找到这个方法的实现” 想象下objc_msgSend会怎么做？通常情况下，下面这张图就是你正常走objc_msgSend过程，和直接调用_objc_msgForward的前后差别： 有哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明： JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的： JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。 作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。 同时 RAC(ReactiveCocoa) 源码中也用到了该方法。 26. runtime如何实现weak变量的自动置nil？ runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。 在上篇中的《runtime 如何实现 weak 属性》有论述。（注：在上篇的《使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？》里给出的“对象的内存销毁时间表”也提到__weak引用的解除时间。） 我们可以设计一个函数（伪代码）来表示上述机制： objc_storeWeak(&amp;a, b)函数： objc_storeWeak函数把第二个参数–赋值对象（b）的内存地址作为键值key，将第一个参数–weak修饰的属性变量（a）的内存地址（&amp;a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&amp;a）从weak表中删除， 你可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。 在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。 而如果a是由assign修饰的，则：在b非nil时，a和b指向同一个内存地址，在b变nil时，a还是指向该内存地址，变野指针。此时向a发送消息极易崩溃。 下面我们将基于objc_storeWeak(&amp;a, b)函数，使用伪代码模拟“runtime如何实现weak属性”： 12345678// 使用伪代码模拟：runtime如何实现weak属性// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilong id obj1; objc_initWeak(&amp;obj1, obj);/*obj引用计数变为0，变量作用域结束*/ objc_destroyWeak(&amp;obj1); 下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释： 总体说来，作用是：通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。 下面分别介绍下方法的内部实现： objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。 12obj1 = 0；obj_storeWeak(&amp;obj1, obj); 也就是说： weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的） 然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。 objc_storeWeak(&amp;obj1, 0); 前面的源代码与下列源代码相同。 123456789// 使用伪代码模拟：runtime如何实现weak属性// https://weibo.com/luohanchenyilong/// https://github.com/ChenYilongid obj1;obj1 = 0;objc_storeWeak(&amp;obj1, obj);/* ... obj的引用计数变为0，被置nil ... */objc_storeWeak(&amp;obj1, 0); objc_storeWeak函数把第二个参数–赋值对象（obj）的内存地址作为键值，将第一个参数–weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。 27. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 不能向编译后得到的类中增加实例变量； 能向运行时创建的类中添加实例变量； 解释下： 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量； 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。 28. runloop和线程有什么关系？总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。 runloop 和线程的关系： 主线程的run loop默认是启动的。 iOS的应用程序里面，程序启动后会有一个如下的main()函数 12345int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。 1NSRunLoop *runloop = [NSRunLoop currentRunLoop]; 参考链接：《Objective-C之run loop详解》。 29. runloop的mode作用是什么？model 主要是用来指定事件在运行循环中的优先级的，分为： NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时 UIInitializationRunLoopMode：启动时 NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合 苹果公开提供的 Mode 有两个： NSDefaultRunLoopMode（kCFRunLoopDefaultMode） NSRunLoopCommonModes（kCFRunLoopCommonModes） 30. 以下的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？+ scheduledTimerWithTimeInterval… RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候,ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。 同时因为mode还是可定制的，所以： Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下： 1234567891011121314151617// // https://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)// https://github.com/ChenYilong//将timer添加到NSDefaultRunLoopMode中[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];//然后再添加到NSRunLoopCommonModes里NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 31. 猜想runloop内部是如何实现的？ 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： function loop() { initialize(); do { var message = get_next_message(); process_message(message); } while (message != quit); }或使用伪代码来展示下: // // https://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁) // https://github.com/ChenYilong int main(int argc, char * argv[]) { //程序一直运行状态 while (AppIsRunning) { //睡眠状态，等待唤醒事件 id whoWakesMe = SleepForWakingUp(); //得到唤醒事件 id event = GetEvent(whoWakesMe); //开始处理事件 HandleEvent(event); } return 0; }参考链接： 《深入理解RunLoop》 摘自博文CFRunLoop，原作者是微博@我就叫Sunny怎么了 32. objc使用什么机制管理对象内存？通过 retainCount 的机制来决定对象是否需要释放。每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。 33. ARC通过什么方式帮助开发者管理内存？ 编译时根据代码上下文，插入 retain/release ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。 在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略。【TODO:后续更新会详细描述下】 34. 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）分两种情况：手动干预释放时机、系统自动去释放。 手动干预释放时机–指定autoreleasepool就是所谓的：当前作用域大括号结束时释放。 系统自动去释放–不手动指定autoreleasepool Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。 释放的时机总结起来，可以用下图来表示： 下面对这张图进行详细的解释： 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。 我们都知道：所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。 但是如果每次都放进应用程序的 main.m 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？ 在一次完整的运行循环结束之前，会被销毁。 那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。 从 RunLoop 源代码中可知，子线程默认是没有 RunLoop 的，如果需要在子线程开启 RunLoop ，则需要调用 [NSRunLoop CurrentRunLoop] 方法，它内部实现是先检查线程，如果发现是子线程，以懒加载的形式 创建一个子线程的 RunLoop。并存储在一个全局的 可变字典里。编程人员在调用 [NSRunLoop CurrentRunLoop] 时，是自动创建 RunLoop 的，而没法手动创建。 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。 但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。 @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。 参考链接：《黑幕背后的Autorelease》 35. BAD_ACCESS在什么情况下出现？访问了悬垂指针，比如对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。死循环 36. 苹果是如何实现autoreleasepool的？autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成. objc_autoreleasepoolPush objc_autoreleasepoolPop objc_autorelease 看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。 举例说明：我们都知道用类方法创建的对象都是 Autorelease 的，那么一旦 Person 出了作用域，当在 Person 的 dealloc 方法中打上断点，我们就可以看到这样的调用堆栈信息： 37. 使用block时什么情况会发生引用循环，如何解决？一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。 解决方法是将该对象使用weak或者block修饰符修饰之后再在block中使用。 id weak weakSelf = self;或者 weak __typeof(&amp;*self)weakSelf = self该方法可以设置宏 id __block weakSelf = self; 或者将其中一方强制制空 xxx = nil。 检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具 FBRetainCycleDetector 。 38. 在block内如何修改block外部变量？默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下: 123456__block int a = 0;void (^foo)(void) = ^{ a = 1; };foo(); //这里，a的值被修改为1 这是 微博@唐巧_boy的《iOS开发进阶》中的第11.2.3章节中的描述。你同样可以在面试中这样回答，但你并没有答到“点子上”。真正的原因，并没有书这本书里写的这么“神奇”，而且这种说法也有点牵强。面试官肯定会追问“为什么写操作就生效了？”真正的原因是这样的： 我们都知道：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 Block不允许修改外部变量的值。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。 我们可以打印下内存地址来进行验证： 12345678__block int a = 0;NSLog(@&quot;定义前：%p&quot;, &amp;a); //栈区void (^foo)(void) = ^{ a = 1; NSLog(@&quot;block内部：%p&quot;, &amp;a); //堆区};NSLog(@&quot;定义后：%p&quot;, &amp;a); //堆区foo(); 1232016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f82016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc82016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8 “定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。 那么如何证明“block内部”打印的是堆地址？ 把三个16进制的内存地址转成10进制就是： 定义后前：6171559672 block内部：5732708296 定义后后：5732708296 中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。 这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。 __block 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16 字节要多一倍）。 理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象： 以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。 123456789101112NSMutableString *a = [NSMutableString stringWithString:@&quot;Tom&quot;];NSLog(@&quot;\\n 定以前：------------------------------------\\n\\ a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a); //a在栈区void (^foo)(void) = ^{ a.string = @&quot;Jerry&quot;; NSLog(@&quot;\\n block内部：------------------------------------\\n\\ a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a); //a在栈区 a = [NSMutableString stringWithString:@&quot;William&quot;];};foo();NSLog(@&quot;\\n 定以后：------------------------------------\\n\\ a指向的堆中地址：%p；a在栈中的指针地址：%p&quot;, a, &amp;a); //a在栈区 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。 上文已经说过：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。 39. 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑： 所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些： 1[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; 1[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; 12345[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;someNotification&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * notification) { self.someProperty = xyz; }]; 这些情况不需要考虑“引用循环”。 但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用： 1234567__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^{__typeof__(self) strongSelf = weakSelf;[strongSelf doSomething];[strongSelf doSomethingElse];} ); 类似的： 12345678__weak __typeof__(self) weakSelf = self;_observer = [[NSNotificationCenter defaultCenter] addObserverForName:@&quot;testKey&quot; object:nil queue:nil usingBlock:^(NSNotification *note) { __typeof__(self) strongSelf = weakSelf; [strongSelf dismissModalViewControllerAnimated:YES];}]; self –&gt; _observer –&gt; block –&gt; self 显然这也是一个循环引用。 检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具 FBRetainCycleDetector 。 40. GCD的队列（dispatch_queue_t）分哪两种类型？ 串行队列Serial Dispatch Queue 并行队列Concurrent Dispatch Queue 41. 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。 12345678dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^{ /*加载图片1 */ });dispatch_group_async(group, queue, ^{ /*加载图片2 */ });dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 合并图片}); 42. dispatch_barrier_async的作用是什么？ 在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 dispatch_barrier_async 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。 打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 dispatch_barrier_async 函数追加的内容就如同 “上完厕所就上高速”这个动作。 （注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并行队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。 ） 43. 苹果为什么要废弃 dispatch…？dispatch_get_current_queue函数的行为常常与开发者所预期的不同。由于派发队列是按层级来组织的，这意味着排在某条队列中的块会在其上级队列里执行。队列间的层级关系会导致检查当前队列是否为执行同步派发所用的队列这种方法并不总是奏效。dispatch_get_current_queue函数通常会被用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用”队列特定数据”来解决。 44. 以下代码运行结果如何？- (void)viewDidLoad { [super viewDidLoad]; NSLog(@&quot;1&quot;); dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@&quot;2&quot;); }); NSLog(@&quot;3&quot;); }只输出：1 。发生主线程锁死。 45. 各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？addObserver:forKeyPath:options:context: 12345678// 添加键值观察/*1 观察者，负责处理监听事件的对象2 观察的属性3 观察的选项4 上下文*/[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;]; observer中需要实现一下方法： 12345678// 所有的 kvo 监听到事件，都会调用此方法/* 1. 观察的属性 2. 观察的对象 3. change 属性变化字典（新／旧） 4. 上下文，与监听的时候传递的一致 */- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 46. 如何手动触发一个value的KVO所谓的“手动触发”是区别于“自动触发”： 自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。 想知道如何手动触发，必须知道自动触发 KVO 的原理： 键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。 那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。 具体做法如下： 如果这个 value 是 表示时间的 self.now ，那么代码如下：最后两行代码缺一不可。 相关代码已放在仓库里。 12345678910111213141516// .m文件// Created by https://github.com/ChenYilong// 微博@iOS程序犭袁(https://weibo.com/luohanchenyilong/).// 手动触发 value 的KVO，最后两行代码缺一不可。//@property (nonatomic, strong) NSDate *now;- (void)viewDidLoad { [super viewDidLoad]; _now = [NSDate date]; [self addObserver:self forKeyPath:@&quot;now&quot; options:NSKeyValueObservingOptionNew context:nil]; NSLog(@&quot;1&quot;); [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。 NSLog(@&quot;2&quot;); [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。 NSLog(@&quot;4&quot;);} 但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理： 比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。 大家可能以为这是因为 setNow: 是合成方法，有时候我们也能看到有人这么写代码: 12345- (void)setNow:(NSDate *)aDate { [self willChangeValueForKey:@&quot;now&quot;]; // 没有必要 _now = aDate; [self didChangeValueForKey:@&quot;now&quot;];// 没有必要} 这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。下文《apple用什么方式实现对一个对象的KVO？》会有详述。 参考链接： Manual Change Notification—Apple 官方文档 47. 若一个类有实例变量 NSString *_foo ，调用setValue:forKey:时，可以以foo还是 _foo 作为key？都可以。 48. KVC的keyPath中的集合运算符如何使用？ 必须用在集合对象上或普通对象的集合属性上 简单集合运算符有@avg， @count ， @max ， @min ，@sum， 格式 @”@sum.age”或 @”集合属性.@max.age“ 49. KVC和KVO的keyPath一定是属性么？KVC 支持实例变量，KVO 只能手动支持手动设定实例变量的KVO实现监听 50. 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？请参考： 《如何自己动手实现 KVO》 KVO for manually implemented properties 51. apple用什么方式实现对一个对象的KVO？Apple 的文档对 KVO 实现的描述： Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … 从Apple 的文档可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露： 当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。我画了一张示意图，如下所示： KVO 确实有点黑魔法： Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。 下面做下详细解释： 键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。 比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。大家可能以为这是因为 setNow: 是合成方法，有时候我们也能看到有人这么写代码: 12345- (void)setNow:(NSDate *)aDate { [self willChangeValueForKey:@&quot;now&quot;]; // 没有必要 _now = aDate; [self didChangeValueForKey:@&quot;now&quot;];// 没有必要} 这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 addObserver:forKeyPath:options:context: 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下: 12345- (void)setNow:(NSDate *)aDate { [self willChangeValueForKey:@&quot;now&quot;]; [super setValue:aDate forKey:@&quot;now&quot;]; [self didChangeValueForKey:@&quot;now&quot;];} 这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。 KVO 在实现中通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在Apple 的文档可以得到印证： Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class … 然而 KVO 在实现中使用了 isa 混写（ isa-swizzling） ，这个的确不是很容易发现：Apple 还重写、覆盖了 -class 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。 但是，假设“被监听的对象”的类对象是 MYClass ，有时候我们能看到对 NSKVONotifying_MYClass 的引用而不是对 MYClass 的引用。借此我们得以知道 Apple 使用了 isa 混写（isa-swizzling）。具体探究过程可参考 这篇博文 。 那么 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 这三个方法的执行顺序是怎样的呢？ wilChangeValueForKey: 、 didChangeValueForKey: 很好理解，observeValueForKeyPath:ofObject:change:context: 的执行时机是什么时候呢？ 先看一个例子： 代码已放在仓库里。 12345678910111213- (void)viewDidLoad { [super viewDidLoad]; [self addObserver:self forKeyPath:@&quot;now&quot; options:NSKeyValueObservingOptionNew context:nil]; NSLog(@&quot;1&quot;); [self willChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。 NSLog(@&quot;2&quot;); [self didChangeValueForKey:@&quot;now&quot;]; // “手动触发self.now的KVO”，必写。 NSLog(@&quot;4&quot;);}- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context { NSLog(@&quot;3&quot;);} 如果单单从下面这个例子的打印上， 顺序似乎是 wilChangeValueForKey: 、 observeValueForKeyPath:ofObject:change:context: 、 didChangeValueForKey: 。 其实不然，这里有一个 observeValueForKeyPath:ofObject:change:context: , 和 didChangeValueForKey: 到底谁先调用的问题：如果 observeValueForKeyPath:ofObject:change:context: 是在 didChangeValueForKey: 内部触发的操作呢？ 那么顺序就是： wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 不信你把 didChangeValueForKey: 注视掉，看下 observeValueForKeyPath:ofObject:change:context: 会不会执行。 了解到这一点很重要，正如 46. 如何手动触发一个value的KVO 所说的： “手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。 而“回调的调用时机”就是在你调用 didChangeValueForKey: 方法时。 52. IBOutlet连出来的视图属性为什么可以被设置成weak?参考链接： Should IBOutlets be strong or weak under ARC? 文章告诉我们： 因为既然有外链那么视图在xib或者storyboard中肯定存在，视图已经对它有一个强引用了。 不过这个回答漏了个重要知识，使用storyboard（xib不行）创建的vc，会有一个叫_topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，所以这时即便outlet声明成weak也没关系 53. IB中User Defined Runtime Attributes如何使用？它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller 54. 如何调试BAD_ACCESS错误 重写object的respondsToSelector方法，现实出现EXEC_BAD_ACCESS前访问的最后一个object 通过 Zombie 设置全局断点快速定位问题代码所在行 Xcode 7 已经集成了BAD_ACCESS捕获功能：Address Sanitizer。用法如下：在配置中勾选✅Enable Address Sanitizer 55. lldb（gdb）常用的调试命令？ breakpoint 设置断点定位到某一个函数 n 断点指针下一步 po打印对象 更多 lldb（gdb） 调试命令可查看 The LLDB Debugger ； 苹果官方文档： iOS Debugging Magic 。 Posted by 微博@iOS程序犭袁原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | Creative Commons BY-NC-ND 3.0 其他题目 import””, import&lt;&gt;, 的区别1· #import和#include的区别：import不会引发交叉编译，include会 #import&lt;&gt;和#import“”的区别：import&lt;&gt;引用系统文件，对于系统自带头文件的饮用import“”引用自定义文件，首先会在用户目录下查找视图相关1· 没有navigationController的情况下，从一个viewController切换到另一个viewController的方法是：[self presentModalViewController:nextViewController animated:YES]pushViewController需要有navigationController2· UISplitViewController控制器可以呈现屏幕分栏视图的效果，MasterView占有320点的固定大小。正确答案: BA 是B 否解释：ios8 sdk 中 ，UISplitViewController 可以在 iphone 中 使用 了，masterView 的 宽度 是 整个 屏幕的 宽度，所以 不是 固定的 大小 3203· iOS中导航设计模式有几种？正确答案: A B C 你的答案: A B C D (错误)A 平铺导航B 标签导航C 树形导航D 模态视图导航解释：我们经常会遇到在某个路径中滑出一个单屏、进行编辑、查看信息、操作界面的上的内容的情况发生。这是一种应用行为的特定形态，一般带有流程的界面变更的情况发生，比如一张页面临时取代了整个应用程序的显示屏，我们称这种处理方式为“模态视图”。默认情况下，模式视图从屏幕底部边缘滑上来切一半覆盖了当前整个屏幕,模态视图完成和程序主功能有关系的独立任务，尤其适合于主功能界面中欠缺的多级子任务。这种操作会暂时绕开应用的正常操作。模态视图常常被用来编辑或添加内容，当你需要的时候模态视图一般从屏幕底部滑出而后遮盖先前的页面，当你完成任务后滑出的页面也会相应的缩回去，然后可以继续之前的流程。有些控件和界面元素只在次要任务中被偶尔用到，模态视图很好的把他们暂时隐藏了，并且当需要的时候出现，有效的节约了屏幕空间。模态视图有点像是导航中的死胡同，为了能够让用户也可以同样方便的回到正常的流程中去，模态视图除了正常的操作之外一般还有加上一个“完成”按钮，或者“取消”按钮。4· 模态视图专用属性有哪些？正确答案: A B C DA UIModalPresentationFullScreen，全屏状态，是默认呈现样式，iPhone只能全屏呈现。B UIModalPresentationPageSheet，它的宽度是固定的768点，在iPad竖屏情况下则全屏呈现。C UIModalPresentationFormSheet，它的是固定的540x620点，无论是横屏还是竖屏情况下呈现尺寸都不会变化。D UIModalPresentationCurrentContext，它与父视图控制器有相同的呈现方式。解释：作用：临时中断当前工作流程，显示一个新的视图层次结构。用途：立即从用户那里收集信息；临时显示一些内容；临时改变工作模式；为不同的设备方向实现可替代的界面；使用指定类型的过渡动画来显示一个新的视图结构；模态视图的显示风格：通过设置属性modalpresentationStyleUIModalPresentationFullScreen;UIModalPresentationPageSheet;UIModalPresentationFormSheet;模态视图的过渡风格：通过设置属性modalTransitionStyleUIModalTransitionStyleCoverVertical;UIModalTransitionStyleFlipHorizontal;UIModalTransitionStyleCrossDissolve;步骤：创建一个要展示的视图控件；在适当的地方分配一个委托对象；调用当前视图控制前的presentModalViewController:animated:方法，传递你要模态显示的视图控制器；多线程相关1· 实现多线程都有哪几种方法？正确答案: B CA 使用@synchronized(self)B 使用GCDC 使用NSOperationQueueD 使用@thread解释：@thred是安卓的关键字2· 关于NSOperation queue的说法，正确的是？正确答案: A C DA 主要用于多线程并发处理B 它是一个队列，有严格的先进先出C 它不会遵守严格的先进先出D NSOperationQueue可以通过调整权重来调整队列的执行顺序解释：首先NSOperationQueue是属于多线程并发处理这一部分，它主要用来提供一个可添加的操作队列，将一系列操作添加到队列中，然后根据操作的优先级和内部操作依赖来决定操作执行的顺序。高优先级的操作先于低优先级执行。一个操作所依赖的操作全部执行完毕后才能执行。所以A,C,D正确内存相关1· 与alloc相反，与retain相反，与alloc配对的分别是:dealloc, release, release正确答案: BA dealloc release deallocB dealloc release releaseC dealloc dealloc deallocD release release release解释:alloc其实相当于c++中的构造函数，dealloc相当于析构函数；retain相反的是release，这个应该没异议，alloc配对使用的也是release，alloc会使对象的retainCount=1，所以配对的是release。2· 下列程序输出是： 1234567891011NSMutableArray* ary = [[NSMutableArray array] retain];NSString *str = [NSString stringWithFormat:@&quot;test&quot;];[str retain];[ary addObject:str];NSLog(@&quot;%@%d&quot;,str,[str retainCount]);[str retain];[str release];[str release];NSLog(@&quot;%@%d&quot;,str,[str retainCount]);[ary removeAllObjects];NSLog(@&quot;%@%d&quot;,str,[str retainCount]); 答案： -1, -1, -1解释：NSString *str = [NSString stringWithFormat:@”test”];当中stringWithFormat是类方法，内存管理上是autorelease的，因此内存管理是-13· 下面关于 Objective-C 内存管理的描述错误的是正确答案: A C 你的答案: A B C (错误)A 当使用ARC来管理内存时，代码中可以出现autoreleaseB autoreleasepoll在drain的时候会释放在其中分配的对象C 当使用ARC来管理内存时，在线程中大量分配对象而不用autoreleasepool则可能会造成内存泄露4· 关于内存管理，下列说法错误的是正确答案: CA 谁申请，谁释放B 内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放。C 关键字alloc 或new 生成的对象可以自动释放；D 设置正确的property属性，对于retain需要在合适的地方释放，解释:alloc或new生成的对象不会自动释放，要自动释放需要调用autorelease方法。谁申请，谁释放。也不是很对，在non-ARC中，如果一个函数要返回一个在堆上alloc的对象，在返回的时候需要调用autorelease方法。实际上是你申请了，但释放交给了NSAutoReleasePool。RunLoop相关1· 选CNSRunLoop的以下描述错误的是（） 1/1A Runloop并不是由系统自动控制的B 有3类对象可以被run loop监控：sources，timers，observersC 线程是默认启动run loop的D NSTimer可手动添加到新建的NSRunLoop中解释：A:Runloop的作用在于当有事情要做时它使当前的thread工作，没有事情做时又使thread 休眠sleep。Runloop并不是由系统自动控制的，尤其是对那些新建的次线程需要对其进行显示的控制。B：有3类对象可以被run loop监控：sources、timers、observers。当这些对象需要处理的时候，为了接收回调，首先必须通过 CFRunLoopAddSource ,CFRunLoopAddTimer 或者 CFRunLoopAddObserver 把这些对象放入run loop。 要停止接收它的回调，可以通过CFRunLoopRemoveSource从run loop中移除某个对象。C：每一个线程都有自己的runloop, 主线程是默认开启的，创建的子线程要手动开启，因为NSApplication 只启动main applicaiton thread。D：NSTimer默认添加到当前NSRunLoop中，也可以手动制定添加到自己新建的NSRunLoop的中。2· 对下述代码错误描述正确的是( )NSTimer *myTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(doSomeThing:) userInfo:nil repeats:YES];[myTimer fire]正确答案: AA 没有将timer加入runloopB doSomeThing缺少参数C 忘记传递数据给userInfoD myTimer对象未通过[[myTimer alloc] init]方法初始化解释：NSTimer有两种初始化方法：初始化方法一： scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: 方法+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds target:(id)target selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats seconds ：需要调用的毫秒数target ：调用方法需要发送的对象。即：发给谁userInfo ：发送的参数repeats ：指定定时器是否重复调用目标方法 现在做个比喻：可以把调度一个计时器与启动汽车的引擎相比较。被调度的计时器就是运行中的引擎。没有被调度的计时器就是一个已经准备好启动但是还没有运行的引擎。我们在程序里面 , 无论何时 , 都可以调度和取消调度计时器 , 就像根据我们所处的环境 , 决定汽车的引擎是启动还是停止。如果你想要在程序中 , 手动的在某一个确定时间点调度计时器 , 可以使用 NSTimer 的类方法 timerWithTimeInterval:target:selector:userInfo:repeats: 方法。初始化方法二：如果，我们想在任何时候都能够随心所欲的 启动 / 停止定时器。咋办？不用急，还有 NSTimer 的另一种初始化方法，能够满足我们的要求： 12345678910// 使用 timerWithTimeInterval 方法来实例化一个 NSTimer, 这时候 NSTimer 是不会启动的self.paintingTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(paint:) userInfo:nil repeats:YES]; // 当需要调用时 , 可以把计时器添加到事件处理循环中 [[NSRunLoop currentRunLoop] addTimer:self.paintingTimer forMode:NSDefaultRunLoopMode]; 总结： scheduled开头的方法初始化的，会将这个timer调度到当前运行的loop中; timer和init开头的初始化方法，只是创建，并没有调度到loop中，需要手动addTimer。3·NSString *str = @“lanou”;[str retain];NSLog(@“%lu”,str.retainCount);此处打印出来的值是多少().正确答案: DA 1B 2C -1D ULONG_MAX解释：这是一个放在常量区的字符串常量，返回的结果是UINT_MAX值 有些地方的回答TableView相关1· 以下关于tableView编辑的方法中哪个不属于代理方法？AA -(void)setEditing:(BOOL)editing animated:(BOOL)animatedB -(BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPathC -(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPathD -(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath解释： A是tableView自己的方法，不是代理2· 下面哪些属于UITableViewDelegate协议的方法？正确答案: CA tableView:cellForRowAtIndexPath:B tableView:numberOfRowsInSection:C tableView:didSelectRowAtIndexPath:D numberOfSectionsInTableView:解释：代理的作用是用来完成指定的某种动作，所以必须是动作性的操作而不是数据性的操作property相关1· 关于readwrite, readonly, assign, automatic的说法，下列说法错误的是A readwrite 是可读可写特性；需要生成getter方法和setter方法时B readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变C assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时；D nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作；nonatomic表示多线程安全；一般使用atomic解释：D项说一般使用atomic是不对的，一般使用nonatomic。readonly, readwrite：是控制属性的访问权限，readonly只生成getter方法，其他类是无法修改其值的。readwrite是会同时生成getter和setter方法，其他类可以修改其值。assign, retain, weak, strong, copy, unsafe_unretained：在non-ARC中，assign和retain是一组，assign的对象属性引用计数不变，而retain会被+1。对应的在ARC中，weak和strong是一组，weak的对象属性引用计数不变，而strong会被+1。assign还用来赋值非对象属性，例如，int，double，BOOL，char等。copy用来设置不可变的对象属性，例如，NSString，NSArray，NSDictionary等。在ARC中，一个属性被设置为weak，当出了作用域，其值会被设置成nil。与其相对应的是unsafe_unretained，unsafe_unretained不会改变对象属性的引用计数，同时出了作用域的时候，其值也不会被设置成nil。unsafe_unretained相当于non-ARC中的assign。atomic, nonatomic: atomic是原子操作，nonatomic是非原子操作，一般常用的是nonatomic。2· 设置代理为属性正确的是（）正确答案: AA @property(nonatomic,assign)B @property(atomic,copy)C @property(nonatomic,copy)D @property(nonatomic,retain)解释：用weak更好，但是A最接近3· 关于Objective-C中属性的说明，以下错误的是（）正确答案: DA readwrite是可读可写特性，需要生成getter方法和setter方法B readonly是只读特性，只有getter方法，没有setter方法C assign是赋值属性，setter方法将传入参数赋值给实例变量D retain表示持有特性，copy属性表示拷贝属性，都会建立一个相同的对象解释： copy是直接创建一个。数组、字典等相关1· 以下哪一段代码不会抛出异常（） CA NSArray array=@[1，2，3];NSNumber * number=array[3];B NSDictionary *dict=@{@”key”:nil};C NSString *str=nil;NSString *str2=[str substringFromIndex:3];D NSString *str=@”hi”;NSString *str2=[str substringFromIndex:3];解释：A 数组越界B 字典的Key不能为nilD 数组下标越界2· 关于下列程序，输出是NSMutableArray ary = [[NSMutableArray array] retain];NSString str = [NSString stringWithFormat:@”test”];[str retain];[ary addObject:str];NSLog(@”%@%d”,str,[str retainCount]);[str retain];[str release];[str release];NSLog(@”%@%d”,str,[str retainCount]);[aryremoveAllObjects];NSLog(@”%@%d”,str,[str retainCount]);正确答案: DA 2，3，1B 3，2，1C 1，2，3D -1，-1，-1解释：objective-C: NSString应该用initWithFormat? 还是 stringWithFormat?今天在看书上的一段代码时，发现NSString实例化时，有时用的是initWithFormat方法，有时用的是stringWithFormat，到底应该如何选择呢？区别：1、initWithFormat是实例方法只能通过 NSString str = [[NSString alloc] initWithFormat:@”%@”,@”Hello World”] 调用，但是必须手动release来释放内存资源2、stringWithFormat是类方法可以直接用 NSString* str = [NSString stringWithFormat:@”%@”,@”Hello World”] 调用，内存管理上是autorelease的，不用手动显式release。网络相关1· NSURLConnectionDelegate协议中的方法有哪些？正确答案: A B DA connection:didReceiveData:B connection:didFailWithError:C initWithRequest:delegate:D connectionDidFinishLoading:解释：单 看 NSURLConnectionDelegate ，答案只有 B ，而 A 和 D 属于 NSURLConnectionDataDelegate 。仔 细 看 NSURLConnectionDataDelegate 的声明：@protocol NSURLConnectionDataDelegate C是方法，不是代理2· NSURLConnection类的同步请求方法是？正确答案: AA + sendSynchronousRequest:returningResponse:error:B – initWithRequest:delegate:C – initWithRequest:delegate:startImmediately:解释：B和C都是异步方法，需要设置delegate属性。3· NSURL的构造函数有？正确答案: C D requestWithURL:– initWithURL: URLWithString:– initWithString:解释：[NSURL URLWithString:@”https://a.com&quot;];[[NSURL alloc] initWithString:@”https://a.com&quot;];数据持久化相关1· iOS中持久化方式有哪些？正确答案: A B C DA 属性列表文件B 对象归档C SQLite数据库D CoreData解释：A ：属性列表文件 //NSUserDefaults 的存储，实际是本地生成一个 plist 文件，将所需属性存储在 plist 文件中B ：对象归档 // 本地创建文件并写入数据，文件类型不限C ： SQLite 数据库 // 本地创建数据库文件，进行数据处理D ： CoreData // 同数据库处理思想相同，但实现方式不同某些情况下，B生成的文件也可以是数据库文件，但是对数据的处理方式肯定是不同的所以，ABCD都属于本地持久化的方式2· 以下适合在客户端做数据持久化存储的数据的有正确答案: B DA redisB localStorageC sessionStorageD userData解释：redis是一个开源使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。所以A选项中redis数据就是一个干扰项，直接排除。localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。不同：localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。所以选B不选CD选项用户数据当然适合做持久化存储，免登陆就是获取之前存储的用户数据来实现的。指针相关1· 关于浅复制和深复制的说法，下列说法正确的是正确答案: A B DA 浅层复制：只复制指向对象的指针，而不复制引用对象本身。B 深层复制：复制引用对象本身。C 如果是浅复制，若类中存在成员变量指针，修改一个对象一定会影响另外一个对象D 如果是深拷贝，修改一个对象不会影响到另外一个对象解释：我认为浅拷贝是一个不喜欢思考的懒汉，而深拷贝则是一个思维严谨，喜欢思考的人。对于懒汉来说，虽然给了他任务，但是他总是想尽量的少做一些事情，所以很多时候做出来的东西就是只看到了表面，不会去思考对不对。structX{intx;inty;};对于懒汉来说，他很直白的看到了x，看到了y，然后就拷贝x和y，然后就不管了，反正我完成我的拷贝了，至于对不对，我不管。而一旦有了引用或者指针，事情就不一样了structX{intx;inty;intp;};懒汉依然只是直接表面级别的拷贝，于是拷贝x, y , p，但是他没有思考接下来的事情对不对。对于指针或者引用来说，若是只是拷贝表面，那么拷贝后的物体的指针也和原来的指针指向的是同一个对象，所以虽然目的想完成一个完美的克隆体，但是却发现克隆体和原来的物体中间还有一根线连着，没有完美的分离。intp=newint(47);int*q=p;如q与p都是指向一个物体一样。那么如果原来的物体销毁了，但是现在拷贝的物体还在，那么这时候你拷贝后的物体的成员指针就是一个悬挂指针，指向了不再存在的物体，那么你访问的话，那就不知道会发生什么了。而对于深拷贝，这一个勤奋的人，他不会只做表面，他会把每一个细节都照顾好。于是，当他遇到指针的时候，他会知道new出来一块新的内存，然后把原来指针指向的值拿过来，这样才是真正的完成了克隆体和原来的物体的完美分离，如果物体比作人的话，那么原来的人的每一根毛细血管都被完美的拷贝了过来，而绝非只是表面。所以，这样的代价会比浅拷贝耗费的精力更大，付出的努力更多，但是是值得的。当原来的物体销毁后，克隆体也可以活的很好。然而事实上是这个世界上大多都是懒汉，包括编程的人，编译器等，所以默认的行为都是浅拷贝，于是有时候你需要做一个勤奋的人，让事情做正确，自己去完成深拷贝所需要的事情。delegate、protocol相关1· 使用protocol时，声明一组可选择实现与否的函数，需要在声明的前一行加上：正确答案: BA @requiredB @optionalC @interfaceD @protocol解释： 默认是@required,可以选择实现与否就是@optional内省相关内省（Introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。明智地使用内省可以使面向对象的程序更加高效和强壮。它有助于避免错误地进行消息派发、错误地假设对象相等、以及类似的问题。1· 下面哪个方法不属于NSObject的内省(Introspection)方法正确答案: CA isMemberOfClassB responseToSelectorC initD isKindOfClass解释:内省是指能够揭示自己作为一个运行时对象所具有的信息的能力。对于NSObject对象来说，内省能力有，揭示对象的继承关系(isMemberOfClass,isKindOfClass)，是否遵守某个协议(confirmsToProtocol)，是否实现某个方法(respondsToSelector)main函数相关1· ios 应用程序中， main 函数在最大程度上被使用，应用程序运行的一小部分工作由 AppMain 函数来处理，是否正确？正确答案: BA 对B 错解释：在iOS应用程序，main函数的作用是很少的。它的主要工作是控制UIKit framework。在iPhone的应用程序中,main函数仅在最小程度上被使用,应用程序运行所需的大多数实际工作由UIApplicationMain函数来处理。main例程只做三件事: 1.创建一一个自动释放池,2.调用UIApplicationMain函数,3.释放自动释放池。测试相关1· iOS单元测试框架有哪些？正确答案: A B CA OCUnitB GHUnitC OCMockD 0NSXML解释：OCUnit和XCTest都是官方的测试框架，OCUnit已经过时被XCTest所取代。GHUnit和OCMock都是第三方的测试框架，其官方地址分别为：https://github.com/gh-unit/gh-unithttps://github.com/erikdoe/ocmock正则表达式相关1· 下列正则表达式不能匹配”www.innotechx.com”的是：正确答案: A DA ^w+.w+.w+$B [w]{0,3}.[a-z].[a-z]+C ^w.*com$D [w]{3}.[a-z]{11}.[a-z]解释：首先来看A选项，^表示匹配字符串的开始，而 w 和 . 是没有特殊意义的，千万不要看错成是“\\w（匹配字母或数字或下划线或汉字）”了，+ 表示重复一次或者多次，$是匹配字符串的结束。所以该选项会匹配 www.www.www（其中w可重复一次以上）。B选项，[w]{0,3}限定符，表示将w重复0到3次， “ . ”无特殊意义， 表示重复任意次，包括零次，[a-z]表示匹配a到z的字母，所以就是匹配a到z中的某一字母任意次重复。后面这个相同意思，就是+号是重复一次以上。连起来看，是可以匹配选项的。C选项，与上述选项相同，^先匹配字符串开始，然后包含一个 w ，和 “ . “重复任意次，最后以com结尾。这个正则会匹配包含了 “wcom”的字符串，但是w要是开头，com要是结尾，所以可以匹配选项，大家可以自己试试看。D选项，重复三次w，然后一个” . “,但是后面这里要重复11次a到z中的某一字母，数了下题目中选项只有9个字母，后面就不要看啦，已经错啦~图片相关1· 使用imageNamed方法创建UIImage对象时，与普通的init方法有什么区别？正确答案: CA 没有区别，只是为了方便B imageNamed方法只是创建了一个指针，没有分配其他内存C imageNamed方法将图片加载到内存中后不再释放D imageNamed方法将使用完图片后立即释放解释： imageNamed是会把读取到的image存在某个缓存里面，第二次读取相同图片的话系统就会直接从那个缓存中获取，从某种意义上好像一种优化，但是imageNamed读取到的那个图片似乎不会因为Memory Warning而释放，所以用这个会导致在 内存不足 的时候闪退。简单的说imageNamed采用了缓存机制，如果缓存中已加载了图片，直接从缓存读就行了，每次就不用再去读文件了，效率会更高。1.KVO实现原理？KVO在Apple中的API文档如下： Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …KVO基本原理：1.KVO是基于runtime机制实现的2.当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制3.如果原类为Person，那么生成的派生类名为NSKVONotifying_Person4.每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法5.键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。KVO深入原理：1.Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。2.NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；3.所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。4.（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。5.子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。KVO原理图 2.说说你理解的埋点？以下几篇文章写的相当不错，可以适当借鉴下！ iOS无埋点数据SDK实践之路 iOS无埋点数据SDK的整体设计与技术实现 iOS无埋点SDK 之 RN页面的数据收集 3.消息转发机制原理？消息转发机制基本分为三个步骤： 1、动态方法解析 2、备用接受者 3、完整转发 转发机制原理新建一个HelloClass的类，定义两个方法： 123@interfaceHelloClass:NSObject- (void)hello;+ (HelloClass *)hi;@end 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。 123456789101112131415161718192021222324252627282930313233void functionForMethod(id self, SEL _cmd){ NSLog(@&quot;Hello!&quot;);}Class functionForClassMethod(id self, SEL _cmd){ NSLog(@&quot;Hi!&quot;); return [HelloClass class];}#pragma mark - 1、动态方法解析+ (BOOL)resolveClassMethod:(SEL)sel{ NSLog(@&quot;resolveClassMethod&quot;); NSString *selString = NSStringFromSelector(sel); if ([selString isEqualToString:@&quot;hi&quot;]) { Class metaClass = objc_getMetaClass(&quot;HelloClass&quot;); class_addMethod(metaClass, @selector(hi), (IMP)functionForClassMethod, &quot;v@:&quot;); return YES; } return [super resolveClassMethod:sel];}+ (BOOL)resolveInstanceMethod:(SEL)sel{ NSLog(@&quot;resolveInstanceMethod&quot;); NSString *selString = NSStringFromSelector(sel); if ([selString isEqualToString:@&quot;hello&quot;]) { class_addMethod(self, @selector(hello), (IMP)functionForMethod, &quot;v@:&quot;); return YES; } return [super resolveInstanceMethod:sel];} 备用接受者动态方法解析无法处理消息，则会走备用接受者。这个备用接受者只能是一个新的对象，不能是self本身，否则就会出现无限循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。 12345678910111213141516171819202122232425262728293031#pragma mark - 2、备用接收者- (id)forwardingTargetForSelector:(SEL)aSelector{ NSLog(@&quot;forwardingTargetForSelector&quot;); NSString *selectorString = NSStringFromSelector(aSelector); // 将消息交给_helper来处理 if ([selectorString isEqualToString:@&quot;hello&quot;]) { return _helper; } return [super forwardingTargetForSelector:aSelector];}在本类中需要实现这个新的接受对象@interfaceHelloClass(){ RuntimeMethodHelper *_helper;}@end@implementationHelloClass- (instancetype)init{ self = [super init]; if (self) { _helper = [RuntimeMethodHelper new]; } return self;}RuntimeMethodHelper 类需要实现这个需要转发的方法：#import&quot;RuntimeMethodHelper.h&quot;@implementationRuntimeMethodHelper- (void)hello{ NSLog(@&quot;%@, %p&quot;, self, _cmd);}@end 完整消息转发如果动态方法解析和备用接受者都没有处理这个消息，那么就会走完整消息转发： 123456789101112131415161718192021#pragma mark - 3、完整消息转发- (void)forwardInvocation:(NSInvocation *)anInvocation{ NSLog(@&quot;forwardInvocation&quot;); if ([RuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:_helper]; }}/*必须重新这个方法，消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象*/- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) { if ([RuntimeMethodHelper instancesRespondToSelector:aSelector]) { signature = [RuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; } } return signature;} 4.说说你理解weak属性？weak实现原理：Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。1、初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。2、添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。3、释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。追问的问题一：1.实现weak后，为什么对象释放后会自动为nil？runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。追问的问题二：2.当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？1、调用objc_release2、因为对象的引用计数为0，所以执行dealloc3、在dealloc中，调用了_objc_rootDealloc函数4、在_objc_rootDealloc中，调用了object_dispose函数5、调用objc_destructInstance6、最后调用objc_clear_deallocating,详细过程如下：a. 从weak表中获取废弃对象的地址为键值的记录b. 将包含在记录中的所有附有 weak修饰符变量的地址，赋值为 nilc. 将weak表中该记录删除d. 从引用计数表中删除废弃对象的地址为键值的记录5.假如Controller太臃肿，如何优化？1.将网络请求抽象到单独的类中方便在基类中处理公共逻辑；方便在基类中处理缓存逻辑，以及其它一些公共逻辑；方便做对象的持久化。2.将界面的封装抽象到专门的类中构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。3.构造 ViewModel借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。4.专门构造存储类专门来处理本地数据的存取。5.整合常量6.项目中网络层如何做安全处理？ 1、尽量使用httpshttps可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。2、不要传输明文密码不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refreshtoken去申请新的token。3、Post并不比Get安全事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。4、不要使用301跳转301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。5、http请求都带上MAC所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message AuthenticationCode）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（requestparams＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。6、http请求使用临时密钥高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AESkey需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AESkey进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。7、AES使用CBC模式不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。7.main()之前的过程有哪些？1、main之前的加载过程1）dyld 开始将程序二进制文件初始化2）交由ImageLoader 读取 image，其中包含了我们的类，方法等各种符号（Class、Protocol 、Selector、 IMP）3）由于runtime 向dyld 绑定了回调，当image加载到内存后，dyld会通知runtime进行处理4）runtime 接手后调用map_images做解析和处理5）接下来load_images 中调用call_load_methods方法，遍历所有加载进来的Class，按继承层次依次调用Class的+load和其他Category的+load方法6）至此 所有的信息都被加载到内存中7）最后dyld调用真正的main函数注意：dyld会缓存上一次注意：dyld会缓存上一次注意：dyld会缓存上一 概念部分struct和class的区别？ struct中不能定义函数（针对面向过程语言，例如C）// 可不用 使用大括号进行初始化 class和struct如果定义了构造函数，就不能用大括号初始化，若没有，则struct可以，class只有在所有成员变量均为public时才行。 // 可不用 默认访问权限 class默认成员访问权限为private；struct默认访问你权限为public。 // 重点 继承方式 class默认private；struct默认public。 // 重点 说出以下指针的含义：1234int **a : 指向一个指针的指针，该指针指向一个整数。int *a[10] : 指向一个有10个指针的数组，每个指针指向一个整数。int (*a)[10] : 指向一个有10个整数数组的指针。int (*a)(int) : 指向一个函数的指针，该函数有一个整数参数，并返回一个整数。 int 和 NSInterger 的区别： 以C语言举例，int和long的字节数和当前操作系统中的指针所占位数是相等的，也就是说，long的长度永远 ≥ int，并且我们需要去考虑此时是使用int还是long比较合适，会不会因为一时疏忽选择了int而导致位数不够造成溢出。 而在OC中使用 NSInterger ，苹果对其进行了一个宏定义的判断（cmd+鼠标左键进去看吧），这个宏定义会自动判断当前App运行的硬件环境，到底是32位机还是64位机等等，从而自动返回最大的类型，而不用我们去思考此时到底应该是用int还是long。 深拷贝和浅拷贝的区别： 浅拷贝：又称“指针拷贝”。不增加新内存，只增加一个指针指向原来的内存区域。 深拷贝：又称“内容拷贝”。同时拷贝指正和指针所指向的内存，新增指针指向新增内存。 // 可对OC中的可变对象和不可变对象做拓展，此问题只是单纯的概念。 内存中的区域是怎么划分的？ 用之前做的一张图进行描述： 语言部分nil、Nil、NULL和NSNULL的区别： nil： 把对象置空，置空后是一个空对象且完全从内存中释放； Nil： 用nil的地方均可用Nil替换，Nil表示置空一个类； NULL： 表示把一个指针置空。（空指针） NSNULL： 把一个OC对象置空，但想保留其容器（大小）。 category和extension的区别： category：为已知类增加新方法。 新增方法被子类集成； 新增的方法比原有类具备更高的优先级，且不可重名，防止被覆盖； 不能增加成员变量。 extension： 为当前类增加私有变量和私有方法，添加的方法是必须实现的。 @Property关键词及其相关关键字的理解： 根据被修改的可能性，、@Property中关键字的排列推荐为：原子性、读写性、内存管理特性； 原子性： automatic和nonautomatic。决定了该属性是否为原子性的，即在多线程的操作中，不能被其它线程打断的特性，一旦使用了该变量的操作不能被完整执行时，将会回到该变量操作之前的状态，但原子性即automatic因为是原语操作（保证setter/getter的原语执行），会损耗性能，在iOS开发中一般不用，而在macOS开发中随意。 读写性： readOnly和readWrite。默认为readWrite，编译器会帮助生成serter/getter方法，而readOnly只会帮助生成getter方法。 // 此处可拓展，非要修改readOnly修饰的变量怎么办，可用KVC，又可继续拓展KVC相关知识。 内存管理特性： assign、weak、strong、unsafe_unretained。 assign：一般用于值类型，比如int、BOOL等（还可用于修饰OC对象； weak：用于修饰引用类型（弱引用，只能修饰OC对象）； strong：用于修饰引用类型（强引用）； unsafeunretained：只用于修饰引用类型（弱引用），与weak的区别在于，被unsafeunretained修饰的对象被销毁后，其指针并不会被自动置空，此时指向了一个野地址。 OC中如何定义一个枚举？在OC中定义一个枚举有三种做法： 因为OC是兼容C的，所以可以使用C语言风格的enum进行定义。 使用NS_ENUM宏进行定义； 使用NS_OPTIONS宏进行定义； NS_ENUM为定义通用性枚举，只能单选，NS_OPTIONS为定义位移枚举，可多选。 // 枚举为啥要这么分？因为涉及到是否使用C++模式进行编译有关。 Block和函数的关系（对Block的理解）？ Block与函数指针非常类似，但Block能够访问函数以外、词法作用域以外的外部变量的值； Block不仅实现了函数的功能，还携带了函数的执行环境； Block实际上是指向结构体的指针；（可参考这篇文章） Block会把进入其内部的基本数据类型变量当做常量处理。】 Block执行的是一个回调，并不知道其中的对象合适被释放，所以为了防止在使用对象之前就被释放掉了，会自动给其内部所使用的对象进行retain一次。 Block使用copy修饰符进行修饰，且不能使用retain进行修饰，因为retain只是进行了一次回调，但block的内存还是放在了栈空间中，在栈上的变量随时会被系统回收，且Block在创建的时候内存默认就已经分配在栈空间中，其本身的作用域限于其创建时，一旦在超出其创建时的作用域之外使用，则会导致程序的崩溃，故使用copy修饰，使其拷贝到堆空间中，block有时还会用到一些本地变量，只有将其copy到堆空间中，才能使用这些变量。 deletegate需要weak修饰的原因？以图说明，图中所表示的是VC对tableView的持有，如果此时的tableView.deletegate对VC也是强引用，会导致循环引用，同时也给了我们敲了警钟，当出现两个对象都是强引用时，万分小心！ 解释一下这段代码的输出： 简写： 123456789Computer : NSObjectMac : Computer@implementation MacNSLog(@&quot;%@&quot;, [self class]);NSLog(@&quot;%@&quot;, [super class])@end 二者都会输出Mac。 [self class]：当使用self调用方法时，从当前类方法列表中找，若没有则再去父类中找。调用[self class]时，会转化成objc_msgSend函数，其定义为id objc_msgSend(id self, SEL op, …)，第一个参数是Mac实例，但其并无-(Class)class方法，此时去父类Computer中寻找，发现也没有，再去其父类NSObject中找，找到了！返回的就是self其本身，可猜测其方法实现如下： 123- (Class)class {return object_getClass(self);} [super class]：从父类方法列表中开始找，调用父类方法。当调用[super class]时，转换成objc_msgSendSuper函数，其定义为id objc_msgSendSuper(struct objc_super *super, SEL op, …)，而struct objc_super结构体的定义为： 1234struct objc_super {__unsafe_unretained id receiver;__unsafe_unretained Class super_class;} 所以转换成objc_msgSendSuper函数后，第一步要先去构造objc_super结构体，结构的第一个成员receiver就是self，第二个成员是(id)class_getSuperclass(object_getClass(“Mac”))，该函数输出的结果为super_class值，即Computer，第二步，则去Computer类中去找- (Class)class，发现并未找到，接着去NSObject中找，找到了！最后是使用了objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用了，这个时候已经跟之前的[self class]调用输出结果重复了，返回结果还是Mac。 iOS部分UITableView性能调优的方法： Cell重用： 数据源方法优化：创建一个静态变量重用ID，例如：static NSString *cellID = @&quot;cellID&quot;;防止因为调用次数过多，static保证只创建一次，提高性能（感觉性能的提升可以忽略不记emmm） 缓存池获取可重用Cell的两个方法： dequeueReusableCellWithIdentifier:(NSString *)ID会查询可重用Cell，若注册了原型Cell则能够查询到，否则为nil，故需要先判断if(cell == nil) dequeueReusableCellWithIdentifier:(NSString *)ID indexPath:(NSIndexPath *)indexPath，使用之前必须通过SB/class进行可重用Cell的注册（registerNib/registerClass），不需要判断nil，一定会返回cell，若缓冲区Cell不存在，会使用原型Cell重新实例化一个新Cell。 尽量使用一种类型的Cell：能够减少代码量，减小Nib文件的数量；保证只有一种类型的Cell，实际上App运后只有N个Cell，但若有M种Cell，则实际上运行最多却可能会是MxN 个。 善用hidden隐藏subview：把所有不同类型的view都定义好，通过cell的枚举类型变量及hidden显示/隐藏不同类型的内容，因为在实际快速滑动中，单纯的显示/隐藏subview比实时创建快得多。 提前计算并缓存Cell的高度。如果我们不预估行高，则优先调用heightForRowAtIndexPath获取每个Cell即将显示的高度，实际上就是要确定总的tableView.contenSize，最后才又接着调用cellForRowAtIndexPath，可以建一个frame模型，保存下提前计算好的cell高度。 异步绘制：这是目前最火的tableView性能调优方法，新浪微博是这么做的，可以使用ASDK这个库进行。 tableView滑动时，按需加载：识别tableView静止或减速滑动结束后，异步加载，在快速滑动过程中，只按需加载目标方位内的Cell。 避免大量使用图片缩放、颜色渐变、透明图层、CALayer特效（阴影）等操作，尽量显示大小刚好合适的图片资源。 内存优化方案： 首先ARC。但要注意防止循环引用，避免内存泄露； 懒加载。延迟创建对象，用时再创建； 复用。比如tableView、collectionView单元格的复用； 巧妙使用单例，而不是全都使用单例！ 单例的写法？12345678910111213141516171819static User *user;+ (User *)shareInstance { if (user == nil) { @synchronized(self) { // 加锁 user = [User alloc] init]; } } return user;}+ (User *)shareInstance { static dispatch_onec_t onecToken; dispatch_onece(&amp;onceToken, ^{ user = [User alloc] init; }) return user;} iOS的远程推送过程？以图讲解： iOS中多线程的概念：（单问概念） 多线程优点：提高程序执行效率。缺点：开启线程需要一定的内存控件。 同步和异步：决定了要不要开启新的线程。同步：在当前线程中执行任务，不具备开启新线程能力；异步：在新线程中执行任务，具备开启新线程的能力。 并行和串行：决定了任务的执行方式。并行：多个任务并发（同时）执行，类似迅雷多任务同时下载；串行：一个任务执行完毕后，再执行下一个任务，类似一个一个下载。 重点： 必须要明确iOS中只有一个主线程——UI线程，且不可将耗时任务放在主线程执行，否则会造成卡顿。","link":"/program//kaopu/"},{"title":"深入剖析-WebKit","text":"HTML 标准HTML HTML DOM 树的插入状态规范 https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode HTML Tokenize 规范 https://html.spec.whatwg.org/multipage/parsing.html#tokenization https://dev.w3.org/html5/spec-preview/tokenization.html HTMLElement 堆栈规范 https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements 浏览器历史1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。 1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。 1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。 1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。 2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。 2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。 2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio / video 音频视频，3D/graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。 完整的浏览器发展史可以在这里看：https://en.wikipedia.org/wiki/Timeline_of_web_browsers WebKit 全貌架构可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。先看看它的大模块：WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：整个 WebKit 架构，如下：实线部分是共享的，虚线部分会根据不同的平台有不同的实现。 下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图： 解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。 DOM Tree从网页 URL 到构建完 DOM 树的过程如图 CSS Rule Tree 通过上面的两个数构造的 Style Context Tree 浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下： 计算每个 Node 的位置，执行 Layout 过程 Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。 WebKit 源代码结构说明 JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。 WebCore：浏览器渲染引擎，包含了各个核心模块。 WebCore/css：CSS 解释器，CSS 规则等。 WebCore/dom：各种 DOM 元素和 DOM Tree 结构相关的类。 WebCore/html：HTML 解释器和各种 HTML 元素等相关内容。 WebCore/rendering：Render Object 相关，还有页面渲染的样式和布局等。 WebCore/inspector：网页调试工具。 WebCore/loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。 WebCore/page：页面相关的操作，页面结构和交互事件等。 WebCore/platform：各个平台相关的代码，比如 iOS，Mac 等 WebCore/storage：存储相关，比如 WebStorage，Index DB 等接口的实现。 WebCore/workers：Worker 线程封装，提供 JS 多线程执行环境。 WebCore/xml：XML 相关比如 XML Parser，XPath，XSLT 等。 WebCore/accessibility：图形控件访问接口。 WebCore/bindings：DOM 元素和 JS 绑定的接口。 WebCore/bridge：C，JavaScript 和 Objective-C 的桥接。 WebCore/editing：页面编辑相关，比如 DOM 修改，拼写检查等。 WebCore/history：Page Cache 实现前进后退浏览记录等。 WebCore/mathml：数学表达式在网页中的规范代码实现。 WebCore/plugins：NPPlugin 的支持接口 WebCore/svg：矢量图形的支持。 WebKit：平台相关的接口，每个目录都是不同的平台接口实现。 WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。 DumpRenderTree：用于生成 RenderTree TestWebKitAPI：测试 WebKit 的 API 的测试代码 WebKit 代码风格 内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。 代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。 代码编写风格：可以在官网查看到：https://webkit.org/code-style-guidelines/ 想给 WebKit 做贡献的同学们可以好好看看了。 WebKit 的设计模式下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。 单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。 工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。 观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。 组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。 命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。 主要类整体 Frame：中心类，通过它找其它类 FrameLoader：加载资源用的 Document：具体实现是 HTMLDocument Page：窗口的操作 EventHandler：输入事件的处理，比如键盘，鼠标，触屏等 WebCore::Frame FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。 FrameLoader：frame 的加载 NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。 DOMWindow：管理 DOM 相关的事件，属性和消息。 FrameView：Frame 的排版。 Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。 ScriptController：管理 js 脚本。 Editor：管理页面比如 copy，paste和输入等编辑操作。 SelectionController：管理 Frame 里的选择操作。 AnimationControlle：动画控制。 EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。 渲染引擎上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程： Frame 的主要接口Create123456Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client){ ASSERT(page); ASSERT(client); return adoptRef(*new Frame(*page, ownerElement, *client));} Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。初始调用顺序 123456webPage::setViewwebPage::setViewportSizewebPage::mainFramewebPagePrivate::createMainFramewebFrameData::webFrameDataFrame::create 解析中发现 iframe 时的调用顺序 12345678FrameLoader::finishedLoadingHTMLDocumentParser::appendHTMLTreeBuilder::processTokenHTMLElementBase::openURLSubFrameLoader::requestFrameFrameLoaderClient::creatFramewebFrameData::webFrameDataFrame::create createView12345c++void Frame::createView(const IntSize&amp; viewportSize, const Color&amp; backgroundColor, bool transparent, const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect, bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock, ScrollbarMode verticalScrollbarMode, bool verticalLock) 会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。调用顺序 12345c++FrameLoader::commitProvisionalLoadFrameLoader::transitionToCommittedFrameLoaderClient::transitionToCommittedForNewPageFrame::createView setDocument12c++void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument) 用来关联 Frame 和 Document 对象Frame 初始化调用顺序 1234567c++WebFrame::webFramewebFramePrivate::initFrame::initFrameLoader::initDocumentWriter::beginFrame::setDocument js 脚本更改数据时的调用顺序 1234567891011c++DocumentLoader::receivedDataDocumentLoader::commitLoadFrameLoaderClient::committedLoadDocumentLoader::commitDataDocumentWriter::setEncodingDocumentWriter::willSetEncodingFrameLoader::receivedFirstDataDocumentWriter::beginFrameLoader::clearFrame::setDocument WTF全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。 Smart ptr 智能指针对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。 智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。 智能指针的实现方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243template &lt;typename T&gt;class SmartPtr { public: typedef T ValueType; typedef ValueType *PtrType; //构造析构函数 SmartPtr() :m_ptr(NULL) {} SmartPtr(PtrType ptr) :m_ptr(ptr) {} ~SmartPtr() { if(m_ptr) delete m_ptr; } //拷贝构造函数 SmartPtr(const SmartPtr&lt;T&gt;&amp; o); //堆上分配的对象 template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; o); //拷贝赋值运算符 template&lt;typename U&gt; SmartPtr&amp; operator = (const SmartPtr&lt;U&gt;&amp; o); //指针运算，是为了让智能指针在行为上更类似原生指针 ValueType&amp; operator*() const { return *m_ptr; } PtrType operator-&gt;() const { return m_ptr; } //逻辑运算符重载 //对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr) bool operator!() const { return !m_ptr; } //转成 raw ptr operator PtrType() { return m_ptr; } private: PtrType m_ptr;}//创建智能指针对象格式SmartPtr(new ValueType()); RefPtrRefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF/Source/wtf/RefCounted.h 里。类模板的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class RefCountedBase {public: void ref() const {#if CHECK_REF_COUNTED_LIFECYCLE ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun); ASSERT(!m_adoptionIsRequired);#endif ++m_refCount; } bool hasOneRef() const {#if CHECK_REF_COUNTED_LIFECYCLE ASSERT(!m_deletionHasBegun);#endif return m_refCount == 1; } unsigned refCount() const { return m_refCount; } void relaxAdoptionRequirement() {#if CHECK_REF_COUNTED_LIFECYCLE ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun); ASSERT(m_adoptionIsRequired); m_adoptionIsRequired = false;#endif }protected: RefCountedBase() : m_refCount(1)#if CHECK_REF_COUNTED_LIFECYCLE , m_deletionHasBegun(false) , m_adoptionIsRequired(true)#endif { } ~RefCountedBase() {#if CHECK_REF_COUNTED_LIFECYCLE ASSERT(m_deletionHasBegun); ASSERT(!m_adoptionIsRequired);#endif } // Returns whether the pointer should be freed or not. bool derefBase() const {#if CHECK_REF_COUNTED_LIFECYCLE ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun); ASSERT(!m_adoptionIsRequired);#endif ASSERT(m_refCount); unsigned tempRefCount = m_refCount - 1; if (!tempRefCount) {#if CHECK_REF_COUNTED_LIFECYCLE m_deletionHasBegun = true;#endif return true; } m_refCount = tempRefCount; return false; }#if CHECK_REF_COUNTED_LIFECYCLE bool deletionHasBegun() const { return m_deletionHasBegun; }#endifprivate:#if CHECK_REF_COUNTED_LIFECYCLE friend void adopted(RefCountedBase*);#endif mutable unsigned m_refCount;#if CHECK_REF_COUNTED_LIFECYCLE mutable bool m_deletionHasBegun; mutable bool m_adoptionIsRequired;#endif};template&lt;typename T&gt; class RefCounted : public RefCountedBase { WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;public: void deref() const { if (derefBase()) delete static_cast&lt;const T*&gt;(this); }protected: RefCounted() { } ~RefCounted() { }}; 上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。 Assert 断言的实现和应用断言在 WTF 里是这样定义的 1234567891011121314151617181920212223242526272829303132333435 c++#define ASSERT(assertion) do { \\ if (!(assertion)) { \\ //打印用 WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \\ //重点 CRASH(); \\ } \\} while (0)#ifndef CRASH#if defined(NDEBUG) &amp;&amp; OS(DARWIN)// Crash with a SIGTRAP i.e EXC_BREAKPOINT.// We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily// trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.#define CRASH() do { \\ //直接 inline 汇编代码 WTFBreakpointTrap(); \\ __builtin_unreachable(); \\} while (0)#else#define CRASH() WTFCrash()#endif#endif // !defined(CRASH)//根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏#if CPU(X86_64) || CPU(X86)#define WTFBreakpointTrap() __asm__ volatile (&quot;int3&quot;)#elif CPU(ARM_THUMB2)#define WTFBreakpointTrap() __asm__ volatile (&quot;bkpt #0&quot;)#elif CPU(ARM64)#define WTFBreakpointTrap() __asm__ volatile (&quot;brk #0&quot;)#else#define WTFBreakpointTrap() WTFCrash() // Not implemented.#endif 内存管理WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏 1234567891011121314151617181920212223242526272829303132 c++#define WTF_MAKE_FAST_ALLOCATED \\public: \\ void* operator new(size_t, void* p) { return p; } \\ void* operator new[](size_t, void* p) { return p; } \\ \\ void* operator new(size_t size) \\ { \\ return ::WTF::fastMalloc(size); \\ } \\ \\ void operator delete(void* p) \\ { \\ ::WTF::fastFree(p); \\ } \\ \\ void* operator new[](size_t size) \\ { \\ return ::WTF::fastMalloc(size); \\ } \\ \\ void operator delete[](void* p) \\ { \\ ::WTF::fastFree(p); \\ } \\ void* operator new(size_t, NotNullTag, void* location) \\ { \\ ASSERT(location); \\ return location; \\ } \\private: \\typedef int __thisIsHereToForceASemicolonAfterThisMacro 这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现： 12345void* fastMalloc(size_t size){ ASSERT_IS_WITHIN_LIMIT(size); return bmalloc::api::malloc(size);} 可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：https://goog-perftools.sourceforge.net/doc/tcmalloc.html 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。 容器类WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。 Vector 动态数组WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246 c++template&lt;typename T, size_t inlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, size_t minCapacity = 16, typename Malloc = FastMalloc&gt;class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; { WTF_MAKE_FAST_ALLOCATED;private: //VectorBuffer 是内部存储数据的容器 typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base; //Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里 typedef VectorTypeOperations&lt;T&gt; TypeOperations;public: typedef T ValueType; //iterator 直接使用的原生指针 typedef T* iterator; typedef const T* const_iterator; typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator; typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator; Vector() { } // Unlike in std::vector, this constructor does not initialize POD types. explicit Vector(size_t size) : Base(size, size) { asanSetInitialBufferSizeTo(size); if (begin()) TypeOperations::initialize(begin(), end()); } Vector(size_t size, const T&amp; val) : Base(size, size) { asanSetInitialBufferSizeTo(size); if (begin()) TypeOperations::uninitializedFill(begin(), end(), val); } Vector(std::initializer_list&lt;T&gt; initializerList) { reserveInitialCapacity(initializerList.size()); asanSetInitialBufferSizeTo(initializerList.size()); for (const auto&amp; element : initializerList) uncheckedAppend(element); } ~Vector() { if (m_size) TypeOperations::destruct(begin(), end()); asanSetBufferSizeToFullCapacity(0); } Vector(const Vector&amp;); template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt; explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;); Vector&amp; operator=(const Vector&amp;); template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt; Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;); Vector(Vector&amp;&amp;); Vector&amp; operator=(Vector&amp;&amp;); //返回 Vector 里元素个数 size_t size() const { return m_size; } static ptrdiff_t sizeMemoryOffset() { return OBJECT_OFFSETOF(Vector, m_size); } //返回的是 Vector 中的容量，容量随着元素增加和删除而变化 size_t capacity() const { return Base::capacity(); } bool isEmpty() const { return !size(); } //这里提供的是数组的访问功能 T&amp; at(size_t i) { if (UNLIKELY(i &gt;= size())) OverflowHandler::overflowed(); return Base::buffer()[i]; } const T&amp; at(size_t i) const { if (UNLIKELY(i &gt;= size())) OverflowHandler::overflowed(); return Base::buffer()[i]; } T&amp; at(Checked&lt;size_t&gt; i) { RELEASE_ASSERT(i &lt; size()); return Base::buffer()[i]; } const T&amp; at(Checked&lt;size_t&gt; i) const { RELEASE_ASSERT(i &lt; size()); return Base::buffer()[i]; } //返回数组中第几个元素 T&amp; operator[](size_t i) { return at(i); } const T&amp; operator[](size_t i) const { return at(i); } T&amp; operator[](Checked&lt;size_t&gt; i) { return at(i); } const T&amp; operator[](Checked&lt;size_t&gt; i) const { return at(i); } T* data() { return Base::buffer(); } const T* data() const { return Base::buffer(); } static ptrdiff_t dataMemoryOffset() { return Base::bufferMemoryOffset(); } //迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。 iterator begin() { return data(); } iterator end() { return begin() + m_size; } const_iterator begin() const { return data(); } const_iterator end() const { return begin() + m_size; } reverse_iterator rbegin() { return reverse_iterator(end()); } reverse_iterator rend() { return reverse_iterator(begin()); } const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); } const_reverse_iterator rend() const { return const_reverse_iterator(begin()); } T&amp; first() { return at(0); } const T&amp; first() const { return at(0); } T&amp; last() { return at(size() - 1); } const T&amp; last() const { return at(size() - 1); } T takeLast() { T result = WTFMove(last()); removeLast(); return result; } //O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好 template&lt;typename U&gt; bool contains(const U&amp;) const; template&lt;typename U&gt; size_t find(const U&amp;) const; template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const; template&lt;typename U&gt; size_t reverseFind(const U&amp;) const; template&lt;typename U&gt; bool appendIfNotContains(const U&amp;); //实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力 void shrink(size_t size); void grow(size_t size); void resize(size_t size); void resizeToFit(size_t size); void reserveCapacity(size_t newCapacity); bool tryReserveCapacity(size_t newCapacity); void reserveInitialCapacity(size_t initialCapacity); void shrinkCapacity(size_t newCapacity); void shrinkToFit() { shrinkCapacity(size()); } void clear() { shrinkCapacity(0); } void append(ValueType&amp;&amp; value) { append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); } template&lt;typename U&gt; void append(U&amp;&amp;); template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...); template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...); void uncheckedAppend(ValueType&amp;&amp; value) { uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); } template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;); template&lt;typename U&gt; void append(const U*, size_t); template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;); template&lt;typename U&gt; bool tryAppend(const U*, size_t); template&lt;typename U&gt; void insert(size_t position, const U*, size_t); template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;); template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;); void remove(size_t position); void remove(size_t position, size_t length); template&lt;typename U&gt; bool removeFirst(const U&amp;); template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0); template&lt;typename U&gt; unsigned removeAll(const U&amp;); template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0); void removeLast() { if (UNLIKELY(isEmpty())) OverflowHandler::overflowed(); shrink(size() - 1); } void fill(const T&amp;, size_t); void fill(const T&amp; val) { fill(val, size()); } template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end); MallocPtr&lt;T&gt; releaseBuffer(); void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other) {#if ASAN_ENABLED if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice. return;#endif // Make it possible to copy inline buffers. asanSetBufferSizeToFullCapacity(); other.asanSetBufferSizeToFullCapacity(); Base::swap(other, m_size, other.m_size); std::swap(m_size, other.m_size); asanSetInitialBufferSizeTo(m_size); other.asanSetInitialBufferSizeTo(other.m_size); } void reverse(); void checkConsistency(); template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;private: void expandCapacity(size_t newMinCapacity); T* expandCapacity(size_t newMinCapacity, T*); bool tryExpandCapacity(size_t newMinCapacity); const T* tryExpandCapacity(size_t newMinCapacity, const T*); template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;); template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...); template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...); void asanSetInitialBufferSizeTo(size_t); void asanSetBufferSizeToFullCapacity(size_t); void asanSetBufferSizeToFullCapacity() { asanSetBufferSizeToFullCapacity(size()); } void asanBufferSizeWillChangeTo(size_t); using Base::m_size; using Base::buffer; using Base::capacity; using Base::swap; using Base::allocateBuffer; using Base::deallocateBuffer; using Base::tryAllocateBuffer; using Base::shouldReallocateBuffer; using Base::reallocateBuffer; using Base::restoreInlineBufferIfNeeded; using Base::releaseBuffer;#if ASAN_ENABLED using Base::endOfBuffer;#endif}; HashTable 哈希表HashTable 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206 c++ template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt; class HashTable { public: typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator; typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator; typedef Traits ValueTraits; typedef Key KeyType; typedef Value ValueType; typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType; typedef HashTableAddResult&lt;iterator&gt; AddResult;#if DUMP_HASHTABLE_STATS_PER_TABLE struct Stats { Stats() : numAccesses(0) , numRehashes(0) , numRemoves(0) , numReinserts(0) , maxCollisions(0) , numCollisions(0) , collisionGraph() { } unsigned numAccesses; unsigned numRehashes; unsigned numRemoves; unsigned numReinserts; unsigned maxCollisions; unsigned numCollisions; unsigned collisionGraph[4096]; void recordCollisionAtCount(unsigned count) { if (count &gt; maxCollisions) maxCollisions = count; numCollisions++; collisionGraph[count]++; } void dumpStats() { dataLogF(&quot;\\nWTF::HashTable::Stats dump\\n\\n&quot;); dataLogF(&quot;%d accesses\\n&quot;, numAccesses); dataLogF(&quot;%d total collisions, average %.2f probes per access\\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) / numAccesses); dataLogF(&quot;longest collision chain: %d\\n&quot;, maxCollisions); for (unsigned i = 1; i &lt;= maxCollisions; i++) { dataLogF(&quot; %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) / numAccesses, 100.0 * collisionGraph[i] / numAccesses); } dataLogF(&quot;%d rehashes\\n&quot;, numRehashes); dataLogF(&quot;%d reinserts\\n&quot;, numReinserts); } };#endif HashTable(); ~HashTable() { invalidateIterators(); if (m_table) deallocateTable(m_table, m_tableSize);#if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION m_table = (ValueType*)(uintptr_t)0xbbadbeef;#endif } HashTable(const HashTable&amp;); void swap(HashTable&amp;); HashTable&amp; operator=(const HashTable&amp;); HashTable(HashTable&amp;&amp;); HashTable&amp; operator=(HashTable&amp;&amp;); // When the hash table is empty, just return the same iterator for end as for begin. // This is more efficient because we don&apos;t have to skip all the empty and deleted // buckets, and iterating an empty table is a common case that&apos;s worth optimizing. iterator begin() { return isEmpty() ? end() : makeIterator(m_table); } iterator end() { return makeKnownGoodIterator(m_table + m_tableSize); } const_iterator begin() const { return isEmpty() ? end() : makeConstIterator(m_table); } const_iterator end() const { return makeKnownGoodConstIterator(m_table + m_tableSize); } unsigned size() const { return m_keyCount; } unsigned capacity() const { return m_tableSize; } bool isEmpty() const { return !m_keyCount; } AddResult add(const ValueType&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); } AddResult add(ValueType&amp;&amp; value) { return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); } // A special version of add() that finds the object by hashing and comparing // with some other type, to avoid the cost of type conversion if the object is already // in the table. template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;); template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;); iterator find(const KeyType&amp; key) { return find&lt;IdentityTranslatorType&gt;(key); } const_iterator find(const KeyType&amp; key) const { return find&lt;IdentityTranslatorType&gt;(key); } bool contains(const KeyType&amp; key) const { return contains&lt;IdentityTranslatorType&gt;(key); } template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;); template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const; template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const; void remove(const KeyType&amp;); void remove(iterator); void removeWithoutEntryConsistencyCheck(iterator); void removeWithoutEntryConsistencyCheck(const_iterator); template&lt;typename Functor&gt; void removeIf(const Functor&amp;); void clear(); static bool isEmptyBucket(const ValueType&amp; value) { return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); } static bool isDeletedBucket(const ValueType&amp; value) { return KeyTraits::isDeletedValue(Extractor::extract(value)); } static bool isEmptyOrDeletedBucket(const ValueType&amp; value) { return isEmptyBucket(value) || isDeletedBucket(value); } ValueType* lookup(const Key&amp; key) { return lookup&lt;IdentityTranslatorType&gt;(key); } template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;); template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);#if !ASSERT_DISABLED void checkTableConsistency() const;#else static void checkTableConsistency() { }#endif#if CHECK_HASHTABLE_CONSISTENCY void internalCheckTableConsistency() const { checkTableConsistency(); } void internalCheckTableConsistencyExceptSize() const { checkTableConsistencyExceptSize(); }#else static void internalCheckTableConsistencyExceptSize() { } static void internalCheckTableConsistency() { }#endif private: static ValueType* allocateTable(unsigned size); static void deallocateTable(ValueType* table, unsigned size); typedef std::pair&lt;ValueType*, bool&gt; LookupType; typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType; LookupType lookupForWriting(const Key&amp; key) { return lookupForWriting&lt;IdentityTranslatorType&gt;(key); }; template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;); template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;); template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;); template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;); void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*); void removeAndInvalidate(ValueType*); void remove(ValueType*); bool shouldExpand() const { return (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; } bool mustRehashInPlace() const { return m_keyCount * m_minLoad &lt; m_tableSize * 2; } bool shouldShrink() const { return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; } ValueType* expand(ValueType* entry = nullptr); void shrink() { rehash(m_tableSize / 2, nullptr); } ValueType* rehash(unsigned newTableSize, ValueType* entry); ValueType* reinsert(ValueType&amp;&amp;); static void initializeBucket(ValueType&amp; bucket); static void deleteBucket(ValueType&amp; bucket) { hashTraitsDeleteBucket&lt;Traits&gt;(bucket); } FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash) { return FullLookupType(LookupType(position, found), hash); } iterator makeIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize); } const_iterator makeConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize); } iterator makeKnownGoodIterator(ValueType* pos) { return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); } const_iterator makeKnownGoodConstIterator(ValueType* pos) const { return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); }#if !ASSERT_DISABLED void checkTableConsistencyExceptSize() const;#else static void checkTableConsistencyExceptSize() { }#endif#if CHECK_HASHTABLE_ITERATORS void invalidateIterators();#else static void invalidateIterators() { }#endif static const unsigned m_maxLoad = 2; static const unsigned m_minLoad = 6; ValueType* m_table; unsigned m_tableSize; unsigned m_tableSizeMask; unsigned m_keyCount; unsigned m_deletedCount;#if CHECK_HASHTABLE_ITERATORS public: // All access to m_iterators should be guarded with m_mutex. mutable const_iterator* m_iterators; // Use std::unique_ptr so HashTable can still be memmove&apos;d or memcpy&apos;ed. mutable std::unique_ptr&lt;Lock&gt; m_mutex;#endif#if DUMP_HASHTABLE_STATS_PER_TABLE public: mutable std::unique_ptr&lt;Stats&gt; m_stats;#endif }; 完整具体的实现可以查看 WTF/Source/wtf/HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。 线程WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF/Source/wtf/MessageQueue.h 里有对消息队列的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243 c++// The queue takes ownership of messages and transfer it to the new owner// when messages are fetched from the queue.// Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.template&lt;typename DataType&gt;class MessageQueue { WTF_MAKE_NONCOPYABLE(MessageQueue);public: MessageQueue() : m_killed(false) { } ~MessageQueue(); void append(std::unique_ptr&lt;DataType&gt;); void appendAndKill(std::unique_ptr&lt;DataType&gt;); bool appendAndCheckEmpty(std::unique_ptr&lt;DataType&gt;); void prepend(std::unique_ptr&lt;DataType&gt;); std::unique_ptr&lt;DataType&gt; waitForMessage(); std::unique_ptr&lt;DataType&gt; tryGetMessage(); Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; takeAllMessages(); std::unique_ptr&lt;DataType&gt; tryGetMessageIgnoringKilled(); template&lt;typename Predicate&gt; std::unique_ptr&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime); template&lt;typename Predicate&gt; void removeIf(Predicate&amp;&amp;); void kill(); bool killed() const; // The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time. bool isEmpty();private: //m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装 mutable Lock m_mutex; //Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程 Condition m_condition; //内部主要存储结构 Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; m_queue; bool m_killed;}; 可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I/O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。 Loader主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore/platform/network 里。如果是 iOS 就在 WebCore/platform/network/iOS 里，如果 Mac 就在 WebCore/platform/network/mac 里。 Loader 的资源网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型： HTML：页面主文件 JavaScript：单独的文件后者直接在 HTML 代码里 CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里 图片：各种编码图片比如 jpg 和 png SVG：矢量图片 CSS Shader：为 CSS 带来 3D 图形特性 音频视频：多媒体资源以及视频字幕 字体：自定义的字体 XSL：对 XSLT 语言编写的文件支持 WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。 FrameLoader加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。 MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。 CacheResourceLoader：缓存资源读取。 资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。 DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。 加载过程 解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。 这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。 整个资源加载过程，这篇文章有详细的介绍：https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/ 类关系 Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。 SubFrameLoader：维护子 Frame。 DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。 DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。 HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。 ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。 SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。 FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。 PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。 FrameLoader 的主要接口Frame::initFrameLoader 自身的初始化。初始化的调用顺序 1234WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)Frame::init()FrameLoader::init() FrameLoader::commitProvisionalLoad提交 provisional 阶段时下载的数据完成 Document loading 的调用顺序 123DocumentLoader::finishLoadingDocumentLoader::commitIfReadyFrameLoader::commitProvisionalLoad 资源数据接受提交调用顺序 123456ResourceLoader::didReceiveDataMainResourceLoader::addDataDocumentLoader::receiveDataDocumentLoader::commitLoadDocumentLoader::commitIfReadyDocumentLoader::commitProvisionalLoad Frame::finishedLoading网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。函数的调用顺序 1234ResourceLoader::didFinishLoadingMainResourceLoader::didFinishLoadingFrameLoader::finishedLoadingFrameLoader::init() FrameLoader::finishedParsing完成解析时调用的接口调用顺序 1234DocumentWritter::endDocument::finishParsingDocument::finishedParsingFrameLoader::finishedParsing FrameLoader::load(FrameLoadRequest&amp;&amp; request)加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210 c++//创建 DocumentLoadervoid FrameLoader::load(FrameLoadRequest&amp;&amp; request){ if (m_inStopAllLoaders) return; if (!request.frameName().isEmpty()) { Frame* frame = findFrameForNavigation(request.frameName()); if (frame) { request.setShouldCheckNewWindowPolicy(false); if (&amp;frame-&gt;loader() != this) { frame-&gt;loader().load(WTFMove(request)); return; } } } if (request.shouldCheckNewWindowPolicy()) { NavigationAction action { request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() }; policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), nullptr, request.frameName(), [this] (const ResourceRequest&amp; request, FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, bool shouldContinue) { continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress); }); return; } if (!request.hasSubstituteData()) request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url())); //FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。 Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData()); applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request); load(loader.ptr());}//完善 request 信息void FrameLoader::load(DocumentLoader* newDocumentLoader){ ResourceRequest&amp; r = newDocumentLoader-&gt;request(); //ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。 addExtraFieldsToMainResourceRequest(r); FrameLoadType type; if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) { r.setCachePolicy(ReloadIgnoringCacheData); type = FrameLoadType::Same; } else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType == FrameLoadType::Reload) type = FrameLoadType::Reload; else if (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid()) type = FrameLoadType::RedirectWithLockedBackForwardList; else type = FrameLoadType::Standard; if (m_documentLoader) newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding()); if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) { history().saveDocumentAndScrollState(); ASSERT(type == FrameLoadType::Standard); type = FrameLoadType::Reload; } loadWithDocumentLoader(newDocumentLoader, type, 0, AllowNavigationToInvalidURL::Yes);}//校验检查void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL){ // Retain because dispatchBeforeLoadEvent may release the last reference to it. Ref&lt;Frame&gt; protect(m_frame); ASSERT(m_client.hasWebView()); ASSERT(m_frame.view()); if (!isNavigationAllowed()) return; if (m_frame.document()) m_previousURL = m_frame.document()-&gt;url(); const URL&amp; newURL = loader-&gt;request().url(); // Log main frame navigation types. if (m_frame.isMainFrame()) { if (auto* page = m_frame.page()) page-&gt;mainFrameLoadStarted(newURL, type);static_cast&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted); } policyChecker().setLoadType(type); bool isFormSubmission = formState; const String&amp; httpMethod = loader-&gt;request().httpMethod(); if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) { RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader; NavigationAction action { *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission }; oldDocumentLoader-&gt;setTriggeringAction(action); oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest()); policyChecker().stopCheck(); policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, oldDocumentLoader.get(), formState, [this] (const ResourceRequest&amp; request, FormState*, bool shouldContinue) { continueFragmentScrollAfterNavigationPolicy(request, shouldContinue); }); return; } if (Frame* parent = m_frame.tree().parent()) loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding()); policyChecker().stopCheck(); //把 DocumentLoader 赋给 m_policyDocumentLoader setPolicyDocumentLoader(loader); //将请求信息记在 loader.m_triggeringAction 中 if (loader-&gt;triggeringAction().isEmpty()) loader-&gt;setTriggeringAction({ *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission }); if (Element* ownerElement = m_frame.ownerElement()) { if (!m_stateMachine.committedFirstRealDocumentLoad() &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) { continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false, allowNavigationToInvalidURL); return; } } //使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求 policyChecker().checkNavigationPolicy(loader-&gt;request(), false /* didReceiveRedirectResponse */, loader, formState, [this, allowNavigationToInvalidURL] (const ResourceRequest&amp; request, FormState* formState, bool shouldContinue) { //shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。 continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL); });}//void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, bool shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL){ // If we loaded an alternate page to replace an unreachableURL, we&apos;ll get in here with a // nil policyDataSource because loading the alternate page will have passed // through this method already, nested; otherwise, policyDataSource should still be set. ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty()); bool isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false; bool urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid(); // Three reasons we can&apos;t continue: // 1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this // is the user responding Cancel to the form repost nag sheet. // 2) User responded Cancel to an alert popped up by the before unload event handler. // 3) The request&apos;s URL is invalid and navigation to invalid URLs is disallowed. bool canContinue = shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed; if (!canContinue) { // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we // need to report that the client redirect was cancelled. // FIXME: The client should be told about ignored non-quick redirects, too. if (m_quickRedirectComing) clientRedirectCancelledOrFinished(false); setPolicyDocumentLoader(nullptr); // If the navigation request came from the back/forward menu, and we punt on it, we have the // problem that we have optimistically moved the b/f cursor already, so move it back. For sanity, // we only do this when punting a navigation for the target frame or top-level frame. if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) { if (Page* page = m_frame.page()) { if (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem()) { page-&gt;backForward().setCurrentItem(resetItem); m_frame.loader().client().updateGlobalHistoryItemForPage(); } } } return; } FrameLoadType type = policyChecker().loadType(); // A new navigation is in progress, so don&apos;t clear the history&apos;s provisional item. stopAllLoaders(ShouldNotClearProvisionalItem); // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders() // might detach the current FrameLoader, in which case we should bail on this newly defunct load. if (!m_frame.page()) return; //把 DocumentLoader 赋值给 m_provisionalDocumentLoader setProvisionalDocumentLoader(m_policyDocumentLoader.get()); m_loadType = type; //设置 FrameLoader 状态为 Provisional setState(FrameStateProvisional); setPolicyDocumentLoader(nullptr); if (isBackForwardLoadType(type)) { auto&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient(); if (history().provisionalItem()-&gt;isInPageCache()) { diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes); loadProvisionalItemFromCachedPage(); return; } diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes); } if (!formState) { continueLoadAfterWillSubmitForm(); return; } m_client.dispatchWillSubmitForm(*formState, [this] (PolicyAction action) { policyChecker().continueLoadAfterWillSubmitForm(action); });} 接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。 WebKit 网络处理WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore/platform/network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。 ResourceHandle 的相关类 ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。 MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存 SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。 ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。 ResourceHandleClientResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class ResourceHandleClient {public: WEBCORE_EXPORT ResourceHandleClient(); WEBCORE_EXPORT virtual ~ResourceHandleClient(); WEBCORE_EXPORT virtual ResourceRequest willSendRequest(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;); virtual void didSendData(ResourceHandle*, unsigned long long /*bytesSent*/, unsigned long long /*totalBytesToBeSent*/) { } //收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功 virtual void didReceiveResponse(ResourceHandle*, ResourceResponse&amp;&amp;) { } //收到服务器端包含请求数据的响应包 virtual void didReceiveData(ResourceHandle*, const char*, unsigned, int /*encodedDataLength*/) { } WEBCORE_EXPORT virtual void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength); //接受过程结束 virtual void didFinishLoading(ResourceHandle*) { } //接受失败 virtual void didFail(ResourceHandle*, const ResourceError&amp;) { } virtual void wasBlocked(ResourceHandle*) { } virtual void cannotShowURL(ResourceHandle*) { } virtual bool usesAsyncCallbacks() { return false; } virtual bool loadingSynchronousXHR() { return false; } // Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready. WEBCORE_EXPORT virtual void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;); // Client will call ResourceHandle::continueDidReceiveResponse() when ready. WEBCORE_EXPORT virtual void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;);#if USE(PROTECTION_SPACE_AUTH_CALLBACK) // Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready. WEBCORE_EXPORT virtual void canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp;);#endif // Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.#if USE(CFURLCONNECTION) WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, CFCachedURLResponseRef);#elif PLATFORM(COCOA) WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse *);#endif#if USE(SOUP) virtual char* getOrCreateReadBuffer(size_t /*requestedLength*/, size_t&amp; /*actualLength*/) { return 0; }#endif virtual bool shouldUseCredentialStorage(ResourceHandle*) { return false; } virtual void didReceiveAuthenticationChallenge(ResourceHandle*, const AuthenticationChallenge&amp;) { }#if USE(PROTECTION_SPACE_AUTH_CALLBACK) virtual bool canAuthenticateAgainstProtectionSpace(ResourceHandle*, const ProtectionSpace&amp;) { return false; }#endif virtual void receivedCancellation(ResourceHandle*, const AuthenticationChallenge&amp;) { }#if PLATFORM(IOS) || USE(CFURLCONNECTION) virtual RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) { return nullptr; }#endif#if USE(CFURLCONNECTION) virtual CFCachedURLResponseRef willCacheResponse(ResourceHandle*, CFCachedURLResponseRef response) { return response; }#if PLATFORM(WIN) virtual bool shouldCacheResponse(ResourceHandle*, CFCachedURLResponseRef) { return true; }#endif // PLATFORM(WIN)#elif PLATFORM(COCOA) virtual NSCachedURLResponse *willCacheResponse(ResourceHandle*, NSCachedURLResponse *response) { return response; }#endif}; 与 ResourceHandleClient 相关的类如下 加载流程 MainResourceLoader 的加载顺序MainResourceLoader 加载的是 html 文本资源。 12345678910111213141516171819202122232425262728293031 c++MainResourceLoader::loadMainResourceLoader::loadNowMainResourceLoader::willSendRequestResourceLoader::willSendRequest //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。PolicyChecker::checkNavigationPolicy //检查 NavigationPolicy 可以过滤一些重复的请求ResourceHandle::create 开始发网络请求MainResourceLoader::didReceiveResponse //主资源收到第一个 HTTP 的响应回调，处理 HTTP headerPolicyChecker:: checkContentPolicy //进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求MainResourceLoader::continueAfterContentPolicy //看看 ContentPolicy 检查后是否有错误ResourceLoader::didReceiveResponse //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClientMainResourceLoader::didReceiveData //主资源开始接受 body 数据ResourceLoader::didReceiveData //基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClientMainResourceLoader::addDataDocumentLoader::receivedDataDocumentLoader::commitLoadFrameLoader::commitProvisionalLoad //从 provisional 状态到 Committed 状态FrameLoaderClientQt::committedLoadDocumentLoader::commitDataDocumentWriter::setEncodingDocumentWriter::addDataDocumentParser::appendByteDecodedDataDocumentParser::appendBytes //编码处理HTMLDocumentParser::append //解析 HTMLMainResourceLoader::didFinishLoadingFrameLoader::finishedLoadingDocumentLoader::finishedLoadingFrameLoader::finishedLoadingDocumentDocumentWriter::endDocument::finishParsingHTMLDocumentParser::finish 在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。 在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码： 12345678910111213141516171819 c++void ResourceLoader::addDataOrBuffer(const char* data, unsigned length, SharedBuffer* buffer, DataPayloadType dataPayloadType){ if (m_options.dataBufferingPolicy == DoNotBufferData) return; if (!m_resourceData || dataPayloadType == DataPayloadWholeResource) { if (buffer) m_resourceData = buffer; else m_resourceData = SharedBuffer::create(data, length); return; } if (buffer) m_resourceData-&gt;append(*buffer); else m_resourceData-&gt;append(data, length);} 接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里 12345678910111213141516171819202122 c++void DocumentLoader::commitLoad(const char* data, int length){ // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource // by starting a new load, so retain temporarily. RefPtr&lt;Frame&gt; protectedFrame(m_frame); Ref&lt;DocumentLoader&gt; protectedThis(*this); commitIfReady(); FrameLoader* frameLoader = DocumentLoader::frameLoader(); if (!frameLoader) return;#if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML) if (ArchiveFactory::isArchiveMimeType(response().mimeType())) return;#endif //FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态 frameLoader-&gt;client().committedLoad(this, data, length); if (isMultipartReplacingLoad()) frameLoader-&gt;client().didReplaceMultipartContent();} 随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 c++void DocumentWriter::begin(const URL&amp; urlReference, bool dispatch, Document* ownerDocument){ // We grab a local copy of the URL because it&apos;s easy for callers to supply // a URL that will be deallocated during the execution of this function. // For example, see &lt;https://bugs.webkit.org/show_bug.cgi?id=66360&gt;. URL url = urlReference; // Create a new document before clearing the frame, because it may need to // inherit an aliased security context. //创建了 Document 对象 Ref&lt;Document&gt; document = createDocument(url); // If the new document is for a Plugin but we&apos;re supposed to be sandboxed from Plugins, // then replace the document with one whose parser will ignore the incoming data (bug 39323) if (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins)) document = SinkDocument::create(m_frame, url); // FIXME: Do we need to consult the content security policy here about blocked plug-ins? bool shouldReuseDefaultView = m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url); if (shouldReuseDefaultView) document-&gt;takeDOMWindowFrom(m_frame-&gt;document()); else document-&gt;createDOMWindow(); // Per &lt;https://www.w3.org/TR/upgrade-insecure-requests/&gt;, we need to retain an ongoing set of upgraded // requests in new navigation contexts. Although this information is present when we construct the // Document object, it is discard in the subsequent &apos;clear&apos; statements below. So, we must capture it // so we can restore it. HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade; if (auto* existingDocument = m_frame-&gt;document()) insecureNavigationRequestsToUpgrade = existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade(); m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView); clear(); // m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document. // Bail out if document has no view. if (!document-&gt;view()) return; if (!shouldReuseDefaultView) m_frame-&gt;script().updatePlatformScriptObjects(); m_frame-&gt;loader().setOutgoingReferrer(url); m_frame-&gt;setDocument(document.copyRef()); document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade)); if (m_decoder) document-&gt;setDecoder(m_decoder.get()); if (ownerDocument) { document-&gt;setCookieURL(ownerDocument-&gt;cookieURL()); document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy()); document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode()); } m_frame-&gt;loader().didBeginDocument(dispatch); document-&gt;implicitOpen(); // We grab a reference to the parser so that we&apos;ll always send data to the // original parser, even if the document acquires a new parser (e.g., via // document.open). m_parser = document-&gt;parser(); if (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView()) m_frame-&gt;view()-&gt;setContentsSize(IntSize()); m_state = StartedWritingState;} Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下： 1234567891011121314 c++void DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, const char* data, size_t length){ if (!length) return; //解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。 String decoded = writer.createDecoderIfNeeded()-&gt;decode(data, length); if (decoded.isEmpty()) return; //解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步 writer.reportDataReceived(); append(decoded.releaseImpl());} 数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。 下面看看解码的流程：decoder 的类图如下: SubResourceLoader 的加载顺序SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下： 会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243 c++RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface){ auto&amp; localName = token.name(); // FIXME: This can&apos;t use HTMLConstructionSite::createElement because we // have to pass the current form element. We should rework form association // to occur after construction to allow better code sharing here. // https://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token Document&amp; ownerDocument = ownerDocumentForCurrentNode(); bool insideTemplateElement = !ownerDocument.frame(); //将 tagName 和节点构造创建成 HTMLImageElement RefPtr&lt;Element&gt; element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true); if (UNLIKELY(!element)) { auto* window = ownerDocument.domWindow(); if (customElementInterface &amp;&amp; window) { auto* registry = window-&gt;customElementRegistry(); if (UNLIKELY(registry)) { if (auto* elementInterface = registry-&gt;findInterface(localName)) { *customElementInterface = elementInterface; return nullptr; } } } QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI); if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) { element = HTMLElement::create(qualifiedName, ownerDocument); element-&gt;setIsCustomElementUpgradeCandidate(); } else element = HTMLUnknownElement::create(qualifiedName, ownerDocument); } ASSERT(element); // FIXME: This is a hack to connect images to pictures before the image has // been inserted into the document. It can be removed once asynchronous image // loading is working. if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element)) downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode())); //设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载 setAttributes(*element, token, m_parserContentPolicy); ASSERT(element-&gt;isHTMLElement()); return element;} 在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下： 1234567891011121314 c++void HTMLImageElement::selectImageSource(){ // First look for the best fit source from our &lt;picture&gt; parent if we have one. ImageCandidate candidate = bestFitSourceFromPictureElement(); if (candidate.isEmpty()) { // If we don&apos;t have a &lt;picture&gt; or didn&apos;t find a source, then we use our own attributes. auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length(); candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize); } setBestFitURLAndDPRFromImageCandidate(candidate); //updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源 m_imageLoader.updateFromElementIgnoringPreviousError();} SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图： ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理 Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。 CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。 MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap &lt;String,CachedResource&gt; m_resources; 在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源： 12enum RevalidationPolicy { Use, Revalidate, Reload, Load }; RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const; 可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 c++RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);switch (policy) {case Reload: memoryCache.remove(*resource); FALLTHROUGH;case Load: if (resource) logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey()); resource = loadResource(type, WTFMove(request)); break;case Revalidate: if (resource) logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey()); resource = revalidateResource(WTFMove(request), *resource); break;case Use: ASSERT(resource); if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) { resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request)); if (resource-&gt;status() != CachedResource::Status::Cached) policy = Load; } else { ResourceError error; if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error)) return makeUnexpected(WTFMove(error)); logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey()); loadTiming.setResponseEnd(MonotonicTime::now()); memoryCache.resourceAccessed(*resource); if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) { auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin()); if (initiatorContext == InitiatorContext::Worker) { ASSERT(is&lt;CachedRawResource&gt;(resource.get())); downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming)); } else { ASSERT(initiatorContext == InitiatorContext::Document); m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame()); m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming)); } } if (forPreload == ForPreload::No) resource-&gt;setLoadPriority(request.priority()); } break;} 在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。 CachedResource 加载CachedResource 实现了 RFC2616 https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示： 会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。 在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041 c++ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type){ switch (type) { case CachedResource::MainResource: return ResourceLoadPriority::VeryHigh; case CachedResource::CSSStyleSheet: case CachedResource::Script: return ResourceLoadPriority::High;#if ENABLE(SVG_FONTS) case CachedResource::SVGFontResource:#endif case CachedResource::MediaResource: case CachedResource::FontResource: case CachedResource::RawResource: case CachedResource::Icon: return ResourceLoadPriority::Medium; case CachedResource::ImageResource: return ResourceLoadPriority::Low;#if ENABLE(XSLT) case CachedResource::XSLStyleSheet: return ResourceLoadPriority::High;#endif case CachedResource::SVGDocumentResource: return ResourceLoadPriority::Low; case CachedResource::Beacon: return ResourceLoadPriority::VeryLow;#if ENABLE(LINK_PREFETCH) case CachedResource::LinkPrefetch: return ResourceLoadPriority::VeryLow; case CachedResource::LinkSubresource: return ResourceLoadPriority::VeryLow;#endif#if ENABLE(VIDEO_TRACK) case CachedResource::TextTrackResource: return ResourceLoadPriority::Low;#endif } ASSERT_NOT_REACHED(); return ResourceLoadPriority::Low;} 整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 c++void WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader){ ASSERT(resourceLoader);#if PLATFORM(IOS) // If there&apos;s a web archive resource for this URL, we don&apos;t need to schedule the load since it will never touch the network. if (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) { resourceLoader-&gt;startLoading(); return; }#else if (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) { resourceLoader-&gt;start(); return; }#endif//根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里#if PLATFORM(IOS) HostInformation* host = hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);#else HostInformation* host = hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);#endif ResourceLoadPriority priority = resourceLoader-&gt;request().priority(); bool hadRequests = host-&gt;hasRequests(); //把优先级存放到 host 的 m_requestsPending 属性里 host-&gt;schedule(resourceLoader, priority);#if PLATFORM(COCOA) || USE(CFURLCONNECTION) if (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) { // Serve all requests at once to keep the pipeline full at the network layer. // FIXME: Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms? servePendingRequests(host, ResourceLoadPriority::VeryLow); return; }#endif//这里就是如何根据优先级来进行安排的#if PLATFORM(IOS) if ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) { //重要资源立刻进行 servePendingRequests(host, priority); return; }#else if (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) { //重要资源立刻进行 servePendingRequests(host, priority); return; }#endif // Handle asynchronously so early low priority requests don&apos;t // get scheduled before later high priority ones. //不重要的就延迟进行，然后根据优先级，由高到低依次加载 scheduleServePendingRequests();} servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下： 123456789101112131415161718192021222324252627282930313233 c++void WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority){ auto priority = ResourceLoadPriority::Highest; while (true) { auto&amp; requestsPending = host-&gt;requestsPending(priority); while (!requestsPending.isEmpty()) { RefPtr&lt;ResourceLoader&gt; resourceLoader = requestsPending.first(); // For named hosts - which are only http(s) hosts - we should always enforce the connection limit. // For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn&apos;t done parsing // and we don&apos;t know all stylesheets yet. Document* document = resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : 0; bool shouldLimitRequests = !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded())); if (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority)) return; requestsPending.removeFirst(); host-&gt;addLoadInProgress(resourceLoader.get());#if PLATFORM(IOS) if (!IOSApplication::isWebProcess()) { resourceLoader-&gt;startLoading(); return; }#endif //在这个函数里创建了 ResourceHandle resourceLoader-&gt;start(); } if (priority == minimumPriority) return; --priority; }} 加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下： 123456789101112131415161718192021222324 c++void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType){ ASSERT(m_resource); if (m_resource-&gt;response().httpStatusCode() &gt;= 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors()) return; ASSERT(!m_resource-&gt;resourceToRevalidate()); ASSERT(!m_resource-&gt;errorOccurred()); ASSERT(m_state == Initialized); // Reference the object in this method since the additional processing can do // anything including removing the last reference to this object; one example of this is 3266216. Ref&lt;SubresourceLoader&gt; protectedThis(*this); //ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里 ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType); if (!m_loadingMultipartContent) { if (auto* resourceData = this-&gt;resourceData()) m_resource-&gt;addDataBuffer(*resourceData); else m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length); }} 以 image 为例如图所示： 举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。 CacheImage 的加载过程如下图： 具体调用方法顺序如下： 1234567891011121314151617181920212223242526272829303132 c++HTMLImageElement::create //解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象ImageLoader::updateFromElementIgnoringPreviousError //解析到 img 的 href 属性ImageLoader::updateFromElementCachedResourceLoader::requestImageCachedResourceLoader::requestResource //判断是否从缓存读取，还是网络获取CachedResourceLoader::loadResource //创建不同类型的 CachedResource，这里是 CachedImageMemoryCache::add //创建对应的 cache 项目CachedImage::loadCachedResource::loadCachedResourceLoader::loadCachedResourceRequest::loadResourceLoaderScheduler::scheduleSubresourceLoadSubresourceLoader::createResourceLoadScheduler::requestTimerFiredResourceLoader::startResourceHandle::createResourceLoader::didReceiveResponse //收到 HTTP Header 的 responseSubresourceLoader::didiReceiveResponseCachedResourceRequest::didReceiveResponse //处理响应ResourceLoader::didReceiveResponseResourceLoader::didReceiveData //收到 body 数据SubresourceLoader::didReceiveDataResourceLoader::didReceiveDataResourceLoader::addDataCachedResourceRequest::didReceiveDataResourceLoader::didFinishLoading //数据读取完成SubresourceLoader::didFinishLoadingCachedResourceRequest::didFinishLoadingCachedResource::finishCachedResourceLoader::loadDoneCachedImage::data //创建 Image 对象，进行解码 可以用下图概括下：一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。 资源的生命周期资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。 WebKit 的 CacheWebKit 主要有三种 Cache。 Page Cache对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下： 12345678 c++if (!m_frame.tree().parent() &amp;&amp; history().currentItem()) { // Check to see if we need to cache the page we are navigating away from into the back/forward cache. // We are doing this here because we know for sure that a new page is about to be loaded. PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page()); WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();} PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243 c++void PageCache::addIfCacheable(HistoryItem&amp; item, Page* page){ if (item.isInPageCache()) return; if (!page || !canCache(*page)) return; ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), &quot;Utility pages such as SVGImage pages should never go into PageCache&quot;); setPageCacheState(*page, Document::AboutToEnterPageCache); // Focus the main frame, defocusing a focused subframe (if we have one). We do this here, // before the page enters the page cache, while we still can dispatch DOM blur/focus events. if (page-&gt;focusController().focusedFrame()) page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame()); // Fire the pagehide event in all frames. firePageHideEventRecursively(page-&gt;mainFrame()); // Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers // could have altered the page in a way that could prevent caching. if (!canCache(*page)) { setPageCacheState(*page, Document::NotInPageCache); return; } destroyRenderTree(page-&gt;mainFrame()); setPageCacheState(*page, Document::InPageCache); // Make sure we no longer fire any JS events past this point. NoEventDispatchAssertion assertNoEventDispatch; //创建一个新的 CachedPage 存放到 HistoryItem 里 item.m_cachedPage = std::make_unique&lt;CachedPage&gt;(*page); item.m_pruningReason = PruningReason::None; //将 HistoryItem 添加到 m_items 列表中 m_items.add(&amp;item); //检查是否有超过回收的限制，进行资源回收 prune(PruningReason::ReachedMaxSize);} 当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。 Memory Cache使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：Memory Cache 有三个比较重要的属性。 m_resources：类型是 HashMap，key 是 url，值是 CacheResource。 m_allResources：采用的是 LRU 算法，类型是 Vector&lt;LRUList,32&gt; 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。 m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。 Disk Cache根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。 HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token解析成 HTML Token 的算法初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。 在 Tag open state 状态时如果碰到 / 字符那么就会创建 End tag token，同时状态变成 Tag name state。 在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。 HTMLToken 的所有类型定义在 HTMLToken.h 里 12345678910 c++enum Type { Uninitialized, //默认类型 DOCTYPE, //文档类型 StartTag, //起始标签 EndTag, //结束标签 Comment, //注释 Character, //元素内容 EndOfFile, //文档结束}; 接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。 1234567891011121314151617 c++private: Type m_type; //那种类型 DataVector m_data; //根据类型来，不同类型内容不一样 UChar m_data8BitCheck; // For StartTag and EndTag bool m_selfClosing; //是否是自封闭 AttributeList m_attributes; //属性列表 Attribute* m_currentAttribute; //当前属性 // For DOCTYPE std::unique_ptr&lt;DoctypeData&gt; m_doctypeData; unsigned m_attributeBaseOffset { 0 }; // Changes across document.write() boundaries.}; 在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型 HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：https://dev.w3.org/html5/spec-preview/tokenization.html 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 c++//HTML 有限状态机的状态非空集合enum State { DataState, //初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character CharacterReferenceInDataState, RCDATAState, CharacterReferenceInRCDATAState, RAWTEXTState, ScriptDataState, PLAINTEXTState, TagOpenState, //碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里 EndTagOpenState, //TagOpenState 状态碰见 / 进入。HTMLToken 的 type 为 endTag TagNameState, //在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag RCDATALessThanSignState, RCDATAEndTagOpenState, RCDATAEndTagNameState, RAWTEXTLessThanSignState, RAWTEXTEndTagOpenState, RAWTEXTEndTagNameState, ScriptDataLessThanSignState, ScriptDataEndTagOpenState, ScriptDataEndTagNameState, ScriptDataEscapeStartState, ScriptDataEscapeStartDashState, ScriptDataEscapedState, ScriptDataEscapedDashState, ScriptDataEscapedDashDashState, ScriptDataEscapedLessThanSignState, ScriptDataEscapedEndTagOpenState, ScriptDataEscapedEndTagNameState, ScriptDataDoubleEscapeStartState, ScriptDataDoubleEscapedState, ScriptDataDoubleEscapedDashState, ScriptDataDoubleEscapedDashDashState, ScriptDataDoubleEscapedLessThanSignState, ScriptDataDoubleEscapeEndState, BeforeAttributeNameState, //TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname AttributeNameState, //BeforeAttributeNameState 碰见字母进入 AfterAttributeNameState, BeforeAttributeValueState, //AttributeNameState 状态碰到 = 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的 AttributeValueDoubleQuotedState, //BeforeAttributeValueState 碰到 &quot; 符号 AttributeValueSingleQuotedState, //BeforeAttributeValueState 碰到 &apos; 符号 AttributeValueUnquotedState, CharacterReferenceInAttributeValueState, AfterAttributeValueQuotedState, // 再次碰到 &quot; 或 &apos; 符号。HTMLToken 记录属性的值 SelfClosingStartTagState, BogusCommentState, ContinueBogusCommentState, // Not in the HTML spec, used internally to track whether we started the bogus comment token. MarkupDeclarationOpenState, //TagOpenState 后遇到! 比如&lt;! //解析comment CommentStartState, //MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT CommentStartDashState, CommentState, //CommentStartState 碰到字母进入这个状态 CommentEndDashState, //在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容 CommentEndState, //在 CommentEndDashState 状态碰见 - 进入 CommentEndBangState, //解析 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 这种标签 DOCTYPEState, //匹配到 DOCTYPE，&lt;!DOCTYPE BeforeDOCTYPENameState, //DOCTYPE 状态后遇到空格 DOCTYPENameState, //BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html AfterDOCTYPENameState, //DOCTYPENameState 遇到空格 &lt;!DOCTYPE html AfterDOCTYPEPublicKeywordState, //AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC BeforeDOCTYPEPublicIdentifierState, //AfterDOCTYPEPublicKeywordState 状态后碰到空格 DOCTYPEPublicIdentifierDoubleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &quot; 进入 DOCTYPEPublicIdentifierSingleQuotedState, //BeforeDOCTYPEPublicIdentifierState 状态碰到 &apos; 进入 AfterDOCTYPEPublicIdentifierState, //再次遇到 &quot; 或 &apos; 。可将 HTMLToken 的 m_publicIdentifier 确定 BetweenDOCTYPEPublicAndSystemIdentifiersState, AfterDOCTYPESystemKeywordState, BeforeDOCTYPESystemIdentifierState, DOCTYPESystemIdentifierDoubleQuotedState, DOCTYPESystemIdentifierSingleQuotedState, AfterDOCTYPESystemIdentifierState, BogusDOCTYPEState, CDATASectionState, // These CDATA states are not in the HTML5 spec, but we use them internally. CDATASectionRightSquareBracketState, CDATASectionDoubleRightSquareBracketState,}; 词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程： HTML 语法解析HTML 的语法定义HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：https://www.w3.org/TR/html4/strict.dtd 相关类关系图 Document 和 DocumentParser 相互引用 HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。 HTMLInputStream：解码后的字符流的保存，作为缓冲区。 HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。 HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。 HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用 HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。 HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。 解析过程 DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。 HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。 把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。 然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。 Element 属性设置是通过 Element::parserSetAttributes 来设置的 123456789101112131415161718192021 c++void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector){ ASSERT(!isConnected()); ASSERT(!parentNode()); ASSERT(!m_elementData); if (!attributeVector.isEmpty()) { if (document().sharedObjectPool()) m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector); else m_elementData = ShareableElementData::createWithAttributes(attributeVector); } parserDidSetAttributes(); // Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData. for (const auto&amp; attribute : attributeVector) attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);} m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片 资源加载HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。 构建 DOM Tree构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）相关类流程图： 前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树 DOM 标准规范Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：下面对各个 level 进行说明DOM level 1 Core：底层接口，接口支持 XML 等任何结构化文档。 HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。 DOM level 2 Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。 HTML：允许动态访问修改文档。 Views：文档的各种视图。 Events：鼠标事件等。 Style：可以修改 HTML 样式的一个属性。 Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。 节点DOM level 3 Core：加入了新接口 adoptNode 和 textContent。 Load and Save：加载 XML 转成 DOM 表示的文档结构。 Validation：验证文档有效性。 Events：加入键盘支持。 XPath：一种简单直观检索 DOM 节点的方式。 DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore/dom/Document.idl 文件里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171interface Document : Node { readonly attribute DOMImplementation implementation; // FIXME: Should be [SameObject]. [ImplementedAs=urlForBindings] readonly attribute USVString URL; [ImplementedAs=urlForBindings] readonly attribute USVString documentURI; readonly attribute USVString origin; readonly attribute DOMString compatMode; [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString characterSet; [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString charset; // Historical alias of .characterSet, [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; // Historical alias of .characterSet. readonly attribute DOMString contentType; readonly attribute DocumentType? doctype; [DOMJIT=Getter] readonly attribute Element? documentElement; HTMLCollection getElementsByTagName(DOMString qualifiedName); HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName); HTMLCollection getElementsByClassName(DOMString classNames); [NewObject, MayThrowException, ImplementedAs=createElementForBindings] Element createElement(DOMString localName); // FIXME: missing options parameter. [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); // FIXME: missing options parameter. [NewObject] DocumentFragment createDocumentFragment(); [NewObject] Text createTextNode(DOMString data); [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data); [NewObject] Comment createComment(DOMString data); [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data); [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep = false); [CEReactions, MayThrowException] Node adoptNode(Node node); [NewObject, MayThrowException] Attr createAttribute(DOMString localName); [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName); [MayThrowException, NewObject] Event createEvent(DOMString type); [NewObject] Range createRange(); // NodeFilter.SHOW_ALL = 0xFFFFFFFF. [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null); [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null); // Extensions from HTML specification (https://html.spec.whatwg.org/#the-document-object). [PutForwards=href, Unforgeable] readonly attribute Location? location; [SetterMayThrowException] attribute USVString domain; readonly attribute USVString referrer; [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie; readonly attribute DOMString lastModified; readonly attribute DocumentReadyState readyState; // DOM tree accessors. [CEReactions] attribute DOMString title; [CEReactions] attribute DOMString dir; [CEReactions, DOMJIT=Getter, ImplementedAs=bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body; readonly attribute HTMLHeadElement? head; readonly attribute HTMLCollection images; // Should be [SameObject]. readonly attribute HTMLCollection embeds; // Should be [SameObject]. readonly attribute HTMLCollection plugins; // Should be [SameObject]. readonly attribute HTMLCollection links; // Should be [SameObject]. readonly attribute HTMLCollection forms; // Should be [SameObject]. readonly attribute HTMLCollection scripts; // Should be [SameObject]. NodeList getElementsByName([AtomicString] DOMString elementName); readonly attribute HTMLScriptElement? currentScript; // FIXME: Should return a HTMLOrSVGScriptElement. // dynamic markup insertion // FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure // that the caller document matches those semantics. It is possible we should replace it with // the existing &apos;incumbent document&apos; concept. [CEReactions, CallWith=ResponsibleDocument, ImplementedAs=openForBindings, MayThrowException] Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;); [CallWith=ActiveWindow&amp;FirstWindow, ImplementedAs=openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features); [CEReactions, ImplementedAs=closeForBindings, MayThrowException] void close(); [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void write(DOMString... text); [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void writeln(DOMString... text); // User interaction. readonly attribute DOMWindow? defaultView; boolean hasFocus(); [CEReactions] attribute DOMString designMode; [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString? value = null); // FIXME: value should not be nullable. boolean queryCommandEnabled(DOMString commandId); boolean queryCommandIndeterm(DOMString commandId); boolean queryCommandState(DOMString commandId); boolean queryCommandSupported(DOMString commandId); DOMString queryCommandValue(DOMString commandId); // Special event handler IDL attributes that only apply to Document objects. [LenientThis] attribute EventHandler onreadystatechange; // Extensions from the CSSOM specification (https://drafts.csswg.org/cssom/#extensions-to-the-document-interface). // FIXME: Should likely be moved to DocumentOrShadowRoot. readonly attribute StyleSheetList styleSheets; // FIXME: Should be [SameObject]. // Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-document-interface). readonly attribute Element? scrollingElement; // Extensions from Selection API (https://www.w3.org/TR/selection-api/#extensions-to-document-interface). // FIXME: Should likely be moved to DocumentOrShadowRoot. DOMSelection? getSelection(); // XPath extensions (https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator). [MayThrowException] XPathExpression createExpression(optional DOMString expression = &quot;undefined&quot;, optional XPathNSResolver? resolver); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong. XPathNSResolver createNSResolver(Node? nodeResolver); [MayThrowException] XPathResult evaluate(optional DOMString expression = &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type = 0, optional XPathResult? inResult); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong. // Extensions from FullScreen API (https://fullscreen.spec.whatwg.org/#api). // FIXME: Should probably be unprefixed. [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled; [Conditional=FULLSCREEN_API, ImplementedAs=webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement; [Conditional=FULLSCREEN_API] void webkitExitFullscreen(); [Conditional=FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; // Mozilla version. [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; // Mozilla version. [Conditional=FULLSCREEN_API, ImplementedAs=webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; // Mozilla version. [Conditional=FULLSCREEN_API] void webkitCancelFullScreen(); // Mozilla version. [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange; [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror; // Extensions from Pointer Lock API (https://www.w3.org/TR/pointerlock/#extensions-to-the-document-interface). [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockchange; // FIXME: Should be enumerable. [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockerror; // FIXME: Should be enumerable. [Conditional=POINTER_LOCK] void exitPointerLock(); // Extensions from CSS Font Loading API (https://drafts.csswg.org/css-font-loading/#font-face-source). // FIXME: Should be in a separate FontFaceSource interface. readonly attribute FontFaceSet fonts; // Extensions from Page visibility API (https://www.w3.org/TR/page-visibility/#sec-document-interface). readonly attribute boolean hidden; readonly attribute VisibilityState visibilityState; attribute EventHandler onvisibilitychange; // FIXME: Those were dropped from the CSSOM specification. readonly attribute DOMString? preferredStylesheetSet; attribute DOMString? selectedStylesheetSet; // FIXME: Those have been dropped from the DOM specification. readonly attribute DOMString? xmlEncoding; [SetterMayThrowException] attribute DOMString? xmlVersion; attribute boolean xmlStandalone; // FIXME: Blink has already dropped this (https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/s3ezjTuC8ig). CSSStyleDeclaration getOverrideStyle(optional Element? element = null, optional DOMString pseudoElement = &quot;undefined&quot;); // FIXME: Should be moved to GlobalEventHandlers (https://w3c.github.io/selection-api/#extensions-to-globaleventhandlers). [NotEnumerable] attribute EventHandler onselectstart; // FIXME: Should be enumerable. [NotEnumerable] attribute EventHandler onselectionchange; // FIXME: Should be enumerable. // Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet. Range caretRangeFromPoint(optional long x = 0, optional long y = 0); // FIXME: This is not standard and has been dropped from Blink already. RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height); // Non standard (https://developer.apple.com/reference/webkitjs/document/1633863-webkitgetnamedflows). [Conditional=CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows(); // Obsolete features from https://html.spec.whatwg.org/multipage/obsolete.html [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor; [CEReactions, ImplementedAs=linkColorForBindings] attribute [TreatNullAs=EmptyString] DOMString linkColor; [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor; [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor; [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor; readonly attribute HTMLCollection anchors; /* [SameObject] */ readonly attribute HTMLCollection applets; /* [SameObject] */ void clear(); void captureEvents(); void releaseEvents(); [Replaceable] readonly attribute HTMLAllCollection all; /* [SameObject] */}; DOM Tree Token 的构造算法这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：https://www.w3.org/TR/html5/syntax.html#html-parser 当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。 具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。 接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。 再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。 关键类构建 DOM 的几个关键的类 HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。 HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。 HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。 HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。 构建 DOM 树的过程如下图： 举个例子： 12345678&lt;html&gt; &lt;body&gt; &lt;p&gt; Hello World &lt;/p&gt; &lt;div&gt; &lt;img src=\"example.png\"/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 转成 DOM Tree 如下： 加载通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url 1234FetchRequest fetchRequest(m_request, FetchInitiatorTypeNames::document, mainResourceLoadOptions); m_mainResource = RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData); DocumentLoader 的 commitData 会去处理 dataReceived 的数据块 1234567891011void DocumentLoader::commitData(const char* bytes, size_t length) { ensureWriter(m_response.mimeType()); //会初始化 HTMLDocumentParser 实例化 document 对象 if (length) m_dataReceived = true; m_writer-&gt;addData(bytes, length); //给 Parser 解析，这里的bytes就是返回来的 html 文本代码}//ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次void DocumentLoader::ensureWriter(const AtomicString&amp; mimeType, const KURL&amp; overridingURL) { if (m_writer) return;} DOM TreeDOM Tree 已经被 W3 标准化了 Document Object Model (DOM) Technical Reports 在 DOM Level 3 里 IDL 的定义在 IDL Definitions Node 节点Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图： 在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：https://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。 需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements DOM Node 的数据结构 HTMLElement由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下： 构建 DOM Tree从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore/html/parser/HTMLTreeBuilder.cpp 文件里。constructtreefromToken 12345678910111213141516171819202122232425262728293031void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token){ switch (token.type()) { case HTMLToken::Uninitialized: ASSERT_NOT_REACHED(); break; case HTMLToken::DOCTYPE: m_shouldSkipLeadingNewline = false; processDoctypeToken(WTFMove(token)); break; case HTMLToken::StartTag: m_shouldSkipLeadingNewline = false; processStartTag(WTFMove(token)); break; case HTMLToken::EndTag: m_shouldSkipLeadingNewline = false; processEndTag(WTFMove(token)); break; case HTMLToken::Comment: m_shouldSkipLeadingNewline = false; processComment(WTFMove(token)); return; case HTMLToken::Character: processCharacter(WTFMove(token)); break; case HTMLToken::EndOfFile: m_shouldSkipLeadingNewline = false; processEndOfFile(WTFMove(token)); break; }} 将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。 123456789101112131415161718192021222324252627282930313233343536373839void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) { HTMLHtmlElement* element = HTMLHtmlElement::create(*m_document); attachLater(m_attachmentRoot, element); m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); //push 到 HTMLStackItem 栈里 executeQueuedTasks();}//通过 attachLater 创建 taskvoid HTMLConstructionSite::attachLater(ContainerNode* parent, Node* child, bool selfClosing) { HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert); task.parent = parent; task.child = child; task.selfClosing = selfClosing; //判断是否到达最深，512是最深 if (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp; task.parent-&gt;parentNode()) task.parent = task.parent-&gt;parentNode(); queueTask(task);}//executeQueued 添加子节点void ContainerNode::parserAppendChild(Node* newChild) { if (!checkParserAcceptChild(*newChild)) return; AdoptAndAppendChild()(*this, *newChild, nullptr); } notifyNodeInserted(*newChild, ChildrenChangeSourceParser);}//添加前会先检查是否支持子元素void ContainerNode::appendChildCommon(Node&amp; child) { child.setParentOrShadowHostNode(this); if (m_lastChild) { child.setPreviousSibling(m_lastChild); m_lastChild-&gt;setNextSibling(&amp;child); } else { setFirstChild(&amp;child); } setLastChild(&amp;child);} 闭标签会把元素 pop 出来 1m_tree.openElements()-&gt;popUntilPopped(token-&gt;name()); 对错误的处理parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子 问题一些网站会用 替代 ，处理的代码如下： 1234if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) { reportError(MalformedBRError); t-&gt;beginTag = true;} stray tablestray table 是一个 table 包含了一个不在 table cell 的 table。 123456&lt;table&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; WebKit 的处理 12if (m_inStrayTableContent &amp;&amp; localName == tableTag) popBlock(tableTag); 这样会处理成两个同级 table 123456&lt;table&gt; &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 嵌套 form将一个 form 放到另一个 form 里。那么第二个 form 会被忽略 123if (!m_currentFormElement) { m_currentFormElement = new HTMLFormElement(formTag, m_document);} 过深的层级同一个类型里只允许嵌套 20 个 tag。 12345678bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName){unsigned i = 0;for (HTMLStackElem* curr = m_blockStack; i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName; curr = curr-&gt;next, i++) { }return i != cMaxRedundantTagDepth;} html 或 body 的 end tags 缺失这些都会在 end() 是调用 12if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag ) return; CSSCSS 语法简介所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。 CSS declarations在这里可以找到 CSS 的不同的属性。 CSS declaration blocks使用大括号包起来。 CSS selectors and rules在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。 selector 可以分为以下类别 Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。 Attribute selectors：属性选择器，通过属性匹配。 Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。 Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^=http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。 Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。 Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。 Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种 [attr]：不论值是什么选择所有 attr 属性的元素。 [attr=val]：按照 attr 属性的值为 val 的所有元素。 [attr~=val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。 还有 Substring value attribute selector 这样的伪正则选择器： [attr|=val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。 [attr^=val]：匹配选择以 val 开头的元素。 [attr$=val]：匹配选择以 val 结尾的元素。 [attr*=val]：匹配选择包含 val 的元素。 Combinators 组合器有以下几种 A,B： 匹配 A B 的任意元素。 A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。 A &gt; B：B 是 A 的直接子节点。 A + B：B 是 A 的兄弟节点。 A ~ B：B 是 A 兄弟节点中的任意一个。 CSS statementsCSS rule 只是 CSS statements 的一种。其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。 @charset：元数据 @import：元数据 @media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。 @supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。 @document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。 @font-face：描述性信息 比如 1@import &apos;starming.css&apos;; 表示向当前的 CSS 导入了 starming.css 文件。再举个例子： 123456@media (min-width: 801px) { body { margin:0 auto; width:800px; }} 这个表示页面宽度超过801像素时才会运用 @-规则里的内容。 Shorthand有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。比如 1maring: 20px 10px 10px 20px; 等效于 1234margin-top: 20px;margin-right: 10px;margin-bottom: 10px;margin-left: 20px; 再比如 background 属性 1background: black url(starming-bg.png) 20px 20px repeat-x fixed; 和下面的属性设置等效 12345background-color: black;background-image: url(starming-bg.png);background-position: 20px 20px;background-repeat: repeat-x;background-scroll: fixed; Value and unit absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1/72 of an inch) 点，picas (12 points.) 十二点活字。 相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1/100 和视图高度的 1/100，但是支持没有 rem 那么好。 无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。 百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。 颜色：有165个不同关键字可用，具体见 https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle 透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。 函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’); 验证 CSS 语法正确性可以通过 w3c 提供的服务 https://jigsaw.w3.org/css-validator/ 来验证，w3c 还提供了 html 的验证服务 https://validator.w3.org/#validate_by_uri CSS BNFCSS 语法 BNF 123456789101112131415161718192021222324ruleset : selector [ &apos;,&apos; S* selector ]* &apos;{&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;}&apos; S* ;selector : simple_selector [ combinator selector | S+ [ combinator selector ] ] ;simple_selector : element_name [ HASH | class | attrib | pseudo ]* | [ HASH | class | attrib | pseudo ]+ ;class : &apos;.&apos; IDENT ;element_name : IDENT | &apos;*&apos; ;attrib : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S* [ IDENT | STRING ] S* ] &apos;]&apos; ;pseudo : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ] ; WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。 CSS 主要类与关系上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。 StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。 CSS 文档结构的类图如下： StyleRuleBase 类的继承关系RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系我们来看看这些子类类型都是对应 CSS 里的什么 StyleRule：常用的都是这个类型 StyleRuleImport：对应的是 @import StyleRuleMedia：对应的是 @media StyleRuleFontFace：对应的 @font-face StyleRulePage：对应的 @page StyleRuleKeyFrames：对应的 @-webkit-key-frames StyleRuleRegion：分区域排版 StyleRule 类的结构 解析 CSSWebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图： 字符串转 tokens 将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。定义 matchType 1234567891011121314151617enum MatchType { Unknown, Tag, //比如 div Id, // #id Class, // .class PseudoClass, // :nth-child(2) PseudoElement, // ::first-line PagePseudoClass, // AttributeExact, // E[attr=&quot;value&quot;] AttributeSet, // E[attr] AttributeHyphen, // E[attr|=&quot;value&quot;] AttributeList, // E[attr~=&quot;value&quot;] AttributeContain, // E[attr*=&quot;value&quot;] AttributeBegin, // E[attr^=&quot;value&quot;] AttributeEnd, // E[attr$=&quot;value&quot;] FirstAttributeSelectorMatch = AttributeExact,}; 定义 selectors 的 Relation 类型 123456789101112enum RelationType { SubSelector, // No combinator Descendant, // &quot;Space&quot; combinator Child, // &gt; combinator DirectAdjacent, // + combinator IndirectAdjacent, // ~ combinator // Special cases for shadow DOM related selectors. ShadowPiercingDescendant, // &gt;&gt;&gt; combinator ShadowDeep, // /deep/ combinator ShadowPseudo, // ::shadow pseudo element ShadowSlot // ::slotted() pseudo element}; CSS 的属性是 id 来标识的 12345678enum CSSPropertyID { CSSPropertyColor = 15, CSSPropertyWidth = 316, CSSPropertyMarginLeft = 145, CSSPropertyMarginRight = 146, CSSPropertyMarginTop = 147, CSSPropertyMarkerEnd = 148,} 默认样式，Blink ua全部 CSS 样式：https://yincheng.site/html/chrome-ua-css.html 。w3c 的默认样式是：https://www.w3.org/TR/CSS2/sample.html 接着会生成 hash map，分成四个类型 1234CompactRuleMap m_idRules; //idCompactRuleMap m_classRules; //classCompactRuleMap m_tagRules; //标签CompactRuleMap m_shadowPseudoElementRules; //伪类选择器 CSS 解析完会触发 layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。 layout 会更新递归所有 DOM 元素 123456void ContainerNode::attachLayoutTree(const AttachContext&amp; context) { for (Node* child = firstChild(); child; child = child-&gt;nextSibling()) { if (child-&gt;needsAttach()) child-&gt;attachLayoutTree(childrenContext); }} 然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector 1234567891011121314151617181920//idif (element.hasID()) collectMatchingRulesForList( matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()), cascadeOrder, matchRequest);//classif (element.isStyledElement() &amp;&amp; element.hasClass()) { for (size_t i = 0; i &lt; element.classNames().size(); ++i) collectMatchingRulesForList( matchRequest.ruleSet-&gt;classRules(element.classNames()[i]), cascadeOrder, matchRequest);}//伪类...//tag 和 selectorcollectMatchingRulesForList( matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()), cascadeOrder, matchRequest);//通配符... 可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。 在 classRules 里会进行检验 12345678910111213141516if (!checkOne(context, subResult)) return SelectorFailsLocally;if (context.selector-&gt;isLastInTagHistory()) { return SelectorMatches;}//checkOne 的实现switch (selector.match()) { case CSSSelector::Tag: return matchesTagName(element, selector.tagQName()); case CSSSelector::Class: return element.hasClass() &amp;&amp; element.classNames().contains(selector.value()); case CSSSelector::Id: return element.hasID() &amp;&amp; element.idForStyleResolution() == selector.value();} 如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。 1234567891011121314switch (relation) { case CSSSelector::Descendant: for (nextContext.element = parentElement(context); nextContext.element; nextContext.element = parentElement(nextContext)) { MatchStatus match = matchSelector(nextContext, result); if (match == SelectorMatches || match == SelectorFailsCompletely) return match; if (nextSelectorExceedsScope(nextContext)) return SelectorFailsCompletely; } return SelectorFailsCompletely; case CSSSelector::Child: //...} 可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。 CSS 规则匹配CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。 CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：匹配的流程图如下： 设置 style设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。 123style-&gt;inheritFrom(*state.parentStyle())matchUARules(collector);matchAuthorRules(*state.element(), collector); 在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下 12345for (const CSSSelector* selector = this; selector; selector = selector-&gt;tagHistory()) { temp = total + selector-&gt;specificityForOneSelector();}return total; 每个不同类型的 selector 的优先级如下 12345678910111213141516171819202122switch (m_match) { case Id: return 0x010000; case PseudoClass: return 0x000100; case Class: case PseudoElement: case AttributeExact: case AttributeSet: case AttributeList: case AttributeHyphen: case AttributeContain: case AttributeBegin: case AttributeEnd: return 0x000100; case Tag: return 0x000001; case Unknown: return 0; } return 0;} 可以看出 id 的优先级最大是 0x010000 = 65536，类，属性，伪类优先级是 0x000100 = 256，标签是 0x000001 = 1 举个优先级计算的例子 12345678/*优先级为257 = 265 + 1*/.text h1{ font-size: 8em;}/*优先级为65537 = 65536 + 1*/#my-text h1{ font-size: 16em;} 将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。 目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。 排序规则 123456789static inline bool compareRules(const MatchedRule&amp; matchedRule1, const MatchedRule&amp; matchedRule2) { unsigned specificity1 = matchedRule1.specificity(); unsigned specificity2 = matchedRule2.specificity(); if (specificity1 != specificity2) return specificity1 &lt; specificity2; return matchedRule1.position() &lt; matchedRule2.position();} 规则和优先级完后就开始设置元素的 style 了： 123456789applyMatchedPropertiesAndCustomPropertyAnimations( state, collector.matchedResult(), element);applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;( state, matchResult.allRules(), false, applyInheritedOnly, needsApplyPass); for (auto range : ImportantAuthorRanges(matchResult)) { applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;( state, range, true, applyInheritedOnly, needsApplyPass); } 最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下： CSS Object Model (CSSOM)CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。 W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore/page/DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下： 1234567891011121314151617181920212223242526272829303132// Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-window-interface).[NewObject] MediaQueryList matchMedia(CSSOMString query);[Replaceable] readonly attribute Screen screen; // FIXME: Should be [SameObject].// Browsing context (CSSOM-View).void moveTo(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.void moveBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.void resizeTo(optional unrestricted float width = NaN, optional unrestricted float height = NaN); // Parameters should be mandatory and of type long.void resizeBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.// Viewport (CSSOM-View).[Replaceable] readonly attribute long innerHeight;[Replaceable] readonly attribute long innerWidth;// Viewport scrolling (CSSOM-View).[Replaceable] readonly attribute double scrollX;[Replaceable, ImplementedAs=scrollX] readonly attribute double pageXOffset;[Replaceable] readonly attribute double scrollY;[Replaceable, ImplementedAs=scrollY] readonly attribute double pageYOffset;[ImplementedAs=scrollTo] void scroll(optional ScrollToOptions options);[ImplementedAs=scrollTo] void scroll(unrestricted double x, unrestricted double y);void scrollTo(optional ScrollToOptions options);void scrollTo(unrestricted double x, unrestricted double y);void scrollBy(optional ScrollToOptions option);void scrollBy(unrestricted double x, unrestricted double y);// Client (CSSOM-View).[Replaceable] readonly attribute long screenX;[Replaceable] readonly attribute long screenY;[Replaceable] readonly attribute long outerWidth;[Replaceable] readonly attribute long outerHeight;[Replaceable] readonly attribute double devicePixelRatio; 可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。 RenderObject Tree当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。 整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。上图所示，WebKit 会先检查 DOM 节点是否需要新的 RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。 RenderObjectRenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下： RenderObject 被创建时创建时相关的类如下图所示：Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图： RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图： RenderObject 核心对象关系图如下： RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。 RenderObject 的继承关系图如下： RenderObject 的一些主要虚函数 parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。 layout()，style()，enclosingBox() 这些计算和获取布局的函数。 isASubClass 类似这样判断那种子类类型的函数。 paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。 RenderObject 用来构建 Render Tree 的相关方法 1234567891011121314151617181920RenderElement* parent() const { return m_parent; }bool isDescendantOf(const RenderObject*) const;RenderObject* previousSibling() const { return m_previous; }RenderObject* nextSibling() const { return m_next; }// Use RenderElement versions instead.virtual RenderObject* firstChildSlow() const { return nullptr; }virtual RenderObject* lastChildSlow() const { return nullptr; }RenderObject* nextInPreOrder() const;RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;RenderObject* nextInPreOrderAfterChildren() const;RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;RenderObject* previousInPreOrder() const;RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;WEBCORE_EXPORT RenderObject* childAt(unsigned) const;RenderObject* firstLeafChild() const;RenderObject* lastLeafChild() const; RenderObject 用来布局相关的方法 1234567891011121314151617bool needsLayout() const{ return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout() || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();}bool selfNeedsLayout() const { return m_bitfields.needsLayout(); }bool needsPositionedMovementLayout() const { return m_bitfields.needsPositionedMovementLayout(); }bool needsPositionedMovementLayoutOnly() const{ return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout() &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();}bool posChildNeedsLayout() const { return m_bitfields.posChildNeedsLayout(); }bool needsSimplifiedNormalFlowLayout() const { return m_bitfields.needsSimplifiedNormalFlowLayout(); }bool normalChildNeedsLayout() const { return m_bitfields.normalChildNeedsLayout(); } RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。 RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。 RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。 RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。 RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。 RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下： StyleResolverRenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。 规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。 1234567891011PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle = 0, StyleSharingBehavior = AllowStyleSharing, RuleMatchingBehavior = MatchAllRules, RenderRegion* regionForStyling = 0); ...... PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle); PassRefPtr&lt;RenderStyle&gt; styleForPage(int pageIndex); PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement(); PassRefPtr&lt;RenderStyle&gt; styleForText(Text*); static PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* = 0); StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。 styleForElement 进行 CSS 选择和匹配具体代码实现如下： 12345678910111213141516171819202122232425//保存 elementinitElement(element);initForStyleResolve(element, defaultParent); .... //规则匹配 MatchResult matchResult; if (matchingBehavior == MatchOnlyUserAgentRules) matchUARules(matchResult); else matchAllRules(matchResult, matchingBehavior != MatchAllRulesExcludingSMIL); //将规则和 element 做映射applyMatchedProperties(matchResult, element);//matchUARulesvoid StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules) { m_matchedRules.clear(); result.ranges.lastUARule = result.matchedProperties.size() - 1; //收集匹配规则 collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, false); //规则排序 sortAndTransferMatchedRules(result); } RuleSetmatchUARules 的 RuleSet 代表 CSS 规则，比如 1p { background : red; } RuleSet 的成员变量 12345678class RuleSet ... {.....AtomRuleMap m_idRules;AtomRuleMap m_classRules;AtomRuleMap m_tagRules;AtomRuleMap m_shadowPseudoElementRules;...}; sortAndTransferMatchedRules 是为了保证正确的匹配顺序。 RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。 1234567891011121314151617181920212223void StyledElement::rebuildPresentationAttributeStyle() { ..... RefPtr&lt;StylePropertySet&gt; style; if (cacheHash &amp;&amp; cacheIterator-&gt;value) { style = cacheIterator-&gt;value-&gt;value; presentationAttributeCacheCleaner().didHitPresentationAttributeCache(); } else { style = StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode); unsigned size = attributeCount(); for (unsigned i = 0; i &lt; size; ++i) { const Attribute* attribute = attributeItem(i); collectStyleForPresentationAttribute(*attribute, style.get()); } } // ImmutableElementAttributeData doesn&apos;t store presentation attribute style, so make sure we have a MutableElementAttributeData. ElementAttributeData* attributeData = mutableAttributeData(); attributeData-&gt;m_presentationAttributeStyleIsDirty = false; attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? 0 : style); .... 关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。 Render tree 和 DOM tree 做对应其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。 有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的： 上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。 构建 Render Tree 的流程解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。 RenderLayer TreeRenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件： HTMLElement 节点对应的 RenderBlock 节点。 有设置 relative，absolute，transform 的 CSS position 属性的。 透明效果的 RenderObject 节点。 节点有 overflow， apha mask 或反射效果的 RenderObject 节点。 设置了 CSS filter 属性的节点。 使用 Canvas 或 WebGL 的 RenderObject 节点。 Video 节点对应的 RenderObject 节点。 RenderObject Tree 和 RenderLayer Tree 的关系如下图：接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示： style 计算构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。 这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。 我们先看看 style 计算可能会有一些什么样问题 Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。 如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。 应用规则涉及到比较复杂的层级规则。 下面来说下如何解决这些问题 共享 style 数据WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的 element 必须有相同的鼠标状态 都没有 id tag 名能匹配上 class 属性能匹配上 一组映射的属性是相同的 链接状态能匹配上 focus 状态能匹配上 任何 element 都不会被属性 selectors 影响 elements 不能有 inline style 属性 不要使用兄弟 selectors Rule treeWebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。 通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。 可确定样式分到各个 structs 里一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。 rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。 使用 rule tree 计算 style contexts当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。 从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree 上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。 如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。 如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。 看个例子 123456789101112&lt;html&gt; &lt;body&gt; &lt;div class=\"err\" id=\"div1\"&gt; &lt;p&gt; this is a &lt;span class=\"big\"&gt; big error &lt;/span&gt; this is also a &lt;span class=\"big\"&gt; very big error&lt;/span&gt; error &lt;/p&gt; &lt;/div&gt; &lt;div class=\"err\" id=\"div2\"&gt;another error&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 下面是 CSS 的定义 123456div {margin:5px;color:black}.err {color:red}.big {margin-top:3px}div span {margin-bottom:4px}#div1 {color:blue}#div2 {color:green} 这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree context tree： 假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。 现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。 已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。 对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。 如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。 比较容易匹配的 rules下面是不同的 style rules 的来源： CSS rules，来自于 style sheets 或者在 style elements 里 1p {color:blue} Inline style 属性 1&lt;p style=\"color:blue\" /&gt; HTML 视觉属性 1&lt;p bgcolor=\"blue\"&gt; 后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。 如果是 class name 那么会添加到 class map 里。 这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。 下面举个例子 123p.error {color:red}#messageDiv {height:50px}div {margin:5px} 第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。 对于下面的 HTML 12&lt;p class=\"error\"&gt;an error occurred &lt;/p&gt;&lt;div id=\" messageDiv\"&gt;this is a message&lt;/div&gt; 我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule 1table div {margin:5px} selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。 Style sheet 的 cascade 排序一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。 浏览器的设置 用户的设置 网页里普通的设置 网页里重要的设置 用户重要的设置 CSS specificationselector 的 specifity 在 w3c 里有定义 https://www.w3.org/TR/CSS2/cascade.html#specificity 计算方法如下 style attribute 数量 =a ID attribute 数量 =b 其它的 attribute 和 pseudo-classes 数量 =c element names 和 pseudo-element 数量 =d 举个例子 12345678910111213141516171819 * {} /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */ li {} /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */ li:first-line {} /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ ul li {} /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ ul ol+li {} /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */ h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */ ul ol li.red {} /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */ li.red.level {} /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */ #x34y {} /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */ style=\"\" /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */&lt;HEAD&gt;&lt;STYLE type=\"text/css\"&gt; #x97z { color: red }&lt;/STYLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P ID=x97z style=\"color: green\"&gt;&lt;/BODY&gt; 从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。 Rules 排序这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符 123456static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2){ int spec1 = r1.selector()-&gt;specificity(); int spec2 = r2.selector()-&gt;specificity(); return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; } Layout 布局当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。 HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。 Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。 Layout 处理过程完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下 12345678910111213141516FrameView:: layout( bool allowSubtree) // 栈 顶 Document:: implicitClose() FrameLoader:: checkCallImplicitClose() FrameLoader:: checkCompleted() FrameLoader:: finishedParsing() Document:: finishedParsing() HTMLParser:: finished() HTMLTokenizer:: end() HTMLTokenizer:: finish() Document:: finishParsing() FrameLoader:: endIfNotLoadingMainResource() FrameLoader:: end() DocumentLoader:: finishedLoading() FrameLoader:: finishedLoading() MainResourceLoader:: didFinishLoading() ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h) layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313void FrameView::layout(bool allowSubtree){ ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate()); LOG(Layout, &quot;FrameView %p (%dx%d) layout, main frameview %d, allowSubtree=%d&quot;, this, size().width(), size().height(), frame().isMainFrame(), allowSubtree); //判断是否已在 layout 过程中，避免多次 layout if (isInRenderTreeLayout()) { LOG(Layout, &quot; in layout, bailing&quot;); return; } if (layoutDisallowed()) { LOG(Layout, &quot; layout is disallowed, bailing&quot;); return; } // Protect the view from being deleted during layout (in recalcStyle). Ref&lt;FrameView&gt; protectedThis(*this); // Many of the tasks performed during layout can cause this function to be re-entered, // so save the layout phase now and restore it on exit. SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout); // Every scroll that happens during layout is programmatic. SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true); bool inChildFrameLayoutWithFrameFlattening = isInChildFrameWithFrameFlattening(); if (inChildFrameLayoutWithFrameFlattening) { if (!m_frameFlatteningViewSizeForMediaQuery) { LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; snapshotting size &quot; &lt;&lt; ScrollView::layoutSize() &lt;&lt; &quot; for media queries&quot;); m_frameFlatteningViewSizeForMediaQuery = ScrollView::layoutSize(); } startLayoutAtMainFrameViewIfNeeded(allowSubtree); //获取 root。这个 root 就是 RenderView 对象 RenderElement* root = m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView(); if (!root || !root-&gt;needsLayout()) return; } TraceScope tracingScope(LayoutStart, LayoutEnd);#if PLATFORM(IOS) if (updateFixedPositionLayoutRect()) allowSubtree = false;#endif //也是避免多次触发，会把 layoutTimer 先停止 m_layoutTimer.stop(); m_delayedLayout = false; m_setNeedsLayoutWasDeferred = false; //我们不应该在 painting 时进入 layout ASSERT(!isPainting()); if (isPainting()) return; InspectorInstrumentationCookie cookie = InspectorInstrumentation::willLayout(frame()); AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation()); if (!allowSubtree &amp;&amp; m_layoutRoot) convertSubtreeLayoutToFullLayout(); ASSERT(frame().view() == this); ASSERT(frame().document()); Document&amp; document = *frame().document(); ASSERT(document.pageCacheState() == Document::NotInPageCache); //对样式先进行更新 { SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false); if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) { // This is a new top-level layout. If there are any remaining tasks from the previous // layout, finish them now. SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true); performPostLayoutTasks(); } m_layoutPhase = InPreLayoutStyleUpdate; // Viewport-dependent media queries may cause us to need completely different style information. auto* styleResolver = document.styleScope().resolverIfExists(); if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) { LOG(Layout, &quot; hasMediaQueriesAffectedByViewportChange, enqueueing style recalc&quot;); document.styleScope().didChangeStyleSheetEnvironment(); // FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds. InspectorInstrumentation::mediaQueryResultChanged(document); } document.evaluateMediaQueryList(); // If there is any pagination to apply, it will affect the RenderView&apos;s style, so we should // take care of that now. applyPaginationToViewport(); // Always ensure our style info is up-to-date. This can happen in situations where // the layout beats any sort of style recalc update that needs to occur. document.updateStyleIfNeeded(); // If there is only one ref to this view left, then its going to be destroyed as soon as we exit, // so there&apos;s no point to continuing to layout if (hasOneRef()) return; // Close block here so we can set up the font cache purge preventer, which we will still // want in scope even after we want m_layoutSchedulingEnabled to be restored again. // The next block sets m_layoutSchedulingEnabled back to false once again. } m_layoutPhase = InPreLayout; RenderLayer* layer = nullptr; bool subtree = false; RenderElement* root = nullptr; ++m_nestedLayoutCount; { SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false); autoSizeIfEnabled(); //重新设置 RenderView 对象，准备开始 layout root = m_layoutRoot ? m_layoutRoot : document.renderView(); if (!root) return; subtree = m_layoutRoot; if (!m_layoutRoot) { auto* body = document.bodyOrFrameset(); if (body &amp;&amp; body-&gt;renderer()) { if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) { body-&gt;renderer()-&gt;setChildNeedsLayout(); } else if (is&lt;HTMLBodyElement&gt;(*body)) { if (!m_firstLayout &amp;&amp; m_size.height() != layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport()) body-&gt;renderer()-&gt;setChildNeedsLayout(); } }#if !LOG_DISABLED if (m_firstLayout &amp;&amp; !frame().ownerElement()) LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs\\n&quot;, this, document.timeSinceDocumentCreation().value());#endif } m_needsFullRepaint = !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing()); if (!subtree) { ScrollbarMode hMode; ScrollbarMode vMode; calculateScrollbarModesForLayout(hMode, vMode); if (m_firstLayout || (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())) { if (m_firstLayout) { setScrollbarsSuppressed(true); m_firstLayout = false; m_firstLayoutCallbackPending = true; m_lastViewportSize = sizeForResizeEvent(); m_lastZoomFactor = root-&gt;style().zoom(); // Set the initial vMode to AlwaysOn if we&apos;re auto. if (vMode == ScrollbarAuto) setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear. // Set the initial hMode to AlwaysOff if we&apos;re auto. if (hMode == ScrollbarAuto) setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear. Page* page = frame().page(); if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger()); setScrollbarModes(hMode, vMode); setScrollbarsSuppressed(false, true); } else setScrollbarModes(hMode, vMode); } LayoutSize oldSize = m_size; m_size = layoutSize(); if (oldSize != m_size) { LOG(Layout, &quot; layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat()); m_needsFullRepaint = true; if (!m_firstLayout) { RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr; auto* body = document.bodyOrFrameset(); RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr; if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport()) bodyRenderer-&gt;setChildNeedsLayout(); else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport()) rootRenderer-&gt;setChildNeedsLayout(); } } m_layoutPhase = InPreLayout; } layer = root-&gt;enclosingLayer(); SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot); RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view()); ASSERT(m_layoutPhase == InPreLayout); m_layoutPhase = InRenderTreeLayout; forceLayoutParentViewIfNeeded(); ASSERT(m_layoutPhase == InRenderTreeLayout);#ifndef NDEBUG RenderTreeNeedsLayoutChecker checker(*root);#endif //从 RenderView 这个根级开始进行 layout。 root-&gt;layout(); ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());#if ENABLE(TEXT_AUTOSIZING) if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) { float minimumZoomFontSize = frame().settings().minimumZoomFontSize(); float textAutosizingWidth = frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0; if (int overrideWidth = frame().settings().textAutosizingWindowSizeOverride().width()) textAutosizingWidth = overrideWidth; LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth); if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) { root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth); if (root-&gt;needsLayout()) root-&gt;layout(); } }#endif ASSERT(m_layoutPhase == InRenderTreeLayout); m_layoutRoot = nullptr; // Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer. } m_layoutPhase = InViewSizeAdjust; bool neededFullRepaint = m_needsFullRepaint; if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) { adjustViewSize(); // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by // navigating away from the current document (see webkit.org/b/173329). if (hasOneRef()) return; } m_layoutPhase = InPostLayout; m_needsFullRepaint = neededFullRepaint; // Now update the positions of all layers. if (m_needsFullRepaint) root-&gt;view().repaintRootContents(); root-&gt;view().releaseProtectedRenderWidgets(); ASSERT(!root-&gt;needsLayout()); layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint)); updateCompositingLayersAfterLayout(); m_layoutPhase = InPostLayerPositionsUpdatedAfterLayout; m_layoutCount++;#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK) if (AXObjectCache* cache = root-&gt;document().existingAXObjectCache()) cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);#endif#if ENABLE(DASHBOARD_SUPPORT) updateAnnotatedRegions();#endif#if ENABLE(IOS_TOUCH_EVENTS) document.setTouchEventRegionsNeedUpdate();#endif updateCanBlitOnScrollRecursively(); handleDeferredScrollUpdateAfterContentSizeChange(); handleDeferredScrollbarsUpdateAfterDirectionChange(); if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER)) updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight()); frame().document()-&gt;markers().invalidateRectsForAllMarkers(); if (!m_postLayoutTasksTimer.isActive()) { if (!m_inSynchronousPostLayout) { if (inChildFrameLayoutWithFrameFlattening) updateWidgetPositions(); else { SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true); performPostLayoutTasks(); // Calls resumeScheduledEvents(). } } if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) { // If we need layout or are already in a synchronous call to postLayoutTasks(), // defer widget updates and event dispatch until after we return. postLayoutTasks() // can make us need to update again, and we can get stuck in a nasty cycle unless // we call it through the timer here. m_postLayoutTasksTimer.startOneShot(0_s); } if (needsLayout()) layout(); } InspectorInstrumentation::didLayout(cookie, *root); DebugPageOverlays::didLayout(frame()); --m_nestedLayoutCount;} RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下： 123456789101112void RenderView::layoutContent(const LayoutState&amp; state){ UNUSED_PARAM(state); ASSERT(needsLayout()); RenderBlockFlow::layout(); if (hasRenderNamedFlowThreads()) flowThreadController().layoutRenderNamedFlowThreads();#ifndef NDEBUG checkLayoutState(state);#endif} 可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight){ ASSERT(needsLayout()); //当不需要布局子节点同时能 simplifiedLayout 重新布局成功 if (!relayoutChildren &amp;&amp; simplifiedLayout()) return; LayoutRepainter repainter(*this, checkForRepaintDuringLayout()); //重新计算逻辑宽度 if (recomputeLogicalWidthAndColumnWidth()) relayoutChildren = true; rebuildFloatingObjectSetFromIntrudingFloats(); //先保留一份以前的高度为后面做对比用 LayoutUnit previousHeight = logicalHeight(); // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(), // for consistency with other render classes? //然后将 logicalHeight 设置为 0，避免累加以前的。 setLogicalHeight(0); bool pageLogicalHeightChanged = false; checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged); const RenderStyle&amp; styleToUse = style(); LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged); preparePaginationBeforeBlockLayout(relayoutChildren); if (!relayoutChildren) relayoutChildren = namedFlowFragmentNeedsUpdate(); // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track // our current maximal positive and negative margins. These values are used when we // are collapsed with adjacent blocks, so for example, if you have block A and B // collapsing together, then you&apos;d take the maximal positive margin from both A and B // and subtract it from the maximal negative margin from both A and B to get the // true collapsed margin. This algorithm is recursive, so when we finish layout() // our block knows its current maximal positive/negative values. // // Start out by setting our margin values to our current margins. Table cells have // no margins, so we don&apos;t fill in the values for table cells. bool isCell = isTableCell(); if (!isCell) { initMaxMarginValues(); setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk()); setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk()); setPaginationStrut(0); } LayoutUnit repaintLogicalTop = 0; LayoutUnit repaintLogicalBottom = 0; LayoutUnit maxFloatLogicalBottom = 0; if (!firstChild() &amp;&amp; !isAnonymousBlock()) setChildrenInline(true); //Inline 和 Block 的不同布局处理 if (childrenInline()) layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom); else layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom); // Expand our intrinsic height to encompass floats. LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight(); if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext()) setLogicalHeight(lowestFloatLogicalBottom() + toAdd); if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) { ASSERT(!shouldBreakAtLineToAvoidWidow()); return; } // Calculate our new height. 计算新高 LayoutUnit oldHeight = logicalHeight(); LayoutUnit oldClientAfterEdge = clientLogicalBottom(); // Before updating the final size of the flow thread make sure a forced break is applied after the content. // This ensures the size information is correctly computed for the last auto-height region receiving content. if (is&lt;RenderFlowThread&gt;(*this)) downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge); updateLogicalHeight(); LayoutUnit newHeight = logicalHeight(); if (oldHeight != newHeight) { if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) { // One of our children&apos;s floats may have become an overhanging float for us. We need to look for it. for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) { if (blockFlow.isFloatingOrOutOfFlowPositioned()) continue; if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight) addOverhangingFloats(blockFlow, false); } } } //前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点 bool heightChanged = (previousHeight != newHeight); if (heightChanged) relayoutChildren = true; layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer()); //Add overflow from children (unless we&apos;re multi-column, since in that case all our child overflow is clipped anyway). computeOverflow(oldClientAfterEdge); statePusher.pop(); fitBorderToLinesIfNeeded(); if (view().layoutState()-&gt;m_pageLogicalHeight) setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop())); updateLayerTransform(); // Update our scroll information if we&apos;re overflow:auto/scroll/hidden now that we know if // we overflow or not. updateScrollInfoAfterLayout(); // FIXME: This repaint logic should be moved into a separate helper function! // Repaint with our new bounds if they are different from our old bounds. bool didFullRepaint = repainter.repaintAfterLayout(); if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) { // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines // it had to lay out. We wouldn&apos;t need the hasOverflowClip() hack in that case either. LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow(); LayoutUnit repaintLogicalRight = logicalRightVisualOverflow(); if (hasOverflowClip()) { // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&apos;t propagate to our block&apos;s overflow. // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit. // layoutInlineChildren should be patched to compute the entire repaint rect. repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow()); repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow()); } LayoutRect repaintRect; if (isHorizontalWritingMode()) repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop); else repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft); if (hasOverflowClip()) { // Adjust repaint rect for scroll offset repaintRect.moveBy(-scrollPosition()); // Don&apos;t allow this rect to spill out of our overflow box. repaintRect.intersect(LayoutRect(LayoutPoint(), size())); } // Make sure the rect is still non-empty after intersecting for overflow above if (!repaintRect.isEmpty()) { repaintRectangle(repaintRect); // We need to do a partial repaint of our content. if (hasReflection()) repaintRectangle(reflectedRect(repaintRect)); } } clearNeedsLayout();} 以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。 Layout Tree 创建Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是Skia 开源 2D 图形库做底层 Paint 引擎。 123void Document::finishedParsing() { updateStyleAndLayoutTree();} 每个 Node 都会创建一个 LayoutObject， 12LayoutObject* newLayoutObject = m_node-&gt;createLayoutObject(style);parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject); Layout 值的计算Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom){ LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore(); LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore(); // The child is a normal flow object. Compute the margins we will use for collapsing now. child.computeAndSetBlockDirectionMargins(*this); // Try to guess our correct logical top position. In most cases this guess will // be correct. Only if we&apos;re wrong (when we compute the real logical top position) // will we have to potentially relayout. LayoutUnit estimateWithoutPagination; //估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标 LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination); // Cache our old rect so that we can dirty the proper repaint rects if the child moves. LayoutRect oldRect = child.frameRect(); LayoutUnit oldLogicalTop = logicalTopForChild(child);#if !ASSERT_DISABLED LayoutSize oldLayoutDelta = view().layoutDelta();#endif // Position the child as though it didn&apos;t collapse with the top. //先设置布局前 top 坐标 setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta); estimateRegionRangeForBoxChild(child); RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr; bool markDescendantsWithFloats = false; if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats()) markDescendantsWithFloats = true; else if (UNLIKELY(logicalTopEstimate.mightBeSaturated())) // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for // very large elements. If it does the comparison with oldLogicalTop might yield a // false negative as adding and removing margins, borders etc from a saturated number // might yield incorrect results. If this is the case always mark for layout. markDescendantsWithFloats = true; else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) { // If an element might be affected by the presence of floats, then always mark it for // layout. LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom()); if (fb &gt; logicalTopEstimate) markDescendantsWithFloats = true; } if (childBlockFlow) { if (markDescendantsWithFloats) childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout(); if (!child.isWritingModeRoot()) previousFloatLogicalBottom = std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom()); } child.markForPaginationRelayoutIfNeeded(); bool childHadLayout = child.everHadLayout(); //对子节点进行布局 bool childNeededLayout = child.needsLayout(); if (childNeededLayout) child.layout(); // Cache if we are at the top of the block right now. bool atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock(); //保证 top 坐标和子节点布局后能够同步 // Now determine the correct ypos based off examination of collapsing margin // values. LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo); // Now check for clear. LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear); bool paginated = view().layoutState()-&gt;isPaginated(); if (paginated) logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear); //经过上面的子节点布局完后重新计算得到新高 setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta); // Now we have a final top position. See if it really does end up being different from our estimate. // clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&apos;t move. This happens // when collapseMargins dynamically adds overhanging floats because of a child with negative margins. if (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) { if (child.shrinkToAvoidFloats()) { // The child&apos;s width depends on the line width. When the child shifts to clear an item, its width can // change (because it has more available line width). So mark the item as dirty. child.setChildNeedsLayout(MarkOnlyThis); } if (childBlockFlow) { if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats()) childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout(); child.markForPaginationRelayoutIfNeeded(); } } if (updateRegionRangeForBoxChild(child)) child.setNeedsLayout(MarkOnlyThis); // In case our guess was wrong, relayout the child. child.layoutIfNeeded(); // We are no longer at the top of the block if we encounter a non-empty child. // This has to be done after checking for clear, so that margins can be reset if a clear occurred. if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock()) marginInfo.setAtBeforeSideOfBlock(false); // Now place the child in the correct left position //计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。 determineLogicalLeftPositionForChild(child, ApplyLayoutDelta); // Update our height now that the child has been placed in the correct position. setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child)); if (mustSeparateMarginAfterForChild(child)) { setLogicalHeight(logicalHeight() + marginAfterForChild(child)); marginInfo.clearMargin(); } // If the child has overhanging floats that intrude into following siblings (or possibly out // of this block), then the parent gets notified of the floats now. if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats()) maxFloatLogicalBottom = std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout)); LayoutSize childOffset = child.location() - oldRect.location(); if (childOffset.width() || childOffset.height()) { view().addLayoutDelta(childOffset); // If the child moved, we have to repaint it as well as any floating/positioned // descendants. An exception is if we need a layout. In this case, we know we&apos;re going to // repaint ourselves (and the child) anyway. if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout()) child.repaintDuringLayoutIfMoved(oldRect); } //渲染 if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) { child.repaint(); child.repaintOverhangingFloats(true); } if (paginated) { if (RenderFlowThread* flowThread = flowThreadContainingBlock()) flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child); // Check for an after page/column break. LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo); if (newHeight != height()) setLogicalHeight(newHeight); } ASSERT(view().layoutDeltaMatches(oldLayoutDelta));} 判断值的类型是固定值还是百分比的方法 12345678switch (length.type()) { case Fixed: return LayoutUnit(length.value()); //返回 LayoutUnit 封装的数据 1px = 1 &lt;&lt; 6 = 64 unit case Percent: //maximumValue 是传进来的最大值 return LayoutUnit( static_cast&lt;float&gt;(maximumValue * length.percent() / 100.0f));} 计算 margin 的值 123456789101112// CSS 2.1: &quot;If both &apos;margin-left&apos; and &apos;margin-right&apos; are &apos;auto&apos;, their used// values are equal. This horizontally centers the element with respect to// the edges of the containing block.&quot;const ComputedStyle&amp; containingBlockStyle = containingBlock-&gt;styleRef();if (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) { LayoutUnit centeredMarginBoxStart = std::max( LayoutUnit(), (availableWidth - childWidth) / 2); marginStart = centeredMarginBoxStart; marginEnd = availableWidth - childWidth - marginStart; return;} Box Model 里 12m_frameRect.setWidth(width);m_marginBox.setStart(marginLeft); 经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码： 12345&lt;html&gt;&lt;body&gt;&lt;p&gt;First line.&lt;br&gt;Second one.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 布局计算后带布局信息的 Render Tree 如下： 123456RenderBlock {HTML} at (0, 0) size 640x480 |—— RenderBody {BODY} at (0, 80) size 640x480 [bgcolor=# FFFFFF] | |—— RenderBlock {P} at (0, 0) size 640x80 | | |—— RenderText {#text} at (0, 0) size 48x24 &quot;First line.&quot; | | |—— RenderBR {BR} at (20, 20) size 0x0 | | |—— RenderText {#text} at (0, 24) size 48x24 &quot;Second one.&quot; Box Model 数据结构所有的 elements 都有 display 属性用来确定显示类型。属性值有 block：生成一个 block box inline：生成一个或多个 inline boxes none：不生成 box 默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：https://www.w3.org/TR/CSS2/sample.html 定位的方案有三种方案 Normal：由 render tree 来决定的位置。 Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。 Absolute：让其在 render tree 的位置和 DOM tree 不一样 定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。 对于 float 的处理，首先需要判断宽度是否需要 fit content 123456bool LayoutBox::sizesLogicalWidthToFitContent( const Length&amp; logicalWidth) const { if (isFloating() || isInlineBlockOrInlineTable()) return true; ...} 如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。 对于 float:left 的计算 12345678910111213141516//logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束while (logicalRightOffsetForPositioningFloat( logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) - floatLogicalLeft &lt; floatLogicalWidth) { //下移 logicalTopOffset += std::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight); //新的 floatLogicalLeft floatLogicalLeft = logicalLeftOffsetForPositioningFloat( logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft); }}//看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值floatLogicalLeft = std::max( logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft); Box 类型Block box：在浏览器的 window 里有自己的矩形 Inline box：没有自己的 block，但是会在一个 block 里 Block 是按照垂直排列，Inline 是按照水平来排列 Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。 下面举个例子看看 Inline 类型的例子，比如有如下的 html： 1&lt;p&gt;First line.&lt;br&gt;Second one.&lt;/p&gt; 这段 html 的 Render Tree 如下： Position 类型Relative：相对定位，先按照正常的定位然后根据设置的值再移动。 Float：会被移动到左边或右边侧 Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。 分层分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。 1234567891011&lt;STYLE type=\"text/css\"&gt; div { position: absolute; left: 2in; top: 2in; }&lt;/STYLE&gt;&lt;P&gt;&lt;DIV style=\"z-index: 3;background-color:red; width: 1in; height: 1in; \"&gt;&lt;/DIV&gt;&lt;DIV style=\"z-index: 1;background-color:green;width: 2in; height: 2in;\"&gt;&lt;/DIV&gt;&lt;/p&gt; 效果如下： 可以看到层级是按照 z-index 来排的。 大小的计算border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是 123456// More IE extensions. clientWidth and clientHeight represent the interior of// an object excluding border and scrollbar.LayoutUnit LayoutBox::clientWidth() const { return m_frameRect.width() - borderLeft() - borderRight() - verticalScrollbarWidth();} offsetWidth 是 frameRect 的宽度 123// IE extensions. Used to calculate offsetWidth/Height.LayoutUnit offsetWidth() const override { return m_frameRect.width(); }LayoutUnit offsetHeight() const override { return m_frameRect.height(); } Margin 区域是用 LayoutRectOutsets 1234LayoutUnit m_top;LayoutUnit m_right;LayoutUnit m_bottom;LayoutUnit m_left; 位置位置的计算，即 x 和 y 是通过下面两个函数计算得到 123456// 根据 margin 得到 y 值LayoutUnit logicalTopBeforeClear = collapseMargins(child, layoutInfo, childIsSelfCollapsing, childDiscardMarginBefore, childDiscardMarginAfter);// 得到 x 值determineLogicalLeftPositionForChild(child); 计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。 ming1016","link":"/program//webkit/"},{"title":"Homebrew","text":"macOS（或 Linux）缺失的软件包的管理器 — Homebrew 安装 Homebrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 将以上命令粘贴至终端。 脚本会在执行前暂停，并说明它将做什么。高级安装选项在 这里 (required for Linux and Windows Subsystem for Linux)。 Homebrew 能干什么?使用 Homebrew 安装 Apple（或您的 Linux 系统）没有预装但 你需要的东西。 1$ brew install wget Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 。 12345678$ cd /usr/local$ find CellarCellar/wget/1.16.1Cellar/wget/1.16.1/bin/wgetCellar/wget/1.16.1/share/man/man1/wget.1$ ls -l binbin/wget -&gt; ../Cellar/wget/1.16.1/bin/wget Homebrew 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置。 轻松创建你自己的 Homebrew 包。 12$ brew create https://foo.com/bar-1.0.tgzCreated /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/bar.rb 完全基于 Git 和 Ruby，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并。 1$ brew edit wget # 使用 $EDITOR 编辑! Homebrew 的配方都是简单的 Ruby 脚本： 12345678910class Wget &lt; Formula homepage &quot;https://www.gnu.org/software/wget/&quot; url &quot;https://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz&quot; sha256 &quot;52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd&quot; def install system &quot;./configure&quot;, &quot;--prefix=#{prefix}&quot; system &quot;make&quot;, &quot;install&quot; endend Homebrew 使 macOS（或您的 Linux 系统）更完整。使用 gem 来安装 RubyGems、用 brew 来安装那些依赖包。 “要安装，请拖动此图标……”不会再出现了。使用 brew cask 安装 macOS 应用程序、字体和插件以及其他非开源软件。 1$ brew cask install firefox 制作一个 cask 就像创建一个配方一样简单。 12$ brew cask create fooEditing /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/foo.rb 怎么删掉 brew cask list 里面的已安装记录？1rm -rf /usr/local/Caskroom/名称 更多文档docs.brew.sh Homebrew Packagesformulae.brew.sh GitHubhttps://github.com/Homebrew/brew","link":"/news/brew/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"","slug":"","link":"/tags//"},{"name":"program","slug":"program","link":"/tags/program/"},{"name":"善用佳软","slug":"善用佳软","link":"/tags/善用佳软/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"}],"categories":[{"name":"notes","slug":"notes","link":"/categories/notes/"},{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"news","slug":"news","link":"/categories/news/"},{"name":"label","slug":"label","link":"/categories/label/"},{"name":"Software","slug":"Software","link":"/categories/Software/"},{"name":"program","slug":"program","link":"/categories/program/"}]}