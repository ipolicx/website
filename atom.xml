<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>POLICX</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.policx.com/"/>
  <updated>2019-08-30T05:12:22.058Z</updated>
  <id>https://www.policx.com/</id>
  
  <author>
    <name>policx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>苹果2019秋季发布会邀请函壁纸</title>
    <link href="https://www.policx.com/news/2019-Apple-Special-Event/"/>
    <id>https://www.policx.com/news/2019-Apple-Special-Event/</id>
    <published>2019-08-30T03:20:47.000Z</published>
    <updated>2019-08-30T05:12:22.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Apple 特别活动</strong><br>于 Steve Jobs Theater 现场直播<br>北京时间 2019 年 9 月 11 日凌晨 1 点<br><em><a href="/cn/apple-events/home/built/assets/sep-event.ics">添加到日历</a></em><br>你也可以到 Apple 官网，或上<br>腾讯视频、爱奇艺、优酷、哔哩哔哩，<br>不用到现场，通通都是前排的待遇。</p></blockquote><a id="more"></a><p><img src="https://gitee.com/policx/im/raw/master/images/g062t1.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Apple 特别活动&lt;/strong&gt;&lt;br&gt;于 Steve Jobs Theater 现场直播&lt;br&gt;北京时间 2019 年 9 月 11 日凌晨 1 点&lt;br&gt;&lt;em&gt;&lt;a href=&quot;/cn/apple-events/home/built/assets/sep-event.ics&quot;&gt;添加到日历&lt;/a&gt;&lt;/em&gt;&lt;br&gt;你也可以到 Apple 官网，或上&lt;br&gt;腾讯视频、爱奇艺、优酷、哔哩哔哩，&lt;br&gt;不用到现场，通通都是前排的待遇。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 桌面进化史</title>
    <link href="https://www.policx.com/Linux/desktop/"/>
    <id>https://www.policx.com/Linux/desktop/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2019-08-29T00:40:36.813Z</updated>
    
    <content type="html"><![CDATA[<p>本周 Linux 刚刚迎来它的 <a href="https://www.oschina.net/news/109387/linux-kernel-28-years-old" target="_blank" rel="noopener">28 岁生日</a>。自 20 世纪 90 年代初期以来，Linux 桌面也已从简单的窗口管理器发展为成熟、完整的桌面。那么它究竟是如何一步步发展至今的呢？作为从 1993 年就开始使用 Linux 的资深用户，FreeDOS 创始人 Jim Hall 从初代窗口管理器开始，仔细梳理了一遍 Linux 桌面的进化史——</p><a id="more"></a><h4 id="X-和窗口管理器"><a href="#X-和窗口管理器" class="headerlink" title="X 和窗口管理器"></a><strong>X 和窗口管理器</strong></h4><p>Linux 上的第一个”桌面”是在 X Window 系统上运行的窗口管理器。X 为图形用户界面提供了基本构建块，例如在屏幕上创建窗口并提供键盘和鼠标输入。要运行 X 图形环境，用户需要一种方法来管理会话中的所有窗口，这就是窗口管理器的用武之地。运行像 xterm 或 xclock 这样的 X 程序，它们就会在窗口中打开。</p><p>窗口管理器负责跟踪窗口并执行基本的任务管理，例如移动窗口并最小化。剩下的则取决于个人，你可以在通过将 X 列在 ~/.xinitrc 文件中来启动程序，不过通常，用户会从 xterm 运行新程序。</p><p>1993 年最常见的窗口管理器是 TWM，它可以追溯至 1988 年。TWM 非常简单，只提供基本的窗口管理功能。</p><p><img src="https://oscimg.oschina.net/oscnet/b15342f4dfc0dc3d74ba7280bd519fb5f52.jpg" alt></p><p><em>▲SLM 1.05 上的 TWM，图中为 xterm、xclock 和 Emacs 编辑器</em></p><p>另一个早期的窗口管理器是 OpenLook 虚拟窗口管理器（OLVWM）。OpenLook 是 Sun Microsystems 在 20 世纪 80 年代开发的图形用户界面，后来也被移植到其他 Unix 平台。作为虚拟窗口管理器，OLVWM 支持多个工作区。</p><p><img src="https://oscimg.oschina.net/oscnet/f733e9919db5c2c90b90ae55561d0740ba1.jpg" alt></p><p><em>▲SLS 1.05 上的 OLVWM，图为 xterm 和 Virtual Workspaces 选择器</em></p><p>当 Linux 开始普及时，创建一个具有流畅性能和改进界面的新窗口管理器并不需要花费很大力气。这些新窗口管理器中的首个便是 FVWM，一个虚拟窗口管理器。 FVWM 比 TWM 或 OLVWM 更具现代感。当然对于现代人来说，TWM 和 FVWM 可能看起来很平常。</p><p><img src="https://oscimg.oschina.net/oscnet/403aded818b5025c425ff6ddf01e7ec86aa.jpg" alt></p><p><em>▲SLS 1.05 上的 FVWM，图为 xterm 和文件管理器</em></p><p>当时的 Windows 桌面看起来相当简单。 Windows 版本 1 到 3 使用称为”程序管理器”的普通启动程序。</p><p><img src="https://oscimg.oschina.net/oscnet/2e98527c0f1baa646c613b3afecc01889e7.jpg" alt></p><p><em>▲Windows 3.11 上的程序管理器和记事本编辑器</em></p><p>1995 年 8 月，微软发布了 Windows 95 并改变了现代 PC 桌面环境。在当时，Windows 3.x 看起来是笨拙而丑陋的，Windows 95 显然更为流畅好看。更重要的是，Windows 95 改变了人们对桌面的定义。</p><p>Windows 95 桌面意味着集成。程序管理器消失了，取而代之的是屏幕底部的任务栏，可以使用更简单的”开始”菜单启动新程序。与之前版本的 Windows 甚至其他 Linux 窗口管理器相比，Windows 95 界面更加灵活且易于使用。</p><p><img src="https://oscimg.oschina.net/oscnet/6be31783abd1c4dfc7da65a50634643f86b.jpg" alt></p><p><em>▲Windows 95 上的记事本编辑器</em></p><p>Linux 开发人员不甘示弱，创建了一个模仿 Windows 95 界面的新版 FVWM，并称为 FVWM95。新的窗口管理器仍然不是桌面，但它看起来比以前好得多。用户可以在任务栏中使用”开始”菜单启动新的 X 程序，任务栏还使用类似于 Windows 95 的按钮显示正在运行的程序。</p><p><img src="https://oscimg.oschina.net/oscnet/cf9b34602e406aaf6a9cbf4b6e0eca4db5c.jpg" alt></p><p><em>▲Red Hat Linux 5.2 上的 FVWM95</em></p><p>虽然 FVWM95 和其他窗口管理器在不断改进，但核心问题仍然存在：Linux 并没有真正拥有桌面。它只有一系列窗口管理器罢了。</p><h4 id="首个-Linux-桌面"><a href="#首个-Linux-桌面" class="headerlink" title="首个 Linux 桌面"></a><strong>首个 Linux 桌面</strong></h4><p>1996 年，Matthias Ettrich 希望将所有内容集成在一起，就像一个真正的桌面一样。于是他开始研究 K 桌面环境（KDE），并于 1998 年 7 月完成。KDE 1.0 比 FVWM95 这样的普通窗口管理器有了明显的改进。</p><p><img src="https://oscimg.oschina.net/oscnet/407a6285cf81a4058f549120a20b270ba4e.jpg" alt></p><p><em>▲KDE 1.0</em></p><p>KDE 代表着 Linux 的一大进步，从此 Linux 拥有了真正的桌面应用程序集成和更现代的桌面图标。</p><p>KDE 的设计与 Windows 95 相差无几。它在屏幕底部有一个任务栏，提供了相当于 Windows 95 的开始菜单以及几个应用程序的快捷方式。此外，KDE 还支持虚拟桌面。</p><p>但并非所有人都对 KDE 感到满意。为了从系统中抽象 GUI，KDE 使用了 Trolltech 的 Qt 工具包库。不幸的是，Qt 没有在免费软件许可下发布。Trolltech 允许 Qt 在免费软件应用程序中免费使用，但在商业或专有应用程序中使用它需要付费。这使 Linux 发行版陷入两难抉择：应该包含 KDE 吗？或者默认使用较旧但免费的软件图形用户界面，如 FVWM？</p><p>很快，事情有了新的变化。Miguel de Icaza 和 Federico Mena 于 1997 年开始为新的 Linux 桌面工作。这个新项目被称为 GNOME，用于 GNU 网络对象模型环境。GNOME 旨在成为完全免费的软件，并使用来自 GIMP 图像编辑器的不同工具包，即 GTK（GIMP Tool Kit）。</p><p>当 GNOME 1.0 最终在 1999 年发布时，Linux 又拥有了一个现代桌面环境。</p><p><img src="https://oscimg.oschina.net/oscnet/1fb86c4cd40cfb1594ac8dfbbb1446c9aa6.jpg" alt></p><p><em>▲GNOME 1.0</em></p><p>此后，KDE 与 GNOME 的竞争持续了一段时间。转眼来到 1999 年，Trolltech 根据新的公共许可证——Q 公共许可证（QPL）重新发布了 Qt 库。但新许可证仍然有所限制，QPL 仅适用于 Qt 在开源软件项目中的使用，而非商业项目。因此，自由软件基金会认为 QPL 与 GNU 通用公共许可证（GNU GPL）不兼容。这个许可问题将一直持续到 Trolltech 在 2000 年 GNU GPL 第 2 版下重新发布 Qt 库。</p><h4 id="随着时间的发展"><a href="#随着时间的发展" class="headerlink" title="随着时间的发展"></a><strong>随着时间的发展</strong></h4><p>Linux 桌面继续成熟。 KDE 和 GNOME 进入良性竞争状态，互相推动新的发展。到 2004 年，GNOME 和 KDE 都取得了重大进展，但只对用户界面进行了增量更改。</p><p>KDE 2 和 3 继续依赖于屏幕底部的任务栏概念，但包含了用于运行应用程序的按钮。KDE 最明显的变化之一是增加了 Konqueror 浏览器，它最初出现在 KDE 2 中。</p><p><img src="https://oscimg.oschina.net/oscnet/63cbb0f1951147687811f5e297fa1e2fb46.jpg" alt></p><p><em>▲KDE 2.2.2 （2001）</em></p><p><img src="https://oscimg.oschina.net/oscnet/554437033ebbf7e5fb280f4b7d23ffbaf4f.jpg" alt></p><p><em>▲Fedora Core 2 上的 KDE 3.2.2（2004）</em></p><p>GNOME 2 也使用了任务栏概念，但它将栏分成两部分：屏幕顶部用于启动应用程序并响应桌面警报，页面底部显示正在运行的应用程序。除了简化的用户界面外，GNOME 还添加了一个名为 Nautilus 的文件管理器，由 Eazel 开发。</p><p><img src="https://oscimg.oschina.net/oscnet/cdf267f1c7db0ae1f9150b4e841f5fd73fb.jpg" alt></p><p><em>▲Fedora Core 2 上的 GNOME 2.6.0（2004）</em></p><p>随着时间的推移，KDE 和 GNOME 采取了不同的发展路径。两者都提供功能丰富、强大且现代化的桌面环境，但它们具有不同的用户界面目标。2011 年可以说是 GNOME 和 KDE 的分水岭。KDE 4.6（2011 年 1 月）和 KDE 4.7（2011 年 7 月）提供了更为传统的桌面，同时继续依赖许多用户熟悉的任务栏概念。从外观上来看，KDE 并没有什么太大的变化。</p><p><img src="https://oscimg.oschina.net/oscnet/2957f96a8bcdb2901817afd336912cae752.jpg" alt></p><p><em>▲KDE 4.6</em></p><p>另一边的 GNOME 则在 2011 年通过新的桌面概念完全改变了方向。 GNOME 3 旨在创建更简化的桌面体验，使用户能够专注于他们正在进行的工作。任务栏消失，取而代之的是屏幕顶部的黑色状态栏，其中包括音量和网络控制，显示时间和电池状态，并允许用户通过重新设计的菜单启动新程序。</p><p><img src="https://oscimg.oschina.net/oscnet/63b990f463bbeacafcbf6385ecd4dd4e7e3.jpg" alt></p><p><em>▲GNOME 3.0</em></p><h4 id="选择合适的桌面"><a href="#选择合适的桌面" class="headerlink" title="选择合适的桌面"></a><strong>选择合适的桌面</strong></h4><p>有人喜欢 KDE，有人喜欢 GNOME，选择最适合自己的就好。可以肯定的是，KDE 和 GNOME 都有批评者和支持者。这其中最著名的批评者也许是 Linus Torvalds，他在 2011 年大声谴责 GNOME 为 “unholy mess” 并放弃了它，两年后却又再度回归。</p><p>其他不少人对 GNOME 3 也提出了类似的批评，以至于一些开发人员将 GNOME 2 源代码分叉并创建 MATE 桌面。MATE 继承了 GNOME 2 的传统任务栏界面。</p><p>无论如何，毫无疑问，今天最流行的两个 Linux 桌面是 KDE 和 GNOME。它们目前的版本都非常成熟，并且功能丰富。KDE 5.16（2019）和 GNOME 3.32（2019）都试图简化 Linux 桌面体验，不过是以不同的方式。GNOME 3.32 继续瞄准最简洁的外观，删除所有令人分心的用户界面元素，以便用户可以专注于应用程序和工作。而 KDE 5.16 仍旧采用了较为熟悉的任务栏方法，但增加了其他视觉改进，特别是改进了图标和小部件处理。</p><p><img src="https://oscimg.oschina.net/oscnet/3e3d3fc4624c5a65c2b5156c19040815ad5.jpg" alt></p><p><em>▲KDE 5.6</em></p><p><img src="https://oscimg.oschina.net/oscnet/04b04752c3797920f5466e7c8c16edb273c.jpg" alt></p><p><em>▲GNOME 3.32</em></p><p>每个主要的 Linux 发行版都提供兼容性库，因此兼容性不会丢失，用户可以在 GNOME 上运行 KDE 应用程序，反之亦然。</p><p>KDE 和 GNOME 之间的良性竞争使两个阵营的开发人员都能够不断突破，这是一件好事。无论你使用的是 KDE 还是 GNOME，你都拥有一个集成度很高的现代化桌面。</p><p>最重要的是，这意味着 Linux 拥有自由软件中的最佳功能：选择。</p><p>本文译自：<a href="https://opensource.com/article/19/8/how-linux-desktop-grown" target="_blank" rel="noopener">opensource.com</a></p><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://www.oschina.net/news/109440/how-linux-desktop-grown" target="_blank" rel="noopener"><img src="https://static.oschina.net/new-osc/img/logo_osc_new.svg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本周 Linux 刚刚迎来它的 &lt;a href=&quot;https://www.oschina.net/news/109387/linux-kernel-28-years-old&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;28 岁生日&lt;/a&gt;。自 20 世纪 90 年代初期以来，Linux 桌面也已从简单的窗口管理器发展为成熟、完整的桌面。那么它究竟是如何一步步发展至今的呢？作为从 1993 年就开始使用 Linux 的资深用户，FreeDOS 创始人 Jim Hall 从初代窗口管理器开始，仔细梳理了一遍 Linux 桌面的进化史——&lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://www.policx.com/categories/program/"/>
    
      <category term="Linux" scheme="https://www.policx.com/categories/program/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.policx.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>体系</title>
    <link href="https://www.policx.com/program/system/"/>
    <id>https://www.policx.com/program/system/</id>
    <published>2019-08-28T14:11:04.000Z</published>
    <updated>2019-08-30T11:18:10.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>知识体系图</p></blockquote><a id="more"></a><div class="content">                                <div><br><a class="button is-link">前端知识体系</a><br></div><br>                                <div id="book-web" class="card" style="width: 100%; height: 1300px; -webkit-tap-highlight-color: transparent; user-select: none; position: relative;" _echarts_instance_="ec_1566889275033">                                    <div style="position: relative; overflow: hidden; width: 817px; height: 1300px; padding: 0px; margin: 0px; border-width: 0px; cursor: default;">                                        <canvas data-zr-dom-id="zr_0" width="1634" height="2600" style="position: absolute; left: 0px; top: 0px; width: 817px; height: 1300px; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); padding: 0px; margin: 0px; border-width: 0px;"></canvas>                                    </div>                                    <div></div>                                </div>                                <div><br><a class="button is-link">Android知识体系</a><br></div><br>                                <div id="book-android" class="card" style="width: 100%; height: 1200px; -webkit-tap-highlight-color: transparent; user-select: none; position: relative;" _echarts_instance_="ec_1566889275034">                                    <div style="position: relative; overflow: hidden; width: 817px; height: 1200px; padding: 0px; margin: 0px; border-width: 0px;">                                        <canvas data-zr-dom-id="zr_0" width="1634" height="2400" style="position: absolute; left: 0px; top: 0px; width: 817px; height: 1200px; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); padding: 0px; margin: 0px; border-width: 0px;"></canvas>                                    </div>                                    <div></div>                                </div>                                <div><br><a class="button is-link">物联网和接口体系</a><br></div><br>                                <div id="book-iot" class="card" style="width: 100%; height: 600px; -webkit-tap-highlight-color: transparent; user-select: none; position: relative;" _echarts_instance_="ec_1566889275035">                                    <div style="position: relative; overflow: hidden; width: 817px; height: 600px; padding: 0px; margin: 0px; border-width: 0px; cursor: default;">                                        <canvas data-zr-dom-id="zr_0" width="1634" height="1200" style="position: absolute; left: 0px; top: 0px; width: 817px; height: 600px; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); padding: 0px; margin: 0px; border-width: 0px;"></canvas>                                    </div>                                    <div></div>                                </div>                                <p><br>小提示：你可以点击分类树的 <strong>叶子节点</strong> 的小圆点直接查看对应的文章内容。<br></p>                                <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>                                <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/4.2.1/echarts-en.js"></script>                                <script type="text/javascript">                                    function transData(t, a, i, e) {                                        for (var o = [], n = {}, l = a, r = i, d = e, s = 0, c = 0, h = t.length; s < h; s++)                                            n[t[s][l]] = t[s]; for (; c < h; c++) { var m = t[c], g = n[m[r]]; g ? (!g[d] && (g[d] = []), g[d].push(m)) : o.push(m) } return o                                    }                                    function clickNode(t, a, i) {                                        void 0 != i && "" !== i && window.open(i)                                    }                                    var webChart = echarts.init(document.getElementById("book-web")); webChart.showLoading(), $.get("https://dp2px.com/json-data/frame-web.json", function (t) { webChart.hideLoading(), echarts.util.each(t.children, function (t, a) { a % 2 === 0 && (t.collapsed = !0) }), webChart.setOption(option = { tooltip: { trigger: "item", triggerOn: "mousemove" }, series: [{ type: "tree", data: transData(t, "value", "sj", "children"), top: "1%", left: "100px", bottom: "1%", right: "40%", symbol: "emptyCircle", symbolSize: 10, label: { normal: { position: "left", verticalAlign: "middle", align: "right", fontSize: 14 } }, leaves: { label: { normal: { position: "right", verticalAlign: "middle", align: "left" } } }, initialTreeDepth: 3, expandAndCollapse: !0, animationDuration: 550, animationDurationUpdate: 750 }] }), webChart.on("click", function (t) { var a = t.data.name, i = t.data.value, e = t.data.url; clickNode(a, i, e) }) });                                    var androidChart = echarts.init(document.getElementById("book-android")); androidChart.showLoading(), $.get("https://dp2px.com/json-data/frame-android.json", function (t) { androidChart.hideLoading(), echarts.util.each(t.children, function (t, a) { a % 2 === 0 && (t.collapsed = !0) }), androidChart.setOption(option = { tooltip: { trigger: "item", triggerOn: "mousemove" }, series: [{ type: "tree", data: transData(t, "value", "sj", "children"), top: "1%", left: "120px", bottom: "1%", right: "40%", symbolSize: 10, label: { normal: { position: "left", verticalAlign: "middle", align: "right", fontSize: 14 } }, leaves: { label: { normal: { position: "right", verticalAlign: "middle", align: "left" } } }, initialTreeDepth: 3, expandAndCollapse: !0, animationDuration: 550, animationDurationUpdate: 750 }] }), androidChart.on("click", function (t) { var a = t.data.name, i = t.data.value, e = t.data.url; clickNode(a, i, e) }) });                                    var iotChart = echarts.init(document.getElementById("book-iot")); iotChart.showLoading(), $.get("https://dp2px.com/json-data/frame-iot.json", function (t) { iotChart.hideLoading(), echarts.util.each(t.children, function (t, a) { a % 2 === 0 && (t.collapsed = !0) }), iotChart.setOption(option = { tooltip: { trigger: "item", triggerOn: "mousemove" }, series: [{ type: "tree", data: transData(t, "value", "sj", "children"), top: "1%", left: "150px", bottom: "1%", right: "40%", symbolSize: 10, label: { normal: { position: "left", verticalAlign: "middle", align: "right", fontSize: 14 } }, leaves: { label: { normal: { position: "right", verticalAlign: "middle", align: "left" } } }, initialTreeDepth: 3, expandAndCollapse: !0, animationDuration: 550, animationDurationUpdate: 750 }] }), iotChart.on("click", function (t) { var a = t.data.name, i = t.data.value, e = t.data.url; clickNode(a, i, e) }) })                                </script>                            </div><table><thead><tr><th><strong>原文链接  水寒的博客</strong></th><th>👇</th></tr></thead><tbody><tr><td><a href="https://dp2px.com/books/" target="_blank" rel="noopener"><img src="https://dp2px.com/images/logo.svg" alt="水寒的博客"></a></td><td></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知识体系图&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Software" scheme="https://www.policx.com/categories/Software/"/>
    
    
      <category term="体系" scheme="https://www.policx.com/tags/%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于知识产权、知识共享与文章翻译</title>
    <link href="https://www.policx.com/news/copyright/"/>
    <id>https://www.policx.com/news/copyright/</id>
    <published>2019-08-25T01:20:42.000Z</published>
    <updated>2019-08-28T16:14:04.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作者简介</strong>： 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：Python猫</p><a id="more"></a><h2 id="一、缘起"><a href="#一、缘起" class="headerlink" title="一、缘起"></a>一、缘起</h2><p>前不久，我在翻译 Guido van Rossum（Python之父）的文章时，给他留言，申请非商业用途的翻译授权。</p><p>过程中起了点小误会，略去不表，最终的结果是：他的文章以 <code>CC BY-NC-SA 4.0</code> 许可协议进行授权。部分对话如下：</p><p><img src="https://oscimg.oschina.net/oscnet/bb25210973dc5b552c5626d16f1e9a27609.jpg" alt></p><p>CC 协议是一种授权许可协议，我曾看到过几次，但了解不多，所以便查阅了相关的内容。</p><p>本文主要是作个记录，既是加深自己的理解，也给有需要的同学一个参考。</p><h2 id="二、著作权、著佐权与自由版权"><a href="#二、著作权、著佐权与自由版权" class="headerlink" title="二、著作权、著佐权与自由版权"></a>二、著作权、著佐权与自由版权</h2><p>对于知识产权，通常有如下几种说法：</p><ul><li>All Rights Reserved（保留所有权利）</li><li>Some Rights Reserved（保留部分权利）</li><li>All Rights Reversed（撤销所有权利）</li></ul><p>注意最后一条的”Reversed”，它长得很像”Reserved”，但意思截然相反。</p><p>它们对权利的诉求由强转弱，从一个极端走向另一个极端。</p><p>有几个与此相关的概念：</p><ul><li>copyright，即版权、著作权</li><li>copyleft，即著作传、著佐权</li><li>copywrong，即反版权、自由版权</li></ul><p>版权制度起源于十五世纪中期，那时西方发明了铅活字印刷术（古登堡，现代印刷术之父），出现了大量盗版，为了保护出版商的利益，政府出台了版权法。</p><p><img src="https://oscimg.oschina.net/oscnet/6593ddee9cd5838de33416efef3384895a8.jpg" alt></p><p>此后版权法在世界各地普及，演化出了很多门类，它们普遍限定了一个有效期限，在此期限内，版权方受到垄断保护（即 All Rights <strong>Reserved</strong> ）。超出期限后，知识作品才会进入公共领域（public domain），才变成自由版权。</p><p>copyright 是一种限制性协议，有利于保护版权方的个体权益，但是也阻碍了知识作品的传播，不利于社会的公共利益。</p><p>我们经常会听到一个词”专利流氓”，说的就是版权被过度使用而造成的社会问题。举个例子，某家商业公司竟然曾”拥有”国旗国徽的版权。</p><p><img src="https://oscimg.oschina.net/oscnet/f3fef7c4d0ea36b7ad7266b64fe12dd2144.jpg" alt></p><p>copyleft 则是一种较为宽松的协议，对应的思想是 Some Rights Reserved（保留部分权利），使用者只要遵守少数的列明条款即可。</p><p>copyleft 之所以会译作”著作 <strong>传</strong> “，因为有” <strong>减少屏蔽，自由流传</strong> “之义。</p><p>另外还翻译为”著 <strong>佐</strong>权”，也是一字之差，跟英文原词神似，非常有趣。</p><p>最后还有一个 copywrong（还有类似的”copyfree”、”copycenter”叫法），它属于另一个极端，无视版权，无拘无束。</p><p>copyleft 与 copywrong 都是对 copyright 的某种矫正，只是矫正的力度不同，总体而言，它们的目的都是促进知识作品的传播，增进整体的社会利益。</p><p>在互联网时代，它们随处可见（可能不直接用这些叫法），极大地促进了自由软件与开源社区的发展。</p><p><img src="https://oscimg.oschina.net/oscnet/b1a7cbee84994a3cb505a48768ae18eb77c.jpg" alt></p><p>上图中的 6 种主流的开源许可证，你应该有所耳闻吧，在我们免费使用的各种软件或代码库中，很可能就藏着它们的身影。</p><p>右侧的 3 种（BSD、MIT、Apache）属于宽松式许可证（permissive license），对使用者几乎没有限制，接近于极端的 All Rights Reversed（撤销所有权利）。</p><p>左侧的 3 种（LGPL、Mozilla、GPL）则属于 copyleft 许可证，仅保留了少数关键的权利，此外不予限制。</p><h2 id="三、知识共享许可协议"><a href="#三、知识共享许可协议" class="headerlink" title="三、知识共享许可协议"></a>三、知识共享许可协议</h2><p>经过一段简要的铺垫，几个概念算是讲清楚了，接着看 Python 之父在本文开头所提到的那种许可协议吧。</p><p>CC 也是 copyleft 的一种，全称为 <code>Creative Commons license</code> ，译作 <strong>知识共享许可协议</strong> ，发布于 2002.12.16，目前已发展到 4.0 版本。</p><blockquote><p>官网地址：<a href="https://creativecommons.org/licenses/" target="_blank" rel="noopener">https://creativecommons.org/licenses</a></p></blockquote><p>CC 协议是一个统称，它有不同的实指，区别在于所保留的权利不同。</p><p>它声明的基本权利有 4 种：</p><ul><li>署名（Attribution，简写 BY）：注明原作者</li><li>相同方式共享（ShareAlike，简写 SA）：允许演绎，但需以相同许可协议发布</li><li>非商业性使用（Noncommercial，简写 NC）：不得用于商业目的</li><li>禁止演绎（No Derivative Works，简写 ND）：不得演绎，也作”非衍生”</li></ul><p><img src="https://oscimg.oschina.net/oscnet/3f64c39d33727d9cbd7db9650ecc714e7ab.jpg" alt></p><p>（注：还有一些基本要求，例如，使用者不可添加法律条款或技术手段来限制别人的合理使用。限于篇幅，这些内容就不多介绍了，详见官网。）</p><p>按照是否保留某项权利，它们可以排出 16 种组合，其中 4 种因为同时包含”SA”与”ND”，互斥而无效，还有 5 种不要求署名，基本没人使用。</p><p>所以，只有 7 种常用的 CC 协议：</p><p><img src="https://oscimg.oschina.net/oscnet/f84440f4f5f671f67d85e3256e8ece1df61.jpg" alt></p><p>上图只列出了 6 种，还有 1 种特殊的是 CC0 协议，它不要求任何权利，是”No Rights Reserved”，无版权要求，属于自由版权。</p><p>这些协议被广泛用于各类互联网产品中（主要是网站、视频、图片或文章），例如：</p><ul><li>CC0：Pexels图片、Unsplash图片、SoundCloud音乐</li><li>CC BY-SA：维基百科内容、Stack Overflow内容</li><li>CC BY-NC-ND：TED 演讲视频</li><li>CC BY-NC-SA：可汗学院视频、斯坦福公开课视频</li></ul><p>很多个人网站或文章，基本采用了”CC BY-NC-ND”或者”CC BY-NC-SA”之一。Guido 最初给我回复的是 ND 这种，后来才澄清为 SA。</p><p><img src="https://oscimg.oschina.net/oscnet/ff95905b37d03359d14cb70f47df3f4ca07.jpg" alt></p><p>这几种权利中，BY（署名）是不言而喻的，也就是我们常见的”转载时请注明作者和出处”，体现了对于原作者的最起码的尊重。</p><p>另外的 3 种权利，值得再细细地辨析一下：</p><ul><li>SA/ND，是否允许演绎。演绎包括”再混合、转换或基于该作品创作”，基本可概括为不允许改动原作品，而且不允许翻译（这点很关键）</li><li>NC，非商业用途。什么算是商业用途呢？官方笼统地概括为”出于商业利益或金融补偿”的用途，还说这取决于具体情况和使用者的意图</li></ul><h2 id="四、关于翻译的几个问题"><a href="#四、关于翻译的几个问题" class="headerlink" title="四、关于翻译的几个问题"></a>四、关于翻译的几个问题</h2><p>本文缘起于翻译，快结束了，我再补充几个跟翻译相关的问题吧，并附上我的理解。</p><p><img src="https://oscimg.oschina.net/oscnet/f0f73b5d8c4c0a2744a129bff8d55183878.jpg" alt></p><h3 id="1、翻译别人的文章会导致侵权么？"><a href="#1、翻译别人的文章会导致侵权么？" class="headerlink" title="1、翻译别人的文章会导致侵权么？"></a>1、翻译别人的文章会导致侵权么？</h3><p>翻译权是著作财产权的一种，属于著作人所有，它的基本含义是：著作权人享有自行翻译其作品和允许他人翻译其作品的权利。所以，未经作者授权或者许可的作品，就不要翻译了，翻译了也不应发布，否则就侵权了。</p><h3 id="2、CC-协议下的作品可自由翻译么？"><a href="#2、CC-协议下的作品可自由翻译么？" class="headerlink" title="2、CC 协议下的作品可自由翻译么？"></a>2、CC 协议下的作品可自由翻译么？</h3><p>如果作者许可的是 ND，即禁止演绎，那么，该作品是不允许被翻译的；如果许可的是 SA，即是允许翻译，但注意需”以相同方式共享”，即翻译后的作品需支持他人继续作出演绎；其它情况，对翻译行为不作约束。</p><h3 id="3、译者对翻译的作品拥有版权么？"><a href="#3、译者对翻译的作品拥有版权么？" class="headerlink" title="3、译者对翻译的作品拥有版权么？"></a>3、译者对翻译的作品拥有版权么？</h3><p>根据我国《著作权法》第十二条所述：</p><blockquote><p>改编、翻译、注释、整理已有作品而产生的作品，其著作权由改编、翻译、注释、整理人享有，但行使著作权时不得侵犯原作品的著作权。</p></blockquote><p>即在不侵犯原作版权的前提下，翻译作品的版权归译者所有。</p><p><img src="https://oscimg.oschina.net/oscnet/40430a04ba347642d1fb08265a4e387596d.jpg" alt></p><h3 id="4、翻译的作品算是原创么？"><a href="#4、翻译的作品算是原创么？" class="headerlink" title="4、翻译的作品算是原创么？"></a>4、翻译的作品算是原创么？</h3><p>从狭义的概念上看，翻译属于二次创作、属于衍生、其”灵魂”是由原作品所赋予的，所以不能算是原创。原创应指独立创作、全新发明，所以在此含义上看，翻译不算是原创。</p><p>但是，还有一种具体的情境，例如在公众号发文时标注的”原创”，此原创并非是要作概念上的区分，而是要保护作者的版权，防止文章被人侵权转载（甚至是被抢去标注原创），在此情境下，我认为可以标”原创”（有”翻译”标记就更好了）。</p><p><strong>所以，综合来看，翻译作品不是原创，但在特殊情况下，又可以是”原创”。</strong></p><h3 id="5、如何理解非商业用途呢？"><a href="#5、如何理解非商业用途呢？" class="headerlink" title="5、如何理解非商业用途呢？"></a>5、如何理解非商业用途呢？</h3><p>维基百科对于商业行为概括有 4 个要点：（1）以营利为目的（2）发生交易行为（3）出于双方自愿（4）符合法律规范</p><p>CC 协议所约定的 NC 条款，应参照如上解释。所以，基于 NC 条款许可的翻译作品，不应用于知识付费，也不应用于其它买卖交易，此外， <strong>一般而言，</strong> 捐助或者赞赏等行为都不算是商业用途，则不受此限制。</p><table><thead><tr><th><strong>原文链接</strong></th><th>👇</th></tr></thead><tbody><tr><td><a href="https://my.oschina.net/u/4051725/blog/3096231" target="_blank" rel="noopener"><img src="https://static.oschina.net/new-osc/img/logo_osc_new.svg" alt></a></td><td><a href="https://my.oschina.net/u/4051725/blog/3096231" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/08/26/dr53gHwPxTSa7sX.jpg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;： 豌豆花下猫，生于广东毕业于武大，现为苏漂程序员，有一些极客思维，也有一些人文情怀，有一些温度，还有一些态度。公众号：Python猫&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>2020年顶级编程语言的统计数据和调查结果如何？</title>
    <link href="https://www.policx.com/news/2020/"/>
    <id>https://www.policx.com/news/2020/</id>
    <published>2019-08-19T00:21:23.000Z</published>
    <updated>2019-08-26T10:03:48.018Z</updated>
    
    <content type="html"><![CDATA[<p>比较编程语言是一件非常复杂的事情，所以有许多图形插图/笑话试图象征编程语言 。</p><a id="more"></a><p><img src="https://i.loli.net/2019/08/22/KIq7s2zZQ5CMFhV.jpg" alt><br>我发现很少，我正在开始这篇文章。</p><p>简单来说， 编程语言使人类能够指导和控制机器。 因此，很自然会有这么多语言试图使这个过程更加强大和简单。 由于这个原因，有数百种编程语言 ，其中许多编程语言现在已经不再使用，很少有将在未来几年过时，然后有一些语言将继续并证明其在未来几年的使用和然后有新的编程语言争取接受。</p><p>本文将介绍顶级编程语言的趋势，这些趋势将在2020年继续。 为了预测2020年 编程语言的趋势，本文根据编程语言使用来自真实调查 ，各种收集的统计数据 ，搜索结果和薪资趋势的数据。 本文将帮助新学习者选择一种编程语言进行学习和专家学习，这将有助于决定切换到另一种语言或继续使用他的专业语言。</p><p>在下一节中，我准备了两个表，总结了过去五年（2015-19）中编程语言的流行趋势。 该数据来自<a href="https://insights.stackoverflow.com/survey/" target="_blank" rel="noopener">2015 - 19年的 Stackoverflow 人气调查</a> 。 为了清楚准确地理解，编程语言分为两组，<strong>第一组是 2000 年以前诞生的语言，第二组是 2000 年以后诞生的语言。</strong>  选择2000作为边界只是随机的，但对于理解这两组的编程趋势非常有帮助。 该表还列出了这些编程/脚本语言的起源年份和主要或记录的目的。</p><!-- ![mark](https://gitee.com/policx/im/raw/master/images/gOeqWL.png) --><table><thead><tr><th>语言</th><th>起源</th><th>2015年</th><th>2016</th><th>2017年</th><th>2018</th><th>2019</th><th>主要目的</th></tr></thead><tbody><tr><td><strong>Javascript</strong></td><td>1995年</td><td>54.4％</td><td>55.4％</td><td>62.5％</td><td>71.5％</td><td>67.8％</td><td>Web开发，动态内容，客户端和服务器端</td></tr><tr><td><strong>Java</strong></td><td>1995年</td><td>37.4％</td><td>36.3％</td><td>39.7％</td><td>45.4％</td><td>41.1％</td><td>企业应用</td></tr><tr><td><strong>Bash/Shell</strong></td><td>1971年至1979年</td><td>-</td><td>-</td><td>-</td><td>40.4％</td><td>36.6％</td><td>自动化和系统管理员</td></tr><tr><td><strong>Python</strong></td><td>1991年</td><td>23.8％</td><td>24.9％</td><td>32.0％</td><td>37.9％</td><td>41.7％</td><td>一般用途</td></tr><tr><td><strong>PHP</strong></td><td>1995年</td><td>29.7％</td><td>25.9％</td><td>28.1％</td><td>31.4％</td><td>26.4％</td><td>Web开发，服务器端</td></tr><tr><td><strong>C ++</strong></td><td>1980至1983年</td><td>20.6％</td><td>19.4％</td><td>22.3％</td><td>24.6％</td><td>23.5％</td><td>一般用途</td></tr><tr><td><strong>C</strong></td><td>1972年</td><td>16.4％</td><td>15.5％</td><td>19.0％</td><td>22.1％</td><td>20.6％</td><td>通用，低级编程</td></tr><tr><td><strong>Ruby</strong></td><td>1995年</td><td>8％</td><td>8.9％</td><td>9.1％</td><td>10.3％</td><td>8.4％</td><td>Web开发</td></tr><tr><td><strong>R</strong></td><td>1993年</td><td>-</td><td>-</td><td>4.5％</td><td>6.0％</td><td>5.8％</td><td>统计计算</td></tr><tr><td><strong>Objective-C</strong></td><td>1986年</td><td>7.8％</td><td>6.5％</td><td>6.4％</td><td>7.3％</td><td>4.8％</td><td>一般用途</td></tr></tbody></table><p> <strong>观察</strong>：</p><p>除了Python之外，从2018年到2019年所有语言的流行度都在下降。</p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>Python是自过去五年以来不断上升的唯一语言。 它是一种通用语言，因此有人希望在2020年只学习一门编程，并希望涵盖更多的软件开发领域，然后可以选择Python 。</p><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><p>Java正在上升但在2019年下降，原因是Kotlin在Android平台上获得了普及。 Java是编程语言的一个很好的选择，但现在它在Oracle下面 ， 谷歌正在推广Kotlin，因此它处于冲突区域。 事实上，由于其开发人员基础，框架和遗留应用程序，大量公司正在使用Java并继续使用Java 。</p><h4 id="C-C"><a href="#C-C" class="headerlink" title="C / C ++"></a>C / C ++</h4><p>C和C ++仍然保持着大约20％，并且由于其固有的功能和遗留系统，它将会存在。</p><h4 id="JAVASCRIPT"><a href="#JAVASCRIPT" class="headerlink" title="JAVASCRIPT"></a>JAVASCRIPT</h4><p>JavaScript受欢迎程度可归因于流行的JavaScript库和node.js等框架的增长.JS是动态网站的语言，由于其积极的开发， Mozilla的支持和惩罚，它将成为未来几年的首选。 图书馆和框架 。 所以，如果有人想要进行Web开发，那么javascript是必须的。</p><h4 id="R"><a href="#R" class="headerlink" title="R"></a>R</h4><p>R近年来越来越受欢迎，原因在于数据分析的增长和普及。 它被数据科学家使用，但与Python相比，它已经成为通用语言，并且拥有大量数据科学库和模块的活跃开发人员。 因此，如果他们必须只选择其中一个，那么人们可以更喜欢Python而不是数据科学中的想要载体，那么学习两者都是一个不错的选择。</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>与PHP一样， Ruby也面临来自JavaScript甚至Python的激烈竞争，以建立后端Web开发编程语言。 所以，再次对于web开发javascript和Python （服务器端（Flask，Django等）将是一个不错的选择，并将提供比Ruby更多的域灵活性。</p><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>在2019年 ， PHP流行度急剧下降，这可以追溯到服务器端对javascript和Python的接受程度。 因此，如果有人想要进行服务器端Web开发，那么PHP仍然是一个很好的选择，有大量流行的框架，如CakePHP ， Codeigniter等，否则选择通用编程语言会更好。</p><h4 id="OBJECTIVE-C"><a href="#OBJECTIVE-C" class="headerlink" title="OBJECTIVE-C"></a>OBJECTIVE-C</h4><p>在Apple迁移到Swift语言之前， Objective-C是Apple软件（如MacOS ， iOS等）的主要语言。 因此，这种转变反映在两种语言的流行中，即Objective-C的受欢迎程度下降，而Swift的普及正在上升。 所以，如果有人想成为Apple产品的开发者，那么Swift应该是首选语言。</p><p><img src="https://gitee.com/policx/im/raw/master/images/w6fHk7.png" alt></p><p> <strong>观察</strong>：</p><p><strong>Swift</strong><br>Swift取代了Objective-C作为Apple相关软件和应用程序的主要语言。 由于苹果公司支持和推广它，因此自成立以来受欢迎程度越来越高，而Apple将继续使用它，所以如果有人正在寻找特定于Apple的开发平台，那么Swift将成为一种必须知道的编程语言。 这主要是供应商和产品特定的语言，在Apple的生态系统之外使用率非常低。</p><p><strong>Go</strong><br>Go（Golang）越来越受到Google的维护，使用和推广。 Go开发的动机是解决对一些流行语言的批评，并在一个地方保持最佳状态。 自2017年以来， Go的受欢迎程度越来越高，并且在谷歌的支持下，它将在未来几年内享受到这一点。 谷歌也将Go作为新项目的主要语言并用Go取代其他语言，这种趋势在未来几年将变得有用和重要，因此人们可以选择Go作为一种新的编程语言。</p><p><strong>Kotlin</strong><br>Kotlin作为Android开发的Java的替代品而被提供，并且它再次得到Google的支持和推广，因此近年来它也受到开发人员的欢迎并越来越受欢迎。 因此，随着Android的增长， Google的支持以及简洁的语法，它将成为Android 应用程序 开发人员的一个选择，是学习Android App 开发人员的不错选择。 Kotlin将成为Android 开发的杰出编程环境。</p><p><strong>Scala</strong><br>Scala试图建立Java的替代品，但在开发人员中并没有得到很好的解决。 它没有来自任何跨国公司的大力支持，认为功能语言和对JVM的依赖并没有提供太大的普及范围。 可能会有稳定的增长，但速度很慢，而且肯定不是一种初学者学习的语言。</p><p><strong>Julia</strong><br>Julia旨在提高“C”的速度和Python的简单性，但奇怪的是，在Stackoverflow 调查中没有发现任何受欢迎程度，但在数据科学领域受到欢迎，并且从长远来看被视为R和Python的挑战者。 当然，朱莉娅会有增长，但仍然， Python或R更适合工作和成长。</p><p><strong>C＃</strong><br>C＃是.NET框架的语言，由Microsoft开发。 它的受欢迎程度在过去几年中基本保持不变，并将继续保持类似的趋势。 这是特定于供应商的语言，因此如果想要在Microsoft开发环境中工作，可以选择此语言。 最近， 微软已开源.NET，因此会出现一些上升趋势，但它又是特定于供应商的，因此不会受到太大影响。</p><p><strong>RUST</strong><br>Rust ， Clojure等是具有用户基础但不那么流行的语言，所以肯定不会有人气的上​​升。</p><hr><h3 id="一张图片说千言万语"><a href="#一张图片说千言万语" class="headerlink" title="一张图片说千言万语"></a>一张图片说千言万语</h3><p>要了解顶级编程语言增长的明显趋势和图景，请通过各种图表来了解它。 图1和图2给出了一个非常清晰的图景，即在旧的语言堆栈中， JavaScript远远领先于其他人，并且信用在网络开发中占据了一席之地，然后C和C ++一起竞争非常接近Java 。 Python在受欢迎程度上越来越高，而且在过去的5年里，只有人气不断增加的语言。 新语言越来越流行，其中大多数语言都受到跨国公司以及微软 ， 谷歌和苹果等IT巨头的支持。</p><p><img src="https://i.loli.net/2019/08/22/QN7rJn1oYyB9bmE.jpg" alt="policx"><br><img src="https://i.loli.net/2019/08/22/sFemgXLqEiYA8R9.jpg" alt="policx"></p><h2 id="喜欢和想要的语言"><a href="#喜欢和想要的语言" class="headerlink" title="喜欢和想要的语言"></a><strong>喜欢和想要的语言</strong></h2><p><img src="https://gitee.com/policx/im/raw/master/images/El36zu.png" alt></p><p><img src="https://gitee.com/policx/im/raw/master/images/XuqkyG.jpg" alt></p><p>从上面的表格和图中，很少有观察结果非常明显，Love of Rust在过去五年中正在增长，而Swift正在失去开发人员的热爱，而Python正处于这两者之间，过去两年中Python已经获益。 另一个独特的观察结果是，5种喜爱的语言中有4种来自2000后的群体，而只有Python是较旧的语言，而Kotlin的爱则是从2017年开始为Android 开发添加Kotlin开始的。</p><p><img src="https://gitee.com/policx/im/raw/master/images/1UYV2x.png" alt>  </p><p>从上表可以看出， javascript和Python开发的愿望在过去几年中不断增长，这反映了人们对语言的热爱和热爱。 Java的数量急剧下降，这是因为Kotlin作为Android应用程序开发的替代品，以及现在拥有Java的Oracle改变了政策。</p><p><img src="https://gitee.com/policx/im/raw/master/images/QgULwt.jpg" alt></p><h2 id="技术和编程语言"><a href="#技术和编程语言" class="headerlink" title="技术和编程语言"></a><strong>技术和编程语言</strong></h2><p><img src="https://gitee.com/policx/im/raw/master/images/XvwWaK.jpg" alt></p><p>在这个图中，可以看到最大的集群用于Web开发和JavaScript ，其各种框架主导着集群，这是JavaScript增长的USP 。 第二大集群是Microsoft 技术和Python 技术 ，它再次清除了对该语言的欢迎和热爱。 Python集群与数据科学技术相关联，这些技术突出了Python的增长故事。</p><h2 id="TIOBE-指数"><a href="#TIOBE-指数" class="headerlink" title="TIOBE 指数"></a><strong>TIOBE 指数</strong></h2><p><a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE</a>索引排名编程语言基于搜索引擎搜索结果 。 搜索引擎和编程语言的选择在其页面中定义。 通过计算最受欢迎的搜索引擎的点击来计算评级。 使用的搜索查询是+“<language> programming”。 在TIOBE索引中， Java在过去二十年中占据主导地位，其中C在过去30年中一直保持着第一和第二的位置。 在过去的二十年里， Python已经走过了漫长的道路，即1999年的第24位，到2019年的第3位。如果有人合并C和C ++，那么它将永远占据第一的位置。</language></p><p><img src="https://gitee.com/policx/im/raw/master/images/MykdeR.jpg" alt></p><p>在新的语言（2000年后）中， Rust的排名上升，即从第33位升至第28位， Julia从第50位升至第39位。 值得注意的是， Kotlin似乎并未接近前20名。</p><h2 id="编程语言（PYPL）索引的流行程度"><a href="#编程语言（PYPL）索引的流行程度" class="headerlink" title="编程语言（PYPL）索引的流行程度"></a><strong>编程语言（PYPL）索引的流行程度</strong></h2><p><a href="https://pypl.github.io/PYPL.html" target="_blank" rel="noopener">PYPL索引</a>是通过分析在Google上搜索语言教程的频率创建的。 搜索语言教程越多，该语言就越受欢迎。 这是一个领先的指标。 原始数据来自<a href="https://trends.google.com/trends/" target="_blank" rel="noopener">Google趋势</a>。</p><p>下图验证了前3种语言是Python ， Java和JavaScript 。 C＃，PHP，C / C ++也是安全的顶级位置，这种趋势再次类似于堆栈溢出和TIOBE索引 。<br><img src="https://i.loli.net/2019/08/22/TZGYq1IQHkCnAxg.jpg" alt><br>上图显示，在新的编程语言中，即2000年后的Kotlin ， Go ， Rust和Julia在排名中上升。<br><img src="https://i.loli.net/2019/08/22/iC8ARK1HezWkGV3.jpg" alt></p><h2 id="就业市场与薪酬"><a href="#就业市场与薪酬" class="headerlink" title="就业市场与薪酬"></a><strong>就业市场与薪酬</strong></h2><p>薪酬取决于产品的地理区域和需求，基于编程语言的薪资比较只是预测或估计薪资趋势的工具。 我们根据流行调查的编程语言汇总了工资，即2018年的Dice薪资调查和2018年和2019年的Stack-overflow调查。</p><p><img src="https://gitee.com/policx/im/raw/master/images/fG2jtd.png" alt></p><p>从上表可以看出，从这两项调查中可以看出， <strong>Go/Golang</strong> 在市场上是一项薪酬非常高的工作，在<a href="https://insights.stackoverflow.com/survey/2019" target="_blank" rel="noopener">2019年的Stack-overflow调查</a>和2018年Salary Survey薪资调查中 ，甚至在高薪工作中排名第一。 现在，原因很简单， Go是谷歌支持的语言，主要用于谷歌和谷歌想要推广这种语言，所以高薪可以连接到谷歌工资单。 有一点很清楚，价格弹性是一个经济术语，它提供了不同的场景，例如产品数量增加，价格，奢侈品和品牌产品成本，高产品可用性降低了价格。 很明显，全球平均工资不是选择语言的好选择。 例如，一种接近灭绝的编程语言，但遗留系统很少，因此维护这些公司往往提供非常高的薪酬，但这些语言中的职位数量总是很少。 在其他情况下，主流语言提供了大量的工作岗位，因此平均工资下降。</p><p>因此，作为结束语，很容易预测语言趋势，但只选择一种语言来学习是一个非常困难的选择，完全取决于个人选择和他们未来的计划，例如，如果你想在Web开发中工作不能忽视Javascript ，如果你想使用Apple的产品你现在不能忽视Swift ，如果你的品味是系统级编程，那么C和C ++是你的朋友， Python让你在很多领域跑得更快，目前亲爱的数据科学 。 您会看到每种语言都会带您踏上不同的旅程。 选择目的地，然后使用该路径的语言进行驾驶。</p><p><strong>-END-</strong></p><table><thead><tr><th><strong>转载声明：本文转载自「编码无限」</strong></th></tr></thead><tbody><tr><td><a href="https://codinginfinite.com/top-programming-languages-2020-stats-surveys/" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/08/22/kGbUXaQCmPZqAgf.jpg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比较编程语言是一件非常复杂的事情，所以有许多图形插图/笑话试图象征编程语言 。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>Dice 称这  5 种编程语言未来可能各自成王</title>
    <link href="https://www.policx.com/news/DiceInsightsB/"/>
    <id>https://www.policx.com/news/DiceInsightsB/</id>
    <published>2019-08-16T08:14:18.000Z</published>
    <updated>2019-08-16T09:00:26.297Z</updated>
    
    <content type="html"><![CDATA[<p>上个月，我们曾报道过一篇”<a href="https://www.policx.com/news/DiceInsightsA">Dice 称这 5 种编程语言可能衰落</a>“的文章，它基于 RedMonk 和 TIOBE 等公司的数据推测的，结果引起了广泛讨论。<a href="https://insights.dice.com/2019/08/12/5-programming-languages-future-greatness/" target="_blank" rel="noopener">Dice Insights</a> 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。经过了半个月，Dice 依靠更大的数据趋势来做出预测，又发布一个更大胆的预测续集，关于 5 种在未来可能会有更多使用的编程语言。</p><a id="more"></a><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a><strong>Swift</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/mnC0iO.jpg" alt="Swift"><br>苹果想要放弃 Objective-C，它是一种有着 35 年历史的编程语言，用于为苹果生态系统构建应用程序。苹果想让 Swift 来取代它，Swift 发布与五年前。根据分析公司 RedMonk 的长期语言排名，Swift 自创建以来的使用量迅速上升。</p><p>虽然如此，但 Objective-C 仍然有在使用，这主要归功于过去三十年中产生的大量遗留代码（legacy code）。不过，苹果已经不会对它抱有任何期待，Swift 才是为苹果的应用程序提供动力的主打语言，苹果在跨平台应用上只可能会加速这门编程语言的发展。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a><strong>Kotlin</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/kcvzdY.jpg" alt="Kotlin"><br>Kotlin 正在上升。Kotlin 来源于一个岛屿的名字，全称是 Kotlin Island，是英语「科特林岛」之意，十年前，Kotlin 还是俄罗斯岛屿，现在它变成编程语言，JetBrains 公司开发了它，不过它受关注的原因，很大程度上归功于 Google，Google 将它作为 Android 的一流开发语言。</p><p>可以说，通过选择 Kotlin，Google 减少了对 Java 的依赖。而且 Java 与 Oracle 发生了巨大法律纠纷，但是不管谷歌的律师是否在推动该公司对 Kotlin 的支持，毋庸置疑的一点，因为它的功能和灵活性，许多开发人员也开始喜欢这种语言。</p><p>早在 2018 年，Pusher 就发起了一项<a href="https://pusher.com/state-of-kotlin" target="_blank" rel="noopener">开发人员调查</a>，发现 Kotlin 的使用量正在天文数字般的增长，这很大程度上是因为 Android。Pusher 补充说明：</p><blockquote><p>很大一部分开发人员，他们的工作和其他项目的程序，使用的是 Kotlin。大多数人都喜欢使用它，因为它的特性，80% 以上的开发人员都喜欢它的空安全性，其次是扩展函数、与 Java 的简化互操作性和数据类。</p></blockquote><h3 id><a href="#" class="headerlink" title></a><img src="https://oscimg.oschina.net/oscnet/d4ff57d5e175ffaa925bf25cc075cd1af7b.jpg" alt></h3><p>对 Kotlin 来说，除了安卓开发之外似乎无路可走了。所以它的最大的问题是，是否能超越 Android 生态系统而开拓新的领域。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/UX6DG4.jpg" alt="Python"><br>Python 是一种强大的语言，为世界各地的开发人员提供了多种用途。但是根据 <a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener">TIOBE 指数</a>(每月更新一次)，Python 的排名还在继续攀升。并且开发人员和技术专业人员也不断发现 Python 的新用途，包括数据分析和机器学习。</p><p>Python 现在也已经有了庞大的用户基础，并且它深深地嵌入到了众多的业务中，所以 Python 不太可能在短期内消失。唯一的问题是这种编程语言还能够持续增长多少，以及它接下来将还能抓住哪些行业。</p><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a><strong>Groovy</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/YNuq0e.jpg" alt="Groovy"><br>Groovy 有广泛的 IDE 支持、与 Java 的相似性以及与流行的开源自动化服务器 <a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a> 的集成支持下，在 TIOBE 的排名是上升的。它已经成为相当多的系统中的”编程语言粘合剂”，它的未来似乎是光明的。</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><strong>TypeScript</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/fWCfFh.png" alt="TypeScript"><br>TypeScript 是 JavaScript 的一个超集，一些开发人员认为它不是一种”完整”的语言，因为它可以转换到 JavaScript。但不管如何说它，<a href="https://redmonk.com/jgovernor/2019/05/07/typescriptexploding/?utm_source=rss&utm_medium=rss&utm_campaign=typescriptexploding" target="_blank" rel="noopener">RedMonk</a>和 <a href="https://octoverse.github.com/" target="_blank" rel="noopener">GitHub</a> （如下图，上升至第七名）的十月报告 TypeScript 排名都是严重上升的。去年夏天，TIOBE 就表示，TypeScript 已经开始侵吞 JavaScript 的市场份额。</p><p><img src="https://oscimg.oschina.net/oscnet/b036983a1d5e98be8b291b0b4df808806f0.jpg" alt></p><p>不管你是否相信，TypeScript 是一种新的、改进的 JavaScript，它将取代这个更老的语言，而且许多技术专业人士认为 TypeScript 在未来几年里还有发展的空间。</p><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://www.oschina.net/news/109114/dice-consider-five-language-great-future" target="_blank" rel="noopener"><img src="https://static.oschina.net/new-osc/img/logo_osc_new.svg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上个月，我们曾报道过一篇”&lt;a href=&quot;https://www.policx.com/news/DiceInsightsA&quot;&gt;Dice 称这 5 种编程语言可能衰落&lt;/a&gt;“的文章，它基于 RedMonk 和 TIOBE 等公司的数据推测的，结果引起了广泛讨论。&lt;a href=&quot;https://insights.dice.com/2019/08/12/5-programming-languages-future-greatness/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dice Insights&lt;/a&gt; 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。经过了半个月，Dice 依靠更大的数据趋势来做出预测，又发布一个更大胆的预测续集，关于 5 种在未来可能会有更多使用的编程语言。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
      <category term="program" scheme="https://www.policx.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>善用佳软--aiXcoder</title>
    <link href="https://www.policx.com/Software/aixcoder/"/>
    <id>https://www.policx.com/Software/aixcoder/</id>
    <published>2019-08-15T12:55:41.000Z</published>
    <updated>2019-08-15T13:43:41.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 从程序员到数据工程师，编写程序代码是一项基本功，但是编写冗长代码的过程也极大地消耗了开发者的耐心。近来，有不少关于代码补全工具的消息爆出，例如，来自美国的 Kite，来自加拿大的 TabNine 等，一时间获得了不少程序员的关注。但其实很多人还并不知道，在这些国外产品不断被媒体推送的背后，有一款能力更为强大、更早将深度学习应用于代码补全的产品，一款源自中国的工具——aiXcoder，它的研发者们来自于北京大学。</p></blockquote><a id="more"></a><p>在本文中，机器之心采访了项目总负责人北京大学计算机科学技术系副教授李戈，请他为读者朋友解读自动代码补全背后的技术，以及 aiXcoder 背后的技术特性和优势。aiXcoder 官网：<a href="https://www.aixcoder.com/#/" target="_blank" rel="noopener">https://www.aixcoder.com/#/</a></p><p><strong>aiXcoder 的代码补全效果</strong></p><p>我们先看看写 TensorFlow 时的代码补全效果：</p><p><img src="https://gitee.com/policx/im/raw/master/images/i4YcMg.jpg" alt></p><p>如上所示，aiXcoder 在 TensorFlow 的代码环境下能够直接「猜测」到模型建立后的一系列代码流程。例如，在定义了 loss 之后需要定义 optimizer，之后需要 train_op、init 方法，然后最终定义模型的保存方式 saver，以及开始运行计算图。这样一个流程基本上是深度学习开发者所知晓的，但是按照流程写下来非常繁琐。在 aiXcoder 的提示下，开发速度得到了提升。</p><p>aiXcoder 支持 Java、C++/C、Python、PHP、JavaScript 等语言，以插件的方式集成到现有的 IDE 中，如 Pycharm、Android Studio、VS Code、Eclipse、Webstorm、Sublime 等，插件的背后是一个强大的云端深度学习引擎。</p><p>针对开发者，该产品目前分为社区版、专业版和企业版。社区版是完全免费的，专业版也可以通过分享而免费获得。它们间的不同之处在于模型会不会继续学习，社区版主要利用事先训练好的公用模型做预测，而专业版则会根据用户的代码习惯及结构作进一步的调整。企业版是 aiXcoder 功能最为强大的版本，它能够在企业内部的私有云中进行部署，并能够利用企业自己的代码来进行模型的优化训练，从而具有更高的准确率和运行性能。</p><p><strong>aiXcoder 用起来怎么样</strong></p><p>百闻不如一见，机器之心也对 aiXocder 进行了使用测试。</p><p>机器之心在 Pycharm 上试用了社区版/专业版，它们都是需要在线推断。不同的地方在于专业版还需要额外的内存，因为每一个 Pro 用户都需要额外的缓冲区来储存模型「学到的」用户习惯。当然，Pro 用户的缓冲区是是只有该插件能访问的。</p><p><strong>使用体会</strong></p><p>一般而言，当我们选择 Python 和 PyCharm 时，代码补全就自然用 IDE 自带的工具。使用 aiXcoder 第一个感受是它比自带的补全工具灵活得多，因为以前的补全主要体现在 Python 函数或其它包的 API，而 aiXcoder 还会预测变量名是什么、运算是什么、想调用的函数又是什么。</p><p>虽然代码补全的推断过程全是在云端完成的，但在我们的使用中，一般网络环境甚至 4G 都能有实时的反馈，所以补全速度上基本和 Pycharm 自带的工具差不多。李戈教授表示，目前 aiXcoder 绝大多数都能在 200ms 左右得到反馈，有部分地区的用户由于网络延迟问题可能会感觉到卡顿，aiXcoder 正在全国各个主要城市部署服务器，以提升用户体验。同时，aiXcoder 团队也特别关注模型压缩技术，希望把基于 CPU 的推理运算时间压缩到可接受的程度，从而推出能够在 CPU 上运行的本地版。</p><p>总体而言，aiXcoder 提供的补全功能在预测变量名、函数名或关键字等效果上确实非常灵活，而且它还会学习开发者的代码风格与编程模式，因此效果还是挺好的。</p><p>如下是自动补全的一些候选，一些函数名称可能是开发者之间经常使用的，因此得到了推荐：</p><p><img src="https://gitee.com/policx/im/raw/master/images/Wb3qeB.jpg" alt></p><p>对于一些变量，aiXcoder 可根据变量类型提出该变量可能的操作，比如，对于下图的变量「m」，aiXcoder 提出了一个对字符串进行增加的代码：<br><img src="https://gitee.com/policx/im/raw/master/images/odcZX3.jpg" alt="pic"></p><p><strong>对比测评</strong></p><p><img src="https://gitee.com/policx/im/raw/master/images/17llLZ.jpg" alt="pic"></p><p>aiXcoder 官方也将产品和其他代码补全工具进行了对比，包括 Kite 和 TabNine 等。</p><p>在对比过程中，aiXcoder 会使用 Kite 或 TabNine 官方提供的示例代码，并测试完成这段代码到底需要多少次按键。结果表明，aiXcoder 较其他插件在效率上提升 1.5 倍以上。</p><p><strong>aiXcoder 是如何打造的</strong></p><p>能够实现高效代码补全的 aiXcoder，背后有着强大的技术支撑。据李戈教授介绍，aiXcoder 很早就试过了语言模型，将代码视为一种语言从而直接建模，这就和 Deep TabNine 一样。但是研究者很快发现，只有语言模型是行不通的，它总会提出一些毫无意义、很不科学的补全建议。为此，aiXcoder 融合了基于序列的程序代码语言模型、基于抽象语法树和程序逻辑关系的图神经网络等方法，共同打造一个完整的系统。</p><p><strong>为什么直接生成代码是困难的</strong></p><p>如果深度学习模型能根据开发者的意图，以端到端的方式直接生成对应的代码，那么这样的模型会很「优雅」。但是经过研究发现，这样的任务需求是很难实现的，这和任务本身所依赖的数据的性质有关系。</p><p>李戈教授从机器学习所依赖的数据性质的角度，对代码生成任务和传统的图像处理任务、自然语言处理任务的不同，给出一种较为形象化的解释。</p><p><img src="https://gitee.com/policx/im/raw/master/images/uynX38.jpg" alt="pic"></p><p>对于图像识别或图像分类任务而言，机器学习的目标是建立一个连续的数据集（图像数据）到一个近乎连续的、有着接近清晰边界的数据集（标签）之间的映射关系。</p><p>这样一来，由于图像数据异常的稠密，而标签集又有足够清晰的边界，那么这就相当于一个标签拥有大量的数据可以学习。这样的映射关系是比较容易建立的，这也是机器学习中和图像相关的任务相对较为容易完成的原因。</p><p><img src="https://gitee.com/policx/im/raw/master/images/X6IyEn.jpg" alt="pic"></p><p>对于自然语言处理任务而言，机器学习需要从一个较为连续的（离散度高于图像）、有着较清晰边界的数据集建立与另一个较为连续的、有着较清晰的边界的数据集之间的映射关系。</p><p>而由于自然语言处理中的文本数据相比图像数据更为稀疏，因此自然语言处理相关的任务更难取得较好的模型性能。</p><p><img src="https://gitee.com/policx/im/raw/master/images/Ezm4TN.jpg" alt="pic"></p><p>但是在代码生成方面，从编程者的意图（intent）生成程序代码的问题，可以看做是「程序员意图空间」到「程序代码空间」的映射，其中意图可以是由自然语言描述的信息。如上图所示，这是从一个较为连续的、有着较清晰边界的数据集，向一个更加离散而没有清晰边界的数据集进行映射。</p><p>换句话说，尽管代码生成的意图较为清楚，但是实现该意图的代码数据却比较稀疏，而且即便对于相同的意图，其对应的实现代码之间仍存在较大差距，因此这样的任务是非常难学习的。</p><p>为此，在 aiXcoder 的实际实现中，对不同应用领域的代码都采用了特定的模型，它们仅使用该领域的数据进行训练。例如，对 TensorFlow 或 PyTorch 等框架也有其特定的代码补全模型。这样做的主要目的就是加强程序分布的稠密性，在特定领域下，代码分布更加接近连续性。可见，根据编程者的「意图」来「直接」生成完整代码是非常困难的，但李戈教授表示，可以用类似的技术来辅助人类程序员来编写代码，我们可以从程序员已经写下的代码中获取程序员的「编程意图」，然后综合分析代码，的结构信息、变量引用信息、API 序列信息、继承关系信息等等，以自动生成后续代码。然而，在这个过程中，只有语言模型是远远不够的，还需要对很多其它代码特征进行分析，才能做好生成式的代码补全。 <strong>单纯的预训练语言模型又怎么样？</strong></p><p>提起代码补全，有些人可能会下意识的认为这仅仅是一个普通的语言建模任务，模型只需要根据开发者之前写的代码预测之后的代码即可。因此使用最先进的预训练语言模型，再在代码数据上进行微调说不定是一种好方法。</p><p>但是李戈教授表示，这样的想法是远远不够的。预训练语言模型在代码补全任务中效果不佳，主要是因为代码补全任务本身存在诸多不同于自然语言分析任务的挑战。</p><p>首先是代码文本中存在的语义抽象性问题。代码的语义（功能语义）与其字面表示之间存在更大的差距。我们无法根据字面确定代码的准确语义。例如，在代码中，只改变一个字符就有可能完全改变整行代码的功能，因此处理代码的语言并准确提取其含义相比自然语言处理任务更棘手。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(&apos;word_ids.txt&apos;,&apos;r&apos;)f = open(&apos;word_ids.txt&apos;,&apos;w&apos;)</span><br></pre></td></tr></table></figure><p><em>上图所示，在 Python 代码中，打开某个文件时使用「r」和「w」会实现完全不同的功能。</em></p><p>此外，代码的功能语义难以进行具体的表达和刻画，而且代码功能语义的表达方式多种多样。例如，有多种代码的形式文本用于实现某个功能，不能说某一种代码是对的而另一种是错的。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_a = [] for i in items:     result = test(i)     list_a.append(result) list_a = [test(i) for i in items]</span><br></pre></td></tr></table></figure><p><em>如图所示，实现 list_a 的代码可以是多种多样的，但语言模型会将它们学习为完全不同的表征。</em></p><p>同时，代码文本本身的结构非常复杂。例如，代码的语义与代码结构（如行与行的缩进）之间存在较大的关联性，代码语义依赖于代码结构进行表达。这是预训练语言模型难以表示的特征。</p><p>最后，代码具有演化性的特征。代码较自然语言的迭代速度更快，因此预训练语言模型不能够及时捕捉演化特征。</p><p>考虑到代码语言中的诸多特性，单纯的预训练语言模型无法得到非常好的效果。</p><p><strong>核心技术</strong></p><p>既然单独的语言模型不行，那么 aiXcoder 又结合了哪些技术，它又是靠什么来补全代码的？总体而言，aiXcoder 主要依赖于其特有的对程序代码进行学习的深度神经网络模型，该模型能够对程序的如下几类特征进行分析：</p><ol><li>程序的结构语义特征：程序语言是一种结构性很强的语言，程序的结构信息也体现着程序的语义。例如，抽象语法树是对代码进行解析的一种较为通用的结构，它体现了代码的语义特征，aiXcoder 便充分利用了抽象语法树，对程序员已经写下的代码的语义进行解读。</li></ol><ol start="2"><li>程序元素间的逻辑关系：程序代码的不同元素之间存在着不同的关系，例如程序变量之间的引用关系、类之间的继承关系、方法与参数之间的调用关系等等。程序本身又可以表示为多种图，例如控制流图、数据流图、调用关系图等等。aiXcoder 借助图神经网络能够对程序元素之间的多种关系进行建模，从而能够对程序元素之间的复杂关系进行分析和推理。</li></ol><p><img src="https://gitee.com/policx/im/raw/master/images/Trw7pQ.jpg" alt="pic"></p><ol start="3"><li>程序语言序列模型：当然，程序语言也具有与自然语言相似的一面，因此可以利用程序标识符之间的序列关系建立程序语言模型。aiXcoder 也使用了最新的深度学习语言模型对程序中的序列信息进行建模。</li></ol><p><img src="https://gitee.com/policx/im/raw/master/images/n3jWGe.jpg" alt="pic"></p><p>在获得程序代码的各种特征之后，就该把这些特征输入深度神经网络进行分析了，但这并不容易，因为在输入神经网络之前需要把这些特征进行向量化表示。在研究过程中，北京大学提出了一系列解决程序语言成分相量化的办法，并且在国际上最早发表了相关的论文，这些都为 aiXcoder 的构造打下了基础。</p><p><strong>团队介绍</strong></p><p>李戈教授所在的北京大学高可信软件技术教育部重点实验室是国内顶尖的软件科学研究团队，是北京大学计算机软件与理论全国重点学科的主要支撑，其建设历史可以追溯到 1955 年，至今已有 60 多年的学术沉淀和积累。该团队在著名软件科学家杨芙清院士和梅宏院士的带领下，已经成长为该领域国际领先的研究团队。<br><img src="https://i.loli.net/2019/08/15/eMlOtfEGvjDLcy7.jpg" alt="pic"><br>基于深度学习的代码分析与生成一直是李戈教授的研究方向，也是北大高可信软件技术教育部重点实验室重点关注的领域，他们从 2013 年开始就开展了基于深度学习的代码分析研究，从 2015 年开始就将深度学习用于代码生成，是最开始进行相关研究的团队之一。该团队在 AAAI/IJCAI/ACL 等顶会上发表过很多代码生成的相关论文，这也是一大笔技术累积。</p><p>李戈教授是 aiXcoder 创始人，北京大学计算机科学技术系副教授，CCF 软件工程专委会秘书长，斯坦福大学计算机系人工智能实验室访问副教授。主要研究方向：程序分析，程序生成，深度学习。所在研究团队聚焦于基于机器学习概率模型的程序语言处理，在代码功能分析、代码自动补全、代码缺陷检测等方面取得并保持了国际上领先的研究成果。</p><table><thead><tr><th>机器之心原创 👇 <br> <strong>作者：思源、一鸣</strong><br></th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s/NCwBMAkC3uAS9Zr7Olcp7w" target="_blank" rel="noopener"><img src="https://gitee.com/policx/im/raw/master/images/osSojv.jpg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 从程序员到数据工程师，编写程序代码是一项基本功，但是编写冗长代码的过程也极大地消耗了开发者的耐心。近来，有不少关于代码补全工具的消息爆出，例如，来自美国的 Kite，来自加拿大的 TabNine 等，一时间获得了不少程序员的关注。但其实很多人还并不知道，在这些国外产品不断被媒体推送的背后，有一款能力更为强大、更早将深度学习应用于代码补全的产品，一款源自中国的工具——aiXcoder，它的研发者们来自于北京大学。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Software" scheme="https://www.policx.com/categories/Software/"/>
    
    
      <category term="善用佳软" scheme="https://www.policx.com/tags/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF/"/>
    
  </entry>
  
  <entry>
    <title>HarmonyOS 鸿蒙</title>
    <link href="https://www.policx.com/news/HarmonyOS/"/>
    <id>https://www.policx.com/news/HarmonyOS/</id>
    <published>2019-08-10T15:28:21.000Z</published>
    <updated>2019-08-15T01:05:16.651Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>鸿蒙</strong>，中国神话传说的远古时代，传说在盘古昆仑山开天辟地之前，世界是一团混沌的元气，这种自然的元气叫做鸿蒙，因此把那个时代称作鸿蒙时代，后来此一词也常被用来泛指称远古时代。</p><a id="more"></a><h4 id="华为开发者大会于8月9日-8月11日举行，华为消费者业务-CEO、华为技术有限公司常务董事余承东以《全场景时代新体验与新生态》为题发表演讲，正式宣布自有操作系统：鸿蒙。据余承东介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。"><a href="#华为开发者大会于8月9日-8月11日举行，华为消费者业务-CEO、华为技术有限公司常务董事余承东以《全场景时代新体验与新生态》为题发表演讲，正式宣布自有操作系统：鸿蒙。据余承东介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。" class="headerlink" title="华为开发者大会于8月9日-8月11日举行，华为消费者业务 CEO、华为技术有限公司常务董事余承东以《全场景时代新体验与新生态》为题发表演讲，正式宣布自有操作系统：鸿蒙。据余承东介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。"></a>华为开发者大会于8月9日-8月11日举行，华为消费者业务 CEO、华为技术有限公司常务董事余承东以《全场景时代新体验与新生态》为题发表演讲，正式宣布自有操作系统：鸿蒙。据余承东介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。</h4><p><a href="https://static.cnbetacdn.com/article/2019/0809/cb92bd466924d81.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/cb92bd466924d81.jpg" alt></a></p><h5 id="根据余承东的说法，安卓有超过1亿行代码，内核就超过2000万行，但一般用户用到的代码不到8-，整体比较冗余，在IoT时代这既没必要也不需要。"><a href="#根据余承东的说法，安卓有超过1亿行代码，内核就超过2000万行，但一般用户用到的代码不到8-，整体比较冗余，在IoT时代这既没必要也不需要。" class="headerlink" title="根据余承东的说法，安卓有超过1亿行代码，内核就超过2000万行，但一般用户用到的代码不到8%，整体比较冗余，在IoT时代这既没必要也不需要。"></a>根据余承东的说法，安卓有超过1亿行代码，内核就超过2000万行，但一般用户用到的代码不到8%，整体比较冗余，在IoT时代这既没必要也不需要。</h5><h5 id="由此他提出了”微内核”的概念，也是鸿蒙OS的特点之一。区别于”宏内核”，微内核采用同一套操作平台，针对不同硬件能力的产品进行部署，并采用分布式架构，提升效率。"><a href="#由此他提出了”微内核”的概念，也是鸿蒙OS的特点之一。区别于”宏内核”，微内核采用同一套操作平台，针对不同硬件能力的产品进行部署，并采用分布式架构，提升效率。" class="headerlink" title="由此他提出了”微内核”的概念，也是鸿蒙OS的特点之一。区别于”宏内核”，微内核采用同一套操作平台，针对不同硬件能力的产品进行部署，并采用分布式架构，提升效率。"></a>由此他提出了”微内核”的概念，也是鸿蒙OS的特点之一。区别于”宏内核”，微内核采用同一套操作平台，针对不同硬件能力的产品进行部署，并采用分布式架构，提升效率。</h5><p><img src="https://static.cnbetacdn.com/article/2019/0809/3195a18e81ef714.png" alt></p><h5 id="也就是说，手机和车载设备的用途不同，灌入同样系统无必要，但它们可以采用同样的内核，部署不同的界面或功能。"><a href="#也就是说，手机和车载设备的用途不同，灌入同样系统无必要，但它们可以采用同样的内核，部署不同的界面或功能。" class="headerlink" title="也就是说，手机和车载设备的用途不同，灌入同样系统无必要，但它们可以采用同样的内核，部署不同的界面或功能。"></a>也就是说，<a href="https://c.duomai.com/track.php?site_id=242986&euid=&t=https://shouji.jd.com/" target="_blank" rel="noopener">手机</a>和车载设备的用途不同，灌入同样系统无必要，但它们可以采用同样的内核，部署不同的界面或功能。</h5><h5 id="余承东表示，希望未来的操作系统，都使用微内核。据介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。"><a href="#余承东表示，希望未来的操作系统，都使用微内核。据介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。" class="headerlink" title="余承东表示，希望未来的操作系统，都使用微内核。据介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。"></a>余承东表示，希望未来的操作系统，都使用微内核。据介绍，鸿蒙OS是基于微内核的全场景分布式OS，这是分布式架构首次用于终端OS，可以实现跨终端无缝协同体验。</h5><p><a href="https://static.cnbetacdn.com/article/2019/0809/cc82956876a1115.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/cc82956876a1115.jpg" alt></a></p><p><strong>余承东介绍了鸿蒙OS的四大技术特性。</strong></p><p><strong>首先，分布式架构首次用于终端OS，实现跨终端无缝协同体验。</strong></p><h5 id="鸿蒙OS的”分布式OS架构”和”分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。"><a href="#鸿蒙OS的”分布式OS架构”和”分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。" class="headerlink" title="鸿蒙OS的”分布式OS架构”和”分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。"></a>鸿蒙OS的”分布式OS架构”和”分布式软总线技术”通过公共通信平台，分布式数据管理，分布式能力调度和虚拟外设四大能力，将相应分布式应用的底层技术实现难度对应用开发者屏蔽，使开发者能够聚焦自身业务逻辑，像开发同一终端一样开发跨终端分布式应用，也使最终消费者享受到强大的跨终端业务协同能力为各使用场景带来的无缝体验。</h5><p><a href="https://static.cnbetacdn.com/article/2019/0809/0da3b9acacd6566.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/0da3b9acacd6566.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/2ca308ed3de5059.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/2ca308ed3de5059.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/4987e4d24c572f6.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/4987e4d24c572f6.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/bb2b308fb2c4863.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/bb2b308fb2c4863.jpg" alt></a></p><p><strong>第二， 确定时延引擎和高性能IPC技术实现系统流畅。</strong></p><h5 id="鸿蒙OS通过使用确定时延引擎和高性能IPC两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低25-7-。鸿蒙微内核结构小巧的特性使IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升5倍。"><a href="#鸿蒙OS通过使用确定时延引擎和高性能IPC两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低25-7-。鸿蒙微内核结构小巧的特性使IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升5倍。" class="headerlink" title="鸿蒙OS通过使用确定时延引擎和高性能IPC两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低25.7%。鸿蒙微内核结构小巧的特性使IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升5倍。"></a>鸿蒙OS通过使用确定时延引擎和高性能IPC两大技术解决现有系统性能不足的问题。确定时延引擎可在任务执行前分配系统中任务执行优先级及时限进行调度处理，优先级高的任务资源将优先保障调度，应用响应时延降低25.7%。鸿蒙微内核结构小巧的特性使IPC（进程间通信）性能大大提高，进程通信效率较现有系统提升5倍。</h5><p><a href="https://static.cnbetacdn.com/article/2019/0809/e0b747fb52cb77d.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/e0b747fb52cb77d.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/8207bd44e2eb60b.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/8207bd44e2eb60b.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/9a8f4828c279726.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/9a8f4828c279726.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/cdad2d91becd4e3.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/cdad2d91becd4e3.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/8c0a561069fb0c4.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/8c0a561069fb0c4.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/7d7e3e9c5c6ca43.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/7d7e3e9c5c6ca43.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/fa8032646a56bd3.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/fa8032646a56bd3.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/5f7aa22198a6ce2.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/5f7aa22198a6ce2.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/72f9cea20b6e7b8.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/72f9cea20b6e7b8.jpg" alt></a></p><p><strong>第三，基于微内核架构重塑终端设备可信安全。</strong></p><h5 id="鸿蒙OS采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。"><a href="#鸿蒙OS采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。" class="headerlink" title="鸿蒙OS采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。"></a>鸿蒙OS采用全新的微内核设计，拥有更强的安全特性和低时延等特点。微内核设计的基本思想是简化内核功能，在内核之外的用户态尽可能多地实现系统服务，同时加入相互之间的安全保护。微内核只提供最基础的服务，比如多进程调度和多进程通信等。</h5><h5 id="另外，鸿蒙OS将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。"><a href="#另外，鸿蒙OS将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。" class="headerlink" title="另外，鸿蒙OS将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。"></a>另外，鸿蒙OS将微内核技术应用于可信执行环境（TEE），通过形式化方法，重塑可信安全。</h5><p><a href="https://static.cnbetacdn.com/article/2019/0809/5f367f2b16631d9.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/5f367f2b16631d9.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/02e885fbf4b0f3c.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/02e885fbf4b0f3c.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/037bb5fc6cf3389.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/037bb5fc6cf3389.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/aa0a3edfb8b5a47.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/aa0a3edfb8b5a47.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/2c7ce2b7bea4e02.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/2c7ce2b7bea4e02.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/0c452598463f956.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/0c452598463f956.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/10e961b6228d627.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/10e961b6228d627.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/39602f71577fc48.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/39602f71577fc48.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/042bce1a1b0ca03.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/042bce1a1b0ca03.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/f97e2fbbe1787c5.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/f97e2fbbe1787c5.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/7887c4d8d1fe8c5.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/7887c4d8d1fe8c5.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/02e885fbf4b0f3c.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/02e885fbf4b0f3c.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/037bb5fc6cf3389.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/037bb5fc6cf3389.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/aa0a3edfb8b5a47.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/aa0a3edfb8b5a47.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/2c7ce2b7bea4e02.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/2c7ce2b7bea4e02.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/0c452598463f956.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/0c452598463f956.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/10e961b6228d627.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/10e961b6228d627.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/39602f71577fc48.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/39602f71577fc48.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/042bce1a1b0ca03.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/042bce1a1b0ca03.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/f97e2fbbe1787c5.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/f97e2fbbe1787c5.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/7887c4d8d1fe8c5.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/7887c4d8d1fe8c5.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/9cc5cc84c9d6090.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/9cc5cc84c9d6090.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/ff6d7bcc4ef22b4.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/ff6d7bcc4ef22b4.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/a481130adebdfed.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/a481130adebdfed.jpg" alt></a></p><p><strong>第四，通过统一IDE支撑一次开发，多端部署，实现跨终端生态共享。</strong></p><h5 id="鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。"><a href="#鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。" class="headerlink" title="鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。"></a>鸿蒙OS凭借多终端开发IDE，多语言统一编译，分布式架构Kit提供屏幕布局控件以及交互的自动适配，支持控件拖拽，面向预览的可视化编程，从而使开发者可以基于同一工程高效构建多端自动运行App，实现真正的一次开发，多端部署，在跨设备之间实现共享生态。</h5><p><a href="https://static.cnbetacdn.com/article/2019/0809/e6c0d84b5fd05d5.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/e6c0d84b5fd05d5.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/8f86d51780a690f.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/8f86d51780a690f.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/314f0188c7b1f16.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/314f0188c7b1f16.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/592701bf2e13602.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/592701bf2e13602.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/99afde8e0be800f.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/99afde8e0be800f.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/bbca58d91073c75.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/bbca58d91073c75.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/f364929dc284706.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/f364929dc284706.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/12dc73398ee3945.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/12dc73398ee3945.jpg" alt></a></p><p><a href="https://static.cnbetacdn.com/article/2019/0809/32a9393836a2e79.jpg" target="_blank" rel="noopener"><img src="https://static.cnbetacdn.com/thumb/article/2019/0809/32a9393836a2e79.jpg" alt></a></p><h5 id="据介绍，华为将在今年首发的智慧屏产品中率先使用鸿蒙-OS-1-0。未来三年，除完善相关技术外，鸿蒙OS会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。"><a href="#据介绍，华为将在今年首发的智慧屏产品中率先使用鸿蒙-OS-1-0。未来三年，除完善相关技术外，鸿蒙OS会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。" class="headerlink" title="据介绍，华为将在今年首发的智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙OS会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。"></a>据介绍，<a href="https://c.duomai.com/track.php?k=WP0ZSPklWdlZyN4MTPklWYmYDO5IDNy0DZp9VZ0l2cmYiRyUSbvNmLsxWYtZnL3d3dGJTJGJTJBNTJzBHd0h" target="_blank" rel="noopener">华为</a>将在今年首发的智慧屏产品中率先使用鸿蒙 OS 1.0。未来三年，除完善相关技术外，鸿蒙OS会逐步应用在可穿戴、智慧屏、车机等更多智能设备中。</h5><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://www.cnbeta.com/articles/tech/876919.htm" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/policx/talk/gh-pages/images/LmADop.jpg" alt="policx"></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;鸿蒙&lt;/strong&gt;，中国神话传说的远古时代，传说在盘古昆仑山开天辟地之前，世界是一团混沌的元气，这种自然的元气叫做鸿蒙，因此把那个时代称作鸿蒙时代，后来此一词也常被用来泛指称远古时代。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>Dice 称这 5 种编程语言可能衰落</title>
    <link href="https://www.policx.com/news/DiceInsightsA/"/>
    <id>https://www.policx.com/news/DiceInsightsA/</id>
    <published>2019-08-10T08:14:18.000Z</published>
    <updated>2019-08-16T09:00:26.297Z</updated>
    
    <content type="html"><![CDATA[<p>Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。</p><p>根据 <a href="https://insights.dice.com/2019/07/29/5-programming-languages-probably-doomed/" target="_blank" rel="noopener">Dice</a> 报道，并不是所有的编程语言都永远存在，因为新一代的开发人员会接受他们觉得更容易使用的其他语言和框架。为了确定哪种编程语言可能在中长期内注定失败，他们查看了 TIOBE 和 RedMonk 的受欢迎程度排名，以及 Dice 自己的职务公告数据库。列出以下语言：</p><a id="more"></a><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a><strong>Ruby</strong></h3><p><img src="https://images.pexels.com/photos/1121123/pexels-photo-1121123.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260" alt="Ruby"><br>很久以前，Ruby 很受欢迎。这是 Tiobe 月刊上的前十名语言，开发人员称赞它学习起来有多么容易。但是在过去的 18 个月里，Tiobe 的排名从第 9 位下降到了第 12 位。</p><p>另外发现，对 Dice 过去一年发布的招聘数据的分析显示，寻找精通 Ruby 的技术专业人员的公司数量大幅下降。2018 年，Ruby 的就业数量下降了 56%。这是一个巨大的警告信号，表明很多公司正在放弃 Ruby，如果是这样的话，该语言的用户基础可能会迅速减少到几乎一无所有。</p><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a><strong>Haskell</strong></h3><p><img src="https://gitee.com/policx/im/raw/master/images/OjslKj.png" alt="Haskell"><br>据说，Haskell 即将在 2020 年进行重大更新。有很多巨头公司和项目（Facebook、GitHub 等）曾经使用 Haskell 开发过一些重要项目。不过，Haskell 在 RedMonk 语言排行榜上的表现一直很平淡，这表明没有更多的开发者在关注这门语言。这意味着它正在死亡还是完全死了？</p><h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a><strong>Objective-C</strong></h3><p><img src="https://img.ithome.com/newsuploadfiles/2019/8/20190808_084451_983.png" alt="Object-C"><br>苹果的 Object-C 已是 35 岁，很明显，苹果公司想让它自生自灭了。五年前，苹果公司的高管们登上舞台，为其软件生态系统推出 Swift，这是一种新的、经过改进的编程语言。毫无疑问，开发者会很快接受 Swift。</p><p>公平地说，更多的开发人员已经开始使用 Swift (特别是在功能变得更加丰富的情况下)，但是 Object-C 并没有像一些人所期望的那样在流行语言排名中崩溃，可能只是许多开发人员更喜欢使用他们一直使用的语言。</p><p>不过，到某一时刻，Object-C 很可能会完全消失。Swift 正在成为一种非常有效的语言，用于构建 iOS、MacOS 和不久的跨平台应用程序。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a><strong>R</strong></h3><p><img src="https://atts.w3cschool.cn/attachments/cover/cover_r.png?t=1542021188&imageView2/1/w/150/h/84" alt><br>早在当时，R 是一种越来越流行的数据分析语言。然而，Python 似乎正在迅速吞噬 R 的市场份额。尽管 R 仍然被学者和数据科学家所使用，但对数据分析感兴趣的公司正转向 Python，因为它的可伸缩性和易用性。因此，R 降低了 TIOBE 的编程语言流行指数，而其他研究显示，R 的使用率下降缓慢，有利于 Python。</p><p>如果 R 要以任何形式存在，那是因为数据分析人员可能最终会将其与 Python 结合使用。首席技术官 Enriko Aryanto 今年早些时候对 Dice 表示（他是加州红木城(Redwood City)的联合创始人之一，总部位于加州的匡蒂明德是一家智能营销数据平台）：</p><blockquote><p>把 R 和 Python 结合起来既合理又可行，我们在内部数据科学平台上运行它们，但如果我今天要重新开始我的职业生涯，我可能会考虑专注于 Python 而不是 R。它是一种更通用的语言，有更广泛的应用程序。</p></blockquote><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a><strong>Perl</strong></h3><p><img src="https://www.runoob.com/wp-content/uploads/2016/06/0020_999_1373967199_perl_256.png" alt><br>即使 RedMonk 的 Perl 受欢迎程度下降，考虑到仍然有大量的遗留网站使用它的代码，该语言还需要很长一段时间才能完全变平。尽管如此，开发人员普遍支持其他语言，比如构建网站，这意味着 Perl 将陷入越来越多的废弃状态。</p><p>在本文的早期版本中，我们说过 Perl 几乎没有活跃的开发。正如一些有帮助的评论者指出的那样，事实并非如此：它每年更新一次。然而，鉴于它在 RedMonk 和 TIOBE 上的衰落，他们仍然认为这是一种衰落的语言。</p><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://www.oschina.net/news/108665/5-programming-languages-probably-doomed" target="_blank" rel="noopener"><img src="https://static.oschina.net/new-osc/img/logo_osc_new.svg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dice Insights 是为北美的科技专业人士提供见解和分析的网站，目的是帮助他们找到工作和发展事业，并且报道就业趋势、新技术等内容。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://insights.dice.com/2019/07/29/5-programming-languages-probably-doomed/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dice&lt;/a&gt; 报道，并不是所有的编程语言都永远存在，因为新一代的开发人员会接受他们觉得更容易使用的其他语言和框架。为了确定哪种编程语言可能在中长期内注定失败，他们查看了 TIOBE 和 RedMonk 的受欢迎程度排名，以及 Dice 自己的职务公告数据库。列出以下语言：&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
      <category term="program" scheme="https://www.policx.com/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>木兰宽松许可证</title>
    <link href="https://www.policx.com/news/MulanPSL/"/>
    <id>https://www.policx.com/news/MulanPSL/</id>
    <published>2019-08-08T03:06:39.000Z</published>
    <updated>2019-08-29T03:57:13.212Z</updated>
    
    <content type="html"><![CDATA[<p><strong>木兰宽松许可证， 第1版</strong></p><p>2019年8月 <a href="http://license.coscl.org.cn/MulanPSL" target="_blank" rel="noopener">http://license.coscl.org.cn/MulanPSL</a></p><a id="more"></a><blockquote><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>您对“软件”的复制、使用、修改及分发受木兰宽松许可证，第1版（“本许可证”）的如下条款的约束： </p></blockquote><p><strong>0.   定义</strong></p><p><strong>“软件”</strong>是指由“贡献”构成的许可在“本许可证”下的程序和相关文档的集合。 </p><p><strong>“贡献者”</strong>是指将受版权法保护的作品许可在“本许可证”下的自然人或“法人实体”。 </p><p><strong>“法人实体”</strong>是指提交贡献的机构及其“关联实体”。 </p><p><strong>“关联实体”</strong>是指，对“本许可证”下的一方而言，控制、受控制或与其共同受控制的机构，此处的控制是指有受控方或共同受控方至少50%直接或间接的投票权、资金或其他有价证券。 </p><p><strong>“贡献”</strong>是指由任一“贡献者”许可在“本许可证”下的受版权法保护的作品。 </p><p><strong>1.   授予版权许可</strong></p><p>每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的版权许可，您可以复制、使用、修改、分发其“贡献”，不论修改与否。 </p><p><strong>2.   授予专利许可</strong></p><p>每个“贡献者”根据“本许可证”授予您永久性的、全球性的、免费的、非独占的、不可撤销的（根据本条规定撤销除外）专利许可，供您制造、委托制造、使用、许诺销售、销售、进口其“贡献”或以其他方式转移其“贡献”。前述专利许可仅限于“贡献者”现在或将来拥有或控制的其“贡献”本身或其“贡献”与许可“贡献”时的“软件”结合而将必然会侵犯的专利权利要求，不包括仅因您或他人修改“贡献”或其他结合而将必然会侵犯到的专利权利要求。如您或您的“关联实体”直接或间接地（包括通过代理、专利被许可人或受让人），就“软件”或其中的“贡献”对任何人发起专利侵权诉讼（包括反诉或交叉诉讼）或其他专利维权行动，指控其侵犯专利权，则“本许可证”授予您对“软件”的专利许可自您提起诉讼或发起维权行动之日终止。 </p><p><strong>3.   无商标许可</strong></p><p>“本许可证”不提供对“贡献者”的商品名称、商标、服务标志或产品名称的商标许可，但您为满足第4条规定的声明义务而必须使用除外。 </p><p><strong>4.   分发限制</strong></p><p>您可以在任何媒介中将“软件”以源程序形式或可执行形式重新分发，不论修改与否，但您必须向接收者提供“本许可证”的副本，并保留“软件”中的版权、商标、专利及免责声明。 </p><p><strong>5.   免责声明与责任限制</strong></p><p>“软件”及其中的“贡献”在提供时不带任何明示或默示的担保。在任何情况下，“贡献者”或版权所有者不对任何人因使用“软件”或其中的“贡献”而引发的任何直接或间接损失承担责任，不论因何种原因导致或者基于何种法律理论,即使其曾被建议有此种损失的可能性。 </p><p><strong>条款结束</strong></p><p><strong>如何将木兰宽松许可证，第1版，应用到您的软件</strong></p><p>如果您希望将木兰宽松许可证，第1版，应用到您的新软件，为了方便接收者查阅，建议您完成如下三步： </p><p>1， 请您补充如下声明中的空白，包括软件名、软件的首次发表年份以及您作为版权人的名字； </p><p>2， 请您在软件包的一级目录下创建以“LICENSE”为名的文件，将整个许可证文本放入该文件中； </p><p>3， 请将如下声明文本放入每个源文件的头部注释中。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) [2019] [name of copyright holder]</span><br><span class="line">[Software Name] is licensed under the Mulan PSL v1.</span><br><span class="line"></span><br><span class="line">You can use this software according to the terms and conditions of the Mulan PSL v1.</span><br><span class="line"></span><br><span class="line">You may obtain a copy of Mulan PSL v1 at:</span><br><span class="line">    http://license.coscl.org.cn/MulanPSL</span><br><span class="line">THIS SOFTWARE IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR</span><br><span class="line">PURPOSE.</span><br><span class="line"></span><br><span class="line">See the Mulan PSL v1 for more details.</span><br></pre></td></tr></table></figure><p><strong>Mulan Permissive Software License，Version 1 (Mulan PSL v1)</strong></p><p>Your reproduction, use, modification and distribution of the Software shall be subject to Mulan PSL v1 (this License) with following terms and conditions:</p><p><strong>0. Definition</strong></p><p><strong>1. Grant of Copyright License</strong></p><p><strong>2. Grant of Patent License</strong></p><p><strong>3. No Trademark License</strong></p><p><strong>4. Distribution Restriction</strong></p><p><strong>5. Disclaimer of Warranty and Limitation of Liability</strong></p><p><strong>End of the Terms and Conditions</strong></p><p><strong>How to apply the Mulan Permissive Software License，Version 1 (Mulan PSL v1) to your software</strong></p><p>To apply the Mulan PSL v1 to your work, for easy identification by recipients, you are suggested to complete following three steps:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) [2019] [name of copyright holder]</span><br><span class="line">[Software Name] is licensed under the Mulan PSL v1.</span><br><span class="line"></span><br><span class="line">You can use this software according to the terms and conditions of the Mulan PSL v1.</span><br><span class="line"></span><br><span class="line">You may obtain a copy of Mulan PSL v1 at:</span><br><span class="line">    http://license.coscl.org.cn/MulanPSL</span><br><span class="line">THIS SOFTWARE IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR</span><br><span class="line">PURPOSE.</span><br><span class="line"></span><br><span class="line">See the Mulan PSL v1 for more details.</span><br></pre></td></tr></table></figure><blockquote><h4 id="Mulan-PSL-v1与BSD-3-clause-License与Apache-License-V2-0在声明义务、专利许可、对用户专利维权限制及版权许可上均有差异，在商标许可上无差异，见下表："><a href="#Mulan-PSL-v1与BSD-3-clause-License与Apache-License-V2-0在声明义务、专利许可、对用户专利维权限制及版权许可上均有差异，在商标许可上无差异，见下表：" class="headerlink" title="Mulan PSL v1与BSD 3-clause License与Apache License V2.0在声明义务、专利许可、对用户专利维权限制及版权许可上均有差异，在商标许可上无差异，见下表："></a>Mulan PSL v1与BSD 3-clause License与Apache License V2.0在声明义务、专利许可、对用户专利维权限制及版权许可上均有差异，在商标许可上无差异，见下表：</h4><p><img src="https://static.oschina.net/uploads/space/2019/0828/072214_6bVH_2720166.jpg" alt></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;木兰宽松许可证， 第1版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2019年8月 &lt;a href=&quot;http://license.coscl.org.cn/MulanPSL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://license.coscl.org.cn/MulanPSL&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>appleCard</title>
    <link href="https://www.policx.com/news/appleCard/"/>
    <id>https://www.policx.com/news/appleCard/</id>
    <published>2019-08-05T09:42:00.000Z</published>
    <updated>2019-08-15T01:05:16.651Z</updated>
    
    <content type="html"><![CDATA[<p>免年费的钛金卡，办一张来收藏也不错。</p><a id="more"></a><p><img src="https://i.loli.net/2019/08/05/bf9BtCq2kErvRGY.jpg" alt="appleCard"><br><img src="https://gitee.com/policx/im/raw/master/images/btDbRs.jpg" alt="appleCard"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;免年费的钛金卡，办一张来收藏也不错。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>善用佳软 uPic</title>
    <link href="https://www.policx.com/Software/uPic/"/>
    <id>https://www.policx.com/Software/uPic/</id>
    <published>2019-07-27T04:11:04.000Z</published>
    <updated>2019-08-15T01:17:12.453Z</updated>
    
    <content type="html"><![CDATA[<p>对于markdown重度用户而言，一款好用的图床工具能够有效提升效率。从Windows到Mac，笔者也算是辗转用过多款图床客户端，包括iPic、PicGo等等。而自从更换新的工作环境之后，笔者对于图床客户端又有了新的需求——自定义图床。</p><a id="more"></a><p>幸好，一次机缘巧合让笔者遇到了uPic，除了支持微博、SM.MS、七牛云、腾讯云等图床之外，还可以自定义配置图床。 </p><blockquote><p>uPic下载地址：<a href="https://github.com/gee1k/uPic/releases" target="_blank" rel="noopener">https://github.com/gee1k/uPic/releases</a> </p></blockquote><p>笔者目前工作所用的编辑器，既不支持外链，也不支持图片粘贴后自动上传，一旦涉及多图文章，光上传图片就浪费不少时间。因此，笔者萌生了构建自定义图床的想法，更幸运的是，笔者公司对于图片上传服务并没有做太多的限制，也让这种想法成为可能。 </p><p>uPic是一款开源简洁的图床客户端，方便用户直接上传图片到指定的存储空间，并获取有效的markdown图片地址，其默认图床为SM.MS，当然也支持配置腾讯云、七牛云、又拍云等常见的对象存储。最关键的是支持图床自定义配置，也让我毅然抛弃了一直以来付费使用的iPic。<br><img src="https://i.loli.net/2019/07/27/5d3bd2c197d8592897.jpg" alt></p><p>其实起初并不顺利，刚上手的uPic（大概是v0.7.0版本），自定义图床配置并不适用于笔者常用的编辑器环境。好在软件开发者@svend足够热心，在了解了笔者的需求及编辑环境之后，重构了自定义图床，使得笔者的想法得以实现，包括大家在反馈群里提出的一些建议，也都及时采纳并更新。 </p><p>直到最新发布的v0.8.0版本，uPic已经成为一款非常成熟且强大的图床客户端，且安装包大小也不过才10.5M。 </p><p>好了，啰嗦了这么多，也该进入正题了。 </p><p>uPic目前仅支持Mac端，默认上传到SM.MS匿名图床，除此之外还支持微博、码云、Github以及腾讯云、阿里云、又拍云、七牛云总共八个图床。其中，由于微博近期已经陆续开启防盗链，笔者不建议在个人博客中使用。<br><img src="https://i.loli.net/2019/07/27/5d3bd288ac38618894.jpg" alt><br>在上传方式上，uPic支持本地选择/复制文件上传、截图上传，甚至可直接拖动文件到菜单栏uPic图标上完成上传动作。<br><img src="https://i.loli.net/2019/07/27/5d3bd3727bf6963617.gif" alt="640"></p><p>在最新更新v0.8.0版本之后，uPic新增支持直接从浏览器中复制或者拖动在线图片上传到指定图床，这样就不用下载到本地再进行上传。<br><img src="https://gitee.com/policx/im/raw/master/images/GoRrBa.gif" alt></p><p>不过需要注意的是，GIF动图不大一样，直接从浏览器中复制或者拖动GIF上传至uPic图床，可能最终上传的只是GIF图中一帧的画面，所以对于GIF最好还是先下载到本地，然后使用uPic上传到图床。 </p><p>在“设置——拓展——访达拓展”中勾选uPic一项，即可开启本地文件右键菜单中“使用uPic上传”的功能，也算是比较方便的一种本地文件上传方式。<br><img src="https://i.loli.net/2019/07/27/5d3bdbd03d58f62506.jpg" alt><br><img src="https://gitee.com/policx/im/raw/master/images/mOO863.jpg" alt></p><p>一旦完成上传动作，所输出的文件链接会自动复制到剪切板，直接在文档中粘贴即可，在输出链接格式上可根据需求选择URL、HTML、Markdown三种。<br><img src="https://gitee.com/policx/im/raw/master/images/Y0lYcO.jpg" alt></p><p>点击菜单栏uPic图标，还可以查看最近十条上传记录，同时可以预览上传内容缩略图，以便选择重新复制。<br><img src="https://gitee.com/policx/im/raw/master/images/Ze9ScG.jpg" alt><br>熟练使用快捷键操作，可以进一步提升使用效率。uPic支持三种上传方式的自定义快捷键。基本不用点击菜单了去选择，即可完成上传动作。<br><img src="https://gitee.com/policx/im/raw/master/images/MqUOQy.jpg" alt><br>例如，通过设定好的快捷键完成截图上传操作，按住鼠标框选所需区域，松开鼠标之后即完成截图并直接上传到图床（注意没有确认截图的过程哦～）。<br><img src="https://gitee.com/policx/im/raw/master/images/k0GikB.gif" alt><br>使用这段时间，笔者感觉uPic已经足够成为一款高效、简洁的图床客户端，支持强大的自定义图床配置，支持复制/拖动上传以及快捷键操作。不过在部分体验上iPic依然值得uPic借鉴，例如复制图片后点击菜单栏的iPic，能够比较直观地看到已复制图片及近期上传图片的预览，体验更加直观。<br><img src="https://gitee.com/policx/im/raw/master/images/dLyZLX.jpg" alt="a"><br>不得不提的是，开发者@svend虽然只利用业余时间更新维护，同样保持了较高的更新频率，发现bug或者其他不稳定的因素更是会连夜修复，并且会及时反馈用户的意见。作为一款免费的Mac图床客户端，uPic已经赢得了越来越多的用户亲睐。 </p><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s/WcchsHp007SswWr2qHGxTQ" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/27/5d3bcf474c70088570.jpg" alt="wechat"></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于markdown重度用户而言，一款好用的图床工具能够有效提升效率。从Windows到Mac，笔者也算是辗转用过多款图床客户端，包括iPic、PicGo等等。而自从更换新的工作环境之后，笔者对于图床客户端又有了新的需求——自定义图床。&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://www.policx.com/categories/Software/"/>
    
    
      <category term="善用佳软" scheme="https://www.policx.com/tags/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF/"/>
    
  </entry>
  
  <entry>
    <title>「拖放」Mac 的底层能力，也是效率神技</title>
    <link href="https://www.policx.com/Software/DragAndDrop/"/>
    <id>https://www.policx.com/Software/DragAndDrop/</id>
    <published>2019-07-26T14:19:21.000Z</published>
    <updated>2019-08-15T01:18:15.665Z</updated>
    
    <content type="html"><![CDATA[<p>个人惯用 Mac 拖放，但每每身边同事看我的操作习惯，都大惊失色，感叹 Mac 还有这种操作，所以决定单独讲一篇 Mac 拖放。</p><a id="more"></a><p>Mac的拖放几乎是全局的，比如你可以将图片文件从应用拖到 Finder，同样可以将文件从 Finder 拖至应用内，甚至从应用A拖拽至应用B。</p><p>总之，基于 Finder 的文件拖拽，让系统和应用、应用和应用协同起来，大大提速。以下是一些示例。</p><blockquote><p>应用-&gt;Finder</p></blockquote><p>1.微信-&gt;Finder<br><img src="https://i.loli.net/2019/07/27/5d3c5f3ea1d9e89990.gif" alt></p><p>2.浏览器-&gt;Finder<br><img src="https://gitee.com/policx/im/raw/master/images/Xfj58J.gif" alt></p><p>出于版权安全的考虑，以及前端技术的极速革新，部分网站已不再支持将图片拖拽至 Finder，但多数网站仍然支持。</p><p>3.PDF-&gt;Finder<br><img src="https://gitee.com/policx/im/raw/master/images/wEnYQa.gif" alt="pic"></p><p>如果你只需要 PDF 20P中的1P，可以单独拖拽至Finder。</p><blockquote><p>Finder-&gt;应用</p></blockquote><p>1.Finder-&gt;微信<br><img src="https://gitee.com/policx/im/raw/master/images/H2aKxW.gif" alt="pic"></p><p>2.Finder-&gt;办公套件<br><img src="https://gitee.com/policx/im/raw/master/images/Pc9jOK.gif" alt="pic"></p><p>3.Finder-&gt;PDF<br><img src="https://gitee.com/policx/im/raw/master/images/Hi56sE.gif" alt="pic"></p><blockquote><p>应用-&gt;应用</p></blockquote><p>1.浏览器-&gt;微信<br><img src="https://gitee.com/policx/im/raw/master/images/6whkO3.gif" alt="pic"></p><p>2.微信-&gt;办公套件<br><img src="https://gitee.com/policx/im/raw/master/images/37ryoD.gif" alt="pic"></p><p>除了以上”应用-&gt;Finder，Finder-&gt;应用，应用-&gt;应用”几种拖放，Mac 还有其他很多地方支持此操作，比如文件拖拽至垃圾桶、应用拖拽至Docker、文件拖拽至 Docker 上应用图标即可打开……  </p><p>使用拖拽，还是复制粘贴，或是通过各个应用的菜单完成操作，都没什么问题，如果你知道了 MacOS 的一项新能力，不妨试试。</p><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s/DPhrXF5qfPEMrEGimslh1w" target="_blank" rel="noopener"><img src="https://gitee.com/policx/im/raw/master/images/Z2gkII.png" alt="pic"></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人惯用 Mac 拖放，但每每身边同事看我的操作习惯，都大惊失色，感叹 Mac 还有这种操作，所以决定单独讲一篇 Mac 拖放。&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://www.policx.com/categories/Software/"/>
    
    
      <category term="善用佳软" scheme="https://www.policx.com/tags/%E5%96%84%E7%94%A8%E4%BD%B3%E8%BD%AF/"/>
    
  </entry>
  
  <entry>
    <title>Python导图</title>
    <link href="https://www.policx.com/program/Python/mind/"/>
    <id>https://www.policx.com/program/Python/mind/</id>
    <published>2019-07-21T06:03:24.000Z</published>
    <updated>2019-08-28T08:10:45.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐：<strong>XMind</strong> 一个全功能的思维导图和头脑风暴软件。</p></blockquote><a id="more"></a><h2 id="Python-系列-一-核心知识"><a href="#Python-系列-一-核心知识" class="headerlink" title="Python 系列 (一)  核心知识"></a>Python 系列 (一)  核心知识</h2><p><img src="/mindImage/0%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86.png" alt><br><img src="/mindImage/1%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.png" alt><br><img src="/mindImage/2Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.png" alt><br><img src="/mindImage/3%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)%E6%95%B0%E5%80%BC%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88.png" alt><br><img src="/mindImage/4%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85.png" alt><br><img src="/mindImage/5%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%8C)%E5%BA%8F%E5%88%97%E5%AF%B9%E8%B1%A1.png" alt><br><img src="/mindImage/6%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt><br><img src="/mindImage/7%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt><br><img src="/mindImage/8%E3%80%90%E8%BF%9B%E9%98%B6%E3%80%91%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt><br><img src="/mindImage/9%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9D%97.png" alt><br><img src="/mindImage/10%E3%80%90%E8%BF%9B%E9%98%B6%E3%80%91%E5%87%BD%E6%95%B0.png" alt><br><img src="/mindImage/11%E6%A8%A1%E5%9D%97.png" alt><br><img src="/mindImage/12%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.png" alt><br><img src="/mindImage/13%E3%80%90%E8%BF%9B%E9%98%B6%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.png" alt><br><img src="/mindImage/14%E3%80%90%E8%BF%9B%E9%98%B6%E3%80%91%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86.png" alt><br><img src="/mindImage/15%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1.png" alt><br><img src="/mindImage/16%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png" alt><br><img src="/mindImage/17%E6%B5%8B%E8%AF%95%E8%B0%83%E8%AF%95.png" alt></p><h2 id="Python系列-一-基础编程"><a href="#Python系列-一-基础编程" class="headerlink" title="Python系列 (一) 基础编程"></a>Python系列 (一) 基础编程</h2><p><img src="/mindImage/1Python%E7%B3%BB%E5%88%97(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B.png" alt><br><img src="/mindImage/2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861.png" alt><br><img src="/mindImage/3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862.png" alt><br><img src="/mindImage/4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt><br><img src="/mindImage/5%E5%BA%8F%E5%88%97.png" alt><br><img src="/mindImage/6%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt><br><img src="/mindImage/7%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84.png" alt><br><img src="/mindImage/8%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88.png" alt><br><img src="/mindImage/9%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF.png" alt><br><img src="/mindImage/10%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1.png" alt><br><img src="/mindImage/11%E9%94%99%E8%AF%AF%EF%BC%86%E5%BC%82%E5%B8%B8.png" alt><br><img src="/mindImage/12%E5%87%BD%E6%95%B0%E4%B8%80.png" alt><br><img src="/mindImage/13%E5%87%BD%E6%95%B0%E4%BA%8C.png" alt><br><img src="/mindImage/14%E6%A8%A1%E5%9D%97.png" alt><br><img src="/mindImage/15%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.png" alt></p><h2 id="Python系列-二-常用标准库及拓展知识"><a href="#Python系列-二-常用标准库及拓展知识" class="headerlink" title="Python系列(二)常用标准库及拓展知识"></a>Python系列(二)常用标准库及拓展知识</h2><p><img src="/mindImage/0%E3%80%90%E7%9B%AE%E5%BD%95%E3%80%91Python%E7%B3%BB%E5%88%97(%E4%BA%8C)%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E5%8F%8A%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86.png" alt><br><img src="/mindImage/1%E6%A0%87%E5%87%86%E5%BA%93%E6%A6%82%E8%BF%B0.png" alt><br><img src="/mindImage/2%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt><br><img src="/mindImage/3%E6%97%A5%E6%9C%9F&%E6%97%B6%E9%97%B4.png" alt><br><img src="/mindImage/4%E7%B3%BB%E7%BB%9F&%E6%96%87%E4%BB%B6.png" alt><br><img src="/mindImage/5%E8%BF%9B%E7%A8%8B&%E7%BA%BF%E7%A8%8B.png" alt><br><img src="/mindImage/6%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt><br><img src="/mindImage/7%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97&%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt></p><h2 id="Python应用领域和数据结构"><a href="#Python应用领域和数据结构" class="headerlink" title="Python应用领域和数据结构"></a>Python应用领域和数据结构</h2><p><a href="https://www.jianshu.com/p/66f6d9a434f9" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/21/5d3400422503e26621.jpg" alt="Python数据结构"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;推荐：&lt;strong&gt;XMind&lt;/strong&gt; 一个全功能的思维导图和头脑风暴软件。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="program" scheme="https://www.policx.com/categories/program/"/>
    
      <category term="Python" scheme="https://www.policx.com/categories/program/Python/"/>
    
    
      <category term="Python" scheme="https://www.policx.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Homebrew</title>
    <link href="https://www.policx.com/news/brew/"/>
    <id>https://www.policx.com/news/brew/</id>
    <published>2019-07-21T00:21:23.000Z</published>
    <updated>2019-08-26T17:12:12.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong>macOS（或 Linux）缺失的软件包的管理器 — Homebrew</strong></p><a id="more"></a><h1 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>将以上命令粘贴至终端。</p><p>脚本会在执行前暂停，并说明它将做什么。高级安装选项在 <a href="https://docs.brew.sh/Installation" target="_blank" rel="noopener">这里</a> (required for Linux and Windows Subsystem for Linux)。</p><h1 id="Homebrew-能干什么"><a href="#Homebrew-能干什么" class="headerlink" title="Homebrew 能干什么?"></a>Homebrew 能干什么?</h1><p>使用 Homebrew 安装 Apple（或您的 Linux 系统）没有预装但 你需要的东西。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install wget</span><br></pre></td></tr></table></figure><p>Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ find Cellar</span><br><span class="line">Cellar/wget/1.16.1</span><br><span class="line">Cellar/wget/1.16.1/bin/wget</span><br><span class="line">Cellar/wget/1.16.1/share/man/man1/wget.1</span><br><span class="line"></span><br><span class="line">$ ls -l bin</span><br><span class="line">bin/wget -&gt; ../Cellar/wget/1.16.1/bin/wget</span><br></pre></td></tr></table></figure><p>Homebrew 不会将文件安装到它本身目录之外，所以您可将 Homebrew 安装到任意位置。</p><p>轻松创建你自己的 Homebrew 包。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew create https://foo.com/bar-1.0.tgz</span><br><span class="line">Created /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/bar.rb</span><br></pre></td></tr></table></figure><p>完全基于 Git 和 Ruby，所以自由修改的同时你仍可以轻松撤销你的变更或与上游更新合并。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew edit wget  # 使用 $EDITOR 编辑!</span><br></pre></td></tr></table></figure><p>Homebrew 的配方都是简单的 Ruby 脚本：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Wget &lt; Formula</span><br><span class="line">  homepage &quot;https://www.gnu.org/software/wget/&quot;</span><br><span class="line">  url &quot;https://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz&quot;</span><br><span class="line">  sha256 &quot;52126be8cf1bddd7536886e74c053ad7d0ed2aa89b4b630f76785bac21695fcd&quot;</span><br><span class="line"></span><br><span class="line">  def install</span><br><span class="line">    system &quot;./configure&quot;, &quot;--prefix=#&#123;prefix&#125;&quot;</span><br><span class="line">    system &quot;make&quot;, &quot;install&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Homebrew 使 macOS（或您的 Linux 系统）更完整。使用 gem 来安装 RubyGems、用 brew 来安装那些依赖包。</p><p>“要安装，请拖动此图标……”不会再出现了。使用 brew cask 安装 macOS 应用程序、字体和插件以及其他非开源软件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install firefox</span><br></pre></td></tr></table></figure><p>制作一个 cask 就像创建一个配方一样简单。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask create foo</span><br><span class="line">Editing /usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/foo.rb</span><br></pre></td></tr></table></figure><h1 id="怎么删掉-brew-cask-list-里面的已安装记录？"><a href="#怎么删掉-brew-cask-list-里面的已安装记录？" class="headerlink" title="怎么删掉 brew cask list 里面的已安装记录？"></a>怎么删掉 brew cask list 里面的已安装记录？</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/local/Caskroom/名称</span><br></pre></td></tr></table></figure><h1 id="更多文档"><a href="#更多文档" class="headerlink" title="更多文档"></a>更多文档</h1><p><a href="https://docs.brew.sh/" target="_blank" rel="noopener">docs.brew.sh</a></p><h1 id="Homebrew-Packages"><a href="#Homebrew-Packages" class="headerlink" title="Homebrew Packages"></a>Homebrew Packages</h1><p><a href="https://formulae.brew.sh/" target="_blank" rel="noopener">formulae.brew.sh</a></p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p><a href="https://github.com/Homebrew/brew" target="_blank" rel="noopener"><strong>https://github.com/Homebrew/brew</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;macOS（或 Linux）缺失的软件包的管理器 — Homebrew&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
  <entry>
    <title>《Python札记》1_列表list</title>
    <link href="https://www.policx.com/program/Python/python3-notes01/"/>
    <id>https://www.policx.com/program/Python/python3-notes01/</id>
    <published>2019-07-18T14:55:41.000Z</published>
    <updated>2019-08-28T08:10:45.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写于开始之前"><a href="#写于开始之前" class="headerlink" title="写于开始之前"></a>写于开始之前</h3><p>笔者即将开始写一个系列的《<code>Python</code>札记》。本系列的札记主要是自学<code>齐伟</code>老师《跟老齐学<code>Python</code>轻松入门》一书整理而来。书第一遍断断续续花了5个月，第二遍边看边整理，保守3个月。</p><a id="more"></a><p><strong>在此深深感谢齐伟老师带我入门<code>Python</code></strong>。<strong>工欲善其事，必先利其器</strong>，本札记的学习环境为：<code>Python3.7.2 + pycharm + jupyter notebook</code>： </p><ul><li><code>Python3</code>取代了<code>Python2</code>，成为主流</li><li>针对<code>Python</code>语言，<code>Pycharm</code>是最好的<code>IDE</code></li><li><code>Jupyter notebook</code>是利用<code>Python</code>进行机器学习的强大利器</li></ul><p><strong>本札记一定会在2个月之内完成</strong>，主要内容包含： </p><ul><li>学习笔记整理</li><li>代码实战练习</li><li>各种练习题</li><li>利用<code>Python</code>实现常用算法 <a href="https://www.jianshu.com/c/7287d92c5db4" target="_blank" rel="noopener">机器学习_Python算法</a></li></ul><p><strong>希望对<code>Python</code>感兴趣的朋友有所帮助，自己也在努力学习中，将来主要方向是：<code>机器学习+数据挖掘+量化投资</code></strong></p><h4 id="良好的开始是成功的一半！Let-s-go-go-go"><a href="#良好的开始是成功的一半！Let-s-go-go-go" class="headerlink" title="良好的开始是成功的一半！Let`s go go go!!!"></a>良好的开始是成功的一半！Let`s go go go!!!</h4><hr><blockquote><p>列表是<code>Python</code>中使用非常广泛的一种对象，用方括号<code>[ ]</code>来表示。括号里面可以是数字，字符串或者<code>True</code>，<code>False</code>的布尔值，或者是多种不同类型的对象，里面也可以嵌套列表。如果列表是空的，用<code>bool()</code>来进行判断，会返回 <code>False</code>。 </p></blockquote><hr><h3 id="一、索引、切片、反转"><a href="#一、索引、切片、反转" class="headerlink" title="一、索引、切片、反转"></a>一、索引、切片、反转</h3><p>列表和字符串一样，都是序列，里面的元素是有序的，也有索引和切片。索引<code>index</code>左边从<code>0</code>开始，右边从<code>-1</code>开始，<code>index()</code>函数可以查看某个元素的索引编号。 </p><p><strong>索引</strong></p><ul><li>左边0开始，右边-1开始</li><li>通过<code>index()</code>函数查看索引编号</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># lang = ['python', 'java', 'html']</span></span><br><span class="line"><span class="hljs-comment"># lang.index('python')</span></span><br><span class="line"><span class="hljs-number">0</span>  <span class="hljs-comment"># 索引从0开始</span></span><br><span class="line"><span class="hljs-comment"># lang.index('html')</span></span><br><span class="line"><span class="hljs-number">2</span></span><br></pre></td></tr></table></figure><p><strong>切片</strong></p><ul><li>索引左边从0开始，右边-1开始</li><li>含头不含尾</li><li>步长可正可负</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="line">print(lst[:])     <span class="hljs-comment">#  相当于是复制 lst</span></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="line">print(lst[::<span class="hljs-number">2</span>])  <span class="hljs-comment">#  步长是2    [开始:结束:步长]</span></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]</span><br><span class="line">print(lst[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])</span><br><span class="line"></span><br><span class="line">lst = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]</span><br><span class="line">print(lst[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>])     <span class="hljs-comment"># 常规用法</span></span><br><span class="line">print(lst[<span class="hljs-number">-5</span>:<span class="hljs-number">-2</span>:<span class="hljs-number">2</span>])   <span class="hljs-comment"># 标号-5代表的是元素2，标号-2代表的是5，步长为2</span></span><br><span class="line">print(lst[<span class="hljs-number">-5</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])</span><br><span class="line">print(lst[<span class="hljs-number">1</span>:<span class="hljs-number">-2</span>:<span class="hljs-number">2</span>])</span><br><span class="line">[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>反转</strong></p><ul><li>通过步长-1进行反转，[::-1]</li><li>通过<code>reversed()</code>进行反转，得到的是<strong>可迭代对象</strong>，并且将迭代对象转为为<code>列表显示</code></li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 反转1</span></span><br><span class="line">print(lst[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># 通过步长为-1进行反转</span></span><br><span class="line">print(lst)   <span class="hljs-comment"># 不影响原来对象</span></span><br><span class="line">[<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 反转2</span></span><br><span class="line">print(list(reversed(lst)))  <span class="hljs-comment"># 通过reversed函数进行反转</span></span><br><span class="line">[<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]</span><br><span class="line"></span><br><span class="line">print(list(reversed(<span class="hljs-string">'abcde'</span>)))    <span class="hljs-comment"># 对字符串进行反转，列表显示</span></span><br><span class="line">[<span class="hljs-string">'e'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'a'</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="二、操作列表"><a href="#二、操作列表" class="headerlink" title="二、操作列表"></a>二、操作列表</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li>len()：求长度</li><li>+：连接两个序列</li><li>*：复制序列</li><li>in：判断元素是否在列表中</li><li>max()、min()：按照元素的字典顺序进行排序</li></ul><p><strong>1、修改元素</strong></p><blockquote><p><strong>列表</strong>中的元素可以进行<strong>修改</strong>，但是字符串中的不能进行修改。列表中修改的时候，直接通过索引号进行指定： </p></blockquote><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>   <span class="hljs-comment"># 指定第三个元素为7</span></span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>2、增加元素</strong><br>追加元素的方法有两种，都是追加在<strong>末尾</strong></p><ul><li>append()函数进行追加</li><li>切片的方式进行追加：a[len(a):] = [ x ]</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst.append(<span class="hljs-number">8</span>)  </span><br><span class="line">lst[len(lst):] = [<span class="hljs-number">8</span>]</span><br><span class="line">print(lst)</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]   <span class="hljs-comment"># 例子承接上面，第三个元素为7，不是3</span></span><br></pre></td></tr></table></figure><p><strong>3、列表函数</strong></p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>append</td><td>将单个元素追加到列表的<strong>最右边</strong>，即末尾部分；<strong>list[len(list):] = [x]</strong>，x是待追加的元素；  <strong>没有返回值None</strong></td></tr><tr><td>extend</td><td>将<strong>两个列表进行合并</strong>，扩充列表的作用；  参数必须是<strong>可迭代对象</strong>；  <strong>list[len(list):] = L</strong>，L是待并入的列表；  完成追加过程，列表L不变，list发生变化；  <strong>没有返回值None</strong></td></tr><tr><td>insert</td><td>指定位置添加元素  格式：list.insert(i,x)，i是插入的位置，x是待追加元素 ；  i如果是0，相当于是插在首位；i如果是len(list)，相当于是插在最后面，则等价于append()函数</td></tr></tbody></table><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># extend()函数</span></span><br><span class="line">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</span><br><span class="line">print(id(lst))   <span class="hljs-comment"># 查看lst的内存地址</span></span><br><span class="line">lst1 = [<span class="hljs-string">'python'</span>, <span class="hljs-string">'java'</span>, <span class="hljs-string">'html'</span>]</span><br><span class="line">lst.extend(lst1)</span><br><span class="line">print(id(lst))   <span class="hljs-comment"># 查看追加列表之后的内存地址，与原来系相同的</span></span><br><span class="line">print(<span class="hljs-string">"lst:"</span>, lst)</span><br><span class="line">print(<span class="hljs-string">"lst1:"</span>, lst1)</span><br><span class="line"></span><br><span class="line"><span class="hljs-number">2435334264968</span></span><br><span class="line"><span class="hljs-number">2435334264968</span></span><br><span class="line">lst: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'python'</span>, <span class="hljs-string">'java'</span>, <span class="hljs-string">'html'</span>]</span><br><span class="line">lst1: [<span class="hljs-string">'python'</span>, <span class="hljs-string">'java'</span>, <span class="hljs-string">'html'</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># append与extend区别</span></span><br><span class="line">lst1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line">lst2 = [<span class="hljs-string">'python'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'java'</span>]</span><br><span class="line">lst1.append(lst2)</span><br><span class="line">print(lst1)</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">'python'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'java'</span>]]   <span class="hljs-comment"># 整建制，将lst2当做一个整体</span></span><br><span class="line"></span><br><span class="line">lst1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span><br><span class="line">lst2 = [<span class="hljs-string">'python'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'java'</span>]</span><br><span class="line">lst1.extend(lst2)</span><br><span class="line">print(lst1)</span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'python'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'java'</span>]   <span class="hljs-comment"># 个体化，将lst2的每个元素进行追加</span></span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>列表是可以进行<strong>修改</strong>的，原地修改</li><li>append是将一个元素加到列表的末尾，<strong>整建制追加</strong></li><li>extend将两个列表进行合并，<strong>个体化扩编</strong></li><li>extend方法执行之后，<strong>内存中id不变</strong>，只是在该id上的内容发生了变化</li><li>insert()函数中的i如果超过最大索引值，则自动追加到末尾，相当于是append()函数的作用</li><li>三种方法均是原地修改，无返回值</li></ul><hr><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>count</td><td>查看元素重复出现的次数  <strong>如果不存在，返回0</strong>，而不是报错</td></tr><tr><td>index</td><td>查看索引编号，不存在则报错  检索的是元素<strong>第一次</strong>出现的位置</td></tr><tr><td>remove</td><td>删除元素，原地修改，无返回值；  list.remove(x)：如果x不存在，则会报错；  如果x出现多次，<strong>删除第一个x，剩下不变</strong></td></tr><tr><td>pop</td><td>pop([i]):参数是可选的；  为空，<strong>默认删除最后一个</strong>，并且将该元素作为返回值；  如果不为空，<strong>可删除索引为i的元素</strong>，并且将该元素作为返回值</td></tr><tr><td>reverse</td><td>原地反转，没有生成新的列表，没有返回值</td></tr><tr><td>reversed</td><td>类似reverse，区别：生成的列表能够<strong>用于迭代</strong></td></tr></tbody></table><p><strong>remove和pop的区别</strong></p><ul><li>remove 没有返回值，pop有返回值</li><li>remove的参数是元素，pop的参数是索引</li></ul><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]</span><br><span class="line">lst1.remove(<span class="hljs-number">2</span>)</span><br><span class="line">print(lst1)</span><br><span class="line"><span class="hljs-comment"># lst1.remove(7)</span></span><br><span class="line"><span class="hljs-comment"># print(lst1)   ValueError: list.remove(x): x not in list</span></span><br><span class="line">lst1.pop(<span class="hljs-number">2</span>)</span><br><span class="line">print(lst1)</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]   <span class="hljs-comment"># 将元素2删除掉</span></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]      <span class="hljs-comment">#  将索引为2的元素3删除掉，本步骤是接在上面的执行，即在列表[1, 3, 4, 5, 6] 中删除4</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 关于反转</span></span><br><span class="line">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</span><br><span class="line">print(lst[::<span class="hljs-number">-1</span>])   <span class="hljs-comment"># 反转实现1</span></span><br><span class="line">print(lst)          <span class="hljs-comment"># 原来的列表对象不改变</span></span><br><span class="line">lst.reverse()    <span class="hljs-comment"># 反转实现2</span></span><br><span class="line">print(lst)          <span class="hljs-comment"># 原来的列表变成反转之后的新列表</span></span><br><span class="line">lst1= reversed(lst)</span><br><span class="line">print(lst1)       <span class="hljs-comment"># lst1是一个列表反转迭代器对象：&lt;list_reverseiterator object at 0x00000233C677F320&gt;</span></span><br><span class="line">print(list(lst1))    <span class="hljs-comment"># 用list函数显示lst1的内容</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>sort</td><td>排序函数，用于<code>列表list</code>中，<strong>原地修改没有返回值</strong>；  <strong>默认从小到大</strong>；将<strong>reverse=True</strong>则变成从大到小排序sort(self, /, *, key=None, reverse=False)</td></tr><tr><td>sorted</td><td>对<code>所有可迭代对象</code>进行操作，返回一个新的 <code>list</code>，不是在原来的list上进行操作  sorted(iterable[, cmp[, key[, reverse]]])</td></tr></tbody></table><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># sort()</span></span><br><span class="line">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]</span><br><span class="line">lst.sort()</span><br><span class="line">print(lst)</span><br><span class="line">lst1 = [<span class="hljs-string">'python'</span>, ‘Java’, <span class="hljs-string">'html'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'php'</span>]</span><br><span class="line">lst1.sort(key=len)  <span class="hljs-comment"># 列表中的字符串进行排序；如果长度相同，则按照出现的先后顺序</span></span><br><span class="line">print(lst1)</span><br><span class="line"></span><br><span class="line">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</span><br><span class="line">[<span class="hljs-string">'c'</span>, <span class="hljs-string">'php'</span>, <span class="hljs-string">'Java'</span>, <span class="hljs-string">'html'</span>, <span class="hljs-string">'python'</span>]</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># sorted()</span></span><br><span class="line">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]</span><br><span class="line">lst1 = sorted(lst)</span><br><span class="line">print(lst)  <span class="hljs-comment"># 原对象不变</span></span><br><span class="line">print(lst1) <span class="hljs-comment"># 新列表为排序后的对象</span></span><br><span class="line"></span><br><span class="line">lst2 =[(<span class="hljs-string">'python'</span>, <span class="hljs-string">'A'</span>),(<span class="hljs-string">'java'</span>, <span class="hljs-string">'C'</span>),(<span class="hljs-string">'c'</span>, <span class="hljs-string">'D'</span>),(<span class="hljs-string">'php'</span>, <span class="hljs-string">'B'</span>)]</span><br><span class="line">lst3 = sorted(lst2, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])   <span class="hljs-comment"># 由元组构成的复合列表，按照元组的第二个元素进行排序，通过匿名函数lamba()</span></span><br><span class="line">print(lst3)</span><br><span class="line">[(<span class="hljs-string">'python'</span>, <span class="hljs-string">'A'</span>), (<span class="hljs-string">'php'</span>, <span class="hljs-string">'B'</span>), (<span class="hljs-string">'java'</span>, <span class="hljs-string">'C'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'D'</span>)]</span><br><span class="line"></span><br><span class="line">lst4 = sorted(lst2, key=<span class="hljs-keyword">lambda</span> x: len(x[<span class="hljs-number">0</span>]))   <span class="hljs-comment"># 通过元组中第一个元素的长度进行排序</span></span><br><span class="line">print(lst4)</span><br><span class="line">[(<span class="hljs-string">'c'</span>, <span class="hljs-string">'D'</span>), (<span class="hljs-string">'php'</span>, <span class="hljs-string">'B'</span>), (<span class="hljs-string">'java'</span>, <span class="hljs-string">'C'</span>), (<span class="hljs-string">'python'</span>, <span class="hljs-string">'A'</span>)]</span><br></pre></td></tr></table></figure><h4 id="自定义类中的元素进行排序"><a href="#自定义类中的元素进行排序" class="headerlink" title="自定义类中的元素进行排序"></a>自定义类中的元素进行排序</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age, grade)</span>:</span></span><br><span class="line">        self.name =  name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.grade = grade</span><br><span class="line">        </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">return</span>  repr((self.name, self.grade, self.age))</span><br><span class="line">    </span><br><span class="line">students_objects = [</span><br><span class="line">    Student(<span class="hljs-string">'Tom'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-number">12</span>),</span><br><span class="line">    Student(<span class="hljs-string">'xiaoming'</span>,<span class="hljs-string">'A'</span>,<span class="hljs-number">17</span>),</span><br><span class="line">    Student(<span class="hljs-string">'xiaohong'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-number">12</span>),</span><br><span class="line">    Student(<span class="hljs-string">'Peter'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-number">8</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">lst5 = sorted(students_objects, key=<span class="hljs-keyword">lambda</span> t:t.age)   <span class="hljs-comment"># 自定义类中，按照年龄进行排序</span></span><br><span class="line">print(lst5)</span><br><span class="line">lst6 = sorted(students_objects, key=<span class="hljs-keyword">lambda</span> t:(t.age, t.grade))   <span class="hljs-comment"># 使用元组，先根据年龄排序，若年龄相同按照grade排序</span></span><br><span class="line">print(lst6)</span><br><span class="line"></span><br><span class="line">[(<span class="hljs-string">'xiaoming'</span>, <span class="hljs-number">17</span>, <span class="hljs-string">'A'</span>), (<span class="hljs-string">'Tom'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'B'</span>), (<span class="hljs-string">'xiaohong'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'C'</span>), (<span class="hljs-string">'Peter'</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'D'</span>)]</span><br><span class="line">[(<span class="hljs-string">'xiaoming'</span>, <span class="hljs-number">17</span>, <span class="hljs-string">'A'</span>), (<span class="hljs-string">'Tom'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'B'</span>), (<span class="hljs-string">'xiaohong'</span>, <span class="hljs-number">12</span>, <span class="hljs-string">'C'</span>), (<span class="hljs-string">'Peter'</span>, <span class="hljs-number">8</span>, <span class="hljs-string">'D'</span>)]</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://www.jianshu.com/c/ab55c73e0037?utm_source=desktop&utm_medium=notes-included-collection" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/20/5d32f16d5b0bf92604.jpg" alt></a></td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写于开始之前&quot;&gt;&lt;a href=&quot;#写于开始之前&quot; class=&quot;headerlink&quot; title=&quot;写于开始之前&quot;&gt;&lt;/a&gt;写于开始之前&lt;/h3&gt;&lt;p&gt;笔者即将开始写一个系列的《&lt;code&gt;Python&lt;/code&gt;札记》。本系列的札记主要是自学&lt;code&gt;齐伟&lt;/code&gt;老师《跟老齐学&lt;code&gt;Python&lt;/code&gt;轻松入门》一书整理而来。书第一遍断断续续花了5个月，第二遍边看边整理，保守3个月。&lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://www.policx.com/categories/program/"/>
    
      <category term="Python" scheme="https://www.policx.com/categories/program/Python/"/>
    
    
      <category term="Python" scheme="https://www.policx.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>超时空从犯</title>
    <link href="https://www.policx.com/label/Accomplice/"/>
    <id>https://www.policx.com/label/Accomplice/</id>
    <published>2019-07-18T02:18:06.000Z</published>
    <updated>2019-08-29T03:51:56.546Z</updated>
    
    <content type="html"><![CDATA[<ul><li><input checked disabled type="checkbox"> 你回头看了我一眼</li></ul><a id="more"></a><ul><li><input disabled type="checkbox"> 我觉得那很久很久</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;input checked disabled type=&quot;checkbox&quot;&gt; 你回头看了我一眼&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="label" scheme="https://www.policx.com/categories/label/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter的环境配置 for Mac</title>
    <link href="https://www.policx.com/program/flutter/"/>
    <id>https://www.policx.com/program/flutter/</id>
    <published>2019-07-16T10:14:18.000Z</published>
    <updated>2019-08-28T08:10:45.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近Flutter已经疯狂的刷屏了各个技术博客、技术网站，完全有一统天下的气势。所以最近也决定开始尝尝鲜，从零开始一步步的来探索Flutter的世界。就从环境搭建开始，记录一下自己探索Flutter的过程。 </p><a id="more"></a><h2 id="安装Flutter"><a href="#安装Flutter" class="headerlink" title="安装Flutter"></a>安装Flutter</h2><p>首先我们可以在<a href="https://link.juejin.im?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Fget-started%2Finstall" target="_blank" rel="noopener">Flutter官网</a>上面看到一些配置环境的步骤。这里就直接开干了，走起。 </p><h3 id="1、配置HomeBrew"><a href="#1、配置HomeBrew" class="headerlink" title="1、配置HomeBrew"></a>1、配置HomeBrew</h3><p>我们在去配置Flutter的环境之前，需要先检查一下HomeBrew是不是最新的。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br></pre></td></tr></table></figure><p>如果没有brew的话，可以去<a href="https://link.juejin.im?target=https%3A%2F%2Fbrew.sh%2F" target="_blank" rel="noopener">HomeBrew官网</a>自行下载。这里就不赘述了，这里如果重新下载的话，看到下面的打印信息就说明下载完毕了。 </p><p><img src="https://i.loli.net/2019/07/16/5d2db3aad595f24923.jpg" alt></p><h3 id="2、下载SDK"><a href="#2、下载SDK" class="headerlink" title="2、下载SDK"></a>2、下载SDK</h3><p>接下来就是去官网下载SDK了。注意，这里下载SDK有两种方法：</p><ul><li>一是直接<code>git clone -b beta https://github.com/flutter/flutter.git</code>下载</li><li>二是自己在官网下载下来，如下图<br><img src="https://i.loli.net/2019/07/16/5d2db40e0aecc50465.jpg" alt></li></ul><p>这里我两种方法都试过了一遍，第一种方法实在是太慢了，在经历了耗费一个半小时下载到94%，最后提示失败了的过程之后，我决定还是用第二种方法，整个过程只用了3分钟的样子，相当满意。下载完之后，是一个名字叫<code>flutter_macos_v1.5.4-hotfix.2-stable.zip</code>的压缩包。 然后我们解压这个zip包，把解压出来的<strong>flutter</strong>文件放到根目录下即可。 </p><h3 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h3><p>因为Flutter的SDK中包含了很多的命令行工具。我们就需要配置环境变量，所以我直接就安装到了根目录下了。</p><p><strong>配置镜像</strong></p><p>因为Flutter在运行的时候，就需要去官网下载一些需要的资源，但是因为天国特色的wall的原因，我们就需要镜像服务器，这个在<a href="https://link.juejin.im?target=https%3A%2F%2Fflutter.dev%2Fcommunity%2Fchina" target="_blank" rel="noopener">官网</a>上面有写的很明白，而且这是一个临时的镜像，后面还要以官网的镜像地址为准。 </p><p><img src="https://i.loli.net/2019/07/16/5d2db3f2c1f4f64480.jpg" alt></p><p>我们跳转到根目录 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>就能找到这个<code>.bash_profile</code>隐藏文件，我们用vim打开这个文件 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><p>然后需要输入就把A键按一下进入编辑模式，把下面三个环境变量配置进去 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">export PATH=/Users/xueliheng/flutter/bin:$PATH</span><br></pre></td></tr></table></figure><p>注意下，第三个环境变量这里<code>/Users/xueliheng/</code>是我的根目录，然后<code>/flutter/</code>是我们刚刚解压的的zip包里面的<code>flutter</code>文件夹。上面两个环境变量是两个镜像地址，上文中也有说过。 接着<code>shift+：</code>然后输入<code>wq</code>保存并退出vim。输入如下命令： </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>最后我们就可以验证一下flutter环境有没有配置成功了。输入： </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter -h</span><br></pre></td></tr></table></figure><p>看到如下如的打印信息就是配置成功了<br><img src="https://i.loli.net/2019/07/16/5d2db44407fa682753.jpg" alt></p><h3 id="4、配置Android-Studio"><a href="#4、配置Android-Studio" class="headerlink" title="4、配置Android Studio"></a>4、配置Android Studio</h3><p>如果没有下载<strong>Android Studio</strong>的话，就去<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fstudio" target="_blank" rel="noopener">官网</a>去下载一下。 我们用<code>flutter doctor</code>命令去检查一下flutter的环境配置，我们可以看到如下打印 </p><p><img src="https://i.loli.net/2019/07/16/5d2db4676ec3a36838.jpg" alt></p><p>这里的每个<code>✗</code>都是我们要去解决的问题。不过他有告诉你应该怎么做。比如第一个提示： </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[✗] Android toolchain - develop for Android devices</span><br><span class="line">    ✗ Unable to locate Android SDK.</span><br></pre></td></tr></table></figure><p>这就是让你去下载Android Studio。我们在下载完成之后，打开AS让他去下载一些应该下载的东西。 如果这里有提示你 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[✗] Android toolchain - develop for Android devices (Android SDK version 24.0.2)</span><br><span class="line">    ✗ Flutter requires Android SDK 28 and the Android BuildTools 28.0.3</span><br></pre></td></tr></table></figure><p>这就是在提示让你去升级一下SDK，然后命令如下 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/Users/xueliheng/Library/Android/sdk/tools/bin/sdkmanager&quot; &quot;platforms;android-28&quot; &quot;build-tools;28.0.3&quot;</span><br></pre></td></tr></table></figure><p>注意一下，这个地方的升级是需要”科学上网“的，如果有的小伙伴没有这个条件的话，我这边百度云上面给大家准备了一个<a href="https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F10yp8PuRXxk7YvcNR_dTy8Q" target="_blank" rel="noopener">链接</a>，提取码: e48c，大家可以下载下来。下载下来之后解压到<code>/Users/Library/Android/</code>这个文件夹。把原先的SDK直接覆盖就行了，就已经是最新的SDK了。 </p><p>接下来我们配置一下安卓的环境变量，还是在根目录下找到<code>.bash_profile</code>文件，并在其中添加四个环境变量 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export ANDROID_HOME=~/Library/Android/sdk</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/emulator</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/tools</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools</span><br></pre></td></tr></table></figure><p>分别是： </p><ul><li>安卓sdk的路径</li><li>安卓的模拟器路径</li><li>安卓tools路径</li><li>安卓平台工具</li></ul><p>接下来我们再用<code>flutter doctor</code>检查的时候，显示的信息如下图<br><img src="https://i.loli.net/2019/07/16/5d2db4964a70b73490.jpg" alt></p><p>意思就是让我们去下载iOS的相关环境，我们先暂时放放，下面还有一个关于<strong>Android Studio</strong>的没有解决完</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br></pre></td></tr></table></figure><p>这个就是缺少Flutter插件的意思，那么我们就去AS里面去配置一下好了。打开AS的<code>Preferences</code>，点击<code>Plugins</code>，在搜索栏中输入<code>flutter</code>，找到相应的插件，然后<code>Install</code>。当跳出安装Dart插件的提示界面时，记得点击Yes进行安装。安装完毕之后<code>restart IDE</code>重启AS。 重启之后就能看到多了一个这个东西<br><img src="https://i.loli.net/2019/07/16/5d2db4b731cbd14001.jpg" alt></p><p>我们再用<code>flutter doctor</code>检测一下<br><img src="https://i.loli.net/2019/07/16/5d2db4cdc6dd137908.jpg" alt></p><p>现在终于ok了。我们看到<code>[✓]Android Studio</code>说明，安卓的环境基本上配置成功，接下来我们就配置一下安卓的模拟器就好了。 </p><h3 id="5、安卓模拟器配置"><a href="#5、安卓模拟器配置" class="headerlink" title="5、安卓模拟器配置"></a>5、安卓模拟器配置</h3><p>在AS中找到模拟器配置如下图并选择<br><img src="https://i.loli.net/2019/07/16/5d2db4dacfde455330.jpg" alt></p><p>接着就创建设备，选择设备<br><img src="https://i.loli.net/2019/07/16/5d2db4e68a2ed68879.jpg" alt></p><p>选择系统<br><img src="https://i.loli.net/2019/07/16/5d2db4f6cdc5889902.jpg" alt></p><p>最后点击下载就完成了。 </p><h3 id="6、配置iOS环境"><a href="#6、配置iOS环境" class="headerlink" title="6、配置iOS环境"></a>6、配置iOS环境</h3><p>我们配置完了安卓的环境，再来<code>flutter doctor</code>检测一下。<br><img src="https://i.loli.net/2019/07/16/5d2db50ad75eb82331.jpg" alt></p><p>情况是这样的。目前1.5.4版本的Flutter需要匹配新版本的Xcode10.2.1。按照他提示的来试试，提示我Xcode版本太低了，需要升级Xcode<br><img src="https://i.loli.net/2019/07/16/5d2db5275c8f825074.jpg" alt></p><p>更新到最新的之后，继续走下面的步骤依旧会报错。那么我们可以试试下面的这个办法： </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ brew link pkg-config</span><br><span class="line">$ brew install --HEAD usbmuxd</span><br><span class="line">$ brew unlink usbmuxd</span><br><span class="line">$ brew link usbmuxd</span><br><span class="line">$ brew install --HEAD libimobiledevice</span><br><span class="line">$ brew install ideviceinstaller</span><br></pre></td></tr></table></figure><p>这些执行完之后执行一下<code>flutter doctor</code><br><img src="https://i.loli.net/2019/07/16/5d2db5515858b19228.jpg" alt></p><p>最后还真是没错，全部配置完成了！那么我们就把iOS的也配置完毕了。</p><h3 id="7、VSCode的使用"><a href="#7、VSCode的使用" class="headerlink" title="7、VSCode的使用"></a>7、VSCode的使用</h3><p>VSCode上面使用的话，就简单多了，这里我就简答的赘述一下。 只需要将<code>Dart</code>和<code>Flutter</code>插件都下载下来<br><img src="https://i.loli.net/2019/07/16/5d2db5643b08597602.jpg" alt></p><p>然后<code>command+shift+p</code>输入<code>flutter</code>，选择<code>Flutter：New Project</code><br><img src="https://i.loli.net/2019/07/16/5d2db576e145096766.jpg" alt></p><p>输入要创建的项目的名称和存放项目的地址。如果提示需要指明flutter的SDK的路径，那就选择根目录那个经过解压得来的flutter的文件夹就好了。 接下来是这样一个界面<br><img src="https://i.loli.net/2019/07/16/5d2db588f1b5152482.jpg" alt></p><p>接下来我们选择<code>View-&gt;Start Debugging</code>来运行项目。<br><img src="https://i.loli.net/2019/07/16/5d2db59bb3b3338193.jpg" alt></p><p>当然这个过程需要你把Xcode的模拟器打开。运行完之后就能看到这个界面，也就是你的第一个Flutter工程啦！<br><img src="https://i.loli.net/2019/07/16/5d2db5ad5eaf434960.jpg" alt></p><h3 id="8、Hot-reload的使用"><a href="#8、Hot-reload的使用" class="headerlink" title="8、Hot reload的使用"></a>8、Hot reload的使用</h3><p>我们打开<code>lib/main.dart</code>文件，然后在其中找到 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have pushed the button this many times:</span><br></pre></td></tr></table></figure><p>并把这个改为 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have clicked the button this many times:</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/16/5d2db5cc5b4f279074.jpg" alt><br>那么我们就能看到界面上多了一个小闪电<br><img src="https://i.loli.net/2019/07/16/5d2db5f044c0553935.jpg" alt></p><p>我们现在如果<code>command+s</code>保存一下更改的话，就能很快的在模拟器上面看到相应的更改，不需要再重新去编译一边。这一点简直是太棒了！解决了iOS开发者一个大痛点啊！！！ </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，flutter的环境搭建工作基本上就进行完毕了，整个过程大概耗时接近2个小时，这期间包括采坑、查资料、下载、科学上网…等等很蛋疼的事情。当然网速基本上是最大的障碍，浪费了很多的时间。所以也是需要一定的耐心来完成的。 后面的文章也会持续的更新，最近有点懈怠，OpenGL系列的文章有点拖更的节奏，这个后面会补起来。Flutter我也才刚刚接手，也是慢慢的来采坑，也会以此来记录自己的学习经历，也希望能多多跟大家交流。 再次我附上自己的邮箱<code>coderspr1nghall@gmail.com</code>欢迎讨论交流。 </p><br><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://juejin.im/post/5d0508d56fb9a07ec373eb9e" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/16/5d2dbb03b8ef977558.jpg" alt></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近Flutter已经疯狂的刷屏了各个技术博客、技术网站，完全有一统天下的气势。所以最近也决定开始尝尝鲜，从零开始一步步的来探索Flutter的世界。就从环境搭建开始，记录一下自己探索Flutter的过程。 &lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://www.policx.com/categories/program/"/>
    
      <category term="Flutter" scheme="https://www.policx.com/categories/program/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Python爬虫</title>
    <link href="https://www.policx.com/program/Python/spider/"/>
    <id>https://www.policx.com/program/Python/spider/</id>
    <published>2019-07-15T02:06:04.000Z</published>
    <updated>2019-08-28T08:10:45.196Z</updated>
    
    <content type="html"><![CDATA[<p>现在Python语言大火，在网络爬虫、人工智能、大数据等领域都有很好的应用。今天我向大家介绍一下Python爬虫的一些知识和常用类库的用法，希望能对大家有所帮助。</p><a id="more"></a><p>其实爬虫这个概念很简单，基本可以分成以下几个步骤：</p><ul><li><p>发起网络请求</p></li><li><p>获取网页</p></li><li><p>解析网页获取数据</p></li></ul><p>发起网络请求这个步骤常用的类库有标准库urllib以及Python上常用的requests库。解析网页常用的类库有的BeautifulSoup。另外requests的作者还开发了另一个很好用的库requests-html，提供了发起请求和解析网页的二合一功能，开发小型爬虫非常方便。另外还有一些专业的爬虫类库，其中比较出名的就是scrapy。本文将会简单介绍一下这些类库，之后还会专门写一篇文章介绍scrapy的用法。</p><h2 id="标准库urllib"><a href="#标准库urllib" class="headerlink" title="标准库urllib"></a><strong>标准库urllib</strong></h2><p>首先先来看标准库urllib。标准库的优点是Python自带的，不需要安装任何第三方库，缺点就是urllib属于偏底层的库，使用起来比较麻烦。下面是urllib发起请求的一个简单例子，大家看看就好。可以看到为了发起一个简单的请求，我们需要创建opener、request、ProxyHandler等好几个对象，比较麻烦。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> request</span><br><span class="line"><span class="hljs-keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="hljs-string">'https'</span>: <span class="hljs-string">'https://127.0.0.1:1080'</span>,</span><br><span class="line">    <span class="hljs-string">'http'</span>: <span class="hljs-string">'http://127.0.0.1:1080'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'user-agent'</span>:</span><br><span class="line">    <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="hljs-string">'--------------使用urllib--------------'</span>)</span><br><span class="line">url = <span class="hljs-string">'http://www.google.com'</span></span><br><span class="line">opener = request.build_opener(request.ProxyHandler(proxies))</span><br><span class="line">request.install_opener(opener)</span><br><span class="line">req = request.Request(url, headers=headers)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode())</span><br></pre></td></tr></table></figure><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a><strong>requests</strong></h2><p>requests是Kenneth Reitz大神的著名作品之一，优点就是极度简单和好用。首先来安装requests。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>下面是一个简单的例子，和上面urllib示例代码实现的功能相同，但是代码量少多了，也更易读。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="hljs-string">'--------------使用requests--------------'</span>)</span><br><span class="line">response = requests.get(<span class="hljs-string">'https://www.google.com'</span>, headers=headers, proxies=proxies)</span><br><span class="line">response.encoding = <span class="hljs-string">'utf8'</span></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>requests还可以方便的发送表单数据，模拟用户登录。返回的Response对象还包含了状态码、header、raw、cookies等很多有用的信息。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="hljs-string">'name'</span>: <span class="hljs-string">'yitian'</span>,</span><br><span class="line">    <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>,</span><br><span class="line">    <span class="hljs-string">'friends'</span>: [<span class="hljs-string">'zhang3'</span>, <span class="hljs-string">'li4'</span>]</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(<span class="hljs-string">'http://httpbin.org/post'</span>, data=data)</span><br><span class="line">pprint(response.__dict__)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><p>关于requests我就不多做介绍了，因为它有中文文档，虽然比官方落后几个小版本号，不过无伤大雅，大家可以放心参阅。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cn.python-requests.org/zh_CN/latest/</span><br></pre></td></tr></table></figure><h2 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a><strong>beautifulsoup</strong></h2><p>利用前面介绍的requests类库，我们可以轻易地获取HTML代码，但是为了从HTML中找到所需的数据，我们还需要HTML/XML解析库，BeautifulSoup就是这么一个常用的库。首先先来安装它：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><p>这次就用我简书主页作为例子，爬取一下我简书的文章列表。首先先用requests获取到网页内容。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint</span><br><span class="line"><span class="hljs-keyword">import</span> bs4</span><br><span class="line"><span class="hljs-keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'user-agent'</span>:</span><br><span class="line">    <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="hljs-string">'https://www.jianshu.com/u/7753478e1554'</span></span><br><span class="line">response = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure><p>然后就是BeautifulSoup的代码了。在使用BeautifulSoup的时候首先需要创建一个HTML树，然后从树中查找节点。BeautifulSoup主要有两种查找节点的办法，第一种是使用find和find_all方法，第二种方法是使用select方法用css选择器。拿到节点之后，用contents去获取它的子节点，如果子节点是文本，就会拿到文本值，注意这个属性返回的是列表，所以要加[0]。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">html = bs4.BeautifulSoup(response.text, features=<span class="hljs-string">'lxml'</span>)</span><br><span class="line">note_list = html.find_all(<span class="hljs-string">'ul'</span>, class_=<span class="hljs-string">'note-list'</span>, limit=<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]</span><br><span class="line"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> note_list.select(<span class="hljs-string">'li&gt;div.content&gt;a.title'</span>):</span><br><span class="line">    title = a.contents[<span class="hljs-number">0</span>]</span><br><span class="line">    link = <span class="hljs-string">f'https://www.jianshu.com<span class="hljs-subst">&#123;a[<span class="hljs-string">"href"</span>]&#125;</span>'</span></span><br><span class="line">    print(<span class="hljs-string">f'《<span class="hljs-subst">&#123;title&#125;</span>》,<span class="hljs-subst">&#123;link&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>BeautifulSoup也有中文文档，同样也是稍微落后两个小版本，影响不大。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</span><br></pre></td></tr></table></figure><h2 id="requests-html"><a href="#requests-html" class="headerlink" title="requests-html"></a><strong>requests-html</strong></h2><p>这个类库是requests的兄弟，同样也是Kenneth Reitz大神的作品。它将请求网页和解析网页结合到了一起。本来如果你用requests的话只能请求网页，为了解析网页还得使用BeautifulSoup这样的解析库。现在只需要requests-html一个库就可以办到。<br>首先先来安装。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests-html</span><br></pre></td></tr></table></figure><p>然后我们来看看用requests-html如何重写上面这个例子。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> requests_html <span class="hljs-keyword">import</span> HTMLSession</span><br><span class="line"><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">url = <span class="hljs-string">'https://www.jianshu.com/u/7753478e1554'</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'user-agent'</span>:</span><br><span class="line">    <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'</span></span><br><span class="line">&#125;</span><br><span class="line">session = HTMLSession()</span><br><span class="line">r = session.get(url, headers=headers)</span><br><span class="line">note_list = r.html.find(<span class="hljs-string">'ul.note-list'</span>, first=<span class="hljs-literal">True</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> note_list.find(<span class="hljs-string">'li&gt;div.content&gt;a.title'</span>):</span><br><span class="line">    title = a.text</span><br><span class="line">    link = <span class="hljs-string">f'https://www.jianshu.com<span class="hljs-subst">&#123;a.attrs[<span class="hljs-string">"href"</span>]&#125;</span>'</span></span><br><span class="line">    print(<span class="hljs-string">f'《<span class="hljs-subst">&#123;title&#125;</span>》,<span class="hljs-subst">&#123;link&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>requests-html除了可以使用css选择器来搜索以外，还可以使用xpath来查找。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> r.html.xpath(<span class="hljs-string">'//ul[@class="note-list"]/li/div[@class="content"]/a[@class="title"]'</span>):</span><br><span class="line">    title = a.text</span><br><span class="line">    link = <span class="hljs-string">f'https://www.jianshu.com<span class="hljs-subst">&#123;a.attrs[<span class="hljs-string">"href"</span>]&#125;</span>'</span></span><br><span class="line">    print(<span class="hljs-string">f'《<span class="hljs-subst">&#123;title&#125;</span>》,<span class="hljs-subst">&#123;link&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>requests-html还有一个很有用的特性就是浏览器渲染。有些网页是异步加载的，直接用爬虫去爬只能得到一个空页面，因为数据是靠浏览器运行JS脚本异步加载的，这时候就需要浏览器渲染了。而浏览器渲染用requests-html做非常简单，只要多调用一个render函数即可。render函数有两个参数，分别指定页面下滑次数和暂停时间。render函数第一次运行的时候，requests-html会下载一个chromium浏览器，然后用它渲染页面。<br>简书的个人文章页面也是一个异步加载的例子，默认只会显示最近几篇文章，通过浏览器渲染模拟页面下滑，我们可以得到所有文章列表。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session = HTMLSession()</span><br><span class="line">r = session.get(url, headers=headers)</span><br><span class="line"><span class="hljs-comment"># render函数指示requests-html用chromium浏览器渲染页面</span></span><br><span class="line">r.html.render(scrolldown=<span class="hljs-number">50</span>, sleep=<span class="hljs-number">0.2</span>)</span><br><span class="line"><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> r.html.xpath(<span class="hljs-string">'//ul[@class="note-list"]/li/div[@class="content"]/a[@class="title"]'</span>):</span><br><span class="line">    title = a.text</span><br><span class="line">    link = <span class="hljs-string">f'https://www.jianshu.com<span class="hljs-subst">&#123;a.attrs[<span class="hljs-string">"href"</span>]&#125;</span>'</span></span><br><span class="line">    print(<span class="hljs-string">f'《<span class="hljs-subst">&#123;title&#125;</span>》,<span class="hljs-subst">&#123;link&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>类似的，今日头条的个人页面也是异步加载的，所以也得调用render函数。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">from</span> requests_html <span class="hljs-keyword">import</span> HTMLSession</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="hljs-string">'user-agent'</span>:</span><br><span class="line">        <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'</span></span><br><span class="line">&#125;</span><br><span class="line">session = HTMLSession()</span><br><span class="line">r = session.get(<span class="hljs-string">'https://www.toutiao.com/c/user/6662330738/#mid=1620400303194116'</span>, headers=headers)</span><br><span class="line">r.html.render()</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r.html.find(<span class="hljs-string">'div.rbox-inner a'</span>):</span><br><span class="line">    title = i.text</span><br><span class="line">    link = <span class="hljs-string">f'https://www.toutiao.com<span class="hljs-subst">&#123;i.attrs[<span class="hljs-string">"href"</span>]&#125;</span>'</span></span><br><span class="line">    print(<span class="hljs-string">f'《<span class="hljs-subst">&#123;title&#125;</span>》 <span class="hljs-subst">&#123;link&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>最后是requests-html的官网地址以及中文文档。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://html.python-requests.org/</span><br><span class="line">https://cncert.github.io/requests-html-doc-cn/</span><br></pre></td></tr></table></figure><h2 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a><strong>scrapy</strong></h2><p>以上介绍的几个框架都是各自有各自的作用，把它们结合起来可以达到编写爬虫的目的，但是要说专业的爬虫框架，还是得谈谈scrapy。作为一个著名的爬虫框架，scrapy将爬虫模型框架化和模块化，利用scrapy，我们可以迅速生成功能强大的爬虫。<br>不过scrapy概念众多，要仔细说还得专门开篇文章，这里就只简单演示一下。首先安装scrapy，如果是Windows系统，还需要安装pypiwin32。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy  </span><br><span class="line">pip install pypiwin32</span><br></pre></td></tr></table></figure><p>然后创建scrapy项目并添加一个新爬虫。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject myproject</span><br><span class="line">cd myproject</span><br><span class="line">scrapy genspider my jianshu.com</span><br></pre></td></tr></table></figure><p>打开配置文件settings.py，设置用户代理，否则会遇到403错误。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_AGENT = <span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0'</span></span><br></pre></td></tr></table></figure><p>然后修改一下爬虫。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="hljs-keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JianshuSpider</span><span class="hljs-params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="hljs-string">'jianshu'</span></span><br><span class="line">    allowed_domains = [<span class="hljs-string">'jianshu.com'</span>]</span><br><span class="line">    start_urls = [<span class="hljs-string">'https://www.jianshu.com/u/7753478e1554'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span><span class="hljs-params">(self, response)</span>:</span></span><br><span class="line">        <span class="hljs-keyword">for</span> article <span class="hljs-keyword">in</span> response.css(<span class="hljs-string">'div.content'</span>):</span><br><span class="line">            <span class="hljs-keyword">yield</span> &#123;</span><br><span class="line">                <span class="hljs-string">'title'</span>: article.css(<span class="hljs-string">'a.title::text'</span>).get(),</span><br><span class="line">                <span class="hljs-string">'link'</span>: <span class="hljs-string">'https://www.jianshu.com'</span> + article.xpath(<span class="hljs-string">'a[@class="title"]/@href'</span>).get()</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>最后运行一下爬虫。</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl my</span><br></pre></td></tr></table></figure><br><table><thead><tr><th>👇</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1563247765&ver=1731&signature=gm2iTUKE3itOZzvlz9SUtKCYNv*PqEYt2C7ReV7kd47e2ZAWPvG5GRXZUJsiRIde34Uh5FznBslw4hHhXmHQXyV3yz0tTdgds1RMCdai6Oyy98w2-iTBRWeJlpm3cWa8&new=1" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/16/5d2d4c5ba835e96705.jpg" alt="Python"></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在Python语言大火，在网络爬虫、人工智能、大数据等领域都有很好的应用。今天我向大家介绍一下Python爬虫的一些知识和常用类库的用法，希望能对大家有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="program" scheme="https://www.policx.com/categories/program/"/>
    
      <category term="Python" scheme="https://www.policx.com/categories/program/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>DDoS（分布式拒绝服务）攻击是无解的吗？</title>
    <link href="https://www.policx.com/news/ddos/"/>
    <id>https://www.policx.com/news/ddos/</id>
    <published>2019-07-14T07:26:43.000Z</published>
    <updated>2019-08-15T01:24:56.404Z</updated>
    
    <content type="html"><![CDATA[<p><strong>“</strong></p><p>DDOS？ </p><p>一言难尽啊！ </p><p>”</p><a id="more"></a><p>先说结论，DDoS是近年来网络攻击中的一棵“常青树”，的确很难缠，但说它是无解的，那也有点太看得起它了。虽然DDoS在对很多大平台的攻击中出尽了风头，但在现在互联网的解决方案中，并不缺乏应对DDoS的解决方案。 </p><p>说起DDoS攻击，我脑海里能够想到的全都是中国民间俗语，什么“双拳难敌四手，好汉架不住人多”，什么“千斤拨四两”，什么“乱拳打死老师傅”等等等等。 </p><p>之前有朋友跑来问我DDoS是个什么东西，为什么这么多互联网巨头都被搞得没有脾气，我记得我当时我是这么举的例子： </p><p>我们这一代人小的时候，自助餐开始在中国内地风行，那会儿这个行业里为了打击竞争对手，对手最惯常使用的阴招是雇佣很多五大三粗的人，给他们钱去对方的店里一通猛吃，杯盘狼藉之下，用不了几天这家自助餐就能给吃黄了。 </p><p>而DDoS攻击比这种还阴损，如果你开了一家餐馆，你的对手如果想搞你，最好的办法就是找一堆地痞流氓到你的店里坐的满满一屋子，你如果上前问，他们就一直跟你扯淡找麻烦，导致真正想吃饭的顾客一看这个情形，掉头就走了。 </p><p>用不了多久，你的餐馆就会开不下去，而你的竞争对手就会趁机蚕食掉你的市场份额，而放在网络语境里，这就是DDoS攻击的最基本原理。 </p><p>而这件事之所以难缠在于，一两个无赖根本成不了气候，想要耍流氓必须要有很多个无赖集结在一起。<strong>所以和现实世界中的无赖一样，DDoS真正的杀手锏在于利用能够发动的汹涌的流量，可以瞬间冲垮被攻击网站的服务器。</strong></p><p>如果我们回溯一下历史的话，会发现黑客组织之所以会有组织有预谋的发起DDoS攻击，基本上都是基于以下几个原因： </p><ul><li><p>有些行业如果网站被恶意攻击，会造成很难估量的损失，这个时候黑客发动DDoS攻击的初衷一般是出于敲诈勒索，为了保证企业的正常运转，他们通常愿意向黑客付高额的赎金； </p></li><li><p>行业内血海一片，DDoS是恶意竞争的屠刀。这个现象从逻辑上，其实雇佣无赖去占领对手餐馆的原理是一毛一样的，而且DDOS攻击早已产业化，现在中国的DDOS黑市，出钱请黑客打1G的流量到一个网吧或网站，市场价只要不到50块钱，但对于一个创业公司或者干脆就是一个小网吧来说，这已经算是可以灭顶的无妄之灾了。 </p></li><li><p>DDoS攻击往往成为掩盖真实网络攻击的烟雾弹，在遭受DDoS攻击的企业中，部分企业还伴随数据丢失的现象，黑客利用DDoS攻击掩盖其窃取用户隐私的真实目的，这种攻击行为在社交网站、金融领域等用户隐私高价值的行业尤为高发。 </p></li></ul><p>比如说，去年年初的时候，荷兰第一大银行荷兰商业银行于2018年1月28日晚间遭到DDoS攻击；第二大银行荷兰合作银行的网银服务29日早晨遭到攻击；第三大银行荷兰银行在那一周内共遭到7次网络攻击，仅周末就有3次。 </p><p>不过这一次发生在荷兰的针对银行系统的攻击并没有造成用户隐私的泄露，原因在于这仅仅是一次来自俄罗斯一个网络间谍组织Cozy Bear对荷兰情报组织AIVD侵犯其计算机的“单纯”的报复行为。<strong>但并不是所有黑客组织发起的DDoS攻击都如此单纯。</strong></p><p>2018年年底时万豪酒店发布了一则公告，称其旗下喜达屋酒店的5亿人次的信息被泄露，共计3.27亿人，泄露信息包括姓名、邮寄地址、电话号码、电子邮件昂面地址、护照号码、出生日期、性别等等入住信息，更糟糕的是万豪无法确定，侵入酒店系统的第三方黑客，在窃取的信息中是否包含客人的银行卡号和密码。（此案例和DDOS攻击无关，建议采用其他案例，比如2011年4月20日至26日，索尼遭受DDoS攻击，目的是为了掩盖盗取索尼PS的用户数据。） </p><p>而游戏领域，则是DDoS攻击的另一个重灾区，不光是刚才前文中提到的暴雪，包括索尼、金山、网易在内的众多知名游戏公司都曾数次遭受攻击，可以说DDoS攻击是游戏企业的噩梦。 </p><p>许多刚创业的游戏公司，可能刚上线就被打死，而一些处在融资阶段的游戏公司，由于遭遇攻击而被迫停服，则很大程度上会调低投资人的预期，甚至导致融资失败。 </p><p>而这些因素，都是竞对打压或者敲诈勒索的绝对软肋。 </p><p>从以上的几个案例我们不难看出，和现实中的耍流氓和敲诈勒索相比，通过网络手段进行攻击的风险和成本更低，坏蛋的嘴脸也更穷凶极恶一点，无论是政府机构还是企业平台，无论你是巨头还是小蚂蚁，只要你身上有羊毛可以薅，你都时刻面临着被洗劫的风险 </p><p>不过刚在开头我也讲了，虽然DDoS很难缠很让人头痛，但本质上图并不是无解的。 </p><p>回到我最开始讲的那个例子。 </p><p>你是一个餐馆老板，过去三十年一直是个老老实实的厨子，突然面对五十个臭流氓到你店里耍无赖的时候，你最好的应对方法，应该是什么？ </p><p>自己组建一支人马，和这些臭流氓正面刚？这恐怕不行，因为你不是臭流氓，你没有相应的作战经验。 </p><p>报警请人民警察来帮忙处理？这恐怕也不行，人家在你店里没有打砸抢，只是“温和的”非暴力不合作，警察来了也只能当民事调解，并且人家马仔众多，明天再换一拨新面孔来，玩的你一点脾气都没有。 </p><p>这就是面对DDoS时，无论是巨头还是小蚂蚁，他们的实实在在的困境。 </p><p>但正所谓“道高一尺魔高一丈”，你在云上和我耍流氓，那我就在云上回击。 </p><p><strong>“云”的事儿，不如还交还给云来处理。</strong>我认为就目前DDoS的在攻击量级上的疯狂进击的前提下，云计算服务厂商或许是狙击它们的最有效手段。 </p><p>2018年年初，峰值1.35TB/秒的流量冲击了开发者平台 GitHub。这是第一次TB量级的DDoS攻击。GitHub 受到攻击后，服务器断断续续，无法访问。攻击发生 10 分钟后，GitHub 向CDN 服务商 Akamai 请求协助，访问 GitHub 的流量已经由后者接管并在15分钟之内完成了防御。 </p><p>Akamai的相关负责人在接受采访时说，我们是基于迄今为止最大规模 DDoS 攻击五倍的峰值而做的相应准备，所以 1.3T 对我们来说是小意思。 </p><p>在关于流量峰值这一点上，我认为饱受双11、双12、618等全民购物狂欢的电商巨头们更有发言权，就拿京东举例子好了。 </p><p>京东云在之前发布的高防版的DDoS服务中，展示出了非常明确的信心是，在多年的电商狂欢流量对抗中，京东云已经在实战中建立了一套完备的防御机制，无论是在流量峰值的建模上，还是在DDoS的防御算法上，它的部署都远远不是纸上谈兵，而是拳拳到肉的经受住了实战的洗礼。要知道，全世界每年有超过5成的DDoS攻击都来自中国，而我们的国家也是全世界超过美国的第一大“肉鸡”市场，由电商大数据加持演化而来的京东云，它在云安全的理解上可以说是非常深刻了。 </p><p>所以说，如果说一定要有一个结论，我想说“上帝的归上帝，而云上的归云上”，像京东云这样的基于电商大数据考验的云计算平台，或许才是对抗DDoS的最终答案。 </p><br><table><thead><tr><th><strong>原文链接</strong><br>👇</th></tr></thead><tbody><tr><td><a href="https://mp.weixin.qq.com/s/n2azdlye7mNHzlfL8nvnLA" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/17/5d2f3adcbb2ed60428.png" alt="jd"></a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;“&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DDOS？ &lt;/p&gt;
&lt;p&gt;一言难尽啊！ &lt;/p&gt;
&lt;p&gt;”&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="https://www.policx.com/categories/news/"/>
    
    
  </entry>
  
</feed>
