<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>River and lake</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-07T15:43:34.134Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>policx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo-theme-icarus</title>
    <link href="http://yoursite.com/2019/07/07/hexo-theme-icarus/"/>
    <id>http://yoursite.com/2019/07/07/hexo-theme-icarus/</id>
    <published>2019-07-07T12:37:10.000Z</published>
    <updated>2019-07-07T15:43:34.134Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!--<div align="center"><img src="https://easyhexo.com/assets/img/icaruslogo.5efd3090.svg"></div>--><!--# hexo-theme-icarus <Badge text="@Susreal"/> <Badge text="Finish"/> <Badge text="2.3.0"/>------**目录：**[[toc]]--------><p><a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Hexo-theme-icarus</a> 是一个优秀的 Hexo 主题，开发者 <a href="https://github.com/ppoffice" target="_blank" rel="noopener">Ruipeng Zhang</a> 同时还维护了 <a href="https://github.com/ppoffice/hexo-theme-hueman" target="_blank" rel="noopener">hexo-theme-hueman</a> 和 <a href="https://github.com/ppoffice/hexo-theme-minos" target="_blank" rel="noopener">hexo-theme-minos</a> 两个项目。</p><a id="more"></a><p>icarus 是一个三栏结构的自适应主题，预置了大量第三方插件，可以方便使用者快速建站。整体风格简约，适合各种类型的站点，无论是技术文章，还是摄影佳作，都可以完美承载。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://easyhexo.com/assets/img/1.7fabd81a.png" alt="Icarus"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在命令行中cd至博客根目录，加载主题：</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="hljs-built_in">clone</span> https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus</span><br></pre></td></tr></table></figure><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>首先，要在博客根目录下的 <code>_config.yml</code> 文件中做两件事情：</p><ol><li>设置语言: <code>language: zh-CN</code></li><li>设置主题为 icarus: <code>theme: icarus</code></li></ol><p>icarus 为我们预置了多达 12 种语言，默认是英文。一开始我没有设置语言，电脑上打开使用的是英文，但是手机上看就是一种类似葡萄牙语的文字。没有深究原因，所以还是按照博客的受众以及平时的喜好设置一下语言，zh-CN是简体中文。</p><h3 id="icarus-的文件结构"><a href="#icarus-的文件结构" class="headerlink" title="icarus 的文件结构"></a>icarus 的文件结构</h3><p>先来看看 icarus 主题的文件结构吧，让我们准备好尖叫声！ </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├─includes</span><br><span class="line">├─languages</span><br><span class="line">├─layout</span><br><span class="line">│  ├─comment</span><br><span class="line">│  ├─common</span><br><span class="line">│  ├─donate</span><br><span class="line">│  ├─plugin</span><br><span class="line">│  ├─search</span><br><span class="line">│  ├─share</span><br><span class="line">│  └─widget</span><br><span class="line">├─sripts</span><br><span class="line">└─source</span><br><span class="line">    ├─css</span><br><span class="line">    ├─images</span><br><span class="line">    └─js</span><br></pre></td></tr></table></figure><p>仔细观察渲染文件 <code>layout</code> 目录，就可以发现 icarus 的强大了，评论、捐赠、搜索、分享以及诸多第三方插件，都已经集成好啦！再说一遍，集成好啦！icarus 的简中翻译相对中规中矩，大家可以根据自己的文案风格修改 <code>languages</code> 目录下的 <code>zh-CN.yml</code> 文件。</p><h3 id="config-yml-文件配置"><a href="#config-yml-文件配置" class="headerlink" title="_config.yml 文件配置"></a><code>_config.yml</code> 文件配置</h3><p>首次在博客根目录执行 <code>hexo clean</code> 或者 <code>hexo g</code> 都会触发 icarus 自动生成一个 <code>_config.yml</code> 文件，我们逐一说明。</p><h3 id="logo"><a href="#logo" class="headerlink" title="logo"></a>logo</h3><p>logo 会展示在顶部导航栏的最左侧以及底部的footer区域，大家可以替换 <code>source/images/</code> 下的 logo 文件，使用 svg 或者 png 格式的都可以。研究源码发现，这个地方给没有 logo 的同学保留了一套文字方案：</p><figure class="highlight js hljs"><figcaption><span>/layout/common/navbar.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="hljs-keyword">if</span> (has_config(<span class="hljs-string">'logo.text'</span>) &amp;&amp; get_config(<span class="hljs-string">'logo.text'</span>)) &#123; %&gt;</span><br><span class="line">    &lt;%= get_config(<span class="hljs-string">'logo.text'</span>) %&gt;</span><br><span class="line">&lt;% &#125; <span class="hljs-keyword">else</span> &#123; %&gt;</span><br><span class="line">    &lt;img src=<span class="hljs-string">"&lt;%- url_for(get_config('logo')) %&gt;"</span> alt=<span class="hljs-string">"&lt;%= get_config('title') %&gt;"</span> height=<span class="hljs-string">"28"</span>&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>也就是说，只要给 logo 添加 <code>text</code> 属性，就会优先展示预设文字作为 logo：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">logo:</span></span><br><span class="line"><span class="hljs-attr">  text:</span> <span class="hljs-string">your</span> <span class="hljs-string">name</span></span><br></pre></td></tr></table></figure><p>这对于不会画 logo 的同学来说无疑是个大好消息了：</p><p><img src="https://easyhexo.com/assets/img/2.bdd49d13.png" alt="logo"></p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>icarus 预置了 <code>Changyan</code> <code>Disqus</code> <code>Facebook</code> <code>Gitment</code> <code>Gitalk</code> <code>Isso</code> <code>LiveRe</code> 和 <code>Valine</code> 八大主流评论插件。</p><p>这里以我使用的 <code>Valine</code> 为例。首先在 <a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 注册一个免费的开发账号，新建一个新应用，并把 appid 和 appkey 配置在对应部分：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">comment:</span></span><br><span class="line"><span class="hljs-attr">    type:</span> <span class="hljs-string">valine</span></span><br><span class="line"><span class="hljs-attr">    app_id:</span>         <span class="hljs-comment"># (required) LeanCloud application id</span></span><br><span class="line"><span class="hljs-attr">    app_key:</span>        <span class="hljs-comment"># (required) LeanCloud application key</span></span><br><span class="line"><span class="hljs-attr">    notify:</span>         <span class="hljs-comment"># (optional) receive email notification</span></span><br><span class="line"><span class="hljs-attr">    verify:</span>         <span class="hljs-comment"># (optional) show verification code</span></span><br><span class="line"><span class="hljs-attr">    placeholder:</span>    <span class="hljs-comment"># (optional) comment box placeholder text</span></span><br></pre></td></tr></table></figure><p>其余的三项选填，这样就完成了 <code>Valine</code> 的基本配置了。此外，<code>Valine</code> 同步 <a href="https://cn.gravatar.com/" target="_blank" rel="noopener">Gravatar</a> 头像，只要在评论的时候留下邮箱，就会展示你独一无二的头像咯！</p><p>效果如下：</p><p><img src="https://easyhexo.com/assets/img/3.59bd3843.png" alt="Valine Comment"></p><p>如果有的文章不希望别人评论，但是我们又希望把整个站点的评论关闭的话，就需要对指定文章进行评论关闭操作了。操作也很简单，只需要在文章 markdown 文件的 front-matter 区域设置  <font color="red"><del><code>comments</code></del> </font> <code>comment</code> 为 <code>false</code> 即可：</p><ul><li>注意：是 <font color="red">comment</font> 没有 <code>s</code></li></ul><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">---</span></span><br><span class="line"><span class="hljs-attr">title:</span> <span class="hljs-string">article</span> <span class="hljs-string">title</span></span><br><span class="line"><span class="hljs-attr">comment:</span> <span class="hljs-literal">false</span></span><br><span class="line"><span class="hljs-meta">---</span></span><br></pre></td></tr></table></figure><h3 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h3><p>作为程序员的收入来源之一，打赏是必不可少的啦。icarus 提供了 <code>支付宝</code> <code>微信</code> <code>PayPal</code> 和 <code>Patreon</code> 四种方式：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">donate:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">alipay</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">/images/alipay.JPG</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">wechat</span></span><br><span class="line"><span class="hljs-attr">        qrcode:</span> <span class="hljs-string">/images/wechat.JPG</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># type: paypal</span></span><br><span class="line">        <span class="hljs-comment"># Paypal business ID or email address</span></span><br><span class="line">        <span class="hljs-comment"># business: ''</span></span><br><span class="line">        <span class="hljs-comment"># Currency code</span></span><br><span class="line">        <span class="hljs-comment"># currency_code: USD</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># type: patreon</span></span><br><span class="line">        <span class="hljs-comment"># URL to the Patreon page</span></span><br><span class="line">        <span class="hljs-comment"># url: ''</span></span><br></pre></td></tr></table></figure><p><code>支付宝</code> 和 <code>微信</code> 只需要提供二维码就可以了，可以使用本地静态资源或者图床链接。效果如下，大家懂的：</p><p><a href="https://susreal.github.io/images/alipay.JPG" target="_blank" rel="noopener"><img src="https://easyhexo.com/assets/img/4.1e986323.png" alt="投喂现场"></a></p><h3 id="widget"><a href="#widget" class="headerlink" title="widget"></a>widget</h3><p>我觉得这是 icarus 比较精髓的部分了，所有的 widget 都是一个卡片，可以自由摆放在任何位置：</p><p><img src="https://easyhexo.com/assets/img/5.c1884f10.png" alt="卡片化部件"></p><p>包括文章在内，个人资料、链接、分类、最新文章、归档、标签和标签云都是一个卡片，可以在 <code>_config.yml</code> 中设置各个卡片的具体属性，同时也可以设置卡片出现在网站的左侧还是右侧：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">widgets:</span></span><br><span class="line"><span class="hljs-bullet">    -</span></span><br><span class="line">        <span class="hljs-comment"># Widget name</span></span><br><span class="line"><span class="hljs-attr">        type:</span> <span class="hljs-string">tagcloud</span></span><br><span class="line">        <span class="hljs-comment"># Where should the widget be placed, left or right</span></span><br><span class="line"><span class="hljs-attr">        position:</span> <span class="hljs-string">left</span></span><br></pre></td></tr></table></figure><h3 id="其他设置（置顶-阅读量统计）"><a href="#其他设置（置顶-阅读量统计）" class="headerlink" title="其他设置（置顶/阅读量统计）"></a>其他设置（置顶/阅读量统计）</h3><p>还有一些其他的设置就不在这里赘述了，具体可以参考 <a href="https://blog.zhangruipeng.me/hexo-theme-icarus/categories/" target="_blank" rel="noopener">官方文档</a> 进行了解。</p><p>除此之外，我根据实际需求，在 icarus 主题内添加了 <a href="https://susreal.com/article/2019/hexo-theme-icarus-2/#%E4%B8%80%E3%80%81%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6" target="_blank" rel="noopener">置顶文章</a> 和 <a href="https://susreal.com/article/2019/hexo-theme-icarus-2/#%E4%BA%8C%E3%80%81%E6%B7%BB%E5%8A%A0%E9%98%85%E8%AF%BB%E7%BB%9F%E8%AE%A1" target="_blank" rel="noopener">阅读量统计</a> 的两个小功能，大家如果有兴趣，可以前往我的博客和我交流喔:-O</p><br><ul><li>原文链接—&gt; <a href="https://easyhexo.com/2-Theme-use-and-config/2-12-hexo-theme-icarus/#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">easyhexo.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!--&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://easyhexo.com/assets/img/icaruslogo.5efd3090.svg&quot;&gt;&lt;/div&gt;--&gt;
&lt;!--
# hexo-theme-icarus &lt;Badge text=&quot;@Susreal&quot;/&gt; &lt;Badge text=&quot;Finish&quot;/&gt; &lt;Badge text=&quot;2.3.0&quot;/&gt;

------

**目录：**

[[toc]]

------
--&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo-theme-icarus&lt;/a&gt; 是一个优秀的 Hexo 主题，开发者 &lt;a href=&quot;https://github.com/ppoffice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ruipeng Zhang&lt;/a&gt; 同时还维护了 &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-hueman&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-theme-hueman&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-minos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo-theme-minos&lt;/a&gt; 两个项目。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中国合伙人</title>
    <link href="http://yoursite.com/2019/07/04/partner/"/>
    <id>http://yoursite.com/2019/07/04/partner/</id>
    <published>2019-07-04T14:59:09.000Z</published>
    <updated>2019-07-08T01:42:21.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote><p> 利益小的时候，什么都好说。利益大到一定程度，就超越了人性。</p></blockquote><a id="more"></a><h2 id="记：539天，失败的创业"><a href="#记：539天，失败的创业" class="headerlink" title="记：539天，失败的创业"></a><em>记：539天，失败的创业</em></h2><p><img src="https://policx.github.io/post-images/1562514309110.jpeg" alt></p><p>⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️</p><p><strong>互联网时代中国合伙人股权分配</strong>，第一我们讨论股权分配，第二我们讨论合伙人的股权分配。第三我们讨论的是中国合伙人股权分配，这些规则还是要符合我们国家这方山水。第四我们讨论的是互联网时代。</p><p>我们今天话题分成四部分，第一部分讨论互联网时代创业合伙人股权分配底层叫人力资本；第二个部分讨论关键词叫合伙人，什么样的人是合伙人。第三部分讨论合伙人内部股权怎么去分配。第四讨论股权的退出机制。</p><h1 id="第一部分-讨论互联网时代创业合伙人股权分配底层叫人力资本"><a href="#第一部分-讨论互联网时代创业合伙人股权分配底层叫人力资本" class="headerlink" title="第一部分 讨论互联网时代创业合伙人股权分配底层叫人力资本"></a>第一部分 讨论互联网时代创业合伙人股权分配底层叫人力资本</h1><p><strong>人力资本</strong></p><p>之前遇到一个创业者，做的是互联网教育。这个企业早期有三个创业合伙人。他们首先大致的算了一下这个项目需要100万启动资金，盘点了一下三个创始股东，各自能出多少钱。老大能出50万，老二能出30万，老三能出20万。随后他们确定了一下股权比例，出多少钱占多少股，然后他们就办理了工商变更登记手续。</p><p>但后来股权出问题了。公司做了半年时间，老二提出离职，一方面他跟老大，老三不和。另一方面，外部有一个其他的创业团队拉他入伙。但当他离职的时候就出现了一个问题。他出了30万，干了不到半年，占了公司30%的股份，这个股份怎么去处理。</p><p>当时要退出的老二，坚决不同意退股份。他有三个理由，第一这个股份也不是免费拿的，是花了30万买了公司30%的股份；第二中国的公司法没有规定，股东离职的情况下，还需要把股份退出来。第三公司章程没有约定，股东离职的情况下还需要把股份退出来。所以他坚决不同意退出股份。</p><p>这个时候老大跟老三傻了眼，他们确实找不到任何合法的理由，能把老二的股权收回来。但是他们又认为这个事情既不公平，也不合理。他们未来还可能继续运营这个公司5年、 10年时间。那10年以后，老二跑回来讲这个公司三分之一是自己的，这是不合理的。</p><p>所以这件事导致的结果是，第一创始人内部的股权战争内讧。第二投资人认为这个股权结构不合适，要等到股权调整到健康的情况下再考虑投资的事情，所以后面资本也投不进来。</p><p>创始人团队内部觉得不公平闹分裂、投资人不愿意投，大家都不满意的情况下，你觉得这个公司能做大吗？所以公司能不能做大倒不是说一个公司的股权结构合理，<strong>但凡是能做大的公司，股权结构都是合理的。</strong>后来就出现这种情况，股东觉得既然股权结构不合理，那就到外面再设计一家公司，赔钱的事情就交给老同事去做，赚钱的事情自己的公司去做。但是一旦出现这种结果的时候，对所有人而言都不是好结果。而且这种情况很有可能搞成转移公司资产，甚至成为刑事犯罪。</p><h6 id="所以绝大部分公司创业团队的股权分配有三个基本特点："><a href="#所以绝大部分公司创业团队的股权分配有三个基本特点：" class="headerlink" title="所以绝大部分公司创业团队的股权分配有三个基本特点："></a>所以绝大部分公司创业团队的股权分配有三个基本特点：</h6><ol><li>第一 把创业者当成投资人，钱出完了就不管了。</li><li>第二 只对钱定价，不对人定价，不考虑未来有没有参与这个项目。</li><li>第三 股权只有进入机制，没有调整机制，也没有退出机制。</li></ol><p>其实这些股权分配，既符合中国的公司法也符合我们工商口制定的章程，还符合传统的股权分配理念。但是这些股权出问题了。</p><p>出了问题，我们就要考虑，是什么原因导致了问题？之前大家都是这么分，也没有出问题，为什么现在出问题了？我们分析发现，其实两个时代特点不同，这种股权分配已经不适合现代了。</p><p>工业经济时代的特点是：公司是资金驱动型、资源驱动型的，公司的大部分员工基本都是体力劳动者，典型代表就是富士康。有钱的时候就能卖机器设备，有钱就能雇员工。这些劳动力资本和资产资本就可以为公司创造价值。<strong>所以工业经济时代，公司只需要钱的贡献，不需要考虑那么多人的贡献。</strong>所以工业时代是资金创造主要的价值，人创造次要的价值，所以只需要考虑钱的贡献。</p><p><strong>而现在我们互联网时代，很多企业都是轻资产的企业，钱在创造价值，但是公司最大的价值是人在创造最主要的价值。</strong>风投早期的时候，投资人出300万占10%的股权，而团队可能出30万就可以占90%。典型代表企业就是滴滴，现在估值250亿美金，一个点的价值是2.5亿美金，苹果投资了10亿美金，也只能占到4个点的股份，而团队出的钱很少，但是占了很大一部分股份。</p><h6 id="所以现在这个时代人在创造最主要的价值，钱只创造一部分价值。那么传统模式的股权分配难以适应了，我们就要重新考虑股权分配了："><a href="#所以现在这个时代人在创造最主要的价值，钱只创造一部分价值。那么传统模式的股权分配难以适应了，我们就要重新考虑股权分配了：" class="headerlink" title="所以现在这个时代人在创造最主要的价值，钱只创造一部分价值。那么传统模式的股权分配难以适应了，我们就要重新考虑股权分配了："></a>所以现在这个时代人在创造最主要的价值，钱只创造一部分价值。那么传统模式的股权分配难以适应了，我们就要重新考虑股权分配了：</h6><ol><li>第一 既要对钱定价，也要对人定价；</li><li>第二 对钱定价是对股东历史贡献的认可，对人定价是对股东未来贡献的认可。</li><li>第三 股权，特别是人力占的股权，既要有进入机制，也得有调整机制和退出机制。</li></ol><h1 id="第二个部分-讨论关键词叫合伙人，什么样的人是合伙人"><a href="#第二个部分-讨论关键词叫合伙人，什么样的人是合伙人" class="headerlink" title="第二个部分 讨论关键词叫合伙人，什么样的人是合伙人"></a>第二个部分 讨论关键词叫合伙人，什么样的人是合伙人</h1><p><strong>合伙人</strong></p><p>徐小平老师讲，合伙人的重要性甚至超过了公司商业模式。雷军讲，创始人要把大部分的时间用在寻找合伙人上。一人打天下的公司越来越少了。无论是腾讯的五虎，还是新东方的三架马车，一人打天下已经很少了。</p><p>那什么样的人才是彼此的合伙人呢？找合伙人需要考虑四个因素，<br><strong>第一要互相信任，第二要能力互补，第三要全职出力，第四必须出钱。</strong></p><p><img src="https://policx.github.io/post-images/1562513667809.jpeg" alt></p><h2 id="1-互相信任"><a href="#1-互相信任" class="headerlink" title="1. 互相信任"></a><strong>1. 互相信任</strong></h2><p>我在广州的时候，有一次股权课程上有一个公司的创始人，他的自我介绍第一句话是，我今天过来是学习股权设计的。他介绍完了以后，他的合伙人站起来说我今天过来学习是如何不被他设计的。<strong>如果一个公司的创业团队，把股权搞成设计和反设计的情况，这会产生公司最大的内耗。</strong>所以需要磨合和互相信任对于合伙人来说非常重要。</p><h2 id="2-能力互补"><a href="#2-能力互补" class="headerlink" title="2. 能力互补"></a><strong>2. 能力互补</strong></h2><p>身份定位是很重要的。之前有很多的创业团队股权分配一开始是平分股权。但是很多人发现平分股权问题很大，需要调整，那么股权应该怎么去调整？要么他把一部分老股权给你，要么你把一部分老股权给他。要么公司给你增向增发一部分，要么公司把他的股份回购一部分。</p><p>当这种调整行不通的时候我们就要考虑，这不是股权设计的问题，而是团队班子搭得不对。<strong>平分有两种结果是都觉得自己具备老大的能力，大家觉得都挺牛逼的，最后就是内讧。</strong>这是第一种搭班子，打的是老大加老大的这种模式。</p><p>第二种模式，找一些能力低于自己但是有所专长的合伙人。但是在实践中，什么样的人适合做老大，什么样的人适合做老二呢？也没有一个标准答案，很多时候是靠对人的理解。而华为内部有一个标准什么样的人适合当部门一把手，什么样的人适合当部门二把手，这种标准很容易解决这种模式中的问题。</p><p>一把手主要是狼的性格，首先具备强烈的攻击性，因为创业本身是开拓性的事情，是一个打江山的事情。第二，一把手要比较理解公司的战略方向，包括很强的策划能力。第三要有很强的意志力，这三个特点是一把手所要具备的。老二要有一种狈的性格，既要擅长管理的，特别是精细化的管理，还要具备很强的执行力。<strong>一个公司搭班子，就是狼加狈的模式，所以我们在这里说狼狈为“坚”，狼跟狈加在一起才是一个稳定的结构。</strong></p><p>  <img src="https://policx.github.io/post-images/1562513695217.jpeg" alt></p><h2 id="3-分工明确"><a href="#3-分工明确" class="headerlink" title="3. 分工明确"></a><strong>3. 分工明确</strong></h2><p>确保每一人全职出力。腾讯一开始5个合伙人里面，其实一开始就有一种清晰明确的分工，张志东负责技术，曾李青销售，许晨晔首席信息官，陈一丹首席行政官。基本是都是能力互补，五个人联手覆盖了一家巨头公司运营的方方面面。<strong>所以互联网公司主要讲技术、产品、运营，而且不是一定说产品做老大，或者技术当老大。</strong></p><h2 id="4-出钱出力"><a href="#4-出钱出力" class="headerlink" title="4. 出钱出力"></a><strong>4. 出钱出力</strong></h2><p>现在创业团队早期启动资金都不多，掏的钱就很少。团队的贡献在长期全职出力。但是出钱也是对自己做好长期贡献的一个表态和铺垫。企业划分为三类人，第一类是创业合伙人，他肯定是全职进来干；而有一部分人是全职干，愿意出点钱，但是达不到合伙人这个级别的，这主要是公司的员工和高管；第三部分是投资人，他看好你的视野，愿意出钱但是不愿意进来全职干。</p><h1 id="第三部分-讨论合伙人内部股权怎么去分配。"><a href="#第三部分-讨论合伙人内部股权怎么去分配。" class="headerlink" title="第三部分 讨论合伙人内部股权怎么去分配。"></a>第三部分 讨论合伙人内部股权怎么去分配。</h1><p><strong>股权分配</strong></p><p>我们可以把企业股权结构分成三种模型。第一种是绝对控股型，第二种是相对控股型，第三种是不控股型。</p><h2 id="1）绝对控股型"><a href="#1）绝对控股型" class="headerlink" title="1）绝对控股型"></a><strong>1）绝对控股型</strong></h2><p>这种模型的典型分配是创始人占三分之二以上，即67%的股权，合伙人占18%的股权，预留团队股权15%，这就叫绝对控股型。<strong>绝对控股型适用于创始人投钱最多，能力最强的情况。</strong>在股东内部，绝对控股型虽然说形式上民主，但是最后是要老板拍板的，所有人反对的事情他都能做。</p><h2 id="2）-相对控股型"><a href="#2）-相对控股型" class="headerlink" title="2） 相对控股型"></a><strong>2） 相对控股型</strong></h2><p>公司老大占51%的股权，合伙人加在一起占34%的股权，员工预留15%的股权。这种模型下除了少数几个事情，比如说公司要不要增加资本，要不要解散结算，要不要更新公司章程，其他<strong>绝大部分事情老大一个人就能拍板。</strong></p><h2 id="3）-不控股型"><a href="#3）-不控股型" class="headerlink" title="3） 不控股型"></a><strong>3） 不控股型</strong></h2><p>公司老大占34%的股权，合伙人团队占51%的股权，激励股权占15%。这种模型主要适用于：<strong>合伙人团队能力互补，每个人能力都很强，老大只是有战略相对优势。</strong>所以基本上合伙人的股权就相对平均一些。</p><p>这三个这个模型里面有几个特点，首先投资人的股份没算在里面。有些创始人，说团队内部后面要融资，先预留一部分由创始人代持。但是预留后面会面临很大的问题。第一从法律关系上来讲，假设创始人预留了20%股权给后面投资人。后面投资人从他手里面买股份，这就叫买老股。</p><p>法律关系上来讲，这是投资人跟创业者个人股份之间的关系，不是跟公司之间的关系。这个钱进不了公司账户，而成为创始人个人变现，不是公司融资。第二一旦卖老股份，投资人出很高的溢价进来，你马上就面临很大的一笔税。所以我们<strong>不建议一开始给投资人预留股份，可以进来以后大家共同稀释。</strong></p><p>那么激励股权为什么一定要预留呢？激励股权不是说一定得预留，只是建议大家预留。预留主要能解决两个方面的问题。第一个是<strong>充当调整机制。</strong>很多创始人刚开始创业的时候，找合伙人其实没有多少选择余地。只是觉得凑合就一起干了，但是过段时间，你发现这个人只能算是一个中层管理人员。</p><p>所以这个时候，我们预留的部分解决两个问题。第一是如果早期的时候股权分配不合理，这个时候可以调整一部分到代持的老股里面去。第二有些人后面参与进来。不管是高管、合伙人或者是员工，也通过预留股权去处理。</p><p>我们做了国内外上市了的做得比较好的互联网方面公司。创始人所占股份平均为20%左右，这是比较常见的一个数据。阿里上市之后，马云只剩了7.8了，马化腾在上市之后也就只有20个点左右。基本上上市了公司老大们都只剩下20个点左右，这种情况下大家就会考虑，公司的控制权会不会出问题。</p><p>我从两个公司来讨论控制权问题。这两个都是标杆型企业，一个是阿里巴巴，另一个是最近闹的沸沸扬扬的万科。这两家公司的股权我们发现有三个共同点。</p><p><strong>第一个共同点是这两家公司的股权都很分散，第二个是它们的经营团队都不控股，第三个是两个公司都保持事业合伙人制。</strong></p><p>马云的股份很少，马云的股份在上市之前的股份只有8.9%，上市之后只剩下7.8%。加上其他团队成员，在上市后总计也就持有10%的股份。万科的股份，也是很分散的。它的股份叫盈安，即就是王石加上整个团队也就只有4.14%的股份，股份很少。两家公司很相似，股份都占的很少。但是两家公司产生了完全不一样的结果。马云牢牢控制住阿里巴巴，而王石就难以控制好万科。</p><p><img src="https://policx.github.io/post-images/1562513832868.jpg" alt></p><p>两家公司完全不同的结果究其是没有处理好公司控股权的问题。不是说只有控股才能控制公司，不控股的老板也能控制公司。这就有几种控制方式。</p><h4 id="1-投票权委托"><a href="#1-投票权委托" class="headerlink" title="1) 投票权委托"></a><strong>1) 投票权委托</strong></h4><p>最典型的是京东。京东上市之前。烧了很多钱，刘强东的股份很少。所以对于后来的投资人都有前提条件，就是要把投票权委托写好。刘强东在上市之前有20%的股份，但是有50%的投票权利。</p><h4 id="2-一致行动人协议"><a href="#2-一致行动人协议" class="headerlink" title="2) 一致行动人协议"></a><strong>2) 一致行动人协议</strong></h4><p>简单来讲就两条。第一条是所有事情先要在董事会内部进行民主协商得到一个一致意见。如果不能协商出一致意见，那就以老大的意见为主。虽然说我也不赞成这个事情，但是既然我签了这个协议。</p><h4 id="3-持股平台"><a href="#3-持股平台" class="headerlink" title="3) 持股平台"></a><strong>3) 持股平台</strong></h4><p>针对于有限合伙。老板可以把合伙人、员工的股份，放在员工持股平台上。通过这种方式，老板可以把合伙人跟员工的股权全部集中到自己手里面。因为有限合伙分为普通合伙人和有限合伙人。普通合伙人即使持有万分之一的股份，这个持股平台里面股份都是他的，他可以代理有限合伙的权利。有限合伙人主要是分钱的权利，基本是没话语权。</p><h4 id="4-AB股计划"><a href="#4-AB股计划" class="headerlink" title="4) AB股计划"></a><strong>4) AB股计划</strong></h4><p>AB股计划通常是把外部投资人一股有一个投票权，运营团队一股有10个投票权，也可以放大的更多。例如京东刘强东一股有20个投票权，所以他有将近90%的投票权。</p><h1 id="第四部分-讨论-股权的退出机制"><a href="#第四部分-讨论-股权的退出机制" class="headerlink" title="第四部分 讨论 股权的退出机制"></a>第四部分 讨论 股权的退出机制</h1><p><strong>退出机制</strong></p><p>很多创业团队，合伙人的变动会很频繁。对于退出的同时避免团队股权战争问题，我们有四个建议：<strong>创始人发限制性股权，股权分期兑现，约定回购机制，**</strong>做好预期<strong>**管理。</strong></p><p><img src="https://policx.github.io/post-images/1562513872462.jpeg" alt></p><h2 id="1-创始人发限制性股权"><a href="#1-创始人发限制性股权" class="headerlink" title="1. 创始人发限制性股权"></a><strong>1. 创始人发限制性股权</strong></h2><p>专业的机构人进来以后，都不要求你创始人的股份分四年兑现。而且中间离职的情况下，公司可以把股份做回购。其实资本进来以后，拿的都是限制性股权。  </p><p><strong>无论融资与否，上市与否，都需要套用限制性股权。</strong> 创业人早期只掏了三五万块钱现金，拿了20%的股份，干了不到半年，公司做到五千万或者一个亿，谁都不希望看到他仅靠一点贡献就拿走一大笔钱。所以我们建议大家拿限制性股权</p><p>限制性股权简单来讲，第一它是股权，可以直接办理工商登记。第二它是有权利限制的，这种权利限制可以四年去兑现。而且中间离职的情况下，公司可以按照一个事先约定的价格进行回购，这就叫限制性股权。限制性股权的限制就在于分期兑现，公司可以去回购。</p><h2 id="2-股权分期兑现"><a href="#2-股权分期兑现" class="headerlink" title="2. 股权分期兑现"></a><strong>2. 股权分期兑现</strong></h2><p>分期兑现有这么几种方式:</p><h3 id="第一种方式-是约定4年，每年兑现四分之一。"><a href="#第一种方式-是约定4年，每年兑现四分之一。" class="headerlink" title="第一种方式 是约定4年，每年兑现四分之一。"></a><em>第一种方式</em> 是约定4年，每年兑现四分之一。</h3><h3 id="第二种方式-是任职满2年兑现50-，三年兑现75-，四年100-。"><a href="#第二种方式-是任职满2年兑现50-，三年兑现75-，四年100-。" class="headerlink" title="第二种方式 是任职满2年兑现50%，三年兑现75%，四年100%。"></a><em>第二种方式</em> 是任职满2年兑现50%，三年兑现75%，四年100%。</h3><blockquote><p>第二种方式是为了预防短期投机行为，小米的员工股权激励就是按照这种模式的。</p></blockquote><h3 id="第三种方式-就是逐年增加，第一年10-、第二年20-、第三年30-、第四年40-，即就是干的时间越长的兑现的越多。"><a href="#第三种方式-就是逐年增加，第一年10-、第二年20-、第三年30-、第四年40-，即就是干的时间越长的兑现的越多。" class="headerlink" title="第三种方式 就是逐年增加，第一年10%、第二年20%、第三年30%、第四年40%，即就是干的时间越长的兑现的越多。"></a><em>第三种方式</em> 就是逐年增加，第一年10%、第二年20%、第三年30%、第四年40%，即就是干的时间越长的兑现的越多。</h3><h3 id="第四种模式-是干满一年兑现四分之一，剩下的在三年之内每个月兑现48分之一。这种模式首先干满一年才可以兑现，其次每干满一个月兑现一个，算得比较清楚。这几种模式其实对团队来讲，是不同的导向，可以根据自己的实际情况进行选择。"><a href="#第四种模式-是干满一年兑现四分之一，剩下的在三年之内每个月兑现48分之一。这种模式首先干满一年才可以兑现，其次每干满一个月兑现一个，算得比较清楚。这几种模式其实对团队来讲，是不同的导向，可以根据自己的实际情况进行选择。" class="headerlink" title="第四种模式 是干满一年兑现四分之一，剩下的在三年之内每个月兑现48分之一。这种模式首先干满一年才可以兑现，其次每干满一个月兑现一个，算得比较清楚。这几种模式其实对团队来讲，是不同的导向，可以根据自己的实际情况进行选择。"></a><em>第四种模式</em> 是干满一年兑现四分之一，剩下的在三年之内每个月兑现48分之一。这种模式首先干满一年才可以兑现，其次每干满一个月兑现一个，算得比较清楚。这几种模式其实对团队来讲，是不同的导向，可以根据自己的实际情况进行选择。</h3><h2 id="3-约定回购机制"><a href="#3-约定回购机制" class="headerlink" title="3. 约定回购机制"></a><strong>3. 约定回购机制</strong></h2><p><strong>股份约定回购机制的关键是回购价格定多少。</strong>因为有一些公司一开始约定说，如果合伙人离职的情况下，双方按照协商一致的价格去回购。所以这里面有几种模式：</p><h3 id="1）-参照原来购买价格的溢价"><a href="#1）-参照原来购买价格的溢价" class="headerlink" title="1） 参照原来购买价格的溢价"></a><strong>1） 参照原来购买价格的溢价</strong></h3><p>比如说他原来的话10个点的股份掏了10万块钱，那如果到了两、三倍，那一定得是溢价。 </p><h3 id="2）-参照公司净资产"><a href="#2）-参照公司净资产" class="headerlink" title="2） 参照公司净资产"></a><strong>2） 参照公司净资产</strong></h3><p>当公司干到第三年，第四年的时候。那时候公司本身资产假如已经有一个亿了。你按照人家原来购买价格的溢价，那么人家干的这几年都白干了。所以对于重资产企业，可以参照净资产来定。因为回购是一个买断的概念。相当于把对方未来十几年的财富都断掉了，所以从公平合理的角度还得有一点溢价。</p><h3 id="3）-参照公司最近一轮融资估值的折扣价"><a href="#3）-参照公司最近一轮融资估值的折扣价" class="headerlink" title="3） 参照公司最近一轮融资估值的折扣价"></a><strong>3） 参照公司最近一轮融资估值的折扣价</strong></h3><p>为什么要折扣回购呢？基于几个考虑：</p><blockquote><p><strong>第一</strong>，从公平合理的角度出发，因为资本就是投资公司的未来。5千万、1个亿的估值是认为未来公司值这么多钱，而这个估值是可变的，并不代表你离职的时候就是这个价格。</p><p><strong>第二</strong>，从公司现金流角度，如果完全按照公司估值，那公司现金流压力很大。</p><p><strong>第三</strong>，是从公司团队的导向出发，这个导向就是引导大家长期干。这里面用什么价格，是按照公司的不同模式。</p></blockquote><h3 id="4-做好预期管理"><a href="#4-做好预期管理" class="headerlink" title="4. 做好预期管理"></a><strong>4. 做好预期管理</strong></h3><p>退出机制怎么去落地？<strong>首先要在我们的理念层面达成共识，之后再谈硬梆梆、冷冰冰的规则。</strong>理念层面大家先沟通到一个层面，比如说我们三个一起创业的。大家先得坐在一起谈一谈，这个事情我们是基于长期看，还是基于短期投资。</p><p>第二，未来这个公司能不能做成，能走多远？能做多大？确定好主要贡献在于长期全职出力。第三，大家得先沟通明白，如果股份不回购对长期参与创业的股东是不是一个公平合理的事情。第四，所有合伙人要同一套标准，游戏规则值得所有人尊重。只有在理念层次沟通好了，才能够平和理性地去谈具体的规则条款。  </p><p><img src="https://policx.github.io/post-images/1562514309107.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 利益小的时候，什么都好说。利益大到一定程度，就超越了人性。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WWDC 2019</title>
    <link href="http://yoursite.com/2019/06/05/2019/"/>
    <id>http://yoursite.com/2019/06/05/2019/</id>
    <published>2019-06-05T03:06:39.000Z</published>
    <updated>2019-07-07T12:07:13.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Your time is limited, so don’t waste it living someone else’s life.…Don’t let the noise of others’ opinions drown out your own inner voice。</p><a id="more"></a><p>你的时间有限，不要浪费于重复别人的生活。不要让别人的观点淹没了你内心的声音。</p><p><img src="https://www.policx.com/talk/images/wwdc2019.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Your time is limited, so don’t waste it living someone else’s life.…Don’t let the noise of others’ opinions drown out your own inner voice。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="http://yoursite.com/categories/news/"/>
    
    
      <category term="" scheme="http://yoursite.com/tags/%EF%A3%BF/"/>
    
  </entry>
  
  <entry>
    <title>git如何删除已经提交的文件夹</title>
    <link href="http://yoursite.com/2018/09/17/git-del/"/>
    <id>http://yoursite.com/2018/09/17/git-del/</id>
    <published>2018-09-17T08:02:32.000Z</published>
    <updated>2019-07-07T04:27:26.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹</p><a id="more"></a><p>在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决</p><p>首先进入你的master文件夹下, Git Bash Here ,打开命令窗口</p><p><code>$ git --help                                      # 帮助命令</code></p><p><code>$ git pull origin master                    # 将远程仓库里面的项目拉下来</code></p><p><code>$ ls                                                # 查看有哪些文件夹</code></p><p><code>$ git rm -r --cached .idea              # 删除.idea文件夹</code></p><p><code>$ git commit -m &#39;删除.idea&#39;        # 提交,添加操作说明</code></p><p><code>$ git push -u origin master               # 将本次更改更新到github项目上去</code></p><hr><p>作者： <a href="https://blog.csdn.net/weiyoushi4001/article/details/82495364" target="_blank" rel="noopener">皮皮今</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Python利用openpyxl来操作Excel</title>
    <link href="http://yoursite.com/2018/06/19/python-excel/"/>
    <id>http://yoursite.com/2018/06/19/python-excel/</id>
    <published>2018-06-19T08:39:16.000Z</published>
    <updated>2019-07-07T04:35:47.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。</p><a id="more"></a><p>如下所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import load_workbook</span><br><span class="line">from openpyxl.styles import colors, Font, Fill, NamedStyle</span><br><span class="line">from openpyxl.styles import PatternFill, Border, Side, Alignment</span><br><span class="line"> </span><br><span class="line"># 加载文件</span><br><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)</span><br></pre></td></tr></table></figure><ul><li>workbook： 工作簿，一个excel文件包含多个sheet。</li><li>worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。</li><li>cell： 单元格，存储数据对象<br>文章所用表格为：<br><img src="https://policx.github.io/post-images/1560761501804.jpeg" alt></li></ul><h3 id="操作sheet"><a href="#操作sheet" class="headerlink" title="操作sheet"></a>操作sheet</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 读取sheetname</span><br><span class="line">print(&apos;输出文件所有工作表名：\n&apos;, wb.sheetnames)</span><br><span class="line">ws = wb[&apos;5a&apos;]</span><br><span class="line"> </span><br><span class="line"># 或者不知道名字时</span><br><span class="line">sheet_names = wb.sheetnames   # 返回一个列表</span><br><span class="line">ws2 = wb[sheet_names[0]]    # index为0为第一张表</span><br><span class="line">print(ws is ws2)    # 两者是一样的</span><br></pre></td></tr></table></figure><p>输出文件所有工作表名：<br>[‘5a’]<br>True</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改sheetname</span><br><span class="line"> </span><br><span class="line">ws.title = &apos;5a_&apos;</span><br><span class="line">print(&apos;修改sheetname：\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>修改sheetname：<br>[‘5a_’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建新的sheet</span><br><span class="line"># 创建的新表必须要赋值给一个对象，不然只有名字但是没有实际的新表</span><br><span class="line"> </span><br><span class="line">ws4 = wb.create_sheet(index=0, title=&apos;newsheet&apos;)</span><br><span class="line"># 什么参数都不写的话，默认插入到最后一个位置且名字为sheet,sheet1...按照顺序排列</span><br><span class="line"> </span><br><span class="line">ws5 = wb.create_sheet()</span><br><span class="line">print(&apos;创建新的sheet:\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>创建新的sheet:<br>[‘newsheet’, ‘5a_’, ‘Sheet’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除sheet</span><br><span class="line">wb.remove(ws4)  # 这里只能写worksheet对象，不能写sheetname</span><br><span class="line">print(&apos;删除sheet：\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>删除sheet：<br>[‘5a_’, ‘Sheet’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改sheet选项卡背景色，默认为白色，设置为RRGGBB模式</span><br><span class="line">ws.sheet_properties.tabColor = &quot;FFA500&quot;</span><br><span class="line"> </span><br><span class="line"># 读取有效区域</span><br><span class="line"> </span><br><span class="line">print(&apos;最大列数为：&apos;, ws.max_column)</span><br><span class="line">print(&apos;最大行数为：&apos;, ws.max_row)</span><br></pre></td></tr></table></figure><p>最大列数为： 5<br>最大行数为： 17</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 插入行和列</span><br><span class="line">ws.insert_rows(1)  # 在第一行插入一行</span><br><span class="line">ws.insert_cols(2, 4)  # 从第二列开始插入四列</span><br><span class="line"> </span><br><span class="line"># 删除行和列</span><br><span class="line">ws.delete_cols(6, 3)  # 从第六列（F列）开始，删除3列即（F:H）</span><br><span class="line">ws.delete_rows(3)   # 删除第三行</span><br></pre></td></tr></table></figure><h3 id="单元格操作"><a href="#单元格操作" class="headerlink" title="单元格操作"></a>单元格操作</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 读取</span><br><span class="line">c = ws[&apos;A1&apos;]</span><br><span class="line">c1 = ws.cell(row=1, column=2)</span><br><span class="line">print(c, c1)</span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure><p>&lt;Cell ‘5a_’.A1&gt;  &lt;Cell ‘5a_’.B1&gt;<br>dth_title Province  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改</span><br><span class="line">ws[&apos;A1&apos;] = &apos;景区名称&apos;</span><br><span class="line">ws.cell(1, 2).value = &apos;省份&apos;</span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure><p>景区名称 省份</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 读取多个单元格</span><br><span class="line"> </span><br><span class="line">cell_range = ws[&apos;A1&apos;:&apos;D5&apos;]</span><br><span class="line">colC = ws[&apos;C&apos;]</span><br><span class="line">col_range = ws[&apos;C:D&apos;]</span><br><span class="line">row10 = ws[10]</span><br><span class="line">row_range = ws[5:10]</span><br><span class="line"># 其返回的结果都是一个包含单元格的元组</span><br><span class="line">print(type(cell_range))</span><br><span class="line">for i in row10:</span><br><span class="line">    print(i)    # row10只有有效单元格</span><br></pre></td></tr></table></figure><p>&lt;class ‘tuple’&gt;<br>&lt;Cell ‘5a_’.A10&gt;<br>&lt;Cell ‘5a_’.B10&gt;<br>&lt;Cell ‘5a_’.C10&gt;<br>&lt;Cell ‘5a_’.D10&gt;<br>&lt;Cell ‘5a_’.E10&gt; </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 按照行列操作</span><br><span class="line">for row in ws.iter_rows(min_row=1, max_row=3,</span><br><span class="line">                        min_col=1, max_col=2):</span><br><span class="line">    for cell in row:</span><br><span class="line">        print(cell)</span><br><span class="line"># 也可以用worksheet.iter_col(),用法都一样</span><br></pre></td></tr></table></figure><p>&lt;Cell ‘5a_’.A1&gt;<br>&lt;Cell ‘5a_’.B1&gt;<br>&lt;Cell ‘5a_’.A2&gt;<br>&lt;Cell ‘5a_’.B2&gt;<br>&lt;Cell ‘5a_’.A3&gt;<br>&lt;Cell ‘5a_’.B3&gt; </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 合并单元格</span><br><span class="line">ws.merge_cells(&apos;F1:G1&apos;)</span><br><span class="line">ws[&apos;F1&apos;] = &apos;合并两个单元格&apos;</span><br><span class="line"># 或者</span><br><span class="line">ws.merge_cells(start_row=2, start_column=6, end_row=3, end_column=8)</span><br><span class="line">ws.cell(2, 6).value = &apos;合并三个单元格&apos;</span><br><span class="line"> </span><br><span class="line"># 取消合并单元格</span><br><span class="line">ws.unmerge_cells(&apos;F1:G1&apos;)</span><br><span class="line"># 或者</span><br><span class="line">ws.unmerge_cells(start_row=2, start_column=6, end_row=3, end_column=8)</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)</span><br><span class="line"># 保存之前的操作,保存文件时，文件必须是关闭的！！！</span><br></pre></td></tr></table></figure><p>注意！！！，openpyxl对Excel的修改并不像是xlwings包一样是实时的，他的修改是暂时保存在内存中的，所以当 后面的修改例如我接下来要在第一行插入新的一行做标题，那么当我对新的A1单元格操作的时候，还在内存中的原A1(现在是A2)的单元格 原有的修改就会被覆盖。所以要先保存，或者从一开始就计划好更改操作避免这样的事情发生。</p><h3 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h3><h4 id="单个单元格样式"><a href="#单个单元格样式" class="headerlink" title="单个单元格样式"></a>单个单元格样式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)    # 读取修改后的文件</span><br><span class="line">ws = wb[&apos;5a_&apos;]</span><br><span class="line"># 我们来设置一个表头</span><br><span class="line">ws.insert_rows(1)    # 在第一行插入新的一行</span><br><span class="line">ws.merge_cells(&apos;A1:E1&apos;)  # 合并单元格</span><br><span class="line">a1 = ws[&apos;A1&apos;]</span><br><span class="line">ws[&apos;A1&apos;] = &apos;5A级风景区名单&apos;</span><br><span class="line"> </span><br><span class="line"># 设置字体</span><br><span class="line">ft = Font(name=&apos;微软雅黑&apos;, color=&apos;000000&apos;, size=15, b=True)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">name:字体名称</span><br><span class="line">color:颜色通常是RGB或aRGB十六进制值</span><br><span class="line">b(bold):加粗（bool）</span><br><span class="line">i(italic):倾斜(bool)</span><br><span class="line">shadow：阴影（bool）</span><br><span class="line">underline：下划线（‘doubleAccounting’, ‘single’, ‘double’, ‘singleAccounting’）</span><br><span class="line">charset:字符集(int)</span><br><span class="line">strike:删除线(bool)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">a1.font = ft</span><br><span class="line"> </span><br><span class="line"># 设置文本对齐</span><br><span class="line"> </span><br><span class="line">ali = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">horizontal:水平对齐(&apos;centerContinuous&apos;, &apos;general&apos;, &apos;distributed&apos;,</span><br><span class="line">                    &apos;left&apos;, &apos;fill&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;right&apos;)</span><br><span class="line">vertical:垂直对齐（&apos;distributed&apos;, &apos;top&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;bottom&apos;）</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">a1.alignment = ali</span><br><span class="line"> </span><br><span class="line"># 设置图案填充</span><br><span class="line"> </span><br><span class="line">fill = PatternFill(&apos;solid&apos;, fgColor=&apos;FFA500&apos;)</span><br><span class="line"># 颜色一般使用十六进制RGB</span><br><span class="line"># &apos;solid&apos;是图案填充类型，详细可查阅文档</span><br><span class="line"> </span><br><span class="line">a1.fill = fill</span><br></pre></td></tr></table></figure><p><a href="https://openpyxl.readthedocs.io/en/stable/api/openpyxl.styles.fills.html" target="_blank" rel="noopener">openpyxl.styles.fills模块参数文档</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 设置边框</span><br><span class="line">bian = Side(style=&apos;medium&apos;, color=&apos;000000&apos;)    # 设置边框样式</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">style:边框线的风格&#123;&apos;dotted&apos;,&apos;slantDashDot&apos;,&apos;dashDot&apos;,&apos;hair&apos;,&apos;mediumDashDot&apos;,</span><br><span class="line">        &apos;dashed&apos;,&apos;mediumDashed&apos;,&apos;thick&apos;,&apos;dashDotDot&apos;,&apos;medium&apos;,</span><br><span class="line">        &apos;double&apos;,&apos;thin&apos;,&apos;mediumDashDotDot&apos;&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">border = Border(top=bian, bottom=bian, left=bian, right=bian)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">top（上）,bottom（下）,left（左）,right（右）:必须是 Side类型</span><br><span class="line">diagonal: 斜线 side类型 </span><br><span class="line">diagonalDownd: 右斜线 bool</span><br><span class="line">diagonalDown: 左斜线 bool</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line"># a1.border = border</span><br><span class="line">for item in ws[&apos;A1:E1&apos;][0]:   # 去元组中的每一个cell更改样式</span><br><span class="line">    item.border = border</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)  # 保存更改</span><br></pre></td></tr></table></figure><p>再次注意！！！：</p><p>不能使用 a1.border = border，否则只会如下图情况，B1：E1单元格没有线。我个人认为是因为线框涉及到相邻单元格边框的改动所以需要单独对每个单元格修改才行。<br>不能使用ws[‘A1:E1’].border = border,由前面的内容可知，openpyxl的多个单元格其实是一个元组，而元组是没有style的方法的,所以必须一个一个改！！其实官方有其他办法，后面讲。</p><h3 id="按列或行设置样式"><a href="#按列或行设置样式" class="headerlink" title="按列或行设置样式"></a>按列或行设置样式</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 现在我们对整个表进行设置</span><br><span class="line"> </span><br><span class="line"># 读取</span><br><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)</span><br><span class="line">ws = wb[&apos;5a_&apos;]</span><br><span class="line"> </span><br><span class="line"># 读取数据表格范围</span><br><span class="line">rows = ws.max_row</span><br><span class="line">cols = ws.max_column</span><br><span class="line"> </span><br><span class="line"># 字体</span><br><span class="line">font1 = Font(name=&apos;微软雅黑&apos;, size=11, b=True)</span><br><span class="line">font2 = Font(name=&apos;微软雅黑&apos;, size=11)</span><br><span class="line"> </span><br><span class="line"># 边框</span><br><span class="line">line_t = Side(style=&apos;thin&apos;, color=&apos;000000&apos;)  # 细边框</span><br><span class="line">line_m = Side(style=&apos;medium&apos;, color=&apos;000000&apos;)  # 粗边框</span><br><span class="line">border1 = Border(top=line_m, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"># 与标题相邻的边设置与标题一样</span><br><span class="line">border2 = Border(top=line_t, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"> </span><br><span class="line"># 填充</span><br><span class="line">fill = PatternFill(&apos;solid&apos;, fgColor=&apos;CFCFCF&apos;)</span><br><span class="line"> </span><br><span class="line"># 对齐</span><br><span class="line">alignment = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;)</span><br><span class="line"> </span><br><span class="line"># 将样式打包命名</span><br><span class="line">sty1 = NamedStyle(name=&apos;sty1&apos;, font=font1, fill=fill,</span><br><span class="line">                  border=border1, alignment=alignment)</span><br><span class="line">sty2 = NamedStyle(name=&apos;sty2&apos;, font=font2, border=border2, alignment=alignment)</span><br><span class="line"> </span><br><span class="line">for r in range(2, rows+1):</span><br><span class="line">    for c in range(1, cols):</span><br><span class="line">        if r == 2:</span><br><span class="line">            ws.cell(r, c).style = sty1</span><br><span class="line">        else:</span><br><span class="line">            ws.cell(r, c).style = sty2</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)</span><br></pre></td></tr></table></figure><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p><img src="https://policx.github.io/post-images/1560761595658.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python操作excel的包(openpyxl、xlsxwriter)</title>
    <link href="http://yoursite.com/2018/06/17/python-writer/"/>
    <id>http://yoursite.com/2018/06/17/python-writer/</id>
    <published>2018-06-17T10:28:27.000Z</published>
    <updated>2019-07-07T04:36:07.789Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>现在支持python操作excel的包有下列这些<br><img src="https://policx.github.io/post-images/1560767425488.png" alt></p><p>官网上最推荐的是openpyxl，其他包支持较老的excel版本。<br><img src="https://policx.github.io/post-images/1560767456846.png" alt><br><img src="https://policx.github.io/post-images/1560767522161.png" alt></p><a id="more"></a><p>xlsxwriter无法对打开的excel进行写操作，excel必须处于关闭状态才能写成功。 </p><h4 id="xlswriter-基本代码："><a href="#xlswriter-基本代码：" class="headerlink" title="xlswriter 基本代码："></a>xlswriter 基本代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import xlsxwriter</span><br><span class="line"></span><br><span class="line">workbook = xlsxwriter.Workbook(&apos;hello.xlsx&apos;)</span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"></span><br><span class="line">worksheet.write(&apos;A1&apos;, &apos;Hello world&apos;)</span><br><span class="line"></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure><h4 id="openpyxl基本代码："><a href="#openpyxl基本代码：" class="headerlink" title="openpyxl基本代码："></a>openpyxl基本代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line">#设置单元格值</span><br><span class="line">ws[&apos;A1&apos;] = 42</span><br><span class="line">#加入一行数据</span><br><span class="line">ws.append([1, 2, 3])</span><br><span class="line"></span><br><span class="line">import datetime</span><br><span class="line">#python 类型数据会被自动转换</span><br><span class="line">ws[&apos;A2&apos;] = datetime.datetime.now()</span><br><span class="line">#保存修改</span><br><span class="line">wb.save(&quot;sample.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>来源:<a href="https://www.jb51.net/article/141817.htm" target="_blank" rel="noopener">脚本之家</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在支持python操作excel的包有下列这些&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767425488.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;官网上最推荐的是openpyxl，其他包支持较老的excel版本。&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767456846.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767522161.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>WWDC 2018</title>
    <link href="http://yoursite.com/2018/06/05/2018/"/>
    <id>http://yoursite.com/2018/06/05/2018/</id>
    <published>2018-06-04T16:59:59.000Z</published>
    <updated>2019-07-04T01:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me。</p><a id="more"></a><p>是否能成为墓地里最富有的人，对我而言无足轻重。重要的是，当我晚上睡觉时，我可以说：我们今天完成了一些美妙的事。</p><p><img src="https://www.policx.com/talk/images/wwdc2018.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me。&lt;/p&gt;
    
    </summary>
    
      <category term="news" scheme="http://yoursite.com/categories/news/"/>
    
    
      <category term="" scheme="http://yoursite.com/tags/%EF%A3%BF/"/>
    
  </entry>
  
  <entry>
    <title>python3 与 MongoDB 之间的交互</title>
    <link href="http://yoursite.com/2018/05/02/pymongo/"/>
    <id>http://yoursite.com/2018/05/02/pymongo/</id>
    <published>2018-05-02T07:27:47.000Z</published>
    <updated>2019-07-07T04:35:29.411Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。</p><a id="more"></a><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。</p><h2 id="2-连接MongoDB"><a href="#2-连接MongoDB" class="headerlink" title="2. 连接MongoDB"></a>2. 连接MongoDB</h2><p>连接MongoDB时，我们需要使用PyMongo库里面的MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line">client = pymongo.MongoClient(host=&apos;localhost&apos;, port=27017)</span><br></pre></td></tr></table></figure><p>这样就可以创建MongoDB的连接对象了。</p><p>另外，MongoClient的第一个参数host还可以直接传入MongoDB的连接字符串，它以mongodb开头，例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = MongoClient(&apos;mongodb://localhost:27017/&apos;)</span><br></pre></td></tr></table></figure><p>这也可以达到同样的连接效果。</p><h2 id="3-指定数据库"><a href="#3-指定数据库" class="headerlink" title="3. 指定数据库"></a>3. 指定数据库</h2><p>MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client.test</span><br></pre></td></tr></table></figure><p>这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client[&apos;test&apos;]</span><br></pre></td></tr></table></figure><p>这两种方式是等价的。</p><h2 id="4-指定集合"><a href="#4-指定集合" class="headerlink" title="4. 指定集合"></a>4. 指定集合</h2><p>MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。</p><p>下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式：<br><code>collection = db.students</code></p><p><code>collection = db[&#39;students&#39;]</code><br>这样我们便声明了一个Collection对象。</p><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><p>接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert(student)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。</p><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5932a68615c2606814c91f3d</span><br></pre></td></tr></table></figure><p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">student1 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170202&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Mike&apos;,</span><br><span class="line">    &apos;age&apos;: 21,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert([student1, student2])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>返回结果是对应的_id的集合：</p><p><code>[ObjectId(&#39;5932a80115c2606a59e8a048&#39;), ObjectId(&#39;5932a80115c2606a59e8a049&#39;)]</code><br>实际上，在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt;</span><br><span class="line">5932ab0f15c2606f0c1cf6c5</span><br></pre></td></tr></table></figure><p>与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。</p><p>对于insert_many()方法，我们可以将数据以列表形式传递，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170202&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Mike&apos;,</span><br><span class="line">    &apos;age&apos;: 21,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.results.InsertManyResult object at 0x101dea558&gt;</span><br><span class="line">[ObjectId(&apos;5932abf415c2607083d3b2ac&apos;), ObjectId(&apos;5932abf415c2607083d3b2ad&apos;)]</span><br></pre></td></tr></table></figure><p>该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。</p><h2 id="6-查询"><a href="#6-查询" class="headerlink" title="6. 查询"></a>6. 查询</h2><p>插入数据后，我们可以利用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find_one(&#123;&apos;name&apos;: &apos;Mike&apos;&#125;)</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;dict&apos;&gt;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;5932a80115c2606a59e8a049&apos;), &apos;id&apos;: &apos;20170202&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 21, &apos;gender&apos;: &apos;male&apos;&#125;</span><br></pre></td></tr></table></figure><p>可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。</p><p>此外，我们也可以根据ObjectId来查询，此时需要使用bson库里面的objectid：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bson.objectid import ObjectId</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;)&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>其查询结果依然是字典类型，具体如下：</p><p><code>{&#39;_id&#39;: ObjectId(&#39;593278c115c2602667ec6bae&#39;), &#39;id&#39;: &#39;20170101&#39;, &#39;name&#39;: &#39;Jordan&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}</code><br>当然，如果查询结果不存在，则会返回None。</p><p>对于多条数据的查询，我们可以使用find()方法。例如，这里查找年龄为20的数据，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">results = collection.find(&#123;&apos;age&apos;: 20&#125;)</span><br><span class="line">print(results)</span><br><span class="line">for result in results:</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.cursor.Cursor object at 0x1032d5128&gt;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;), &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278c815c2602678bb2b8d&apos;), &apos;id&apos;: &apos;20170102&apos;, &apos;name&apos;: &apos;Kevin&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278d815c260269d7645a8&apos;), &apos;id&apos;: &apos;20170103&apos;, &apos;name&apos;: &apos;Harden&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br></pre></td></tr></table></figure><p>返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。</p><p>如果要查询年龄大于20的数据，则写法如下：</p><p><code>results = collection.find({&#39;age&#39;: {&#39;$gt&#39;: 20}})</code><br>这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。</p><p>这里将比较符号归纳为下表。<br><a href="https://cloud.tencent.com/developer/article/1151814" target="_blank" rel="noopener">腾讯云自媒体分享计划</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://yoursite.com/2018/05/02/mongodb/"/>
    <id>http://yoursite.com/2018/05/02/mongodb/</id>
    <published>2018-05-02T06:11:11.000Z</published>
    <updated>2019-07-07T04:23:34.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。</p><a id="more"></a><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>数据库是一个集合的物理容器。每个数据库获取其自己设定在文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库。</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><blockquote><p>集合是一组MongoDB的文件。它与一个RDBMS表是等效的。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。通常情况下，在一个集合中的所有文件都是类似或相关目的。</p></blockquote><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote><p>文档是一组键值对。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。<br>下面给出的示例显示了一个博客网站，仅仅是一个逗号分隔的键值对的文档结构。</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorial&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100, </span><br><span class="line">   comments: [</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user1&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2011,1,20,2,15),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user2&apos;,</span><br><span class="line">         message: &apos;My second comments&apos;,</span><br><span class="line">         dateCreated: new Date(2011,1,25,7,45),</span><br><span class="line">         like: 5</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p>MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>use DATABASE语句的基本语法如下：<br><code>use DATABASE_NAME</code></p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果想创建一个数据库名称为 &lt;mydb&gt;, 那么 use DATABASE 语句应该如下：</span><br><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line"></span><br><span class="line">要检查当前选择的数据库使用命令 db</span><br><span class="line">&gt;db</span><br><span class="line">mydb</span><br><span class="line"></span><br><span class="line">如果想查询数据库列表，那么使用命令 show dbs.</span><br><span class="line">&gt;show dbs</span><br><span class="line">local     0.78125GB</span><br><span class="line">test      0.23012GB</span><br><span class="line"></span><br><span class="line">所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。</span><br><span class="line">&gt;db.movie.insert(&#123;&quot;name&quot;:&quot;yiibai tutorials&quot;&#125;)</span><br><span class="line">&gt;show dbs</span><br><span class="line">local      0.78125GB</span><br><span class="line">mydb       0.23012GB</span><br><span class="line">test       0.23012GB</span><br></pre></td></tr></table></figure><p>MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。</p><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>MongoDB db.dropDatabase() 命令用于删除现有的数据库。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>dropDatabase()指令的基本语法如下：<br><code>db.dropDatabase()</code></p><p>这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库</p><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><p>如果想删除新的数据库 <mydb>, 那么 dropDatabase() 命令将如下所示：</mydb></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.dropDatabase()</span><br><span class="line">&gt;&#123; &quot;dropped&quot; : &quot;mydb&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>String</td><td>要创建的集合的名称</td></tr><tr><td>Options</td><td>Document</td><td>（可选）指定有关内存大小和索引选项</td></tr></tbody></table><p>选项参数是可选的，所以需要指定集合的唯一名字。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>createCollection()方法的基本语法如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt;db.createCollection(&quot;mycollection&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>可以通过使用 show collections 命令来检查创建的集合</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;show collections</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br></pre></td></tr></table></figure><h3 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h3><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>Boolean</td><td>（可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。</td></tr><tr><td>autoIndexID</td><td>Boolean</td><td>（可选）如果为true，自动创建索引_id字段。默认的值是 false.</td></tr><tr><td>size</td><td>number</td><td>（可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。</td></tr><tr><td>max</td><td>number</td><td>（可选）指定上限集合允许的最大文件数。</td></tr></tbody></table><p>尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法 :"></a>语法 :</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexID : true, size : 6142800, max : 10000 &#125; )</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.yiibai.insert(&#123;&quot;name&quot; : &quot;yiibai&quot;&#125;)</span><br><span class="line">&gt;show collections</span><br><span class="line">mycol</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br><span class="line">yiibai</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><p>MongoDB 的 db.collection.drop() 用于从数据库中删除集合。</p><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p>drop() 命令的基本语法如下<br><code>db.COLLECTION_NAME.drop()</code></p><h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><p>下面给出的例子将删除给定名称的集合：mycollection</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.mycollection.drop()</span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><p>将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p>insert()命令的基本语法如下：<br><code>&gt;db.COLLECTION_NAME.insert(document)</code></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.insert(&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c),</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。</p><p>在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。</p><p>_id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下：<br>_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer)</p><p>要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.post.insert([</span><br><span class="line">&#123;</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   title: &apos;NoSQL Database&apos;, </span><br><span class="line">   description: &apos;NoSQL database doesn&apos;t have tables&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 20, </span><br><span class="line">   comments: [</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user1&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2013,11,10,2,35),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。</p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p>find()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find()</code><br>find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。</p><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><p><code>&gt;db.mycol.find().pretty()</code></p><h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>除了find()方法还有findOne()方法，仅返回一个文档。</p><h3 id="RDBMS-Where子句等效于MongoDB"><a href="#RDBMS-Where子句等效于MongoDB" class="headerlink" title="RDBMS Where子句等效于MongoDB"></a>RDBMS Where子句等效于MongoDB</h3><p>查询文档在一些条件的基础上，可以使用下面的操作</p><table><thead><tr><th>操作</th><th>语法</th><th>示例</th><th>RDBMS等效语句</th></tr></thead><tbody><tr><td>Equality</td><td><code>{&lt;key&gt;:&lt;value&gt;}</code></td><td>db.mycol.find({“by”:”yiibai tutorials”}).pretty()</td><td>where by = ‘yiibai tutorials’</td></tr><tr><td>Less Than</td><td><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>Less Than Equals</td><td><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>Greater Than</td><td><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>Greater Than Equals</td><td><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>Not Equals</td><td><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><h4 id="AND-在-MongoDB"><a href="#AND-在-MongoDB" class="headerlink" title="AND 在 MongoDB"></a>AND 在 MongoDB</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><p>在 find()方法，如果您传递多个键通过”,”将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示：<br><code>&gt;db.mycol.find({key1:value1, key2:value2}).pretty()</code></p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview”</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&quot;by&quot;:&quot;yiibai tutorials&quot;,&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>对于上面给出的例子相当于where子句：’ where by=’yiibai tutorials’ AND title=’MongoDB Overview’ ‘。可以传递任何数目的键-值对在find子句。</p><h4 id="OR-在-MongoDB"><a href="#OR-在-MongoDB" class="headerlink" title="OR 在 MongoDB"></a>OR 在 MongoDB</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><p>要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有撰写含有 ‘yiibai tutorials’ 或是标题为 ‘MongoDB Overview’ 的教程</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;$or:[&#123;&quot;by&quot;:&quot;tutorials point&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-AND-和-OR-在一起"><a href="#使用-AND-和-OR-在一起" class="headerlink" title="使用 AND 和 OR 在一起"></a>使用 AND 和 OR 在一起</h4><h5 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 ‘MongoDB Overview’ 或 ‘yiibai tutorials’. 等效于SQL的where子句：’where likes&gt;10 AND (by = ‘yiibai tutorials’ OR title = ‘MongoDB Overview’)’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&quot;likes&quot;: &#123;$gt:10&#125;, $or: [&#123;&quot;by&quot;: &quot;yiibai tutorials&quot;&#125;, &#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;] &#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><p>MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。</p><h4 id="MongoDB-Update-方法"><a href="#MongoDB-Update-方法" class="headerlink" title="MongoDB Update() 方法"></a>MongoDB Update() 方法</h4><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><p>update()方法的基本语法如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)</span><br></pre></td></tr></table></figure><h5 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h5><p>考虑mycol集合有如下数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial”</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;New MongoDB Tutorial&apos;&#125;&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;New MongoDB Tutorial&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Tutorial Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 ‘multi’ 设置为 true。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;New MongoDB Tutorial&apos;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="MongoDB-Save-方法"><a href="#MongoDB-Save-方法" class="headerlink" title="MongoDB Save() 方法"></a>MongoDB Save() 方法</h4><p>save() 方法取代，通过新文档到 save()方法</p><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><p>mongodb 的 save()方法如下所示的基本语法：<br><code>&gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})</code></p><h5 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h5><p>下面的例子将替换该文件_id ‘5983548781331adf45ec7’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.save(</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>MongoDB 的 remove()方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志<br>deletion criteria : 根据文件（可选）删除条件将被删除。<br>justOne : （可选）如果设置为true或1，然后取出只有一个文档。</p><h6 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h6><p>remove()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)</code></p><h6 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h6><p>考虑mycol集合有如下数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将删除所有的文件，其标题为 ‘MongoDB Overview’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Toturials Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h5 id="只删除一个"><a href="#只删除一个" class="headerlink" title="只删除一个"></a>只删除一个</h5><p>如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。<br><code>&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</code></p><h5 id="删除所有文件"><a href="#删除所有文件" class="headerlink" title="删除所有文件"></a>删除所有文件</h5><p>如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove()</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="MongoDB投影"><a href="#MongoDB投影" class="headerlink" title="MongoDB投影"></a>MongoDB投影</h4><p>mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。</p><p>MongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。</p><p>语法</p><p>find()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find({},{KEY:1})</code></p><p>例子</p><p>考虑集合 myycol 有下列数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示文档的标题，在查询文档时。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;)</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0</p><h5 id="限制文档"><a href="#限制文档" class="headerlink" title="限制文档"></a>限制文档</h5><p>MongoDB Limit() 方法</p><p>要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。</p><h6 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h6><p>limit()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER)</code></p><p>例子</p><p>考虑集合 myycol 有下列数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将只显示2个文档，在查询文档时。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果不指定 limit()方法的参数数量，然后它会显示集合中的所有文档。</p><p>MongoDB Skip() 方法</p><p>除了 limit()方法还有一个方法 skip()也接受数字类型参数并用于跳过文件数。</p><p>语法</p><p>skip() 方法的基础语法如下所示：<br><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</code></p><p>例子：</p><p>下面的例子将仅显示第二个文档。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意，skip() 方法的默认值是 0</p><h4 id="文档排序"><a href="#文档排序" class="headerlink" title="文档排序"></a>文档排序</h4><p>要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。</p><p>语法</p><p>sort()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find().sort({KEY:1})</code></p><p>例子</p><p>考虑集合 myycol 有如下数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示的文件排序按标题降序排序。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;title&quot;:-1&#125;)</span><br><span class="line">&#123;&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。</p><h4 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h4><p>索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。</p><p>索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。</p><p>要创建索引，需要使用MongoDB的ensureIndex()方法。</p><p>语法</p><p>ensureIndex()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.ensureIndex({KEY:1})</code></p><p>这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1.</p><p>例子</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.ensureIndex(&#123;&quot;title&quot;:1&#125;)</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。</span><br><span class="line">&gt;db.mycol.ensureIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>ensureIndex() 方法还接受选项列表（这是可选），其列表如下：<br><img src="https://policx.github.io/post-images/1561132706992.png" alt></p><h4 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h4><p>聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。</p><p>语法</p><p>aggregate()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</code></p><p>例子：</p><p>在集合中有以下数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by_user: &apos;Yiibai Yiibai &apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902d)</span><br><span class="line">   title: &apos;NoSQL Overview&apos;, </span><br><span class="line">   description: &apos;No sql database is very fast&apos;,</span><br><span class="line">   by_user: &apos;Yiibai Yiibai&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 10</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902e)</span><br><span class="line">   title: &apos;Neo4j Overview&apos;, </span><br><span class="line">   description: &apos;Neo4j is no sql database&apos;,</span><br><span class="line">   by_user: &apos;Neo4j&apos;,</span><br><span class="line">   url: &apos;http://www.neo4j.com&apos;,</span><br><span class="line">   tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 750</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">   &quot;result&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Yiibai Yiibai&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 1</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><pre><code>用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user</code></pre><p>另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。<br>    <img src="https://policx.github.io/post-images/1561132965786.png" alt></p><h4 id="MongoDB-复制"><a href="#MongoDB-复制" class="headerlink" title="MongoDB 复制"></a>MongoDB 复制</h4><p>复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。</p><h6 id="为什么要复制？"><a href="#为什么要复制？" class="headerlink" title="为什么要复制？"></a>为什么要复制？</h6><blockquote><pre><code>为了让数据安全数据的高（24*7）可用性灾难恢复无停机维护（如备份，索引重建，压缩）读取缩放（额外的副本来读取）副本集是透明的应用</code></pre></blockquote><h5 id="MongoDB复制的工作原理"><a href="#MongoDB复制的工作原理" class="headerlink" title="MongoDB复制的工作原理"></a>MongoDB复制的工作原理</h5><p>MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。</p><blockquote><pre><code>副本集是一组两个或更多个节点（通常至少3节点是必需的）。在副本集一个节点是主节点和其余的节点都是次要的。所有的数据复制是从主到次节点。在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。</code></pre></blockquote><p>mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。<br><img src="https://policx.github.io/post-images/1561133216694.png" alt><br>副本集特征</p><ul><li>N个节点的集群</li><li>任何节点可为原发/主节点</li><li>所有的写操作进入到主节点</li><li>自动故障转移</li><li>自动恢复</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python3 与 MySQL 之间的交互</title>
    <link href="http://yoursite.com/2018/05/02/pymysql/"/>
    <id>http://yoursite.com/2018/05/02/pymysql/</id>
    <published>2018-05-02T03:14:27.000Z</published>
    <updated>2019-07-07T04:35:38.926Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="什么是-PyMySQL？"><a href="#什么是-PyMySQL？" class="headerlink" title="什么是 PyMySQL？"></a>什么是 PyMySQL？</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p>PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。</p><a id="more"></a> <h2 id="安装mysql模块"><a href="#安装mysql模块" class="headerlink" title="安装mysql模块"></a>安装mysql模块</h2><p>在文件中引入模块</p><p><code>import pymysql</code></p><h3 id="1-Connection对象"><a href="#1-Connection对象" class="headerlink" title="1.Connection对象"></a>1.Connection对象</h3><p>•  用于建立与数据库的连接<br>•  创建对象：调用connect()方法<br>conn=connect(参数列表)<br>•  参数host：连接的mysql主机，如果本机是’localhost’<br>•  参数port：连接的mysql主机的端口，默认是3306<br>•  参数db：数据库的名称<br>•  参数user：连接的用户名<br>•  参数password：连接的密码<br>•  参数charset：通信采用的编码方式，默认是’gb2312’，要求与数据库创建时指定的编码一致，否则中文会乱码</p><h3 id="2-对象的方法"><a href="#2-对象的方法" class="headerlink" title="2.对象的方法"></a>2.对象的方法</h3><p>•  close()关闭连接<br>•  commit()事务，所以需要提交才会生效<br>•  rollback()事务，放弃之前的操作<br>•  cursor()返回Cursor对象，用于执行sql语句并获得结果</p><h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><p>•  执行sql语句<br>•  创建对象：调用Connection对象的cursor()方法<br>cursor1=conn.cursor()</p><h4 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h4><p>•  close()关闭<br>•  execute(operation [, parameters ])执行语句，返回受影响的行数<br>•  fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组<br>•  next()执行查询语句时，获取当前行的下一行<br>•  fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回<br>•  scroll(value[,mode])将行指针移动到某个位置<br>•  mode表示移动的方式<br>•  mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动。相对的<br>•  mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0，绝对的。</p><h4 id="举个例子便于理解"><a href="#举个例子便于理解" class="headerlink" title="举个例子便于理解"></a>举个例子便于理解</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 导入python操作mysql的模块</span></span><br><span class="line"><span class="hljs-keyword">import</span> pymysql</span><br><span class="line"><span class="hljs-comment"># 获取连接对象</span></span><br><span class="line">conn = pymysql.connect(host=<span class="hljs-string">'127.0.0.1'</span>, user=<span class="hljs-string">'root'</span>, password=<span class="hljs-string">'123456'</span>, database=<span class="hljs-string">'python01'</span>, port=<span class="hljs-number">3306</span>, charset=<span class="hljs-string">'utf8'</span>)</span><br><span class="line"><span class="hljs-comment"># 获取执行工具</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"><span class="hljs-comment"># sql语句,增删改</span></span><br><span class="line"><span class="hljs-comment">#sql = 'select birthday from t_user'</span></span><br><span class="line">sql = <span class="hljs-string">'select id,name,pwd,birthday from t_user'</span></span><br><span class="line"><span class="hljs-comment"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span></span><br><span class="line">count = cur.execute(sql)</span><br><span class="line">print(<span class="hljs-string">'查询的结果有%s条数据'</span>%count)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#获取第一行</span></span><br><span class="line">dateOne = cur.fetchone()</span><br><span class="line">print(dateOne)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#向上移动一行</span></span><br><span class="line">cur.scroll(<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#向下移动一行</span></span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>,mode=<span class="hljs-string">'absolute'</span>)   绝对的，这里指的是第一行</span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>,mode=<span class="hljs-string">'relative'</span>)   相对的</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#获取所有行的数据</span></span><br><span class="line">dataAll = cur.fetchall()</span><br><span class="line">print(dataAll)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> dataAll:</span><br><span class="line">     print(temp)</span><br><span class="line">     print(dataAll[<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])      <span class="hljs-comment">#dataAll[-1]得到的是一个用户所有的信息，dataAll[-1][2]获取最后一个人的密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> cur:</span><br><span class="line">     print(temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'id:%s,name:%s,pwd:%s,birthday:%s'</span></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> dataAll:</span><br><span class="line">    print(s%(temp[<span class="hljs-number">0</span>],temp[<span class="hljs-number">1</span>],temp[<span class="hljs-number">2</span>],temp[<span class="hljs-number">3</span>]))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 关闭</span></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="3-对象的属性"><a href="#3-对象的属性" class="headerlink" title="3.对象的属性"></a>3.对象的属性</h3><p>•  rowcount只读属性，表示最近一次execute()执行后受影响的行数<br>•  connection获得当前连接对象</p><h3 id="2-增删改查-CRUD"><a href="#2-增删改查-CRUD" class="headerlink" title="2.增删改查(CRUD)"></a>2.增删改查(CRUD)</h3><h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>•  创建testInsert.py文件，向学生表中插入一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;insert into students(sname) values(&apos;张良&apos;)&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h4><p>•  创建testUpdate.py文件，修改学生表的一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;update students set sname=&apos;刘邦&apos; where id=6&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h4><p>•  创建testDelete.py文件，删除学生表的一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8 import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;delete from students where id=6&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="4-查"><a href="#4-查" class="headerlink" title="4.查"></a>4.查</h4><p>•  创建testSelectOne.py文件，查询一条学生信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Pymysql try:</span><br><span class="line">conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">cur=conn.cursor()</span><br><span class="line">cur.execute(&apos;select * from students where id=7&apos;)</span><br><span class="line">result=cur.fetchone()</span><br><span class="line">print result</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p>•  创建testSelectMany.py文件，查询全部学生信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf8 import Pymysql</span><br><span class="line">try:</span><br><span class="line">conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">cur=conn.cursor()</span><br><span class="line">cur.execute(&apos;select * from students&apos;)</span><br><span class="line">result=cur.fetchall()</span><br><span class="line">print result</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><h3 id="实例一：参数"><a href="#实例一：参数" class="headerlink" title="实例一：参数"></a>实例一：参数</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 获取连接对象</span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)</span><br><span class="line"># 获取执行工具</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"># sql语句,增删改，sql注入</span><br><span class="line">sql = &apos;insert into t_user(name,pwd,birthday) values(%s,%s,%s)&apos;</span><br><span class="line"># 参数列表</span><br><span class="line">name = input(&apos;输入姓名:&apos;)</span><br><span class="line">pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">birthday = input(&apos;输入生日:&apos;)     # 2017年10月01日--&gt;日期struct_time(---&gt;2017-10-01)</span><br><span class="line">birthday = time.strptime(birthday,&apos;%Y年%m月%d日&apos;)      #这里我们就用到了时间与字符串的相互转换(详情见MySQL高级)</span><br><span class="line"></span><br><span class="line">params = [name,pwd,birthday]</span><br><span class="line"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">count = cur.execute(sql,params)</span><br><span class="line">#提交</span><br><span class="line">conn.commit()</span><br><span class="line">print(&apos;受影响的行数:%s&apos;%count)</span><br><span class="line"># 关闭</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="实例二：抛出异常"><a href="#实例二：抛出异常" class="headerlink" title="实例二：抛出异常"></a>实例二：抛出异常</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    conn = None</span><br><span class="line">    cur = None</span><br><span class="line">    # 获取连接对象</span><br><span class="line">    conn = pymysql.connect(host=&apos;127.0.0.1&apos;,</span><br><span class="line">                           user=&apos;root&apos;,</span><br><span class="line">                           password=&apos;123456&apos;,</span><br><span class="line">                           database=&apos;python01&apos;,</span><br><span class="line">                           port=3306,</span><br><span class="line">                           charset=&apos;utf8&apos;)</span><br><span class="line">    # 模拟异常</span><br><span class="line">    # a = 1 / 0</span><br><span class="line">    # 获取执行工具</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    # sql语句,增删改</span><br><span class="line">    sql = &apos;insert into t_user(name,pwd,birthday) values(&quot;小伊&quot;,&quot;123456&quot;,str_to_date(&quot;2017年10月20日&quot;,&quot;%Y年%m月%d日&quot;))&apos;</span><br><span class="line">    # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">    count = cur.execute(sql)</span><br><span class="line">    # 提交</span><br><span class="line">    conn.commit()</span><br><span class="line">    print(&apos;受影响的行数:%s&apos; % count)</span><br><span class="line">except Exception as ex:</span><br><span class="line">    # 打印异常信息，测试时候使用，项目上线，去掉</span><br><span class="line">    print(str(ex))</span><br><span class="line">    # 将异常继续抛出</span><br><span class="line">    # raise</span><br><span class="line">finally:</span><br><span class="line">    if cur != None:</span><br><span class="line">        cur.close()</span><br><span class="line">    if conn != None:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure><h3 id="实例三："><a href="#实例三：" class="headerlink" title="实例三："></a>实例三：</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 获取连接对象</span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)</span><br><span class="line"># 获取执行工具</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"># sql语句,增删改</span><br><span class="line">#sql = &apos;select birthday from t_user&apos;</span><br><span class="line">sql = &apos;select id,name,pwd,birthday from t_user&apos;</span><br><span class="line"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">count = cur.execute(sql)</span><br><span class="line">print(&apos;查询的结果有%s条数据&apos;%count)</span><br><span class="line"></span><br><span class="line">#获取第一行</span><br><span class="line"># dateOne = cur.fetchone()</span><br><span class="line"># print(dateOne)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># for temp in cur:</span><br><span class="line">#     print(temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = &apos;id:%s,name:%s,pwd:%s,birthday:%s&apos;</span><br><span class="line">for temp in dataAll:</span><br><span class="line">    print(s%(temp[0],temp[1],temp[2],temp[3]))</span><br><span class="line"></span><br><span class="line"># 关闭</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h3><p>这个库的名字：mySqlHelper</p><p> python操作mysql进行增删改查的封装</p><pre><code>1、增删改，代码类似2、查询代码分析1、获取连接对象2、sql语句不同，参数不同3、获取执行对象    增删改    查询        1、fetchone        2、fetchall4、处理结果5、关闭</code></pre><h4 id="面向对象-建立类，封装属性和函数"><a href="#面向对象-建立类，封装属性和函数" class="headerlink" title="面向对象  建立类，封装属性和函数"></a>面向对象  建立类，封装属性和函数</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">class MysqlHelper:</span><br><span class="line">    &apos;&apos;&apos;python操作mysql的增删改查的封装&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, host, user, password, database, port=3306, charset=&apos;utf8&apos;):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        初始化参数</span><br><span class="line">        :param host:        主机</span><br><span class="line">        :param user:        用户名</span><br><span class="line">        :param password:    密码</span><br><span class="line">        :param database:    数据库</span><br><span class="line">        :param port:        端口号，默认是3306</span><br><span class="line">        :param charset:     编码，默认是utf8</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.database = database</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.charset = charset</span><br><span class="line"></span><br><span class="line">    def connect(self):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        获取连接对象和执行对象</span><br><span class="line">        :return:</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        self.conn = pymysql.connect(host=self.host,</span><br><span class="line">                                    user=self.user,</span><br><span class="line">                                    password=self.password,</span><br><span class="line">                                    database=self.database,</span><br><span class="line">                                    port=self.port,</span><br><span class="line">                                    charset=self.charset)</span><br><span class="line"></span><br><span class="line">        self.cur = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def fetchone(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">         根据sql和参数获取一行数据</span><br><span class="line">       :param sql:          sql语句</span><br><span class="line">       :param params:       sql语句对象的参数元组，默认值为None</span><br><span class="line">       :return:             查询的一行数据</span><br><span class="line">       &apos;&apos;&apos;</span><br><span class="line">        dataOne = None</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            if count != 0:</span><br><span class="line">                dataOne = self.cur.fetchone()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return dataOne</span><br><span class="line"></span><br><span class="line">    def fetchall(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">         根据sql和参数获取一行数据</span><br><span class="line">       :param sql:          sql语句</span><br><span class="line">       :param params:       sql语句对象的参数列表，默认值为None</span><br><span class="line">       :return:             查询的一行数据</span><br><span class="line">       &apos;&apos;&apos;</span><br><span class="line">        dataall = None</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            if count != 0:</span><br><span class="line">                dataall = self.cur.fetchall()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return dataall</span><br><span class="line"></span><br><span class="line">    def __item(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行增删改</span><br><span class="line">        :param sql:           sql语句</span><br><span class="line">        :param params:        sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:              受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        count = 0</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def update(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行修改</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def insert(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行新增</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def delete(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行删除</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        关闭执行工具和连接对象</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        if self.cur != None:</span><br><span class="line">            self.cur.close()</span><br><span class="line">        if self.conn != None:</span><br><span class="line">            self.conn.close()</span><br></pre></td></tr></table></figure><h4 id="1-测试查询多条数据"><a href="#1-测试查询多条数据" class="headerlink" title="1.测试查询多条数据"></a>1.测试查询多条数据</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;select * from t_user where name = %s and id &gt; %s&apos;</span><br><span class="line"># params</span><br><span class="line">params = [&apos;小茗&apos;,1]</span><br><span class="line"># 执行</span><br><span class="line">data = helper.fetchall(sql, params)</span><br><span class="line"># 判断</span><br><span class="line">if data:</span><br><span class="line">    for temp in data:</span><br><span class="line">        print(temp)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;没有数据.&apos;)</span><br><span class="line"></span><br><span class="line">helper.close()</span><br></pre></td></tr></table></figure><h4 id="2-测试查询一条数据"><a href="#2-测试查询一条数据" class="headerlink" title="2.测试查询一条数据"></a>2.测试查询一条数据</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;select * from t_user where id = %s&apos;</span><br><span class="line">#sql = &apos;select * from t_user where id = 1&apos;</span><br><span class="line"># params</span><br><span class="line">params = [2]</span><br><span class="line"># 执行</span><br><span class="line">data = helper.fetchone(sql, params)</span><br><span class="line">#data = helper.fetchone(sql)</span><br><span class="line"># 判断</span><br><span class="line">if data:</span><br><span class="line">    print(data)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;没有数据.&apos;)</span><br></pre></td></tr></table></figure><h4 id="3-测试增删改"><a href="#3-测试增删改" class="headerlink" title="3.测试增删改"></a>3.测试增删改</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;update t_user set name =%s,pwd=%s,birthday=%s where id=%s&apos;</span><br><span class="line"># params</span><br><span class="line">id = input(&apos;输入编号:&apos;)</span><br><span class="line">name = input(&apos;输入姓名:&apos;)</span><br><span class="line">pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">birthday = time.strptime(input(&apos;输入生日:&apos;), &apos;%Y年%m月%d日&apos;)</span><br><span class="line">params = [name, pwd, birthday,id]</span><br><span class="line"># 执行</span><br><span class="line">count = helper.update(sql, params)</span><br><span class="line"># 判断</span><br><span class="line">if count:</span><br><span class="line">    print(&apos;操作成功.&apos;)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;操作失败.&apos;)</span><br></pre></td></tr></table></figure><h4 id="4-登录和注册"><a href="#4-登录和注册" class="headerlink" title="4.登录和注册"></a>4.登录和注册</h4><p>登录和注册的时候需要对密码进行加密</p><p>注意：</p><p>•  需要对密码进行加密<br>•  如果使用md5加密，则密码包含32个字符<br>•  如果使用sha1加密，则密码包含40个字符，这里使用这种方式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table userinfos(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    uname varchar(20),</span><br><span class="line">    upwd char(40),</span><br><span class="line">    isdelete bit default 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ret = doPwd(&apos;123&apos;)</span><br><span class="line">print(ret)</span><br><span class="line">结果：40bd001563085fc35165329ea1ff5c5ecbdbbeef</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">-- 插入如下数据，用户名为123,密码为123,这是sha1加密后的值</span><br><span class="line"></span><br><span class="line">insert into userinfos </span><br><span class="line">values(1,&apos;123&apos;,&apos;40bd001563085fc35165329ea1ff5c5ecbdbbeef&apos;,0);</span><br></pre></td></tr></table></figure><h4 id="登录与注册"><a href="#登录与注册" class="headerlink" title="登录与注册"></a>登录与注册</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from mysqlHelper import MysqlHelper</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    &apos;&apos;&apos;登录&apos;&apos;&apos;</span><br><span class="line">    name = input(&apos;输入用户名:&apos;)</span><br><span class="line">    pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">    #加密</span><br><span class="line">    pwd = doPwd(pwd)</span><br><span class="line"></span><br><span class="line">    helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line">    helper.connect()</span><br><span class="line">    sql = &apos;select * from t_user where name=%s and pwd=%s&apos;</span><br><span class="line">    params = [name, pwd]</span><br><span class="line">    data = helper.fetchone(sql, params)</span><br><span class="line">    if data:</span><br><span class="line">        print(&apos;登录成功.&apos;)</span><br><span class="line">    else:  # None,False,0</span><br><span class="line">        print(&apos;登录失败.&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def doPwd(pwd):</span><br><span class="line">    &apos;&apos;&apos;sha1编码&apos;&apos;&apos;</span><br><span class="line">    mysha1 = hashlib.sha1()</span><br><span class="line">    mysha1.update(pwd.encode(&apos;utf-8&apos;))</span><br><span class="line">    pwd = mysha1.hexdigest()</span><br><span class="line">    return pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def register():</span><br><span class="line">    &apos;&apos;&apos;注册&apos;&apos;&apos;</span><br><span class="line">    name = input(&apos;输入用户名:&apos;)</span><br><span class="line">    pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">    # 加密</span><br><span class="line">    pwd = doPwd(pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line">    helper.connect()</span><br><span class="line">    sql = &apos;insert into t_user(name,pwd) values(%s,%s)&apos;</span><br><span class="line">    params = [name, pwd]</span><br><span class="line">    count = helper.insert(sql, params)</span><br><span class="line">    if count:</span><br><span class="line">        print(&apos;操作成功.&apos;)</span><br><span class="line">    else:  # None,False,0</span><br><span class="line">        print(&apos;操作失败.&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    #register()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-PyMySQL？&quot;&gt;&lt;a href=&quot;#什么是-PyMySQL？&quot; class=&quot;headerlink&quot; title=&quot;什么是 PyMySQL？&quot;&gt;&lt;/a&gt;什么是 PyMySQL？&lt;/h2&gt;&lt;p&gt;PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。&lt;/p&gt;
&lt;p&gt;PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django笔记</title>
    <link href="http://yoursite.com/2018/04/18/django-bi-ji/"/>
    <id>http://yoursite.com/2018/04/18/django-bi-ji/</id>
    <published>2018-04-17T17:00:16.000Z</published>
    <updated>2019-07-07T04:26:44.840Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。</p><a id="more"></a><h2 id="一-版本选择"><a href="#一-版本选择" class="headerlink" title="一. 版本选择"></a>一. 版本选择</h2><p>Django 2.0.x 支持 Python 3.4, 3.5 和 3.6 （注意，不再支持 Python 2）   </p><h2 id="二-安装-Django"><a href="#二-安装-Django" class="headerlink" title="二. 安装 Django"></a><strong>二. 安装 Django</strong></h2><p><strong>2.1. 用 pip 来安装</strong></p><p><strong>2.1.1 需要先安装pip</strong></p><p>(1). Linux, Mac OSX, Windows 下都可用 get-pip.py 来安装<br>pip：<a href="https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="noopener">https://pip.pypa.io/en/latest/installing.html</a>  </p><p>或者直接下载：<a href="https://bootstrap.pypa.io/get-pip.py" title="get-pip.py" target="_blank" rel="noopener">get-pip.py</a> 然后运行在终端运行 <strong>python get-pip.py 就可以安装 pip。</strong></p><p>Note: 也可以下载 pip 源码包，运行 <strong>python setup.py install</strong> 进行安装 </p><p><strong>2.1.2 利用 pip 安装 Django</strong></p><p><code>（sudo) pip install Django    或者(sudo) pip install Django==1.8.16 或者 pip install Django==1.11.8</code>    </p><p>如果想升级 pip 可以用： </p><pre><code>(sudo) pip install --upgrade pip</code></pre><p><strong>2.2. 下载源码安装</strong>  </p><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">https://www.djangoproject.com/download/</a></p><p>如果是源码包, 比如 django-1.11.8.tar.gz </p><p><strong>2.2.1 Linux 或 Mac 下</strong></p><pre><code>tar -xvf django-1.11.8.tar.gzcd django-1.11.8(sudo) python setup.py install</code></pre><h2 id="三-检查是否安装成功"><a href="#三-检查是否安装成功" class="headerlink" title="三. 检查是否安装成功"></a><strong>三. 检查是否安装成功</strong></h2><p>终端上输入 python ,点击 Enter，进行 python 环境</p><pre><code>&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 11, 8, &apos;final&apos;, 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()&apos;1.11.8&apos;</code></pre><p>如果运行后看到版本号，就证明安装成功了！ </p><h2 id="四-搭建多个互不干扰的开发环境（可选）"><a href="#四-搭建多个互不干扰的开发环境（可选）" class="headerlink" title="四. 搭建多个互不干扰的开发环境（可选）"></a><strong>四. 搭建多个互不干扰的开发环境（可选）</strong></h2><p>我们有的时候会发现，一个电脑上有多个项目，一个依赖 Django 1.8，另一个比较旧的项目又要用 Django 1.5，这时候怎么办呢？ </p><p>我们需要一个依赖包管理的工具来处理不同的环境。 </p><h3 id="4-1-虚拟环境依赖安装"><a href="#4-1-虚拟环境依赖安装" class="headerlink" title="4.1 虚拟环境依赖安装"></a>4.1 虚拟环境依赖安装</h3><p>开发会用 virtualenv 来管理多个开发环境 </p><p><strong>Linux/MacOS 下</strong></p><p>virtualenvwrapper 使得virtualenv变得更好用，所以我们一起安装了 </p><pre><code># 安装:(sudo) pip install virtualenv virtualenvwrapper</code></pre><p>修改~/.bash_profile或其它环境变量相关文件(如 .bashrc 或用 ZSH 之后的 .zshrc)，添加以下语句  </p><pre><code>export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspacesource /usr/local/bin/virtualenvwrapper.sh</code></pre><p>修改后使之立即生效(也可以重启终端使之生效)： </p><pre><code>source ~/.bash_profile</code></pre><h3 id="4-2-虚拟环境使用方法："><a href="#4-2-虚拟环境使用方法：" class="headerlink" title="4.2 虚拟环境使用方法："></a><strong>4.2 虚拟环境使用方法：</strong></h3><p><strong>mkvirtualenv zqxt：创建运行环境zqxt</strong></p><p><strong>workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境</strong></p><p><strong>deactivate</strong>: 退出终端环境</p><p><strong>其它的：</strong></p><p><strong>rmvirtualenv</strong> ENV：删除运行环境ENV </p><p><strong>mkproject</strong> mic：创建mic项目和运行环境mic </p><p><strong>mktmpenv</strong>：创建临时运行环境 </p><p><strong>lsvirtualenv</strong>: 列出可用的运行环境 </p><p><strong>lssitepackages</strong>: 列出当前环境安装了的包 </p><p>创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。&lt;/p&gt;
    
    </summary>
    
      <category term="programing" scheme="http://yoursite.com/categories/programing/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django部署——uwsgi+Nginx</title>
    <link href="http://yoursite.com/2018/04/17/django/"/>
    <id>http://yoursite.com/2018/04/17/django/</id>
    <published>2018-04-17T09:42:04.000Z</published>
    <updated>2019-07-07T04:22:37.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了!</p><a id="more"></a><p><img src="https://policx.github.io/post-images/1560768371650.png" alt><br>环境：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3.6</span><br><span class="line">centos 7</span><br><span class="line">Django1.11</span><br></pre></td></tr></table></figure><h2 id="1、本地跑起来Django"><a href="#1、本地跑起来Django" class="headerlink" title="1、本地跑起来Django"></a>1、本地跑起来Django</h2><p>这里不讲Django项目实施过程，假设你已经写了一个Django项目，并且在本地127.0.0.1:8000能够跑起来。喏，给你个参考，项目大概长这样：<br><img src="https://policx.github.io/post-images/1560764670814.png" alt></p><ul><li>kindle目录为我创建的Django App</li></ul><h2 id="2、修改项目配置"><a href="#2、修改项目配置" class="headerlink" title="2、修改项目配置"></a>2、修改项目配置</h2><p>也就是项目目录下的settings.py文件，主要强调几个地方：</p><p>①关闭DEBUG模式：<br><img src="https://policx.github.io/post-images/1560764736238.png" alt><br>②修改ALLOWED_HOSTS：<br><img src="https://policx.github.io/post-images/1560764863424.png" alt><br>③配置静态文件存放路径：<br><img src="https://policx.github.io/post-images/1560764833026.png" alt></p><p>修改好配置之后执行:<br><code>python manage.py collectstatic</code><br>将项目用到的静态文件复制到项目根目录下的static文件中<br><img src="https://policx.github.io/post-images/1560764930146.png" alt></p><h2 id="3、安装uwsgi和Nginx"><a href="#3、安装uwsgi和Nginx" class="headerlink" title="3、安装uwsgi和Nginx"></a>3、安装uwsgi和Nginx</h2><p>这个没什么说的。。。在自己的云服务器上装好这两个工具<br>安装好uwsgi后最好验证一下，验证方法：<br>创建一个test.py文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html&apos;)])</span><br><span class="line">    return [b&apos;Hello world!&apos;]    #python3</span><br><span class="line">    # return [&apos;Hello world!&apos;]    #python2</span><br></pre></td></tr></table></figure><p>启动uwsgi服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :8000 --wsgi-file test.py</span><br></pre></td></tr></table></figure><p>如果可以正常启动而不报错那就应该没问题，不放心的话再在终端验证一下：<br><code>wget http://127.0.0.1:8000</code><br>看一下能否正确获取内容</p><h2 id="4、配置项目的uwsgi"><a href="#4、配置项目的uwsgi" class="headerlink" title="4、配置项目的uwsgi"></a>4、配置项目的uwsgi</h2><p>在项目所在文件夹下创建uwsgi.ini配置文件，也就是这里:<br><img src="https://policx.github.io/post-images/1560765049955.png" alt><br>在uwsgi.ini里进行如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># Django-related settings</span><br><span class="line"> </span><br><span class="line"># 这里的端口可以根据自己需要设定</span><br><span class="line">socket = 127.0.0.1:8001        </span><br><span class="line"> </span><br><span class="line"># the base directory (full path)</span><br><span class="line"># 这个是Django项目的根目录，也就是包含App的那个目录，仔细对照上图</span><br><span class="line">chdir           = /home/python/book2kindle</span><br><span class="line"> </span><br><span class="line"># Django s wsgi file</span><br><span class="line"># 这里是项目名(不是App名).wsgi</span><br><span class="line">module          = book2kindle.wsgi</span><br><span class="line"> </span><br><span class="line"># process-related settings</span><br><span class="line"># master</span><br><span class="line">master          = true</span><br><span class="line"> </span><br><span class="line"># maximum number of worker processes</span><br><span class="line">processes       = 32</span><br><span class="line"> </span><br><span class="line"># ... with appropriate permissions - may be needed</span><br><span class="line"># chmod-socket    = 664</span><br><span class="line"># clear environment on exit</span><br><span class="line">vacuum          = true</span><br><span class="line"> </span><br><span class="line">plugin python = true</span><br><span class="line"> </span><br><span class="line"># 这个是项目的虚拟python环境，如果没用虚拟环境，可以不设定</span><br><span class="line">home = /home/python/book2kindle_env</span><br></pre></td></tr></table></figure><h2 id="5、配置项目的nginx"><a href="#5、配置项目的nginx" class="headerlink" title="5、配置项目的nginx"></a>5、配置项目的nginx</h2><p>找到nginx的配置文件夹，centos7的nginx配置文件在/etc/nginx下，该路径下有一个nginx.conf总配置文件，还有两个文件夹./conf.d、./default.d，我们将nginx.conf复制一份到conf.d文件夹下，命名为nginx.conf（或者项目名.conf）进行如下修改（根据中文注释进行相应配置即可）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream django &#123;</span><br><span class="line">        # 注意这里的server要和uwsgi.ini配置文件中的socket保持一致</span><br><span class="line">        server 127.0.0.1:8002; # for a web port socket</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.com;  # 这里填自己的域名或者服务器的ip（决定你今后访问网站的方式）</span><br><span class="line">        charset      utf-8;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">        root        /home/python/book2kindle/kindle;  # 这是Django App的路径</span><br><span class="line">            uwsgi_pass  django;</span><br><span class="line">            include     uwsgi_params; # the uwsgi_params file you installed</span><br><span class="line">        &#125;</span><br><span class="line">        location /static &#123;</span><br><span class="line">            # Django项目静态文件的路径</span><br><span class="line">            alias /home/python/book2kindle/static; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、启动uwsgi和nginx"><a href="#6、启动uwsgi和nginx" class="headerlink" title="6、启动uwsgi和nginx"></a>6、启动uwsgi和nginx</h2><p>进入uwsgi.ini文件夹下执行：<br><code>uwsgi --ini uwsgi.ini</code><br>在终端执行：<br><code>service nginx restart</code><br>然后就可以根据域名（前提是要将域名解析到服务器ip地址）或者服务器ip来访问网站了！</p><p>OK，完事！就是这么简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了!&lt;/p&gt;
    
    </summary>
    
      <category term="programing" scheme="http://yoursite.com/categories/programing/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>2018创业记：如何选择合伙人？</title>
    <link href="http://yoursite.com/2018/03/25/chuangye/"/>
    <id>http://yoursite.com/2018/03/25/chuangye/</id>
    <published>2018-03-25T13:02:42.000Z</published>
    <updated>2019-07-07T04:22:05.224Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><ul><li><a id="more"></a><h2 id="创业路上危机四伏，如何破局？"><a href="#创业路上危机四伏，如何破局？" class="headerlink" title="创业路上危机四伏，如何破局？"></a>创业路上危机四伏，如何破局？</h2></li></ul><p>很多朋友在2018年做出了改变，迈出了新的一步。比如身边几位朋友正摩拳擦掌准备创业。然而，看别人创业和自己创业完全是两回事儿，见得再多，自己趟水时也难免有所顾虑。</p><p>在跟他们聊过之后，我们发现了他们普遍面临的一个课题：如何选择合伙人?这是身经百战的连续创业者也很难驾轻就熟的一个课题，今天我们就来一起聊聊。本文将从能不能和朋友一起创业、合伙人应该与我互补还是相似、如何判断双方是否志同道合、如何应对常见的分歧几个部分展开来说。</p><p>风物长宜放眼量，抱持开阔的胸襟、敏锐的判断、坚韧的意志，相信大家能够与志同道合的伙伴一起，越过山丘，携手站上梦想之巅。</p><h2 id="能不能和朋友一起创业？"><a href="#能不能和朋友一起创业？" class="headerlink" title="能不能和朋友一起创业？"></a>能不能和朋友一起创业？</h2><p>在创业初期，创业者选择合伙人往往会从身边的朋友“下手”。</p><p>一起创业可以说是认清一个朋友的最好方式。一篇名为《友谊的代价》的论文，考察了3510个风险投资者，以及他们在1975-2003年间11895个投资项目。</p><p>论文写道，有的人选择与自己能力相当的人合作，比如同是名校毕业；但更多的人选择与自己的熟人合作，比如曾经的同学或同事。结果表明，按能力搭档可以增加投资的成功概率，而找熟人搭档，则会明显降低成功的可能性。</p><p>所有人都喜欢强联系，但关系是关系，工作归工作。现在社会学已经有了足够多的证据说明：对工作来说，同乡会和校友录并不是扩展人脉的好地方。《中国合伙人》这部电影上映后，“千万别跟好朋友合伙开公司”也成了热议话题。电影的最后，三位合伙人分道扬镳，而剧本的原型——新东方的三位创始人也以“分家”收场。</p><p>当然，朋友合伙创业成功的案例也不在少数，况且，长期的伙伴关系更有助于共同面对创业过程中的艰难险阻，团队也更容易在创业初期获得投资人的青睐。如果在寻找合伙人的过程中，你觉得还是某个朋友更适合，那么一定要在合作之前约法三章，考虑到最坏的情况，提前用书面合同的方式确定双方的责权利，用规章制度来约束指导双方的行为，而不是靠人情关系。</p><p>中间一旦觉得发生了问题，你就必须考虑一下能否继续合作下去。其实，很多合作者走不到最后就是因为中间的小问题没有解决，一点一点积累最后爆发出来。</p><p>因此，能否和朋友一起创业这个问题，需要辩证思考。如果朋友间相互了解对方的个性和能力，工作中能做到分工明确，用规章制度来规范双方的行为，及时解决小矛盾，相互照顾，一起分担，共同奋斗，那么创业成功就会成为大概率事件。</p><h2 id="合伙人应该与我互补还是相似？"><a href="#合伙人应该与我互补还是相似？" class="headerlink" title="合伙人应该与我互补还是相似？"></a>合伙人应该与我互补还是相似？</h2><p>一个较为合理的答案是：理念和价值观上要相似，能力和经验上要互补。</p><p>理念和价值观上的相近，可以保证你们在重大原则问题上的判断是比较一致的，不至于出现根本性的冲突。这些重大的原则问题包括企业的战略方向、利益分配机制、做事的基本底线等等。</p><p>在这些问题上出现不同意见，通常很难取得共识。因为个性和价值观的形成，通常都不是一朝一夕的事情，也就是我们常说的“江山易改，本性难移”。如果在创业的艰难环境下，双方还要来磨合这个层面的东西，就会非常痛苦。</p><p>能力和经验上的互补相对更好理解。你擅长产品，他专于研发；你有丰富的运营经验，他则对于商业模式的建立更有心得；你对数字不敏感，他则是投资和财务领域的资深人士。这些都是很好的互补。</p><p>互补可以让你们在具体事情的推进中事半功倍，并建立起对于对方在专业领域的依靠和信任。人不可能是全能的，如果一切未知的领域都需要你自己来摸索，费时费力不说，风险还很大。</p><p>对于相似还是互补这个问题的解读，还可以反向进行。比如你们是能力经验上的相近，而在理念上互补，你可以想象一下是个什么局面，一定是你不会的他也不会，你觉得对的他觉得不对，那就真的很难合作下去了。</p><h2 id="如何判断双方是否志同道合？"><a href="#如何判断双方是否志同道合？" class="headerlink" title="如何判断双方是否志同道合？"></a>如何判断双方是否志同道合？</h2><p>对于这个问题，不同的人可能会给出非常不同的答案。雷军就曾说过，他找人有两个要素：“一要最专业，小米的合伙人都是各管一块，这样能保证整个决策非常快，把业务交给他，要能实打实做出成绩来；二要最合适，主要是指要有创业心态，对所做的事要极度喜欢，有共同的愿景，这样就会有很强的驱动力。”</p><p>雷军说，他在三个月的时间里见了超过100位做硬件的人选，终于找到了负责硬件的联合创始人周光平博士，两人第一次见面就谈了12个小时。</p><p>而周鸿祎表示，他会选择具备这四种素质的合伙人：首先应该有创业精神；其次要有很强的学习能力；第三，要有很好的开放合作心态；此外，还要能自我激励，自我驱动，同样一件事，用打工的心态和用创业的心态做，效果完全不一样。</p><p>虽然答案因人而异，但仍然可以总结出一些判断标准，以下几条可为你选择合伙人时提供参考。</p><h3 id="1、关系有一定的深度和广度，彼此信任"><a href="#1、关系有一定的深度和广度，彼此信任" class="headerlink" title="1、关系有一定的深度和广度，彼此信任"></a>1、关系有一定的深度和广度，彼此信任</h3><p>共事且维持朋友关系多年的创业团队关系更深，有可能经受住紧张和冲突的考验。合伙人未必需要成为最要好的朋友，但如果他们相互喜欢的话事情可能会更好办些。更重要的是，创始人之间应该尊重彼此以及他们给团队带来的不同能力。不信任合伙人的能力会导致手伸过头，还可能会导致控制权之争。在这种窝里斗的情况下大部分的合作关系都无法维系。</p><h3 id="2、了解彼此的优势和劣势，分工明确"><a href="#2、了解彼此的优势和劣势，分工明确" class="headerlink" title="2、了解彼此的优势和劣势，分工明确"></a>2、了解彼此的优势和劣势，分工明确</h3><p>尊重彼此的技能和优势并不意味着创始人就不需要审视合伙人的弱点了。友谊更久自然也会更了解某人的特长和技能。这些不同的技能有助于创始人团队自然地分清责任、角色，在某些情况下还可以分清头衔。根据每一位合伙人的技能明确划分职责，对创业的帮助很大。做事的时候每个人要有独立的角色，但同时永远要对其他合伙人的反馈持开放态度。</p><h3 id="3、确保所有合伙人对成功和失败的定义一致"><a href="#3、确保所有合伙人对成功和失败的定义一致" class="headerlink" title="3、确保所有合伙人对成功和失败的定义一致"></a>3、确保所有合伙人对成功和失败的定义一致</h3><p>韧性最强的创始人不会从财务的角度去衡量自己的初创企业是否成功，相反，他们会从使命的角度去衡量。他们的初创企业只是追求实现使命的手段。但是，并不是所有的创始人都这么看，甚至一开始关注使命的创始人有时候到后面也会转向考虑财务方面的事情。</p><p>有的创始人可能志存高远，为了尽快做大愿意烧很多钱，而有的人希望逐步打磨产品，限制人数规模和保留现金尺度。不仅对成功的认知会影响运营决策，对失败的认知同样会起作用。</p><p>在创业过程中，其中一位合伙人急着退出的故事屡见不鲜，因此这个教训值得一提再提。对于拥有成功企业的创始人来说，避免在这个问题上发生冲突的关键是定期讨论这件事。应该在公司早期就设定好目标，并且对这个话题进行定期复议。</p><h3 id="4、所有合伙人均应对股权分配满意"><a href="#4、所有合伙人均应对股权分配满意" class="headerlink" title="4、所有合伙人均应对股权分配满意"></a>4、所有合伙人均应对股权分配满意</h3><p>哈佛教授Wasserman发现，73%的联合创业团队一般在公司成立30天内就确定了如何进行股权分配。股权分配当然是任何共同创业的人都要首先考虑的事情之一，但事实上在那个时候，没人知道谁干活最卖力，谁对初创企业的贡献最有价值。过早确定股权分配会导致后面发生问题。如果可以的话，最好等到你有机会了解大家一起工作会是什么个情况后再正式分蛋糕。话虽如此，这件事情还是不要拖太久，围绕股权的分歧最好在公司早期就解决掉。</p><h3 id="5、永远要相互支持"><a href="#5、永远要相互支持" class="headerlink" title="5、永远要相互支持"></a>5、永远要相互支持</h3><p>这话听上去似乎太空泛，但是合伙人的关系也可能会反复无常，尤其是在受到不同观点、董事会成员等的影响下。合伙人之间的相互支持可带来信心，确保合伙人和员工都有共同的使命感。</p><p>团队应该早点理解一件事，任何情况下合伙人之间都应该背靠背相互支持，所以合伙人要尽量避免当着员工、董事会等人的面互相拆台，这样能够让公司其他人感觉到他们友情之牢固，让每一位合伙人都能保持镇定，因为他们知道对方一定会支持自己的。</p><h2 id="如何应对常见的分歧？"><a href="#如何应对常见的分歧？" class="headerlink" title="如何应对常见的分歧？"></a>如何应对常见的分歧？</h2><h3 id="1、公司走向的歧见"><a href="#1、公司走向的歧见" class="headerlink" title="1、公司走向的歧见"></a>1、公司走向的歧见</h3><p>在0到1的探索期，公司的走向往往是由合伙人一起决定的。但进入1到100的扩张期，一个年轻企业通常会开始有董事会以及重要的供应、通路伙伴。久而久之，合伙人对于公司未来走向的看法，常常会越来越变得分歧。</p><p>防范这个陷阱要从根源开始：每当CEO有了新的资讯、成长、学习、领悟，应该积极地与合伙人分享，协助他们获得与你类似的成长。同时，你应该把小范围的决策授权出去，让他们也能继续主导公司某一部分的走向。最后，你应该积极管理大家对决策的期望值，新创公司必须在“快”与“好”之间做出平衡，因此决策求的是多数对，而不是样样对。</p><h3 id="2、无法适应制度"><a href="#2、无法适应制度" class="headerlink" title="2、无法适应制度"></a>2、无法适应制度</h3><p>0到1的新创团队求快，因此不会有太多制度。进入1到100阶段，公司势必要开始建立一些管理系统，以在风险与发展中间取得平衡。</p><p>有些习惯了说干就干的合伙人，在此时会产生严重的不适应，时间一长甚至会觉得公司背离了创办的初衷。要解决这个问题，除了及早发现及早辅导外，请他们参与、主导制度的设计，也是协助合伙人适应新制度的方法。</p><h3 id="3、越权管理"><a href="#3、越权管理" class="headerlink" title="3、越权管理"></a>3、越权管理</h3><p>当公司开始有部门、部门主管，合伙人还是习惯看不顺眼就管，容易造成经理人的困扰。更有甚者，造成合伙人对经理人不信任，反而让经理人没有足够的时间、空间去适应、学习。这个问题通常是惯性使然，重点就是要打破它。所以，看到这样的行为要赶快提醒伙伴们注意。</p><h3 id="4、无法跟上公司成长的需要"><a href="#4、无法跟上公司成长的需要" class="headerlink" title="4、无法跟上公司成长的需要"></a>4、无法跟上公司成长的需要</h3><p>在公司快速扩张期，一个3人产品团队可能在一年内成长为30人，而两者之间管理上的不同，常常会让本来擅长技术、产品，但从来没有管理中大型团队经验的合伙人一时间跟不上公司发展的步伐。</p><p>回到扩张前，你应该早早找到好的CTO Mentor，在扩张中，经常鼓励他在管理知识与能力上精进。扩张后，如果他真的无法适应，也比较能够接受去寻找更有经验的CTO，而自己退居部门二把手、三把手。</p><h3 id="5、利益分配"><a href="#5、利益分配" class="headerlink" title="5、利益分配"></a>5、利益分配</h3><p>当公司越来越成功、越赚钱、离IPO越近，股权与利益的问题就会越容易产生。尤其当初的股权分配如果没有彰显每个合伙人的相对价值，那团队中可能酝酿出不良情绪。</p><p>比较好的方法当然是早期就把这个问题解决掉，因为到了后期，你的工具会越来越有限。但也不是没有机会修正，如果有合伙人离开，你可以收回他的股权来重新分配。如果有B、C、D轮增资，你可以跟投资人要求“期权池”(ESOP)，通过发放新的选择权来平衡。最后，如果真的过于集中，负责任的CEO，甚至会拿出自己的股权分配给伙伴们。</p><p>选择合伙人未必有一定之规，创业路上可能遇到的危机也远远不止上述这些，希望这篇文章能对你有所裨益，助你在创业路上少走弯路，也祝愿创业者们在2018年博得好彩头，大鹏一日同风起，扶摇直上九万里。</p><p>本文来源：<a href="http://www.sohu.com/a/225670991_100064845" target="_blank" rel="noopener">联想之星</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="life" scheme="http://yoursite.com/categories/life/"/>
    
    
  </entry>
  
  <entry>
    <title>从零搭建博客 教程 Hexo GitHub</title>
    <link href="http://yoursite.com/2018/03/22/hexo-github/"/>
    <id>http://yoursite.com/2018/03/22/hexo-github/</id>
    <published>2018-03-22T11:33:10.000Z</published>
    <updated>2019-07-07T04:27:53.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>快速、简洁且高效的博客框架</p><a id="more"></a><h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><ul><li>1.在GitHub创建个人仓库「名字必须是user.github.io」</li><li>2.本地安装Git（此处省略，文章底部有教程链接）</li><li>3.本地安装Node.js（此处省略，文章底部有教程链接）</li><li>4.本地安装Hexo</li><li>5.网站推送至github</li><li>6.github绑定域名</li><li>7.更换主题</li><li>8.Hexo高级个性化设置</li></ul><h1 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h1><ul><li>1.Hexo文章的开头</li><li>2.Hexo文章的内容</li><li>2.1MarkDown语法</li><li>2.2寻找图床</li></ul><h2 id="1-搭建博客"><a href="#1-搭建博客" class="headerlink" title="1.搭建博客"></a>1.搭建博客</h2><h3 id="1-1-本地安装Hexo"><a href="#1-1-本地安装Hexo" class="headerlink" title="1.1.本地安装Hexo"></a>1.1.本地安装Hexo</h3><p>下载安装Git与Node.js略过</p><h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h4><p><code>npm install hexo -g #-g表示全局安装, npm默认为当前项目安装</code></p><h4 id="2-Hexo基本命令"><a href="#2-Hexo基本命令" class="headerlink" title="2.Hexo基本命令:"></a>2.Hexo基本命令:</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo -g  #升级 </span><br><span class="line">hexo init &lt;folder&gt;  #执行init命令初始化hexo到你指定的目录</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo generate       #自动根据当前目录下文件,生成静态网页 hexo g</span><br><span class="line">hexo server         #运行本地服务 hexo s</span><br><span class="line">hexo clean          #清理</span><br><span class="line">hexo deploy         #部署 hexo d</span><br><span class="line"></span><br><span class="line">hexo server         #Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s      #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br></pre></td></tr></table></figure><p>最常用的是</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这个时候hexo s之后就可以在浏览器<br><code>http://localhost:4000/</code><br>这里看到hexo博客的基本样子了</p><h3 id="1-2-将网站推送至github"><a href="#1-2-将网站推送至github" class="headerlink" title="1.2.将网站推送至github"></a>1.2.将网站推送至github</h3><h4 id="1-首先在本地告诉退给谁"><a href="#1-首先在本地告诉退给谁" class="headerlink" title="1.首先在本地告诉退给谁"></a>1.首先在本地告诉退给谁</h4><p>打开本地博客本目录下的配置文件_config.yml<br>修改最后一行的配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/dongshuyan/dongshuyan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="2-上传github"><a href="#2-上传github" class="headerlink" title="2.上传github"></a>2.上传github</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>若执行hexo g出错则执行<br><code>npm install hexo --save</code><br>若执行hexo d出错则执行<br><code>npm install hexo-deployer-git --save</code><br>错误修正后再次执行hexo g和hexo d上传到服务器。<br>若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username for &apos;https://github.com&apos;:</span><br><span class="line">password for &apos;https://github.com&apos;:</span><br></pre></td></tr></table></figure><p>输入你的github账号密码即可。<br>hexo d执行成功后便可通过<a href="https://xxx.github.io访问博客，看到的内容和http://localhost:4000相同。" target="_blank" rel="noopener">https://xxx.github.io访问博客，看到的内容和http://localhost:4000相同。</a></p><h4 id="3-记住github密码"><a href="#3-记住github密码" class="headerlink" title="3.记住github密码"></a>3.记住github密码</h4><p>在github添加ssh key后不需要每次更新博客再输入用户名和密码。首先检查本地是否包含ssh keys。如果存在则直接将ssh key添加到GitHub之中，否则新生成ssh key。</p><p>执行下述命令生成新的ssh key</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@exampl&quot;</span><br></pre></td></tr></table></figure><p>这里需要将<br><code>your_email@example.com</code><br>改成自己注册的GitHub邮箱地址。默认会在~/.ssh/id_rsa.pub中生成id_rsa和id_rsa.pub文件。</p><p>Mac下利用open ~/.ssh打开文件夹，打开id_rsa.pub文件，里面的信息即为ssh key，将此信息复制到GitHub的Add ssh key路径GitHub-&gt;Setting-&gt;SSH keys-&gt;add SSH key中即可。Title里填写任意标题，将复制的内容粘贴到key中，点击Add key完成添加即可记住密码。</p><p>此时本地博客内容便已关联到GitHub之中，本地博客改变之后，通过hexo g和hexo d便可更新到GitHub之中。</p><h3 id="1-3-github绑定域名"><a href="#1-3-github绑定域名" class="headerlink" title="1.3.github绑定域名"></a>1.3.github绑定域名</h3><p>如果你有自己的域名了<br>那么可以把博客与域名关联起来<br>这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析：<br><img src="https://mubu.com/document_image/a949feea-b9d8-4b58-aa3e-b1bca87ebabc-3316715.jpg" alt><br>然后再你本地博客文件夹下的source文件夹里添加一个文件，文件名为”CNAME”，内容为你的域名。<br>例如：<br>baidu.com<br>这里要求一个字符不差。</p><h3 id="1-4-更改主题（以Yilia为例）"><a href="#1-4-更改主题（以Yilia为例）" class="headerlink" title="1.4.更改主题（以Yilia为例）"></a>1.4.更改主题（以Yilia为例）</h3><p>安装yilia<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br>配置<br>修改hexo根目录下的 _config.yml ： theme: yilia</p><p>更新</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/yilia</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="1-5-Hexo-高级配置"><a href="#1-5-Hexo-高级配置" class="headerlink" title="1.5.Hexo 高级配置"></a>1.5.Hexo 高级配置</h3><p>详见<br>Hexo Yilia 高级配置大全</p><h2 id="2-编写博客"><a href="#2-编写博客" class="headerlink" title="2.编写博客"></a>2.编写博客</h2><h3 id="2-1-Hexo文章的开头"><a href="#2-1-Hexo文章的开头" class="headerlink" title="2.1.Hexo文章的开头"></a>2.1.Hexo文章的开头</h3><p>举例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: 从零搭建博客 教程 Hexo GitHub    #文章标题</span><br><span class="line">subtitle:                            #子标题</span><br><span class="line">#categories: 文章                     #文章分類目錄 可以省略    </span><br><span class="line">toc: true                            #目录 需要安装插件或者主题自带</span><br><span class="line">reward: true                         #打赏 需要安装插件或者主题自带</span><br><span class="line">declare: true                        #版权 需要安装插件或者主题自带</span><br><span class="line">date:                                #文章日期 2019/7/1</span><br><span class="line">header-img:                          #顶部背景图片</span><br><span class="line">tags:                                #标签</span><br><span class="line">- 自学</span><br><span class="line">- Blog</span><br><span class="line">- Original</span><br></pre></td></tr></table></figure><h4 id="2-2-Hexo文章的内容"><a href="#2-2-Hexo文章的内容" class="headerlink" title="2.2.Hexo文章的内容"></a>2.2.Hexo文章的内容</h4><h5 id="2-2-1markdown常用语法"><a href="#2-2-1markdown常用语法" class="headerlink" title="2.2.1markdown常用语法"></a>2.2.1<a href="https://www.policx.com/post/markdown/" target="_blank" rel="noopener">markdown常用语法</a></h5><p><a href="http://dongshuyan.com/2016/04/07/%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速、简洁且高效的博客框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 的设计哲学</title>
    <link href="http://yoursite.com/2018/03/22/markdown/"/>
    <id>http://yoursite.com/2018/03/22/markdown/</id>
    <published>2018-03-22T11:32:01.000Z</published>
    <updated>2019-07-07T04:34:16.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 </p><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown<em>是什么</em>？</h4><h4 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a><em>谁</em>创造了它？</h4><h4 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><em>为什么</em>要使用它？</h4><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a><em>怎么</em>使用？</h4><h4 id="谁在用？"><a href="#谁在用？" class="headerlink" title="谁在用？"></a><em>谁</em>在用？</h4><h4 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h4></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    </p><h3 id="2-谁创造了它？"><a href="#2-谁创造了它？" class="headerlink" title="2. 谁创造了它？"></a>2. <em>谁</em>创造了它？</h3><p>它由<a href="http://www.aaronsw.com/" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于（<em>2013年1月11日</em>）自杀,有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。    </p><p>他有着足以让你跪拜的人生经历：    </p><ul><li><strong>14岁</strong>参与RSS 1.0规格标准的制订。     </li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。   </li><li><strong>2005</strong>年创建<a href="http://infogami.org/" target="_blank" rel="noopener">Infogami</a>，之后与<a href="http://www.reddit.com/" target="_blank" rel="noopener">Reddit</a>合并成为其合伙人。   </li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   </li><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     </li><li><strong>2013</strong>年1月自杀身亡。    </li></ul><p><img src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p><p>天才都有早逝的归途。</p><h3 id="3-为什么要使用它？"><a href="#3-为什么要使用它？" class="headerlink" title="3. 为什么要使用它？"></a>3. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p><blockquote><p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p><h4 id="4-10-反斜杠"><a href="#4-10-反斜杠" class="headerlink" title="4.10 反斜杠\"></a>4.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h4 id="4-11-符号’-’"><a href="#4-11-符号’-’" class="headerlink" title="4.11 符号’`’"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code>    </p></blockquote><h4 id="5-谁在用？"><a href="#5-谁在用？" class="headerlink" title="5. 谁在用？"></a>5. <em>谁</em>在用？</h4><p>Markdown的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h4 id="6-尝试一下"><a href="#6-尝试一下" class="headerlink" title="6. 尝试一下"></a>6. 尝试一下</h4><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的dillinger.io评价也不错   </li><li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。    </li><li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的ReText不错。    </li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化 :)。</strong></p><hr><p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]<br>(<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/" target="_blank" rel="noopener">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/</a> )。</p><hr><p>以上基本是所有traditonal markdown的语法。</p><h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p><p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p><table><thead><tr><th align="center">代码库</th><th>链接</th></tr></thead><tbody><tr><td align="center">MarkDown</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr><tr><td align="center">MarkDownCopy</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr></tbody></table><hr><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p><video src="http://structr.learn-anything.cn/video/道理/陈铭：像我这种老好人，根本没什么真朋友！不jue亲戚的人，根本没什么真亲戚！.mp4" width="320" height="180" controls="controls"></video> </p><p>关于其它扩展语法可参见具体工具的使用说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>数据类型和变量</title>
    <link href="http://yoursite.com/2018/03/01/python-type/"/>
    <id>http://yoursite.com/2018/03/01/python-type/</id>
    <published>2018-02-28T20:28:19.000Z</published>
    <updated>2019-07-07T04:35:56.433Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Python 数据类型和变量</p><a id="more"></a> <h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><p>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识，比如：</p><p><code>&#39;I\&#39;m \&quot;OK\&quot;!&#39;</code><br>表示的字符串内容是：</p><p><code>I&#39;m &quot;OK&quot;!</code><br>转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m ok.&apos;)</span><br><span class="line">I&apos;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m learning\nPython.&apos;)</span><br><span class="line">I&apos;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&apos;\\\n\\&apos;)</span><br><span class="line"></span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义，可以自己试试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容，可以自己试试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt - python                           _ □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; print(&apos;&apos;&apos;line1                                      │</span><br><span class="line">│... line2                                               │</span><br><span class="line">│... line3&apos;&apos;&apos;)                                           │</span><br><span class="line">│line1                                                   │</span><br><span class="line">│line2                                                   │</span><br><span class="line">│line3                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│&gt;&gt;&gt; _                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>当输入完结束符<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果写成程序并存为.py文件，就是：</span><br></pre></td></tr></table></figure></p><p>print(‘’’line1<br>line2<br>line3’’’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多行字符串&apos;&apos;&apos;...&apos;&apos;&apos;还可以在前面加上r使用，请自行测试：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>print(r’’’hello,\n<br>world’’’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">### 布尔值</span><br><span class="line">布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True<br>True<br>False<br>False<br>3 &gt; 2<br>True<br>3 &gt; 5<br>False</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">布尔值可以用and、or和not运算。</span><br><span class="line"></span><br><span class="line">#### and运算是与运算，只有所有都为True，and运算结果才是True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True and True<br>True<br>True and False<br>False<br>False and False<br>False<br>5 &gt; 3 and 3 &gt; 1<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### or运算是或运算，只要其中有一个为True，or运算结果就是True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True or True<br>True<br>True or False<br>True<br>False or False<br>False<br>5 &gt; 3 or 1 &gt; 3<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>not True<br>False<br>not False<br>True<br>not 1 &gt; 2<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">布尔值经常用在条件判断中，比如：</span><br></pre></td></tr></table></figure><p>if age &gt;= 18:<br>    print(‘adult’)<br>else:<br>    print(‘teenager’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">### 空值</span><br><span class="line">空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</span><br><span class="line"></span><br><span class="line">此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</span><br><span class="line"></span><br><span class="line">### 变量</span><br><span class="line">变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</span><br><span class="line"></span><br><span class="line">变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</span><br><span class="line"></span><br><span class="line">`a = 1`</span><br><span class="line">变量a是一个整数。</span><br><span class="line"></span><br><span class="line">`t_007 = &apos;T007&apos;`</span><br><span class="line">变量t_007是一个字符串。</span><br><span class="line"></span><br><span class="line">`Answer = True`</span><br><span class="line">变量Answer是一个布尔值True。</span><br><span class="line"></span><br><span class="line">在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>a = 123 # a是整数<br>print(a)<br>a = ‘ABC’ # a变为字符串<br>print(a)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</span><br></pre></td></tr></table></figure><p>int a = 123; // a是整数类型变量<br>a = “ABC”; // 错误：不能把字符串赋给整型变量</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">和静态语言相比，动态语言更灵活，就是这个原因。</span><br><span class="line"></span><br><span class="line">请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</span><br></pre></td></tr></table></figure><p>x = 10<br>x = x + 2</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</span><br><span class="line"></span><br><span class="line">最后，理解变量在计算机内存中的表示也非常重要。当我们写：</span><br><span class="line"></span><br><span class="line">`a = &apos;ABC&apos;`</span><br><span class="line">时，Python解释器干了两件事情：</span><br><span class="line"></span><br><span class="line">在内存中创建了一个&apos;ABC&apos;的字符串；</span><br><span class="line"></span><br><span class="line">在内存中创建了一个名为a的变量，并把它指向&apos;ABC&apos;。</span><br><span class="line"></span><br><span class="line">也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>a = ‘ABC’<br>b = a<br>a = ‘XYZ’<br>print(b)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">最后一行打印出变量b的内容到底是&apos;ABC&apos;呢还是&apos;XYZ&apos;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&apos;XYZ&apos;，但实际上b的值是&apos;ABC&apos;，让我们一行一行地执行代码，就可以看到到底发生了什么事：</span><br><span class="line"></span><br><span class="line">执行a = &apos;ABC&apos;，解释器创建了字符串&apos;ABC&apos;和变量a，并把a指向&apos;ABC&apos;：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923791878255456/0)</span><br><span class="line"></span><br><span class="line">执行b = a，解释器创建了变量b，并把b指向a指向的字符串&apos;ABC&apos;：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923792058613440/0)</span><br><span class="line"></span><br><span class="line">执行a = &apos;XYZ&apos;，解释器创建了字符串&apos;XYZ&apos;，并把a的指向改为&apos;XYZ&apos;，但b并没有更改：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923792191637760/0)</span><br><span class="line"></span><br><span class="line">所以，最后打印变量b的结果自然是&apos;ABC&apos;了。</span><br><span class="line"></span><br><span class="line">### 常量</span><br><span class="line">所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</span><br><span class="line"></span><br><span class="line">`PI = 3.14159265359`</span><br><span class="line">但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</span><br><span class="line"></span><br><span class="line">最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 / 3<br>3.3333333333333335</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>9 / 3<br>3.0</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 // 3<br>3</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</span><br><span class="line"></span><br><span class="line">因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 % 3<br>1</p><pre><code>无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</code></pre></blockquote></blockquote></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p><p>对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。<br>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 数据类型和变量&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>字典、列表、数组和字符串</title>
    <link href="http://yoursite.com/2018/02/16/python/"/>
    <id>http://yoursite.com/2018/02/16/python/</id>
    <published>2018-02-16T04:28:24.000Z</published>
    <updated>2019-07-07T04:36:14.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Python 字典、列表、数组和字符串</p><a id="more"></a><p>字典</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">dict_1 = &#123;<span class="hljs-string">'1'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'2'</span>: <span class="hljs-string">'b'</span>, <span class="hljs-string">'3'</span>: <span class="hljs-string">'c'</span>&#125;</span><br><span class="line">print(dict_1)  <span class="hljs-comment"># 打印字典</span></span><br><span class="line">print(type(dict_1))  <span class="hljs-comment"># 打印新赋值的字典的类型</span></span><br><span class="line">print(str(dict_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把字典转化成字符串后打印</span></span><br><span class="line">print(tuple(dict_1), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把字典转化为元组后打印</span></span><br><span class="line">print(list(dict_1), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把字典转化为列表后打印</span></span><br></pre></td></tr></table></figure><p>元组</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">tuple_1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">print(tuple_1)  <span class="hljs-comment"># 打印元组</span></span><br><span class="line">print(type(tuple_1))  <span class="hljs-comment"># 打印新赋值的元祖的类型</span></span><br><span class="line">print(str(tuple_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把元组转化成字符串后打印</span></span><br><span class="line">print(list(tuple_1), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把元组转化为列表后打印</span></span><br></pre></td></tr></table></figure><h3 id="元组不可转化为字典"><a href="#元组不可转化为字典" class="headerlink" title="元组不可转化为字典"></a>元组不可转化为字典</h3><p>列表</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">list_1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</span><br><span class="line">print(list_1)  <span class="hljs-comment"># 打印列表</span></span><br><span class="line">print(type(list_1))  <span class="hljs-comment"># 打印新赋值的列表的类型</span></span><br><span class="line">print(str(list_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把列表转化成字符串后打印</span></span><br><span class="line">print(tuple(list_1), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把列表转化为元组后打印</span></span><br></pre></td></tr></table></figure><h3 id="元组不可转化为字典-1"><a href="#元组不可转化为字典-1" class="headerlink" title="元组不可转化为字典"></a>元组不可转化为字典</h3><p>字符串</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">string_1 = <span class="hljs-string">'(1, 2, 3, 4, 5)'</span></span><br><span class="line">print(string_1)  <span class="hljs-comment"># 打印字符串</span></span><br><span class="line">print(type(string_1))  <span class="hljs-comment"># 打印新赋值的字符串</span></span><br><span class="line">print(tuple(eval(string_1)), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把字符串转化成元组后输出</span></span><br><span class="line">print(list(eval(string_1)), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把字符串转化成列表后输出</span></span><br></pre></td></tr></table></figure><h3 id="只有特殊字符串才能转化为字典"><a href="#只有特殊字符串才能转化为字典" class="headerlink" title="只有特殊字符串才能转化为字典"></a>只有特殊字符串才能转化为字典</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string_2 = <span class="hljs-string">'&#123;"name":"tom","age":6&#125;'</span></span><br><span class="line">print(string_2)  <span class="hljs-comment"># 打印新赋值的字符串</span></span><br><span class="line">print(type(string_2))  <span class="hljs-comment"># 打印新赋值的字符串的类型</span></span><br><span class="line">print(dict(eval(string_2)), end=<span class="hljs-string">'字典\n'</span>)  <span class="hljs-comment"># 把字符串转化为字典后打印</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 字典、列表、数组和字符串&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>大话Socket</title>
    <link href="http://yoursite.com/2018/02/06/socket/"/>
    <id>http://yoursite.com/2018/02/06/socket/</id>
    <published>2018-02-06T10:30:55.000Z</published>
    <updated>2019-07-07T04:39:01.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>要了解Socket首先要了解 TCP，他们两个的关系可以说是：</p><p>Socket 是抽象出来的使用 TCP/UDP 的概念模型，屏蔽掉了晦涩的底层协议的实现，是一个接口。</p><a id="more"></a><p>最近看到了一张如此详细的 TCP 三次握手和四次挥手，打印一张放工位！摘自《图解网络硬件》249页 图5-11 《TCP的三次握手》<br><img src="https://camo.githubusercontent.com/23dfbddfdd1d08dfda64dc13436030d947ebd62b/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a7731663275646676363638706a32306d30306e6d343463" alt><br><img src="https://camo.githubusercontent.com/dc8cf3d1737ae2148250573fae94d2eea4eaba3d/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f36356534663165366a773166377532786a6f6361746a32306a383064627134362e6a7067" alt><br>所谓的X、X+1、Y、Y+1<br>对应于你收到了没、我收到了、你收到’我收到’没、我收到了不用回了,为什么用+1表示呢？那是因为前两个指的是一个人，后两个指的是一个人。<br>四组是三个连接，每个连接的序号依次是X、Y、Z。</p><p>TCP的连接过程就像两个人的对话：</p><p>想象一下，每次这俩儿人聊天，都要像下面这样一来一回三次，接下来他们才能【好好聊天了。。。】真是有点“作”。。。</p><p>我是客户端，树懒是服务端，演示三次握手、数据传输步骤<br><img src="https://camo.githubusercontent.com/83074c55d42ddfa4775100aed25d906410581346/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a77316632756467393761796d6a32306d38316d636b316c" alt><br>其实有个问题，为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>而这一设计，主要是因为“服务器不是你想关就能关”。。。</p><p>比如说两个热恋中的人正在QQ上发送一个传mp4格式的文件，</p><p>A说，我要下QQ了，</p><p>B说：我知道了，你下吧。</p><p>A说，那我关了，（想关）</p><p>但是当A尝试关闭QQ的时候，QQ弹窗说“正在传输文件，传输完成后自动关闭QQ？”</p><p>这时候A对B说，呀，正在传东西，等传完了，我就关吧。（不能关）</p><p>B说：行。既然关不掉，不行再聊会儿呗？</p><p>A：聊吧。。。传完了啊，下了啊（传输结束了–能关）</p><p>B：下吧。我也下了。。。</p><p>就是多了一个Finish报文。</p><p>或者简单点表示是这样的：<br><img src="https://camo.githubusercontent.com/770f483cf985366a20e6dafde1e355bc691f2041/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a77316632756a7067346235716a32307969317063716470" alt><br>图片演示了四次挥手，与三次握手相比，只多了一个被动方确认自身任务Finish的动作。<br><img src="https://camo.githubusercontent.com/101010aedc39b107a8615e6c26281e2e848dbbb1/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f36356534663165366a773166377532786a73676e386a32306a3630646b7461682e6a7067" alt><br>总结下相关的函数：</p><p>创建套接字</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket(af,type,protocol)</span><br></pre></td></tr></table></figure><p>建立地址和套接字的联系</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(sockid, local addr, addrlen)</span><br></pre></td></tr></table></figure><p>服务器端侦听客户端的请求</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen( Sockid ,quenlen)</span><br></pre></td></tr></table></figure><p>建立服务器/客户端的连接 (面向连接TCP）</p><p>客户端请求连接</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connect(sockid, destaddr, addrlen)</span><br></pre></td></tr></table></figure><p>服务器端等待从编号为Sockid的Socket上接收客户连接请求</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newsockid=accept(Sockid，Clientaddr, paddrlen)</span><br></pre></td></tr></table></figure><p>发送/接收数据</p><p>面向连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send(sockid, buff, bufflen) </span><br><span class="line">recv( )</span><br></pre></td></tr></table></figure><p>面向无连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendto(sockid,buff,…,addrlen) </span><br><span class="line">recvfrom( )</span><br></pre></td></tr></table></figure><p>释放套接字</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(sockid)</span><br></pre></td></tr></table></figure><p>至于为什么是三次握手，而不是二次握手，还有四次握手，可以看看下面的类比：</p><table><thead><tr><th>三次握手</th><th>二次握手</th><th>四次握手</th></tr></thead><tbody><tr><td><img src="https://camo.githubusercontent.com/9bf301327a629211d40aadd6e8ec65c80e242511/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f36356534663165366a77316637753536776678687a6a32307969317063337a762e6a7067" alt></td><td><img src="https://camo.githubusercontent.com/a6d5cce9b79a51f18b7c2f14b149f5416c1d5e3a/687474703a2f2f7777332e73696e61696d672e636e2f6c617267652f36356534663165366a7731663775347a6433306e706a323079693170637161642e6a7067" alt></td><td><img src="https://camo.githubusercontent.com/8f98f53f7acc4a9a8954c11b885a58f7a0d71a90/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36356534663165366a7731663775347861736d61306a323079693170636163622e6a7067" alt></td></tr></tbody></table><p>参考：<a href="http://zhihu.com/question/24853633/answer/114872771" target="_blank" rel="noopener">知乎</a></p><p>三次握手的对话，也挺像这个的，哈哈：</p><ul><li>A: How are you?</li><li>B: I’m fine, thanks,and you?</li><li>A: I’m fine too.</li></ul><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要了解Socket首先要了解 TCP，他们两个的关系可以说是：&lt;/p&gt;
&lt;p&gt;Socket 是抽象出来的使用 TCP/UDP 的概念模型，屏蔽掉了晦涩的底层协议的实现，是一个接口。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码汇总</title>
    <link href="http://yoursite.com/2018/02/06/http/"/>
    <id>http://yoursite.com/2018/02/06/http/</id>
    <published>2018-02-06T08:32:20.000Z</published>
    <updated>2019-07-07T04:28:01.616Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>HTTP状态码</p><a id="more"></a><p><strong>HTTP状态码</strong>（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。</p><p>HTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。</p><p>微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。</p><!-- more --><table><thead><tr><th>编号</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>1️⃣❌❌</td><td>🔴🔴🔴</td><td>1xx消息 <p></p> 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</td></tr><tr><td>100</td><td>Continue</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>2️⃣❌❌</td><td>🔴🔴🔴</td><td>2xx成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td></tr><tr><td>200</td><td>OK</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<p></p>    如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<p></p>    由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<p></p>    与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>Partial Content</td><td>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<p></p>    该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。<p></p>    响应必须包含如下的头部域：<p></p>        Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<p></p>        Date ETag和／或Content-Location，假如同样的请求本应该返回200响应。<p></p>        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<p></p>    假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<p></p>    假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<p></p>    任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>3️⃣❌❌</td><td>🔴🔴🔴</td><td>3xx重定向 <p></p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。<p></p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</td></tr><tr><td>300</td><td>Multiple Choices</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<p></p>    除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<p></p>    如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<p></p>    新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<p></p>    注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</td></tr><tr><td>302</td><td>Found</td><td>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<p></p>    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<p></p>    注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>See Other</td><td>对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<p></p>    新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>Not Modified</td><td>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<p></p>    该响应必须包含以下的头信息：<p></p>        Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<p></p>        ETag和／或Content-Location，假如同样的请求本应返回200响应。<p></p>        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<p></p>    假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<p></p>    假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<p></p>    假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。<p></p>    注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>Switch Proxy</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<p></p>    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。<p></p>    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>4️⃣❌❌</td><td>🔴🔴🔴</td><td>4xx客户端错误<p></p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<p></p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</td></tr><tr><td>400</td><td>Bad Request</td><td>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>Payment Required</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<p></p>    鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<p></p>    除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<p></p>    冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>Gone</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<p></p>    410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<p></p>    如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>Request-URI Too Long</td><td>请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<p></p>        本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<p></p>        重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<p></p>        客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。<p></p>    假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</td></tr><tr><td>418</td><td>I’m a teapot</td><td>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。</td></tr><tr><td>421</td><td>There are too many connections from your internet address</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td></tr><tr><td>423</td><td>Locked</td><td>当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>Failed Dependency</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>Unordered Collection</td><td>在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>Upgrade Required</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>Retry With</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>5️⃣❌❌</td><td>🔴🔴🔴</td><td>5xx服务器错误 <p></p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。<p></p>这些状态码适用于任何响应方法。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。    注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。</td></tr></tbody></table><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP状态码&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端网络请求优化之 IP 测速排序方案</title>
    <link href="http://yoursite.com/2018/02/06/ip/"/>
    <id>http://yoursite.com/2018/02/06/ip/</id>
    <published>2018-02-06T08:17:03.000Z</published>
    <updated>2019-07-07T04:22:57.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>IP 测速排序方案</p><a id="more"></a><h2 id="1-IP-测速排序方案的目的"><a href="#1-IP-测速排序方案的目的" class="headerlink" title="1. IP 测速排序方案的目的"></a>1. IP 测速排序方案的目的</h2><p>无论是从 Local DNS 解析域名，获取到 IP 列表，还是从第三方的 DNS 解析服务中，获取到域名对应的 IP 列表。我们获得多个 IP 后，总是想选取一个最优的 IP 使用，本文主要探讨如何在客户端探测 IP 的连接性以及连接速度，保证返回可用性最好的IP，以达到“IP优选”的目的。</p><h2 id="2-新浪开源的-httpdns-的-sdk-里的测速逻辑"><a href="#2-新浪开源的-httpdns-的-sdk-里的测速逻辑" class="headerlink" title="2. 新浪开源的 httpdns 的 sdk 里的测速逻辑"></a>2. 新浪开源的 httpdns 的 sdk 里的测速逻辑</h2><p>新浪开源一个 HTTPDNSLib ，里面包含了测速逻辑，GitHub地址如下：</p><ul><li><a href="https://github.com/CNSRE/HTTPDNSLib-for-iOS" target="_blank" rel="noopener">《HTTPDNSLib-for-iOS》</a></li><li><a href="https://github.com/CNSRE/HTTPDNSLib" target="_blank" rel="noopener">《HTTPDNSLib》</a></li></ul><h2 id="3-IP-测试实现原理"><a href="#3-IP-测试实现原理" class="headerlink" title="3. IP 测试实现原理"></a>3. IP 测试实现原理</h2><p>使用 linux socket connect 和 select 函数实现的。 基于以下原理：</p><ol><li>即使套接口是非阻塞的。如果连接的服务器在同一台主机上，那么在调用connect 建立连接时，连接通常会立即建立成功，我们必须处理这种情况。</li><li>源自Berkeley的实现(和Posix.1g)有两条与select 和非阻塞IO相关的规则：<br>A. 当连接建立成功时，套接口描述符变成可写；<br>B. 当连接出错时，套接口描述符变成既可读又可写。</li></ol><p>详细的测速实现如下，原理参考注释：</p><p>以 iOS 实现为例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//#define CYL_SOCKET_CONNECT_TIMEOUT 10 //单位秒</span><br><span class="line">//#define CYL_SOCKET_CONNECT_TIMEOUT_RTT 600000//10分钟 单位毫秒</span><br><span class="line"></span><br><span class="line">- (int)testSpeedOf:(NSString *)ip port:(int16_t)port &#123;</span><br><span class="line">   NSString *oldIp = ip;</span><br><span class="line">   //request time out</span><br><span class="line">   float rtt = 0.0;</span><br><span class="line">   //sock：将要被设置或者获取选项的套接字。</span><br><span class="line">   int s = 0;</span><br><span class="line">   struct sockaddr_in saddr;</span><br><span class="line">   saddr.sin_family = AF_INET;</span><br><span class="line">   // MARK: - 设置端口，这里需要根据需要自定义，默认是80端口。</span><br><span class="line">   saddr.sin_port = htons(port);</span><br><span class="line">   saddr.sin_addr.s_addr = inet_addr([ip UTF8String]);</span><br><span class="line">   //saddr.sin_addr.s_addr = inet_addr(&quot;1.1.1.123&quot;);</span><br><span class="line">   if( (s=socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, create socket failed.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   NSDate *startTime = [NSDate date];</span><br><span class="line">   NSDate *endTime;</span><br><span class="line">   //为了设置connect超时 把socket设置称为非阻塞</span><br><span class="line">   int flags = fcntl(s, F_GETFL,0);</span><br><span class="line">   fcntl(s,F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">   //对于阻塞式套接字，调用connect函数将激发TCP的三次握手过程，而且仅在连接建立成功或者出错时才返回；</span><br><span class="line">   //对于非阻塞式套接字，如果调用connect函数会之间返回-1（表示出错），且错误为EINPROGRESS，表示连接建立，建立启动但是尚未完成；</span><br><span class="line">   //如果返回0，则表示连接已经建立，这通常是在服务器和客户在同一台主机上时发生。</span><br><span class="line">   int i = connect(s,(struct sockaddr*)&amp;saddr, sizeof(saddr));</span><br><span class="line">   if(i == 0) &#123;</span><br><span class="line">       //建立连接成功，返回rtt时间。 因为connect是非阻塞，所以这个时间就是一个函数执行的时间，毫秒级，没必要再测速了。</span><br><span class="line">       close(s);</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   struct timeval tv;</span><br><span class="line">   int valopt;</span><br><span class="line">   socklen_t lon;</span><br><span class="line">   tv.tv_sec = CYL_SOCKET_CONNECT_TIMEOUT;</span><br><span class="line">   tv.tv_usec = 0;</span><br><span class="line">   </span><br><span class="line">   fd_set myset;</span><br><span class="line">   FD_ZERO(&amp;myset);</span><br><span class="line">   FD_SET(s, &amp;myset);</span><br><span class="line">   </span><br><span class="line">   // MARK: - 使用select函数，对套接字的IO操作设置超时。</span><br><span class="line">   /**</span><br><span class="line">    select函数</span><br><span class="line">    select是一种IO多路复用机制，它允许进程指示内核等待多个事件的任何一个发生，并且在有一个或者多个事件发生或者经历一段指定的时间后才唤醒它。</span><br><span class="line">    connect本身并不具有设置超时功能，如果想对套接字的IO操作设置超时，可使用select函数。</span><br><span class="line">    **/</span><br><span class="line">   int maxfdp = s+1;</span><br><span class="line">   int j = select(maxfdp, NULL, &amp;myset, NULL, &amp;tv);</span><br><span class="line">   </span><br><span class="line">   if (j == 0) &#123;</span><br><span class="line">       NSLog(@&quot;INFO:%s:%d, test rtt of (%@) timeout.&quot;,__FUNCTION__,__LINE__, oldIp);</span><br><span class="line">       rtt = CYL_SOCKET_CONNECT_TIMEOUT_RTT;</span><br><span class="line">       close(s);</span><br><span class="line">       return rtt;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   if (j &lt; 0) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       rtt = 0;</span><br><span class="line">       close(s);</span><br><span class="line">       return rtt;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    对于select和非阻塞connect，注意两点：</span><br><span class="line">    [1] 当连接成功建立时，描述符变成可写； [2] 当连接建立遇到错误时，描述符变为即可读，也可写，遇到这种情况，可调用getsockopt函数。</span><br><span class="line">    **/</span><br><span class="line">   lon = sizeof(int);</span><br><span class="line">   //valopt 表示错误信息。</span><br><span class="line">   // MARK: - 测试核心逻辑，连接后，获取错误信息，如果没有错误信息就是访问成功</span><br><span class="line">   /*!</span><br><span class="line">    * //getsockopt函数可获取影响套接字的选项，比如SOCKET的出错信息</span><br><span class="line">    * (get socket option)</span><br><span class="line">    */</span><br><span class="line">   getsockopt(s, SOL_SOCKET, SO_ERROR, (void*)(&amp;valopt), &amp;lon);</span><br><span class="line">   //如果有错误信息：</span><br><span class="line">   if (valopt) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       rtt = 0;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       endTime = [NSDate date];</span><br><span class="line">       rtt = [endTime timeIntervalSinceDate:startTime] * 1000;</span><br><span class="line">   &#125;</span><br><span class="line">   close(s);</span><br><span class="line">   return rtt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当出现错误的时候测试结果是速度是0，所以排序时不能简单地按照值大小排序，可以先删除速度为0的结果，或者将速度为零重置为超时时间，比如上面的 CYL_SOCKET_CONNECT_TIMEOUT_RTT 。避免错误IP为0，结果排序后排在前面。</p><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IP 测速排序方案&lt;/p&gt;
    
    </summary>
    
      <category term="programing" scheme="http://yoursite.com/categories/programing/"/>
    
    
      <category term="" scheme="http://yoursite.com/tags/%EF%A3%BF/"/>
    
  </entry>
  
</feed>
