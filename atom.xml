<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江湖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-03T14:10:21.823Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>policx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WWDC 2019</title>
    <link href="http://yoursite.com/2019/06/05/2019/"/>
    <id>http://yoursite.com/2019/06/05/2019/</id>
    <published>2019-06-05T03:06:39.000Z</published>
    <updated>2019-07-03T14:10:21.823Z</updated>
    
    <content type="html"><![CDATA[<p>Your time is limited, so don’t waste it living someone else’s life.…Don’t let the noise of others’ opinions drown out your own inner voice。</p><a id="more"></a><p>你的时间有限，不要浪费于重复别人的生活。不要让别人的观点淹没了你内心的声音。</p><p><img src="https://www.policx.com/talk/images/wwdc2019.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Your time is limited, so don’t waste it living someone else’s life.…Don’t let the noise of others’ opinions drown out your own inner voice。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git如何删除已经提交的文件夹</title>
    <link href="http://yoursite.com/2018/09/17/git-del/"/>
    <id>http://yoursite.com/2018/09/17/git-del/</id>
    <published>2018-09-17T08:02:32.000Z</published>
    <updated>2019-07-03T15:53:39.263Z</updated>
    
    <content type="html"><![CDATA[<p>在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹</p><a id="more"></a><p>在github上只能删除仓库,却无法删除文件夹或文件, 所以只能通过命令来解决</p><p>首先进入你的master文件夹下, Git Bash Here ,打开命令窗口</p><p><code>$ git --help                                      # 帮助命令</code></p><p><code>$ git pull origin master                    # 将远程仓库里面的项目拉下来</code></p><p><code>$ ls                                                # 查看有哪些文件夹</code></p><p><code>$ git rm -r --cached .idea              # 删除.idea文件夹</code></p><p><code>$ git commit -m &#39;删除.idea&#39;        # 提交,添加操作说明</code></p><p><code>$ git push -u origin master               # 将本次更改更新到github项目上去</code></p><hr><p>作者： <a href="https://blog.csdn.net/weiyoushi4001/article/details/82495364" target="_blank" rel="noopener">皮皮今</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上传项目到github时,忘记忽略了某个文件夹.idea,就直接push上去了, 最后意识到了此问题,决定删除掉远程仓库中的.idea文件夹&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python利用openpyxl来操作Excel</title>
    <link href="http://yoursite.com/2018/06/19/python-excel/"/>
    <id>http://yoursite.com/2018/06/19/python-excel/</id>
    <published>2018-06-19T08:39:16.000Z</published>
    <updated>2019-07-03T16:01:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。</p><a id="more"></a><p>如下所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import load_workbook</span><br><span class="line">from openpyxl.styles import colors, Font, Fill, NamedStyle</span><br><span class="line">from openpyxl.styles import PatternFill, Border, Side, Alignment</span><br><span class="line"> </span><br><span class="line"># 加载文件</span><br><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)</span><br></pre></td></tr></table></figure><ul><li>workbook： 工作簿，一个excel文件包含多个sheet。</li><li>worksheet：工作表，一个workbook有多个，表名识别，如“sheet1”,“sheet2”等。</li><li>cell： 单元格，存储数据对象<br>文章所用表格为：<br><img src="https://policx.github.io/post-images/1560761501804.jpeg" alt></li></ul><h3 id="操作sheet"><a href="#操作sheet" class="headerlink" title="操作sheet"></a>操作sheet</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 读取sheetname</span><br><span class="line">print(&apos;输出文件所有工作表名：\n&apos;, wb.sheetnames)</span><br><span class="line">ws = wb[&apos;5a&apos;]</span><br><span class="line"> </span><br><span class="line"># 或者不知道名字时</span><br><span class="line">sheet_names = wb.sheetnames   # 返回一个列表</span><br><span class="line">ws2 = wb[sheet_names[0]]    # index为0为第一张表</span><br><span class="line">print(ws is ws2)    # 两者是一样的</span><br></pre></td></tr></table></figure><p>输出文件所有工作表名：<br>[‘5a’]<br>True</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改sheetname</span><br><span class="line"> </span><br><span class="line">ws.title = &apos;5a_&apos;</span><br><span class="line">print(&apos;修改sheetname：\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>修改sheetname：<br>[‘5a_’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建新的sheet</span><br><span class="line"># 创建的新表必须要赋值给一个对象，不然只有名字但是没有实际的新表</span><br><span class="line"> </span><br><span class="line">ws4 = wb.create_sheet(index=0, title=&apos;newsheet&apos;)</span><br><span class="line"># 什么参数都不写的话，默认插入到最后一个位置且名字为sheet,sheet1...按照顺序排列</span><br><span class="line"> </span><br><span class="line">ws5 = wb.create_sheet()</span><br><span class="line">print(&apos;创建新的sheet:\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>创建新的sheet:<br>[‘newsheet’, ‘5a_’, ‘Sheet’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除sheet</span><br><span class="line">wb.remove(ws4)  # 这里只能写worksheet对象，不能写sheetname</span><br><span class="line">print(&apos;删除sheet：\n&apos;, wb.sheetnames)</span><br></pre></td></tr></table></figure><p>删除sheet：<br>[‘5a_’, ‘Sheet’]</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 修改sheet选项卡背景色，默认为白色，设置为RRGGBB模式</span><br><span class="line">ws.sheet_properties.tabColor = &quot;FFA500&quot;</span><br><span class="line"> </span><br><span class="line"># 读取有效区域</span><br><span class="line"> </span><br><span class="line">print(&apos;最大列数为：&apos;, ws.max_column)</span><br><span class="line">print(&apos;最大行数为：&apos;, ws.max_row)</span><br></pre></td></tr></table></figure><p>最大列数为： 5<br>最大行数为： 17</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 插入行和列</span><br><span class="line">ws.insert_rows(1)  # 在第一行插入一行</span><br><span class="line">ws.insert_cols(2, 4)  # 从第二列开始插入四列</span><br><span class="line"> </span><br><span class="line"># 删除行和列</span><br><span class="line">ws.delete_cols(6, 3)  # 从第六列（F列）开始，删除3列即（F:H）</span><br><span class="line">ws.delete_rows(3)   # 删除第三行</span><br></pre></td></tr></table></figure><h3 id="单元格操作"><a href="#单元格操作" class="headerlink" title="单元格操作"></a>单元格操作</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 读取</span><br><span class="line">c = ws[&apos;A1&apos;]</span><br><span class="line">c1 = ws.cell(row=1, column=2)</span><br><span class="line">print(c, c1)</span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure><p>&lt;Cell ‘5a_’.A1&gt;  &lt;Cell ‘5a_’.B1&gt;<br>dth_title Province  </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改</span><br><span class="line">ws[&apos;A1&apos;] = &apos;景区名称&apos;</span><br><span class="line">ws.cell(1, 2).value = &apos;省份&apos;</span><br><span class="line">print(c.value, c1.value)</span><br></pre></td></tr></table></figure><p>景区名称 省份</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 读取多个单元格</span><br><span class="line"> </span><br><span class="line">cell_range = ws[&apos;A1&apos;:&apos;D5&apos;]</span><br><span class="line">colC = ws[&apos;C&apos;]</span><br><span class="line">col_range = ws[&apos;C:D&apos;]</span><br><span class="line">row10 = ws[10]</span><br><span class="line">row_range = ws[5:10]</span><br><span class="line"># 其返回的结果都是一个包含单元格的元组</span><br><span class="line">print(type(cell_range))</span><br><span class="line">for i in row10:</span><br><span class="line">    print(i)    # row10只有有效单元格</span><br></pre></td></tr></table></figure><p>&lt;class ‘tuple’&gt;<br>&lt;Cell ‘5a_’.A10&gt;<br>&lt;Cell ‘5a_’.B10&gt;<br>&lt;Cell ‘5a_’.C10&gt;<br>&lt;Cell ‘5a_’.D10&gt;<br>&lt;Cell ‘5a_’.E10&gt; </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 按照行列操作</span><br><span class="line">for row in ws.iter_rows(min_row=1, max_row=3,</span><br><span class="line">                        min_col=1, max_col=2):</span><br><span class="line">    for cell in row:</span><br><span class="line">        print(cell)</span><br><span class="line"># 也可以用worksheet.iter_col(),用法都一样</span><br></pre></td></tr></table></figure><p>&lt;Cell ‘5a_’.A1&gt;<br>&lt;Cell ‘5a_’.B1&gt;<br>&lt;Cell ‘5a_’.A2&gt;<br>&lt;Cell ‘5a_’.B2&gt;<br>&lt;Cell ‘5a_’.A3&gt;<br>&lt;Cell ‘5a_’.B3&gt; </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 合并单元格</span><br><span class="line">ws.merge_cells(&apos;F1:G1&apos;)</span><br><span class="line">ws[&apos;F1&apos;] = &apos;合并两个单元格&apos;</span><br><span class="line"># 或者</span><br><span class="line">ws.merge_cells(start_row=2, start_column=6, end_row=3, end_column=8)</span><br><span class="line">ws.cell(2, 6).value = &apos;合并三个单元格&apos;</span><br><span class="line"> </span><br><span class="line"># 取消合并单元格</span><br><span class="line">ws.unmerge_cells(&apos;F1:G1&apos;)</span><br><span class="line"># 或者</span><br><span class="line">ws.unmerge_cells(start_row=2, start_column=6, end_row=3, end_column=8)</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)</span><br><span class="line"># 保存之前的操作,保存文件时，文件必须是关闭的！！！</span><br></pre></td></tr></table></figure><p>注意！！！，openpyxl对Excel的修改并不像是xlwings包一样是实时的，他的修改是暂时保存在内存中的，所以当 后面的修改例如我接下来要在第一行插入新的一行做标题，那么当我对新的A1单元格操作的时候，还在内存中的原A1(现在是A2)的单元格 原有的修改就会被覆盖。所以要先保存，或者从一开始就计划好更改操作避免这样的事情发生。</p><h3 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h3><h4 id="单个单元格样式"><a href="#单个单元格样式" class="headerlink" title="单个单元格样式"></a>单个单元格样式</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)    # 读取修改后的文件</span><br><span class="line">ws = wb[&apos;5a_&apos;]</span><br><span class="line"># 我们来设置一个表头</span><br><span class="line">ws.insert_rows(1)    # 在第一行插入新的一行</span><br><span class="line">ws.merge_cells(&apos;A1:E1&apos;)  # 合并单元格</span><br><span class="line">a1 = ws[&apos;A1&apos;]</span><br><span class="line">ws[&apos;A1&apos;] = &apos;5A级风景区名单&apos;</span><br><span class="line"> </span><br><span class="line"># 设置字体</span><br><span class="line">ft = Font(name=&apos;微软雅黑&apos;, color=&apos;000000&apos;, size=15, b=True)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">name:字体名称</span><br><span class="line">color:颜色通常是RGB或aRGB十六进制值</span><br><span class="line">b(bold):加粗（bool）</span><br><span class="line">i(italic):倾斜(bool)</span><br><span class="line">shadow：阴影（bool）</span><br><span class="line">underline：下划线（‘doubleAccounting’, ‘single’, ‘double’, ‘singleAccounting’）</span><br><span class="line">charset:字符集(int)</span><br><span class="line">strike:删除线(bool)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">a1.font = ft</span><br><span class="line"> </span><br><span class="line"># 设置文本对齐</span><br><span class="line"> </span><br><span class="line">ali = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">horizontal:水平对齐(&apos;centerContinuous&apos;, &apos;general&apos;, &apos;distributed&apos;,</span><br><span class="line">                    &apos;left&apos;, &apos;fill&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;right&apos;)</span><br><span class="line">vertical:垂直对齐（&apos;distributed&apos;, &apos;top&apos;, &apos;center&apos;, &apos;justify&apos;, &apos;bottom&apos;）</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">a1.alignment = ali</span><br><span class="line"> </span><br><span class="line"># 设置图案填充</span><br><span class="line"> </span><br><span class="line">fill = PatternFill(&apos;solid&apos;, fgColor=&apos;FFA500&apos;)</span><br><span class="line"># 颜色一般使用十六进制RGB</span><br><span class="line"># &apos;solid&apos;是图案填充类型，详细可查阅文档</span><br><span class="line"> </span><br><span class="line">a1.fill = fill</span><br></pre></td></tr></table></figure><p><a href="https://openpyxl.readthedocs.io/en/stable/api/openpyxl.styles.fills.html" target="_blank" rel="noopener">openpyxl.styles.fills模块参数文档</a></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 设置边框</span><br><span class="line">bian = Side(style=&apos;medium&apos;, color=&apos;000000&apos;)    # 设置边框样式</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">style:边框线的风格&#123;&apos;dotted&apos;,&apos;slantDashDot&apos;,&apos;dashDot&apos;,&apos;hair&apos;,&apos;mediumDashDot&apos;,</span><br><span class="line">        &apos;dashed&apos;,&apos;mediumDashed&apos;,&apos;thick&apos;,&apos;dashDotDot&apos;,&apos;medium&apos;,</span><br><span class="line">        &apos;double&apos;,&apos;thin&apos;,&apos;mediumDashDotDot&apos;&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">border = Border(top=bian, bottom=bian, left=bian, right=bian)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">top（上）,bottom（下）,left（左）,right（右）:必须是 Side类型</span><br><span class="line">diagonal: 斜线 side类型 </span><br><span class="line">diagonalDownd: 右斜线 bool</span><br><span class="line">diagonalDown: 左斜线 bool</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line"># a1.border = border</span><br><span class="line">for item in ws[&apos;A1:E1&apos;][0]:   # 去元组中的每一个cell更改样式</span><br><span class="line">    item.border = border</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)  # 保存更改</span><br></pre></td></tr></table></figure><p>再次注意！！！：</p><p>不能使用 a1.border = border，否则只会如下图情况，B1：E1单元格没有线。我个人认为是因为线框涉及到相邻单元格边框的改动所以需要单独对每个单元格修改才行。<br>不能使用ws[‘A1:E1’].border = border,由前面的内容可知，openpyxl的多个单元格其实是一个元组，而元组是没有style的方法的,所以必须一个一个改！！其实官方有其他办法，后面讲。</p><h3 id="按列或行设置样式"><a href="#按列或行设置样式" class="headerlink" title="按列或行设置样式"></a>按列或行设置样式</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 现在我们对整个表进行设置</span><br><span class="line"> </span><br><span class="line"># 读取</span><br><span class="line">wb = load_workbook(&apos;./5a.xlsx&apos;)</span><br><span class="line">ws = wb[&apos;5a_&apos;]</span><br><span class="line"> </span><br><span class="line"># 读取数据表格范围</span><br><span class="line">rows = ws.max_row</span><br><span class="line">cols = ws.max_column</span><br><span class="line"> </span><br><span class="line"># 字体</span><br><span class="line">font1 = Font(name=&apos;微软雅黑&apos;, size=11, b=True)</span><br><span class="line">font2 = Font(name=&apos;微软雅黑&apos;, size=11)</span><br><span class="line"> </span><br><span class="line"># 边框</span><br><span class="line">line_t = Side(style=&apos;thin&apos;, color=&apos;000000&apos;)  # 细边框</span><br><span class="line">line_m = Side(style=&apos;medium&apos;, color=&apos;000000&apos;)  # 粗边框</span><br><span class="line">border1 = Border(top=line_m, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"># 与标题相邻的边设置与标题一样</span><br><span class="line">border2 = Border(top=line_t, bottom=line_t, left=line_t, right=line_t)</span><br><span class="line"> </span><br><span class="line"># 填充</span><br><span class="line">fill = PatternFill(&apos;solid&apos;, fgColor=&apos;CFCFCF&apos;)</span><br><span class="line"> </span><br><span class="line"># 对齐</span><br><span class="line">alignment = Alignment(horizontal=&apos;center&apos;, vertical=&apos;center&apos;)</span><br><span class="line"> </span><br><span class="line"># 将样式打包命名</span><br><span class="line">sty1 = NamedStyle(name=&apos;sty1&apos;, font=font1, fill=fill,</span><br><span class="line">                  border=border1, alignment=alignment)</span><br><span class="line">sty2 = NamedStyle(name=&apos;sty2&apos;, font=font2, border=border2, alignment=alignment)</span><br><span class="line"> </span><br><span class="line">for r in range(2, rows+1):</span><br><span class="line">    for c in range(1, cols):</span><br><span class="line">        if r == 2:</span><br><span class="line">            ws.cell(r, c).style = sty1</span><br><span class="line">        else:</span><br><span class="line">            ws.cell(r, c).style = sty2</span><br><span class="line"> </span><br><span class="line">wb.save(&apos;./5a.xlsx&apos;)</span><br></pre></td></tr></table></figure><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p><img src="https://policx.github.io/post-images/1560761595658.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动化的工作是为了从繁琐重复的劳动中挣脱出来，把精力用在数据分析上。自动化方面python是在好不过了，不过既然要提交报表， 就不免要美观什么的。pandas虽然很强大，但是无法对Excel完全操作，现学vba有点来不及。于是就找到这个openpyxl包，用python来修改Excel。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python操作excel的包(openpyxl、xlsxwriter)</title>
    <link href="http://yoursite.com/2018/06/17/python-writer/"/>
    <id>http://yoursite.com/2018/06/17/python-writer/</id>
    <published>2018-06-17T10:28:27.000Z</published>
    <updated>2019-07-03T16:09:05.888Z</updated>
    
    <content type="html"><![CDATA[<p>现在支持python操作excel的包有下列这些<br><img src="https://policx.github.io/post-images/1560767425488.png" alt></p><p>官网上最推荐的是openpyxl，其他包支持较老的excel版本。<br><img src="https://policx.github.io/post-images/1560767456846.png" alt><br><img src="https://policx.github.io/post-images/1560767522161.png" alt></p><a id="more"></a><p>xlsxwriter无法对打开的excel进行写操作，excel必须处于关闭状态才能写成功。</p><h4 id="xlswriter-基本代码："><a href="#xlswriter-基本代码：" class="headerlink" title="xlswriter 基本代码："></a>xlswriter 基本代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import xlsxwriter</span><br><span class="line"></span><br><span class="line">workbook = xlsxwriter.Workbook(&apos;hello.xlsx&apos;)</span><br><span class="line">worksheet = workbook.add_worksheet()</span><br><span class="line"></span><br><span class="line">worksheet.write(&apos;A1&apos;, &apos;Hello world&apos;)</span><br><span class="line"></span><br><span class="line">workbook.close()</span><br></pre></td></tr></table></figure><h4 id="openpyxl基本代码："><a href="#openpyxl基本代码：" class="headerlink" title="openpyxl基本代码："></a>openpyxl基本代码：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from openpyxl import Workbook</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line">#设置单元格值</span><br><span class="line">ws[&apos;A1&apos;] = 42</span><br><span class="line">#加入一行数据</span><br><span class="line">ws.append([1, 2, 3])</span><br><span class="line"></span><br><span class="line">import datetime</span><br><span class="line">#python 类型数据会被自动转换</span><br><span class="line">ws[&apos;A2&apos;] = datetime.datetime.now()</span><br><span class="line">#保存修改</span><br><span class="line">wb.save(&quot;sample.xlsx&quot;)</span><br></pre></td></tr></table></figure><p>来源:<a href="https://www.jb51.net/article/141817.htm" target="_blank" rel="noopener">脚本之家</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在支持python操作excel的包有下列这些&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767425488.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;官网上最推荐的是openpyxl，其他包支持较老的excel版本。&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767456846.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://policx.github.io/post-images/1560767522161.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WWDC 2018</title>
    <link href="http://yoursite.com/2018/06/05/2018/"/>
    <id>http://yoursite.com/2018/06/05/2018/</id>
    <published>2018-06-04T16:59:59.000Z</published>
    <updated>2019-07-03T14:10:39.656Z</updated>
    
    <content type="html"><![CDATA[<p>Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me。</p><a id="more"></a><p>是否能成为墓地里最富有的人，对我而言无足轻重。重要的是，当我晚上睡觉时，我可以说：我们今天完成了一些美妙的事。</p><p><img src="https://www.policx.com/talk/images/wwdc2018.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python3 与 MongoDB 之间的交互</title>
    <link href="http://yoursite.com/2018/05/02/pymongo/"/>
    <id>http://yoursite.com/2018/05/02/pymongo/</id>
    <published>2018-05-02T07:27:47.000Z</published>
    <updated>2019-07-03T16:07:24.444Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。</p><a id="more"></a><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>在开始之前，请确保已经安装好了MongoDB并启动了其服务，并且安装好了Python的PyMongo库。</p><h2 id="2-连接MongoDB"><a href="#2-连接MongoDB" class="headerlink" title="2. 连接MongoDB"></a>2. 连接MongoDB</h2><p>连接MongoDB时，我们需要使用PyMongo库里面的MongoClient。一般来说，传入MongoDB的IP及端口即可，其中第一个参数为地址host，第二个参数为端口port（如果不给它传递参数，默认是27017）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymongo</span><br><span class="line">client = pymongo.MongoClient(host=&apos;localhost&apos;, port=27017)</span><br></pre></td></tr></table></figure><p>这样就可以创建MongoDB的连接对象了。</p><p>另外，MongoClient的第一个参数host还可以直接传入MongoDB的连接字符串，它以mongodb开头，例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = MongoClient(&apos;mongodb://localhost:27017/&apos;)</span><br></pre></td></tr></table></figure><p>这也可以达到同样的连接效果。</p><h2 id="3-指定数据库"><a href="#3-指定数据库" class="headerlink" title="3. 指定数据库"></a>3. 指定数据库</h2><p>MongoDB中可以建立多个数据库，接下来我们需要指定操作哪个数据库。这里我们以test数据库为例来说明，下一步需要在程序中指定要使用的数据库：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client.test</span><br></pre></td></tr></table></figure><p>这里调用client的test属性即可返回test数据库。当然，我们也可以这样指定：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client[&apos;test&apos;]</span><br></pre></td></tr></table></figure><p>这两种方式是等价的。</p><h2 id="4-指定集合"><a href="#4-指定集合" class="headerlink" title="4. 指定集合"></a>4. 指定集合</h2><p>MongoDB的每个数据库又包含许多集合（collection），它们类似于关系型数据库中的表。</p><p>下一步需要指定要操作的集合，这里指定一个集合名称为students。与指定数据库类似，指定集合也有两种方式：<br><code>collection = db.students</code></p><p><code>collection = db[&#39;students&#39;]</code><br>这样我们便声明了一个Collection对象。</p><h2 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h2><p>接下来，便可以插入数据了。对于students这个集合，新建一条学生数据，这条数据以字典形式表示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定了学生的学号、姓名、年龄和性别。接下来，直接调用collection的insert()方法即可插入数据，代码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert(student)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>在MongoDB中，每条数据其实都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的_id属性。insert()方法会在执行后返回_id值。</p><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5932a68615c2606814c91f3d</span><br></pre></td></tr></table></figure><p>当然，我们也可以同时插入多条数据，只需要以列表形式传递即可，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">student1 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170202&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Mike&apos;,</span><br><span class="line">    &apos;age&apos;: 21,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert([student1, student2])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>返回结果是对应的_id的集合：</p><p><code>[ObjectId(&#39;5932a80115c2606a59e8a048&#39;), ObjectId(&#39;5932a80115c2606a59e8a049&#39;)]</code><br>实际上，在PyMongo 3.x版本中，官方已经不推荐使用insert()方法了。当然，继续使用也没有什么问题。官方推荐使用insert_one()和insert_many()方法来分别插入单条记录和多条记录，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = collection.insert_one(student)</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_id)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.results.InsertOneResult object at 0x10d68b558&gt;</span><br><span class="line">5932ab0f15c2606f0c1cf6c5</span><br></pre></td></tr></table></figure><p>与insert()方法不同，这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id。</p><p>对于insert_many()方法，我们可以将数据以列表形式传递，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170101&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Jordan&apos;,</span><br><span class="line">    &apos;age&apos;: 20,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    &apos;id&apos;: &apos;20170202&apos;,</span><br><span class="line">    &apos;name&apos;: &apos;Mike&apos;,</span><br><span class="line">    &apos;age&apos;: 21,</span><br><span class="line">    &apos;gender&apos;: &apos;male&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = collection.insert_many([student1, student2])</span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.results.InsertManyResult object at 0x101dea558&gt;</span><br><span class="line">[ObjectId(&apos;5932abf415c2607083d3b2ac&apos;), ObjectId(&apos;5932abf415c2607083d3b2ad&apos;)]</span><br></pre></td></tr></table></figure><p>该方法返回的类型是InsertManyResult，调用inserted_ids属性可以获取插入数据的_id列表。</p><h2 id="6-查询"><a href="#6-查询" class="headerlink" title="6. 查询"></a>6. 查询</h2><p>插入数据后，我们可以利用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find_one(&#123;&apos;name&apos;: &apos;Mike&apos;&#125;)</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>这里我们查询name为Mike的数据，它的返回结果是字典类型，运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &apos;dict&apos;&gt;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;5932a80115c2606a59e8a049&apos;), &apos;id&apos;: &apos;20170202&apos;, &apos;name&apos;: &apos;Mike&apos;, &apos;age&apos;: 21, &apos;gender&apos;: &apos;male&apos;&#125;</span><br></pre></td></tr></table></figure><p>可以发现，它多了_id属性，这就是MongoDB在插入过程中自动添加的。</p><p>此外，我们也可以根据ObjectId来查询，此时需要使用bson库里面的objectid：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from bson.objectid import ObjectId</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;)&#125;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>其查询结果依然是字典类型，具体如下：</p><p><code>{&#39;_id&#39;: ObjectId(&#39;593278c115c2602667ec6bae&#39;), &#39;id&#39;: &#39;20170101&#39;, &#39;name&#39;: &#39;Jordan&#39;, &#39;age&#39;: 20, &#39;gender&#39;: &#39;male&#39;}</code><br>当然，如果查询结果不存在，则会返回None。</p><p>对于多条数据的查询，我们可以使用find()方法。例如，这里查找年龄为20的数据，示例如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">results = collection.find(&#123;&apos;age&apos;: 20&#125;)</span><br><span class="line">print(results)</span><br><span class="line">for result in results:</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pymongo.cursor.Cursor object at 0x1032d5128&gt;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278c115c2602667ec6bae&apos;), &apos;id&apos;: &apos;20170101&apos;, &apos;name&apos;: &apos;Jordan&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278c815c2602678bb2b8d&apos;), &apos;id&apos;: &apos;20170102&apos;, &apos;name&apos;: &apos;Kevin&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br><span class="line">&#123;&apos;_id&apos;: ObjectId(&apos;593278d815c260269d7645a8&apos;), &apos;id&apos;: &apos;20170103&apos;, &apos;name&apos;: &apos;Harden&apos;, &apos;age&apos;: 20, &apos;gender&apos;: &apos;male&apos;&#125;</span><br></pre></td></tr></table></figure><p>返回结果是Cursor类型，它相当于一个生成器，我们需要遍历取到所有的结果，其中每个结果都是字典类型。</p><p>如果要查询年龄大于20的数据，则写法如下：</p><p><code>results = collection.find({&#39;age&#39;: {&#39;$gt&#39;: 20}})</code><br>这里查询的条件键值已经不是单纯的数字了，而是一个字典，其键名为比较符号$gt，意思是大于，键值为20。</p><p>这里将比较符号归纳为下表。<br><a href="https://cloud.tencent.com/developer/article/1151814" target="_blank" rel="noopener">腾讯云自媒体分享计划</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似JSON对象，它的字段值可以包含其他文档、数组及文档数组，非常灵活。在这一节中，我们就来看看Python 3下MongoDB的存储操作。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://yoursite.com/2018/05/02/mongodb/"/>
    <id>http://yoursite.com/2018/05/02/mongodb/</id>
    <published>2018-05-02T06:11:11.000Z</published>
    <updated>2019-07-03T16:07:16.536Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。</p><a id="more"></a><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><blockquote><p>数据库是一个集合的物理容器。每个数据库获取其自己设定在文件系统上的文件。一个单一的MongoDB服务器通常有多个数据库。</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><blockquote><p>集合是一组MongoDB的文件。它与一个RDBMS表是等效的。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。通常情况下，在一个集合中的所有文件都是类似或相关目的。</p></blockquote><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><blockquote><p>文档是一组键值对。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。<br>下面给出的示例显示了一个博客网站，仅仅是一个逗号分隔的键值对的文档结构。</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorial&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100, </span><br><span class="line">   comments: [</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user1&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2011,1,20,2,15),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user2&apos;,</span><br><span class="line">         message: &apos;My second comments&apos;,</span><br><span class="line">         dateCreated: new Date(2011,1,25,7,45),</span><br><span class="line">         like: 5</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><blockquote><p>MongoDB use DATABASE_NAME 用于创建数据库。该命令如果数据库不存在，将创建一个新的数据库， 否则将返回现有的数据库。</p></blockquote><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>use DATABASE语句的基本语法如下：<br><code>use DATABASE_NAME</code></p><h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果想创建一个数据库名称为 &lt;mydb&gt;, 那么 use DATABASE 语句应该如下：</span><br><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line"></span><br><span class="line">要检查当前选择的数据库使用命令 db</span><br><span class="line">&gt;db</span><br><span class="line">mydb</span><br><span class="line"></span><br><span class="line">如果想查询数据库列表，那么使用命令 show dbs.</span><br><span class="line">&gt;show dbs</span><br><span class="line">local     0.78125GB</span><br><span class="line">test      0.23012GB</span><br><span class="line"></span><br><span class="line">所创建的数据库（mydb）不存在于列表中。要显示的数据库，需要至少插入一个文档进去。</span><br><span class="line">&gt;db.movie.insert(&#123;&quot;name&quot;:&quot;yiibai tutorials&quot;&#125;)</span><br><span class="line">&gt;show dbs</span><br><span class="line">local      0.78125GB</span><br><span class="line">mydb       0.23012GB</span><br><span class="line">test       0.23012GB</span><br></pre></td></tr></table></figure><p>MongoDB的默认数据库是test。 如果没有创建任何数据库，那么集合将被保存在测试数据库。</p><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>MongoDB db.dropDatabase() 命令用于删除现有的数据库。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>dropDatabase()指令的基本语法如下：<br><code>db.dropDatabase()</code></p><p>这将删除选定的数据库。如果没有选择任何数据库，那么它会删除默认的“test”数据库</p><h5 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h5><p>如果想删除新的数据库 <mydb>, 那么 dropDatabase() 命令将如下所示：</mydb></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.dropDatabase()</span><br><span class="line">&gt;&#123; &quot;dropped&quot; : &quot;mydb&quot;, &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>MongoDB 的 db.createCollection(name, options) 用于创建集合。 在命令中, name 是要创建集合的名称。 Options 是一个文档，用于指定集合的配置</p><table><thead><tr><th>参数</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>String</td><td>要创建的集合的名称</td></tr><tr><td>Options</td><td>Document</td><td>（可选）指定有关内存大小和索引选项</td></tr></tbody></table><p>选项参数是可选的，所以需要指定集合的唯一名字。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>createCollection()方法的基本语法如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use test</span><br><span class="line">switched to db test</span><br><span class="line">&gt;db.createCollection(&quot;mycollection&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>可以通过使用 show collections 命令来检查创建的集合</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;show collections</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br></pre></td></tr></table></figure><h3 id="选项列表"><a href="#选项列表" class="headerlink" title="选项列表"></a>选项列表</h3><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>Boolean</td><td>（可选）如果为true，它启用上限集合。上限集合是一个固定大小的集合，当它达到其最大尺寸会自动覆盖最老的条目。 如果指定true，则还需要指定参数的大小。</td></tr><tr><td>autoIndexID</td><td>Boolean</td><td>（可选）如果为true，自动创建索引_id字段。默认的值是 false.</td></tr><tr><td>size</td><td>number</td><td>（可选）指定的上限集合字节的最大尺寸。如果capped 是true，那么还需要指定这个字段。</td></tr><tr><td>max</td><td>number</td><td>（可选）指定上限集合允许的最大文件数。</td></tr></tbody></table><p>尽管插入文档，MongoDB首先检查字段集合的上限大小，那么它会检查最大字段。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法 :"></a>语法 :</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.createCollection(&quot;mycol&quot;, &#123; capped : true, autoIndexID : true, size : 6142800, max : 10000 &#125; )</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>在MongoDB中并不需要创建集合。 当插入一些文档 MongoDB 会自动创建集合。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.yiibai.insert(&#123;&quot;name&quot; : &quot;yiibai&quot;&#125;)</span><br><span class="line">&gt;show collections</span><br><span class="line">mycol</span><br><span class="line">mycollection</span><br><span class="line">system.indexes</span><br><span class="line">yiibai</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><p>MongoDB 的 db.collection.drop() 用于从数据库中删除集合。</p><h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><p>drop() 命令的基本语法如下<br><code>db.COLLECTION_NAME.drop()</code></p><h5 id="例子：-2"><a href="#例子：-2" class="headerlink" title="例子："></a>例子：</h5><p>下面给出的例子将删除给定名称的集合：mycollection</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mydb</span><br><span class="line">switched to db mydb</span><br><span class="line">&gt;db.mycollection.drop()</span><br><span class="line">true</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h4><p>将数据插入到MongoDB集合，需要使用MongoDB 的 insert() 方法。</p><h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><p>insert()命令的基本语法如下：<br><code>&gt;db.COLLECTION_NAME.insert(document)</code></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.insert(&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c),</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 mycol 是我们的集合名称，它是在之前的教程中创建。如果集合不存在于数据库中，那么MongoDB创建此集合，然后插入文档进去。</p><p>在如果我们不指定_id参数插入的文档，那么 MongoDB 将为文档分配一个唯一的ObjectId。</p><p>_id 是12个字节十六进制数在一个集合的每个文档是唯一的。 12个字节被划分如下：<br>_id: ObjectId(4 bytes timestamp, 3 bytes machine id, 2 bytes process id, 3 bytes incrementer)</p><p>要以单个查询插入多个文档，可以通过文档 insert() 命令的数组方式。</p><h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.post.insert([</span><br><span class="line">&#123;</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   title: &apos;NoSQL Database&apos;, </span><br><span class="line">   description: &apos;NoSQL database doesn&apos;t have tables&apos;,</span><br><span class="line">   by: &apos;yiibai tutorials&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 20, </span><br><span class="line">   comments: [</span><br><span class="line">      &#123;</span><br><span class="line">         user:&apos;user1&apos;,</span><br><span class="line">         message: &apos;My first comment&apos;,</span><br><span class="line">         dateCreated: new Date(2013,11,10,2,35),</span><br><span class="line">         like: 0 </span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>要从集合查询MongoDB数据，需要使用MongoDB的 find()方法。</p><h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><p>find()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find()</code><br>find() 方法将在非结构化的方式显示所有的文件。 如果显示结果是格式化的，那么可以用pretty() 方法。</p><h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><p><code>&gt;db.mycol.find().pretty()</code></p><h5 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find().pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>除了find()方法还有findOne()方法，仅返回一个文档。</p><h3 id="RDBMS-Where子句等效于MongoDB"><a href="#RDBMS-Where子句等效于MongoDB" class="headerlink" title="RDBMS Where子句等效于MongoDB"></a>RDBMS Where子句等效于MongoDB</h3><p>查询文档在一些条件的基础上，可以使用下面的操作</p><table><thead><tr><th>操作</th><th>语法</th><th>示例</th><th>RDBMS等效语句</th></tr></thead><tbody><tr><td>Equality</td><td><code>{&lt;key&gt;:&lt;value&gt;}</code></td><td>db.mycol.find({“by”:”yiibai tutorials”}).pretty()</td><td>where by = ‘yiibai tutorials’</td></tr><tr><td>Less Than</td><td><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>Less Than Equals</td><td><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>Greater Than</td><td><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>Greater Than Equals</td><td><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>Not Equals</td><td><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td><td>db.mycol.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><h4 id="AND-在-MongoDB"><a href="#AND-在-MongoDB" class="headerlink" title="AND 在 MongoDB"></a>AND 在 MongoDB</h4><h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><p>在 find()方法，如果您传递多个键通过”,”将它们分开，那么MongoDB对待它就如AND条件一样。基本语法如下所示：<br><code>&gt;db.mycol.find({key1:value1, key2:value2}).pretty()</code></p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有教程含“yiibai tutorials”和其标题是“MongoDB Overview”</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&quot;by&quot;:&quot;yiibai tutorials&quot;,&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>对于上面给出的例子相当于where子句：’ where by=’yiibai tutorials’ AND title=’MongoDB Overview’ ‘。可以传递任何数目的键-值对在find子句。</p><h4 id="OR-在-MongoDB"><a href="#OR-在-MongoDB" class="headerlink" title="OR 在 MongoDB"></a>OR 在 MongoDB</h4><h5 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h5><p>要查询基于OR条件的文件，需要使用$or关键字。OR的基本语法如下所示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">     &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子将显示所有撰写含有 ‘yiibai tutorials’ 或是标题为 ‘MongoDB Overview’ 的教程</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;$or:[&#123;&quot;by&quot;:&quot;tutorials point&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;]&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="使用-AND-和-OR-在一起"><a href="#使用-AND-和-OR-在一起" class="headerlink" title="使用 AND 和 OR 在一起"></a>使用 AND 和 OR 在一起</h4><h5 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h5><p>下面给出的例子显示有喜欢数大于100 的文档，其标题要么是 ‘MongoDB Overview’ 或 ‘yiibai tutorials’. 等效于SQL的where子句：’where likes&gt;10 AND (by = ‘yiibai tutorials’ OR title = ‘MongoDB Overview’)’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&quot;likes&quot;: &#123;$gt:10&#125;, $or: [&#123;&quot;by&quot;: &quot;yiibai tutorials&quot;&#125;, &#123;&quot;title&quot;: &quot;MongoDB Overview&quot;&#125;] &#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">   &quot;_id&quot;: ObjectId(7df78ad8902c),</span><br><span class="line">   &quot;title&quot;: &quot;MongoDB Overview&quot;, </span><br><span class="line">   &quot;description&quot;: &quot;MongoDB is no sql database&quot;,</span><br><span class="line">   &quot;by&quot;: &quot;yiibai tutorials&quot;,</span><br><span class="line">   &quot;url&quot;: &quot;http://www.yiibai.com&quot;,</span><br><span class="line">   &quot;tags&quot;: [&quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot;],</span><br><span class="line">   &quot;likes&quot;: &quot;100&quot;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><p>MongoDB的update()和save()方法用于更新文档到一个集合。 update()方法将现有的文档中的值更新，而save()方法使用传递到save()方法的文档替换现有的文档。</p><h4 id="MongoDB-Update-方法"><a href="#MongoDB-Update-方法" class="headerlink" title="MongoDB Update() 方法"></a>MongoDB Update() 方法</h4><h5 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h5><p>update()方法的基本语法如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.COLLECTION_NAME.update(SELECTIOIN_CRITERIA, UPDATED_DATA)</span><br></pre></td></tr></table></figure><h5 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h5><p>考虑mycol集合有如下数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将设置其标题“MongoDB Overview”的文件为新标题为“New MongoDB Tutorial”</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;New MongoDB Tutorial&apos;&#125;&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;New MongoDB Tutorial&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Tutorial Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>默认情况下，MongoDB将只更新单一文件，更新多，需要一个参数 ‘multi’ 设置为 true。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.update(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;New MongoDB Tutorial&apos;&#125;&#125;,&#123;multi:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="MongoDB-Save-方法"><a href="#MongoDB-Save-方法" class="headerlink" title="MongoDB Save() 方法"></a>MongoDB Save() 方法</h4><p>save() 方法取代，通过新文档到 save()方法</p><h5 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h5><p>mongodb 的 save()方法如下所示的基本语法：<br><code>&gt;db.COLLECTION_NAME.save({_id:ObjectId(),NEW_DATA})</code></p><h5 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h5><p>下面的例子将替换该文件_id ‘5983548781331adf45ec7’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.save(</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;Yiibai Yiibai New Topic&quot;, &quot;by&quot;:&quot;Yiibai Yiibai&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><p>MongoDB 的 remove()方法用于从集合中删除文档。remove()方法接受两个参数。一个是标准缺失，第二是justOne标志<br>deletion criteria : 根据文件（可选）删除条件将被删除。<br>justOne : （可选）如果设置为true或1，然后取出只有一个文档。</p><h6 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h6><p>remove()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.remove(DELLETION_CRITTERIA)</code></p><h6 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h6><p>考虑mycol集合有如下数据。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将删除所有的文件，其标题为 ‘MongoDB Overview’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove(&#123;&apos;title&apos;:&apos;MongoDB Overview&apos;&#125;)</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Toturials Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h5 id="只删除一个"><a href="#只删除一个" class="headerlink" title="只删除一个"></a>只删除一个</h5><p>如果有多个记录，并要删除仅第一条记录，然后在 remove()方法设置参数 justOne 。<br><code>&gt;db.COLLECTION_NAME.remove(DELETION_CRITERIA,1)</code></p><h5 id="删除所有文件"><a href="#删除所有文件" class="headerlink" title="删除所有文件"></a>删除所有文件</h5><p>如果没有指定删除条件，则MongoDB将从集合中删除整个文件。这相当于SQL的 truncate 命令。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.remove()</span><br><span class="line">&gt;db.mycol.find()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="MongoDB投影"><a href="#MongoDB投影" class="headerlink" title="MongoDB投影"></a>MongoDB投影</h4><p>mongodb投影意义是只选择需要的数据，而不是选择整个一个文档的数据。如果一个文档有5个字段，只需要显示3个，只从中选择3个字段。</p><p>MongoDB的find()方法，解释了MongoDB中查询文档接收的第二个可选的参数是要检索的字段列表。在MongoDB中，当执行find()方法，那么它会显示一个文档的所有字段。要限制这一点，需要设置字段列表值为1或0。1是用来显示字段，而0被用来隐藏字段。</p><p>语法</p><p>find()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find({},{KEY:1})</code></p><p>例子</p><p>考虑集合 myycol 有下列数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示文档的标题，在查询文档时。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;)</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意在执行find()方法时_id字段始终显示，如果不想要显示这个字段，那么需要将其设置为0</p><h5 id="限制文档"><a href="#限制文档" class="headerlink" title="限制文档"></a>限制文档</h5><p>MongoDB Limit() 方法</p><p>要在MongoDB中限制记录，需要使用limit()方法。 limit() 方法接受一个数字类型的参数，这是要显示的文档数量。</p><h6 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h6><p>limit()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER)</code></p><p>例子</p><p>考虑集合 myycol 有下列数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将只显示2个文档，在查询文档时。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2)</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>如果不指定 limit()方法的参数数量，然后它会显示集合中的所有文档。</p><p>MongoDB Skip() 方法</p><p>除了 limit()方法还有一个方法 skip()也接受数字类型参数并用于跳过文件数。</p><p>语法</p><p>skip() 方法的基础语法如下所示：<br><code>&gt;db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</code></p><p>例子：</p><p>下面的例子将仅显示第二个文档。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1)</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意，skip() 方法的默认值是 0</p><h4 id="文档排序"><a href="#文档排序" class="headerlink" title="文档排序"></a>文档排序</h4><p>要排序MongoDB中的文档，需要使用 sort()方法。 sort() 方法接受一个包含字段列表以及排序顺序的文档。 要使用1和-1指定排序顺序。1用于升序，而-1是用于降序。</p><p>语法</p><p>sort()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.find().sort({KEY:1})</code></p><p>例子</p><p>考虑集合 myycol 有如下数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec5), &quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec6), &quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(5983548781331adf45ec7), &quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面的例子将显示的文件排序按标题降序排序。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;title&quot;:-1&#125;)</span><br><span class="line">&#123;&quot;title&quot;:&quot;Yiibai Yiibai Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;NoSQL Overview&quot;&#125;</span><br><span class="line">&#123;&quot;title&quot;:&quot;MongoDB Overview&quot;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>请注意，如果不指定排序类型，那么 sort() 方法将以升序排列文档。</p><h4 id="MongoDB索引"><a href="#MongoDB索引" class="headerlink" title="MongoDB索引"></a>MongoDB索引</h4><p>索引支持查询高效率执行。如果没有索引，MongoDB必须扫描集合中的每一个文档，然后选择那些符合查询语句的文档。若需要 mongod 来处理大量数据，扫描是非常低效的。</p><p>索引是特殊的数据结构，存储在一个易于设置遍历形式的数据的一小部分。索引存储在索引中指定特定字段的值或一组字段，并排序字段的值。</p><p>要创建索引，需要使用MongoDB的ensureIndex()方法。</p><p>语法</p><p>ensureIndex()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.ensureIndex({KEY:1})</code></p><p>这里键是要创建索引字段，1是按名称升序排序。若以按降序创建索引，需要使用 -1.</p><p>例子</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.mycol.ensureIndex(&#123;&quot;title&quot;:1&#125;)</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">在 ensureIndex()方法，可以通过多个字段，来创建多个字段索引。</span><br><span class="line">&gt;db.mycol.ensureIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>ensureIndex() 方法还接受选项列表（这是可选），其列表如下：<br><img src="https://policx.github.io/post-images/1561132706992.png" alt></p><h4 id="MongoDB-聚合"><a href="#MongoDB-聚合" class="headerlink" title="MongoDB 聚合"></a>MongoDB 聚合</h4><p>聚合操作处理数据记录并返回计算结果。从多个文档聚合分组操作数值，并可以执行多种对分组数据业务返回一个结果。 在SQL中的count(*)，使用group by 与mongodb的聚合是等效的。 对于MongoDB的聚合，使用的是aggregate()方法。</p><p>语法</p><p>aggregate()方法的基本语法如下<br><code>&gt;db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</code></p><p>例子：</p><p>在集合中有以下数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902c)</span><br><span class="line">   title: &apos;MongoDB Overview&apos;, </span><br><span class="line">   description: &apos;MongoDB is no sql database&apos;,</span><br><span class="line">   by_user: &apos;Yiibai Yiibai &apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 100</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902d)</span><br><span class="line">   title: &apos;NoSQL Overview&apos;, </span><br><span class="line">   description: &apos;No sql database is very fast&apos;,</span><br><span class="line">   by_user: &apos;Yiibai Yiibai&apos;,</span><br><span class="line">   url: &apos;http://www.yiibai.com&apos;,</span><br><span class="line">   tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 10</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">   _id: ObjectId(7df78ad8902e)</span><br><span class="line">   title: &apos;Neo4j Overview&apos;, </span><br><span class="line">   description: &apos;Neo4j is no sql database&apos;,</span><br><span class="line">   by_user: &apos;Neo4j&apos;,</span><br><span class="line">   url: &apos;http://www.neo4j.com&apos;,</span><br><span class="line">   tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;],</span><br><span class="line">   likes: 750</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>现在从上面的集合，如果想知道每一个用户编写的教程是多少，那么使用aggregate()方法，如下图所示的列表：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;])</span><br><span class="line">&#123;</span><br><span class="line">   &quot;result&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Yiibai Yiibai&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 2</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;_id&quot; : &quot;Neo4j&quot;,</span><br><span class="line">         &quot;num_tutorial&quot; : 1</span><br><span class="line">      &#125;</span><br><span class="line">   ],</span><br><span class="line">   &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><pre><code>用于上述用途将等效于sql查询： select by_user, count(*) from mycol group by by_user</code></pre><p>另外，在上述例子中，我们已经使用字段by_user进行分组并计算总和，也就是by_user 出现各个次数。一个列表中可用的聚集表达式。<br>    <img src="https://policx.github.io/post-images/1561132965786.png" alt></p><h4 id="MongoDB-复制"><a href="#MongoDB-复制" class="headerlink" title="MongoDB 复制"></a>MongoDB 复制</h4><p>复制是同步在多个服务器上的数据过程。复制提供了冗余和数据在不同的数据库服务器上的多个副本提高数据的可用性，复制防止在单个服务器上丢失数据库。 复制也可以从硬件故障和服务中断中恢复。带有数据的其他副本，可以选择其中一个灾难恢复，报告或备份。</p><h6 id="为什么要复制？"><a href="#为什么要复制？" class="headerlink" title="为什么要复制？"></a>为什么要复制？</h6><blockquote><pre><code>为了让数据安全数据的高（24*7）可用性灾难恢复无停机维护（如备份，索引重建，压缩）读取缩放（额外的副本来读取）副本集是透明的应用</code></pre></blockquote><h5 id="MongoDB复制的工作原理"><a href="#MongoDB复制的工作原理" class="headerlink" title="MongoDB复制的工作原理"></a>MongoDB复制的工作原理</h5><p>MongoDB通过使用副本集的复制来实现。副本集是一组承载同一个数据集的mongod实例。在副本的一个节点是接收所有的写操作主节点。所有的实例，次级，应用操作从主以便它们具有相同的数据集。副本集只能有一个主节点。</p><blockquote><pre><code>副本集是一组两个或更多个节点（通常至少3节点是必需的）。在副本集一个节点是主节点和其余的节点都是次要的。所有的数据复制是从主到次节点。在自动故障转移或维护时，选建立了主要和一个新的主节点被选择。故障节点的恢复后，再次加入副本集，并可以作为一个辅助节点。</code></pre></blockquote><p>mongodb复制的典型图如下图，其中客户端应用程序总是与主节点和主节点交互，然后将数据复制到辅助节点。<br><img src="https://policx.github.io/post-images/1561133216694.png" alt><br>副本集特征</p><ul><li>N个节点的集群</li><li>任何节点可为原发/主节点</li><li>所有的写操作进入到主节点</li><li>自动故障转移</li><li>自动恢复</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展。MongoDB是工作在集合和文档上一种概念。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python3 与 MySQL 之间的交互</title>
    <link href="http://yoursite.com/2018/05/02/pymysql/"/>
    <id>http://yoursite.com/2018/05/02/pymysql/</id>
    <published>2018-05-02T03:14:27.000Z</published>
    <updated>2019-07-03T16:17:14.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-PyMySQL？"><a href="#什么是-PyMySQL？" class="headerlink" title="什么是 PyMySQL？"></a>什么是 PyMySQL？</h2><p>PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。</p><p>PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。</p><a id="more"></a><h2 id="安装mysql模块"><a href="#安装mysql模块" class="headerlink" title="安装mysql模块"></a>安装mysql模块</h2><p>在文件中引入模块</p><p><code>import pymysql</code></p><h3 id="1-Connection对象"><a href="#1-Connection对象" class="headerlink" title="1.Connection对象"></a>1.Connection对象</h3><p>•  用于建立与数据库的连接<br>•  创建对象：调用connect()方法<br>conn=connect(参数列表)<br>•  参数host：连接的mysql主机，如果本机是’localhost’<br>•  参数port：连接的mysql主机的端口，默认是3306<br>•  参数db：数据库的名称<br>•  参数user：连接的用户名<br>•  参数password：连接的密码<br>•  参数charset：通信采用的编码方式，默认是’gb2312’，要求与数据库创建时指定的编码一致，否则中文会乱码</p><h3 id="2-对象的方法"><a href="#2-对象的方法" class="headerlink" title="2.对象的方法"></a>2.对象的方法</h3><p>•  close()关闭连接<br>•  commit()事务，所以需要提交才会生效<br>•  rollback()事务，放弃之前的操作<br>•  cursor()返回Cursor对象，用于执行sql语句并获得结果</p><h4 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h4><p>•  执行sql语句<br>•  创建对象：调用Connection对象的cursor()方法<br>cursor1=conn.cursor()</p><h4 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h4><p>•  close()关闭<br>•  execute(operation [, parameters ])执行语句，返回受影响的行数<br>•  fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组<br>•  next()执行查询语句时，获取当前行的下一行<br>•  fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回<br>•  scroll(value[,mode])将行指针移动到某个位置<br>•  mode表示移动的方式<br>•  mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动。相对的<br>•  mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0，绝对的。</p><h4 id="举个例子便于理解"><a href="#举个例子便于理解" class="headerlink" title="举个例子便于理解"></a>举个例子便于理解</h4><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 导入python操作mysql的模块</span></span><br><span class="line"><span class="hljs-keyword">import</span> pymysql</span><br><span class="line"><span class="hljs-comment"># 获取连接对象</span></span><br><span class="line">conn = pymysql.connect(host=<span class="hljs-string">'127.0.0.1'</span>, user=<span class="hljs-string">'root'</span>, password=<span class="hljs-string">'123456'</span>, database=<span class="hljs-string">'python01'</span>, port=<span class="hljs-number">3306</span>, charset=<span class="hljs-string">'utf8'</span>)</span><br><span class="line"><span class="hljs-comment"># 获取执行工具</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"><span class="hljs-comment"># sql语句,增删改</span></span><br><span class="line"><span class="hljs-comment">#sql = 'select birthday from t_user'</span></span><br><span class="line">sql = <span class="hljs-string">'select id,name,pwd,birthday from t_user'</span></span><br><span class="line"><span class="hljs-comment"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span></span><br><span class="line">count = cur.execute(sql)</span><br><span class="line">print(<span class="hljs-string">'查询的结果有%s条数据'</span>%count)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#获取第一行</span></span><br><span class="line">dateOne = cur.fetchone()</span><br><span class="line">print(dateOne)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#向上移动一行</span></span><br><span class="line">cur.scroll(<span class="hljs-number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#向下移动一行</span></span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>)</span><br><span class="line"></span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>,mode=<span class="hljs-string">'absolute'</span>)   绝对的，这里指的是第一行</span><br><span class="line">cur.scroll(<span class="hljs-number">1</span>,mode=<span class="hljs-string">'relative'</span>)   相对的</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">#获取所有行的数据</span></span><br><span class="line">dataAll = cur.fetchall()</span><br><span class="line">print(dataAll)</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> dataAll:</span><br><span class="line">     print(temp)</span><br><span class="line">     print(dataAll[<span class="hljs-number">-1</span>][<span class="hljs-number">2</span>])      <span class="hljs-comment">#dataAll[-1]得到的是一个用户所有的信息，dataAll[-1][2]获取最后一个人的密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> cur:</span><br><span class="line">     print(temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="hljs-string">'id:%s,name:%s,pwd:%s,birthday:%s'</span></span><br><span class="line"><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> dataAll:</span><br><span class="line">    print(s%(temp[<span class="hljs-number">0</span>],temp[<span class="hljs-number">1</span>],temp[<span class="hljs-number">2</span>],temp[<span class="hljs-number">3</span>]))</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 关闭</span></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="3-对象的属性"><a href="#3-对象的属性" class="headerlink" title="3.对象的属性"></a>3.对象的属性</h3><p>•  rowcount只读属性，表示最近一次execute()执行后受影响的行数<br>•  connection获得当前连接对象</p><h3 id="2-增删改查-CRUD"><a href="#2-增删改查-CRUD" class="headerlink" title="2.增删改查(CRUD)"></a>2.增删改查(CRUD)</h3><h4 id="1-增"><a href="#1-增" class="headerlink" title="1.增"></a>1.增</h4><p>•  创建testInsert.py文件，向学生表中插入一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;insert into students(sname) values(&apos;张良&apos;)&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h4><p>•  创建testUpdate.py文件，修改学生表的一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;update students set sname=&apos;刘邦&apos; where id=6&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h4><p>•  创建testDelete.py文件，删除学生表的一条数据</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8 import pymysql</span><br><span class="line">try:</span><br><span class="line">  conn=pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">  cs1=conn.cursor()</span><br><span class="line">  count=cs1.execute(&quot;delete from students where id=6&quot;)</span><br><span class="line">  print(count)</span><br><span class="line">  conn.commit()</span><br><span class="line">  cs1.close()</span><br><span class="line">  conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">  print(e)</span><br></pre></td></tr></table></figure><h4 id="4-查"><a href="#4-查" class="headerlink" title="4.查"></a>4.查</h4><p>•  创建testSelectOne.py文件，查询一条学生信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Pymysql try:</span><br><span class="line">conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">cur=conn.cursor()</span><br><span class="line">cur.execute(&apos;select * from students where id=7&apos;)</span><br><span class="line">result=cur.fetchone()</span><br><span class="line">print result</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p>•  创建testSelectMany.py文件，查询全部学生信息</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf8 import Pymysql</span><br><span class="line">try:</span><br><span class="line">conn=Pymysql.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">cur=conn.cursor()</span><br><span class="line">cur.execute(&apos;select * from students&apos;)</span><br><span class="line">result=cur.fetchall()</span><br><span class="line">print result</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br><span class="line">except Exception as e:</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><h3 id="实例一：参数"><a href="#实例一：参数" class="headerlink" title="实例一：参数"></a>实例一：参数</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 获取连接对象</span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)</span><br><span class="line"># 获取执行工具</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"># sql语句,增删改，sql注入</span><br><span class="line">sql = &apos;insert into t_user(name,pwd,birthday) values(%s,%s,%s)&apos;</span><br><span class="line"># 参数列表</span><br><span class="line">name = input(&apos;输入姓名:&apos;)</span><br><span class="line">pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">birthday = input(&apos;输入生日:&apos;)     # 2017年10月01日--&gt;日期struct_time(---&gt;2017-10-01)</span><br><span class="line">birthday = time.strptime(birthday,&apos;%Y年%m月%d日&apos;)      #这里我们就用到了时间与字符串的相互转换(详情见MySQL高级)</span><br><span class="line"></span><br><span class="line">params = [name,pwd,birthday]</span><br><span class="line"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">count = cur.execute(sql,params)</span><br><span class="line">#提交</span><br><span class="line">conn.commit()</span><br><span class="line">print(&apos;受影响的行数:%s&apos;%count)</span><br><span class="line"># 关闭</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="实例二：抛出异常"><a href="#实例二：抛出异常" class="headerlink" title="实例二：抛出异常"></a>实例二：抛出异常</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    conn = None</span><br><span class="line">    cur = None</span><br><span class="line">    # 获取连接对象</span><br><span class="line">    conn = pymysql.connect(host=&apos;127.0.0.1&apos;,</span><br><span class="line">                           user=&apos;root&apos;,</span><br><span class="line">                           password=&apos;123456&apos;,</span><br><span class="line">                           database=&apos;python01&apos;,</span><br><span class="line">                           port=3306,</span><br><span class="line">                           charset=&apos;utf8&apos;)</span><br><span class="line">    # 模拟异常</span><br><span class="line">    # a = 1 / 0</span><br><span class="line">    # 获取执行工具</span><br><span class="line">    cur = conn.cursor()</span><br><span class="line">    # sql语句,增删改</span><br><span class="line">    sql = &apos;insert into t_user(name,pwd,birthday) values(&quot;小伊&quot;,&quot;123456&quot;,str_to_date(&quot;2017年10月20日&quot;,&quot;%Y年%m月%d日&quot;))&apos;</span><br><span class="line">    # 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">    count = cur.execute(sql)</span><br><span class="line">    # 提交</span><br><span class="line">    conn.commit()</span><br><span class="line">    print(&apos;受影响的行数:%s&apos; % count)</span><br><span class="line">except Exception as ex:</span><br><span class="line">    # 打印异常信息，测试时候使用，项目上线，去掉</span><br><span class="line">    print(str(ex))</span><br><span class="line">    # 将异常继续抛出</span><br><span class="line">    # raise</span><br><span class="line">finally:</span><br><span class="line">    if cur != None:</span><br><span class="line">        cur.close()</span><br><span class="line">    if conn != None:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure><h3 id="实例三："><a href="#实例三：" class="headerlink" title="实例三："></a>实例三：</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 导入python操作mysql的模块</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 获取连接对象</span><br><span class="line">conn = pymysql.connect(host=&apos;127.0.0.1&apos;, user=&apos;root&apos;, password=&apos;123456&apos;, database=&apos;python01&apos;, port=3306, charset=&apos;utf8&apos;)</span><br><span class="line"># 获取执行工具</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"># sql语句,增删改</span><br><span class="line">#sql = &apos;select birthday from t_user&apos;</span><br><span class="line">sql = &apos;select id,name,pwd,birthday from t_user&apos;</span><br><span class="line"># 执行,返回值。如果是增删改，返回受影响的行数，如果是查询，返回查询的行数</span><br><span class="line">count = cur.execute(sql)</span><br><span class="line">print(&apos;查询的结果有%s条数据&apos;%count)</span><br><span class="line"></span><br><span class="line">#获取第一行</span><br><span class="line"># dateOne = cur.fetchone()</span><br><span class="line"># print(dateOne)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># for temp in cur:</span><br><span class="line">#     print(temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = &apos;id:%s,name:%s,pwd:%s,birthday:%s&apos;</span><br><span class="line">for temp in dataAll:</span><br><span class="line">    print(s%(temp[0],temp[1],temp[2],temp[3]))</span><br><span class="line"></span><br><span class="line"># 关闭</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h3><p>这个库的名字：mySqlHelper</p><p> python操作mysql进行增删改查的封装</p><pre><code>1、增删改，代码类似2、查询代码分析1、获取连接对象2、sql语句不同，参数不同3、获取执行对象    增删改    查询        1、fetchone        2、fetchall4、处理结果5、关闭</code></pre><h4 id="面向对象-建立类，封装属性和函数"><a href="#面向对象-建立类，封装属性和函数" class="headerlink" title="面向对象  建立类，封装属性和函数"></a>面向对象  建立类，封装属性和函数</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">class MysqlHelper:</span><br><span class="line">    &apos;&apos;&apos;python操作mysql的增删改查的封装&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, host, user, password, database, port=3306, charset=&apos;utf8&apos;):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        初始化参数</span><br><span class="line">        :param host:        主机</span><br><span class="line">        :param user:        用户名</span><br><span class="line">        :param password:    密码</span><br><span class="line">        :param database:    数据库</span><br><span class="line">        :param port:        端口号，默认是3306</span><br><span class="line">        :param charset:     编码，默认是utf8</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.database = database</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.charset = charset</span><br><span class="line"></span><br><span class="line">    def connect(self):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        获取连接对象和执行对象</span><br><span class="line">        :return:</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        self.conn = pymysql.connect(host=self.host,</span><br><span class="line">                                    user=self.user,</span><br><span class="line">                                    password=self.password,</span><br><span class="line">                                    database=self.database,</span><br><span class="line">                                    port=self.port,</span><br><span class="line">                                    charset=self.charset)</span><br><span class="line"></span><br><span class="line">        self.cur = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def fetchone(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">         根据sql和参数获取一行数据</span><br><span class="line">       :param sql:          sql语句</span><br><span class="line">       :param params:       sql语句对象的参数元组，默认值为None</span><br><span class="line">       :return:             查询的一行数据</span><br><span class="line">       &apos;&apos;&apos;</span><br><span class="line">        dataOne = None</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            if count != 0:</span><br><span class="line">                dataOne = self.cur.fetchone()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return dataOne</span><br><span class="line"></span><br><span class="line">    def fetchall(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">         根据sql和参数获取一行数据</span><br><span class="line">       :param sql:          sql语句</span><br><span class="line">       :param params:       sql语句对象的参数列表，默认值为None</span><br><span class="line">       :return:             查询的一行数据</span><br><span class="line">       &apos;&apos;&apos;</span><br><span class="line">        dataall = None</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            if count != 0:</span><br><span class="line">                dataall = self.cur.fetchall()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return dataall</span><br><span class="line"></span><br><span class="line">    def __item(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行增删改</span><br><span class="line">        :param sql:           sql语句</span><br><span class="line">        :param params:        sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:              受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        count = 0</span><br><span class="line">        try:</span><br><span class="line">            count = self.cur.execute(sql, params)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        finally:</span><br><span class="line">            self.close()</span><br><span class="line">        return count</span><br><span class="line"></span><br><span class="line">    def update(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行修改</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def insert(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行新增</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def delete(self, sql, params=None):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        执行删除</span><br><span class="line">        :param sql:     sql语句</span><br><span class="line">        :param params:  sql语句对象的参数列表，默认值为None</span><br><span class="line">        :return:        受影响的行数</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        return self.__item(sql, params)</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        关闭执行工具和连接对象</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        if self.cur != None:</span><br><span class="line">            self.cur.close()</span><br><span class="line">        if self.conn != None:</span><br><span class="line">            self.conn.close()</span><br></pre></td></tr></table></figure><h4 id="1-测试查询多条数据"><a href="#1-测试查询多条数据" class="headerlink" title="1.测试查询多条数据"></a>1.测试查询多条数据</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;select * from t_user where name = %s and id &gt; %s&apos;</span><br><span class="line"># params</span><br><span class="line">params = [&apos;小茗&apos;,1]</span><br><span class="line"># 执行</span><br><span class="line">data = helper.fetchall(sql, params)</span><br><span class="line"># 判断</span><br><span class="line">if data:</span><br><span class="line">    for temp in data:</span><br><span class="line">        print(temp)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;没有数据.&apos;)</span><br><span class="line"></span><br><span class="line">helper.close()</span><br></pre></td></tr></table></figure><h4 id="2-测试查询一条数据"><a href="#2-测试查询一条数据" class="headerlink" title="2.测试查询一条数据"></a>2.测试查询一条数据</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;select * from t_user where id = %s&apos;</span><br><span class="line">#sql = &apos;select * from t_user where id = 1&apos;</span><br><span class="line"># params</span><br><span class="line">params = [2]</span><br><span class="line"># 执行</span><br><span class="line">data = helper.fetchone(sql, params)</span><br><span class="line">#data = helper.fetchone(sql)</span><br><span class="line"># 判断</span><br><span class="line">if data:</span><br><span class="line">    print(data)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;没有数据.&apos;)</span><br></pre></td></tr></table></figure><h4 id="3-测试增删改"><a href="#3-测试增删改" class="headerlink" title="3.测试增删改"></a>3.测试增删改</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import mysqlHelper</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 初始化对象</span><br><span class="line">helper = mysqlHelper.MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line"># 连接</span><br><span class="line">helper.connect()</span><br><span class="line"># sql</span><br><span class="line">sql = &apos;update t_user set name =%s,pwd=%s,birthday=%s where id=%s&apos;</span><br><span class="line"># params</span><br><span class="line">id = input(&apos;输入编号:&apos;)</span><br><span class="line">name = input(&apos;输入姓名:&apos;)</span><br><span class="line">pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">birthday = time.strptime(input(&apos;输入生日:&apos;), &apos;%Y年%m月%d日&apos;)</span><br><span class="line">params = [name, pwd, birthday,id]</span><br><span class="line"># 执行</span><br><span class="line">count = helper.update(sql, params)</span><br><span class="line"># 判断</span><br><span class="line">if count:</span><br><span class="line">    print(&apos;操作成功.&apos;)</span><br><span class="line">else:  # None,False,0</span><br><span class="line">    print(&apos;操作失败.&apos;)</span><br></pre></td></tr></table></figure><h4 id="4-登录和注册"><a href="#4-登录和注册" class="headerlink" title="4.登录和注册"></a>4.登录和注册</h4><p>登录和注册的时候需要对密码进行加密</p><p>注意：</p><p>•  需要对密码进行加密<br>•  如果使用md5加密，则密码包含32个字符<br>•  如果使用sha1加密，则密码包含40个字符，这里使用这种方式</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table userinfos(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    uname varchar(20),</span><br><span class="line">    upwd char(40),</span><br><span class="line">    isdelete bit default 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">ret = doPwd(&apos;123&apos;)</span><br><span class="line">print(ret)</span><br><span class="line">结果：40bd001563085fc35165329ea1ff5c5ecbdbbeef</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">-- 插入如下数据，用户名为123,密码为123,这是sha1加密后的值</span><br><span class="line"></span><br><span class="line">insert into userinfos </span><br><span class="line">values(1,&apos;123&apos;,&apos;40bd001563085fc35165329ea1ff5c5ecbdbbeef&apos;,0);</span><br></pre></td></tr></table></figure><h4 id="登录与注册"><a href="#登录与注册" class="headerlink" title="登录与注册"></a>登录与注册</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from mysqlHelper import MysqlHelper</span><br><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    &apos;&apos;&apos;登录&apos;&apos;&apos;</span><br><span class="line">    name = input(&apos;输入用户名:&apos;)</span><br><span class="line">    pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">    #加密</span><br><span class="line">    pwd = doPwd(pwd)</span><br><span class="line"></span><br><span class="line">    helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line">    helper.connect()</span><br><span class="line">    sql = &apos;select * from t_user where name=%s and pwd=%s&apos;</span><br><span class="line">    params = [name, pwd]</span><br><span class="line">    data = helper.fetchone(sql, params)</span><br><span class="line">    if data:</span><br><span class="line">        print(&apos;登录成功.&apos;)</span><br><span class="line">    else:  # None,False,0</span><br><span class="line">        print(&apos;登录失败.&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def doPwd(pwd):</span><br><span class="line">    &apos;&apos;&apos;sha1编码&apos;&apos;&apos;</span><br><span class="line">    mysha1 = hashlib.sha1()</span><br><span class="line">    mysha1.update(pwd.encode(&apos;utf-8&apos;))</span><br><span class="line">    pwd = mysha1.hexdigest()</span><br><span class="line">    return pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def register():</span><br><span class="line">    &apos;&apos;&apos;注册&apos;&apos;&apos;</span><br><span class="line">    name = input(&apos;输入用户名:&apos;)</span><br><span class="line">    pwd = input(&apos;输入密码:&apos;)</span><br><span class="line">    # 加密</span><br><span class="line">    pwd = doPwd(pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    helper = MysqlHelper(&apos;127.0.0.1&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;python01&apos;)</span><br><span class="line">    helper.connect()</span><br><span class="line">    sql = &apos;insert into t_user(name,pwd) values(%s,%s)&apos;</span><br><span class="line">    params = [name, pwd]</span><br><span class="line">    count = helper.insert(sql, params)</span><br><span class="line">    if count:</span><br><span class="line">        print(&apos;操作成功.&apos;)</span><br><span class="line">    else:  # None,False,0</span><br><span class="line">        print(&apos;操作失败.&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    #register()</span><br><span class="line">    login()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-PyMySQL？&quot;&gt;&lt;a href=&quot;#什么是-PyMySQL？&quot; class=&quot;headerlink&quot; title=&quot;什么是 PyMySQL？&quot;&gt;&lt;/a&gt;什么是 PyMySQL？&lt;/h2&gt;&lt;p&gt;PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。&lt;/p&gt;
&lt;p&gt;PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Django笔记</title>
    <link href="http://yoursite.com/2018/04/18/django-bi-ji/"/>
    <id>http://yoursite.com/2018/04/18/django-bi-ji/</id>
    <published>2018-04-17T17:00:16.000Z</published>
    <updated>2019-07-03T16:19:13.818Z</updated>
    
    <content type="html"><![CDATA[<p>Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。</p><a id="more"></a><h2 id="一-版本选择"><a href="#一-版本选择" class="headerlink" title="一. 版本选择"></a>一. 版本选择</h2><p>Django 2.0.x 支持 Python 3.4, 3.5 和 3.6 （注意，不再支持 Python 2）   </p><h2 id="二-安装-Django"><a href="#二-安装-Django" class="headerlink" title="二. 安装 Django"></a><strong>二. 安装 Django</strong></h2><p><strong>2.1. 用 pip 来安装</strong></p><p><strong>2.1.1 需要先安装pip</strong></p><p>(1). Linux, Mac OSX, Windows 下都可用 get-pip.py 来安装<br>pip：<a href="https://pip.pypa.io/en/latest/installing.html" target="_blank" rel="noopener">https://pip.pypa.io/en/latest/installing.html</a>  </p><p>或者直接下载：<a href="https://bootstrap.pypa.io/get-pip.py" title="get-pip.py" target="_blank" rel="noopener">get-pip.py</a> 然后运行在终端运行 <strong>python get-pip.py 就可以安装 pip。</strong></p><p>Note: 也可以下载 pip 源码包，运行 <strong>python setup.py install</strong> 进行安装 </p><p><strong>2.1.2 利用 pip 安装 Django</strong></p><p><code>（sudo) pip install Django    或者(sudo) pip install Django==1.8.16 或者 pip install Django==1.11.8</code>    </p><p>如果想升级 pip 可以用： </p><pre><code>(sudo) pip install --upgrade pip</code></pre><p><strong>2.2. 下载源码安装</strong>  </p><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">https://www.djangoproject.com/download/</a></p><p>如果是源码包, 比如 django-1.11.8.tar.gz </p><p><strong>2.2.1 Linux 或 Mac 下</strong></p><pre><code>tar -xvf django-1.11.8.tar.gzcd django-1.11.8(sudo) python setup.py install</code></pre><h2 id="三-检查是否安装成功"><a href="#三-检查是否安装成功" class="headerlink" title="三. 检查是否安装成功"></a><strong>三. 检查是否安装成功</strong></h2><p>终端上输入 python ,点击 Enter，进行 python 环境</p><pre><code>&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 11, 8, &apos;final&apos;, 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()&apos;1.11.8&apos;</code></pre><p>如果运行后看到版本号，就证明安装成功了！ </p><h2 id="四-搭建多个互不干扰的开发环境（可选）"><a href="#四-搭建多个互不干扰的开发环境（可选）" class="headerlink" title="四. 搭建多个互不干扰的开发环境（可选）"></a><strong>四. 搭建多个互不干扰的开发环境（可选）</strong></h2><p>我们有的时候会发现，一个电脑上有多个项目，一个依赖 Django 1.8，另一个比较旧的项目又要用 Django 1.5，这时候怎么办呢？ </p><p>我们需要一个依赖包管理的工具来处理不同的环境。 </p><h3 id="4-1-虚拟环境依赖安装"><a href="#4-1-虚拟环境依赖安装" class="headerlink" title="4.1 虚拟环境依赖安装"></a>4.1 虚拟环境依赖安装</h3><p>开发会用 virtualenv 来管理多个开发环境 </p><p><strong>Linux/MacOS 下</strong></p><p>virtualenvwrapper 使得virtualenv变得更好用，所以我们一起安装了 </p><pre><code># 安装:(sudo) pip install virtualenv virtualenvwrapper</code></pre><p>修改~/.bash_profile或其它环境变量相关文件(如 .bashrc 或用 ZSH 之后的 .zshrc)，添加以下语句  </p><pre><code>export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspacesource /usr/local/bin/virtualenvwrapper.sh</code></pre><p>修改后使之立即生效(也可以重启终端使之生效)： </p><pre><code>source ~/.bash_profile</code></pre><h3 id="4-2-虚拟环境使用方法："><a href="#4-2-虚拟环境使用方法：" class="headerlink" title="4.2 虚拟环境使用方法："></a><strong>4.2 虚拟环境使用方法：</strong></h3><p><strong>mkvirtualenv zqxt：创建运行环境zqxt</strong></p><p><strong>workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境</strong></p><p><strong>deactivate</strong>: 退出终端环境</p><p><strong>其它的：</strong></p><p><strong>rmvirtualenv</strong> ENV：删除运行环境ENV </p><p><strong>mkproject</strong> mic：创建mic项目和运行环境mic </p><p><strong>mktmpenv</strong>：创建临时运行环境 </p><p><strong>lsvirtualenv</strong>: 列出可用的运行环境 </p><p><strong>lssitepackages</strong>: 列出当前环境安装了的包 </p><p>创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django是一个开放源代码的Web应用框架，由Python写成。采用了MTV的框架模式，即模型M，视图V和模版T。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Django部署——uwsgi+Nginx</title>
    <link href="http://yoursite.com/2018/04/17/django/"/>
    <id>http://yoursite.com/2018/04/17/django/</id>
    <published>2018-04-17T09:42:04.000Z</published>
    <updated>2019-07-03T15:53:09.735Z</updated>
    
    <content type="html"><![CDATA[<p>用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了!</p><a id="more"></a><p><img src="https://policx.github.io/post-images/1560768371650.png" alt><br>环境：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3.6</span><br><span class="line">centos 7</span><br><span class="line">Django1.11</span><br></pre></td></tr></table></figure><h2 id="1、本地跑起来Django"><a href="#1、本地跑起来Django" class="headerlink" title="1、本地跑起来Django"></a>1、本地跑起来Django</h2><p>这里不讲Django项目实施过程，假设你已经写了一个Django项目，并且在本地127.0.0.1:8000能够跑起来。喏，给你个参考，项目大概长这样：<br><img src="https://policx.github.io/post-images/1560764670814.png" alt></p><ul><li>kindle目录为我创建的Django App</li></ul><h2 id="2、修改项目配置"><a href="#2、修改项目配置" class="headerlink" title="2、修改项目配置"></a>2、修改项目配置</h2><p>也就是项目目录下的settings.py文件，主要强调几个地方：</p><p>①关闭DEBUG模式：<br><img src="https://policx.github.io/post-images/1560764736238.png" alt><br>②修改ALLOWED_HOSTS：<br><img src="https://policx.github.io/post-images/1560764863424.png" alt><br>③配置静态文件存放路径：<br><img src="https://policx.github.io/post-images/1560764833026.png" alt></p><p>修改好配置之后执行:<br><code>python manage.py collectstatic</code><br>将项目用到的静态文件复制到项目根目录下的static文件中<br><img src="https://policx.github.io/post-images/1560764930146.png" alt></p><h2 id="3、安装uwsgi和Nginx"><a href="#3、安装uwsgi和Nginx" class="headerlink" title="3、安装uwsgi和Nginx"></a>3、安装uwsgi和Nginx</h2><p>这个没什么说的。。。在自己的云服务器上装好这两个工具<br>安装好uwsgi后最好验证一下，验证方法：<br>创建一个test.py文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;, &apos;text/html&apos;)])</span><br><span class="line">    return [b&apos;Hello world!&apos;]    #python3</span><br><span class="line">    # return [&apos;Hello world!&apos;]    #python2</span><br></pre></td></tr></table></figure><p>启动uwsgi服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :8000 --wsgi-file test.py</span><br></pre></td></tr></table></figure><p>如果可以正常启动而不报错那就应该没问题，不放心的话再在终端验证一下：<br><code>wget http://127.0.0.1:8000</code><br>看一下能否正确获取内容</p><h2 id="4、配置项目的uwsgi"><a href="#4、配置项目的uwsgi" class="headerlink" title="4、配置项目的uwsgi"></a>4、配置项目的uwsgi</h2><p>在项目所在文件夹下创建uwsgi.ini配置文件，也就是这里:<br><img src="https://policx.github.io/post-images/1560765049955.png" alt><br>在uwsgi.ini里进行如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># Django-related settings</span><br><span class="line"> </span><br><span class="line"># 这里的端口可以根据自己需要设定</span><br><span class="line">socket = 127.0.0.1:8001        </span><br><span class="line"> </span><br><span class="line"># the base directory (full path)</span><br><span class="line"># 这个是Django项目的根目录，也就是包含App的那个目录，仔细对照上图</span><br><span class="line">chdir           = /home/python/book2kindle</span><br><span class="line"> </span><br><span class="line"># Django s wsgi file</span><br><span class="line"># 这里是项目名(不是App名).wsgi</span><br><span class="line">module          = book2kindle.wsgi</span><br><span class="line"> </span><br><span class="line"># process-related settings</span><br><span class="line"># master</span><br><span class="line">master          = true</span><br><span class="line"> </span><br><span class="line"># maximum number of worker processes</span><br><span class="line">processes       = 32</span><br><span class="line"> </span><br><span class="line"># ... with appropriate permissions - may be needed</span><br><span class="line"># chmod-socket    = 664</span><br><span class="line"># clear environment on exit</span><br><span class="line">vacuum          = true</span><br><span class="line"> </span><br><span class="line">plugin python = true</span><br><span class="line"> </span><br><span class="line"># 这个是项目的虚拟python环境，如果没用虚拟环境，可以不设定</span><br><span class="line">home = /home/python/book2kindle_env</span><br></pre></td></tr></table></figure><h2 id="5、配置项目的nginx"><a href="#5、配置项目的nginx" class="headerlink" title="5、配置项目的nginx"></a>5、配置项目的nginx</h2><p>找到nginx的配置文件夹，centos7的nginx配置文件在/etc/nginx下，该路径下有一个nginx.conf总配置文件，还有两个文件夹./conf.d、./default.d，我们将nginx.conf复制一份到conf.d文件夹下，命名为nginx.conf（或者项目名.conf）进行如下修改（根据中文注释进行相应配置即可）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream django &#123;</span><br><span class="line">        # 注意这里的server要和uwsgi.ini配置文件中的socket保持一致</span><br><span class="line">        server 127.0.0.1:8002; # for a web port socket</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  xxx.com;  # 这里填自己的域名或者服务器的ip（决定你今后访问网站的方式）</span><br><span class="line">        charset      utf-8;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line">        location / &#123;</span><br><span class="line">        root        /home/python/book2kindle/kindle;  # 这是Django App的路径</span><br><span class="line">            uwsgi_pass  django;</span><br><span class="line">            include     uwsgi_params; # the uwsgi_params file you installed</span><br><span class="line">        &#125;</span><br><span class="line">        location /static &#123;</span><br><span class="line">            # Django项目静态文件的路径</span><br><span class="line">            alias /home/python/book2kindle/static; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、启动uwsgi和nginx"><a href="#6、启动uwsgi和nginx" class="headerlink" title="6、启动uwsgi和nginx"></a>6、启动uwsgi和nginx</h2><p>进入uwsgi.ini文件夹下执行：<br><code>uwsgi --ini uwsgi.ini</code><br>在终端执行：<br><code>service nginx restart</code><br>然后就可以根据域名（前提是要将域名解析到服务器ip地址）或者服务器ip来访问网站了！</p><p>OK，完事！就是这么简单！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Django写了个小网站，只能在自己本地跑一跑！这怎么行？听说可以部署在云服务器上，这样别人就可以访问了!&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从零搭建博客 教程 Hexo GitHub</title>
    <link href="http://yoursite.com/2018/03/22/hexo-github/"/>
    <id>http://yoursite.com/2018/03/22/hexo-github/</id>
    <published>2018-03-22T11:33:10.000Z</published>
    <updated>2019-07-03T16:23:04.106Z</updated>
    
    <content type="html"><![CDATA[<p>快速、简洁且高效的博客框架</p><a id="more"></a><h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><ul><li>1.在GitHub创建个人仓库「名字必须是user.github.io」</li><li>2.本地安装Git（此处省略，文章底部有教程链接）</li><li>3.本地安装Node.js（此处省略，文章底部有教程链接）</li><li>4.本地安装Hexo</li><li>5.网站推送至github</li><li>6.github绑定域名</li><li>7.更换主题</li><li>8.Hexo高级个性化设置</li></ul><h1 id="编写博客"><a href="#编写博客" class="headerlink" title="编写博客"></a>编写博客</h1><ul><li>1.Hexo文章的开头</li><li>2.Hexo文章的内容</li><li>2.1MarkDown语法</li><li>2.2寻找图床</li></ul><h2 id="1-搭建博客"><a href="#1-搭建博客" class="headerlink" title="1.搭建博客"></a>1.搭建博客</h2><h3 id="1-1-本地安装Hexo"><a href="#1-1-本地安装Hexo" class="headerlink" title="1.1.本地安装Hexo"></a>1.1.本地安装Hexo</h3><p>下载安装Git与Node.js略过</p><h4 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h4><p><code>npm install hexo -g #-g表示全局安装, npm默认为当前项目安装</code></p><h4 id="2-Hexo基本命令"><a href="#2-Hexo基本命令" class="headerlink" title="2.Hexo基本命令:"></a>2.Hexo基本命令:</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo -g  #升级 </span><br><span class="line">hexo init &lt;folder&gt;  #执行init命令初始化hexo到你指定的目录</span><br><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo generate       #自动根据当前目录下文件,生成静态网页 hexo g</span><br><span class="line">hexo server         #运行本地服务 hexo s</span><br><span class="line">hexo clean          #清理</span><br><span class="line">hexo deploy         #部署 hexo d</span><br><span class="line"></span><br><span class="line">hexo server         #Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s      #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br></pre></td></tr></table></figure><p>最常用的是</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这个时候hexo s之后就可以在浏览器<br><code>http://localhost:4000/</code><br>这里看到hexo博客的基本样子了</p><h3 id="1-2-将网站推送至github"><a href="#1-2-将网站推送至github" class="headerlink" title="1.2.将网站推送至github"></a>1.2.将网站推送至github</h3><h4 id="1-首先在本地告诉退给谁"><a href="#1-首先在本地告诉退给谁" class="headerlink" title="1.首先在本地告诉退给谁"></a>1.首先在本地告诉退给谁</h4><p>打开本地博客本目录下的配置文件_config.yml<br>修改最后一行的配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/dongshuyan/dongshuyan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="2-上传github"><a href="#2-上传github" class="headerlink" title="2.上传github"></a>2.上传github</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>若执行hexo g出错则执行<br><code>npm install hexo --save</code><br>若执行hexo d出错则执行<br><code>npm install hexo-deployer-git --save</code><br>错误修正后再次执行hexo g和hexo d上传到服务器。<br>若未关联GitHub，执行hexo d时会提示输入GitHub账号用户名和密码，即:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username for &apos;https://github.com&apos;:</span><br><span class="line">password for &apos;https://github.com&apos;:</span><br></pre></td></tr></table></figure><p>输入你的github账号密码即可。<br>hexo d执行成功后便可通过<a href="https://xxx.github.io访问博客，看到的内容和http://localhost:4000相同。" target="_blank" rel="noopener">https://xxx.github.io访问博客，看到的内容和http://localhost:4000相同。</a></p><h4 id="3-记住github密码"><a href="#3-记住github密码" class="headerlink" title="3.记住github密码"></a>3.记住github密码</h4><p>在github添加ssh key后不需要每次更新博客再输入用户名和密码。首先检查本地是否包含ssh keys。如果存在则直接将ssh key添加到GitHub之中，否则新生成ssh key。</p><p>执行下述命令生成新的ssh key</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@exampl&quot;</span><br></pre></td></tr></table></figure><p>这里需要将<br><code>your_email@example.com</code><br>改成自己注册的GitHub邮箱地址。默认会在~/.ssh/id_rsa.pub中生成id_rsa和id_rsa.pub文件。</p><p>Mac下利用open ~/.ssh打开文件夹，打开id_rsa.pub文件，里面的信息即为ssh key，将此信息复制到GitHub的Add ssh key路径GitHub-&gt;Setting-&gt;SSH keys-&gt;add SSH key中即可。Title里填写任意标题，将复制的内容粘贴到key中，点击Add key完成添加即可记住密码。</p><p>此时本地博客内容便已关联到GitHub之中，本地博客改变之后，通过hexo g和hexo d便可更新到GitHub之中。</p><h3 id="1-3-github绑定域名"><a href="#1-3-github绑定域名" class="headerlink" title="1.3.github绑定域名"></a>1.3.github绑定域名</h3><p>如果你有自己的域名了<br>那么可以把博客与域名关联起来<br>这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析：<br><img src="https://mubu.com/document_image/a949feea-b9d8-4b58-aa3e-b1bca87ebabc-3316715.jpg" alt><br>然后再你本地博客文件夹下的source文件夹里添加一个文件，文件名为”CNAME”，内容为你的域名。<br>例如：<br>baidu.com<br>这里要求一个字符不差。</p><h3 id="1-4-更改主题（以Yilia为例）"><a href="#1-4-更改主题（以Yilia为例）" class="headerlink" title="1.4.更改主题（以Yilia为例）"></a>1.4.更改主题（以Yilia为例）</h3><p>安装yilia<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br>配置<br>修改hexo根目录下的 _config.yml ： theme: yilia</p><p>更新</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/yilia</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="1-5-Hexo-高级配置"><a href="#1-5-Hexo-高级配置" class="headerlink" title="1.5.Hexo 高级配置"></a>1.5.Hexo 高级配置</h3><p>详见<br>Hexo Yilia 高级配置大全</p><h2 id="2-编写博客"><a href="#2-编写博客" class="headerlink" title="2.编写博客"></a>2.编写博客</h2><h3 id="2-1-Hexo文章的开头"><a href="#2-1-Hexo文章的开头" class="headerlink" title="2.1.Hexo文章的开头"></a>2.1.Hexo文章的开头</h3><p>举例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">title: 从零搭建博客 教程 Hexo GitHub    #文章标题</span><br><span class="line">subtitle:                            #子标题</span><br><span class="line">#categories: 文章                     #文章分類目錄 可以省略    </span><br><span class="line">toc: true                            #目录 需要安装插件或者主题自带</span><br><span class="line">reward: true                         #打赏 需要安装插件或者主题自带</span><br><span class="line">declare: true                        #版权 需要安装插件或者主题自带</span><br><span class="line">date:                                #文章日期 2019/7/1</span><br><span class="line">header-img:                          #顶部背景图片</span><br><span class="line">tags:                                #标签</span><br><span class="line">- 自学</span><br><span class="line">- Blog</span><br><span class="line">- Original</span><br></pre></td></tr></table></figure><h4 id="2-2-Hexo文章的内容"><a href="#2-2-Hexo文章的内容" class="headerlink" title="2.2.Hexo文章的内容"></a>2.2.Hexo文章的内容</h4><h5 id="2-2-1markdown常用语法"><a href="#2-2-1markdown常用语法" class="headerlink" title="2.2.1markdown常用语法"></a>2.2.1<a href="https://www.policx.com/post/markdown/" target="_blank" rel="noopener">markdown常用语法</a></h5><p><a href="http://dongshuyan.com/2016/04/07/%E6%80%8E%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速、简洁且高效的博客框架&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Markdown 的设计哲学</title>
    <link href="http://yoursite.com/2018/03/22/markdown/"/>
    <id>http://yoursite.com/2018/03/22/markdown/</id>
    <published>2018-03-22T11:32:01.000Z</published>
    <updated>2019-07-03T16:24:40.539Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown<em>是什么</em>？</h4><h4 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a><em>谁</em>创造了它？</h4><h4 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><em>为什么</em>要使用它？</h4><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a><em>怎么</em>使用？</h4><h4 id="谁在用？"><a href="#谁在用？" class="headerlink" title="谁在用？"></a><em>谁</em>在用？</h4><h4 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h4></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。    </p><h3 id="2-谁创造了它？"><a href="#2-谁创造了它？" class="headerlink" title="2. 谁创造了它？"></a>2. <em>谁</em>创造了它？</h3><p>它由<a href="http://www.aaronsw.com/" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于（<em>2013年1月11日</em>）自杀,有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="noopener">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。    </p><p>他有着足以让你跪拜的人生经历：    </p><ul><li><strong>14岁</strong>参与RSS 1.0规格标准的制订。     </li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。   </li><li><strong>2005</strong>年创建<a href="http://infogami.org/" target="_blank" rel="noopener">Infogami</a>，之后与<a href="http://www.reddit.com/" target="_blank" rel="noopener">Reddit</a>合并成为其合伙人。   </li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。   </li><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。     </li><li><strong>2013</strong>年1月自杀身亡。    </li></ul><p><img src="https://github.com/younghz/Markdown/raw/master/resource/Aaron_Swartz.jpg" alt="Aaron Swartz"></p><p>天才都有早逝的归途。</p><h3 id="3-为什么要使用它？"><a href="#3-为什么要使用它？" class="headerlink" title="3. 为什么要使用它？"></a>3. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分：<br><strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题   "></a>一级标题   </h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题    </p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用  </p></blockquote><p>效果：</p><blockquote><p>区块引用  </p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{<br>    printf(“Hello, Markdown.”);<br>}    </p><p>代码区块：</p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}</code></pre><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p>*斜体*，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+*） 第一项<br>-（+*） 第二项<br>- （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项    </p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p><blockquote><p>[younghz的Markdown库](https:://github.com/younghz/Markdown “Markdown”)。</p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p>[younghz的Markdown库1][1]<br>[younghz的Markdown库2][2]<br>[1]:https:://github.com/younghz/Markdown “Markdown”<br>[2]:https:://github.com/younghz/Markdown “Markdown”    </p></blockquote><p>效果：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p><h4 id="4-10-反斜杠"><a href="#4-10-反斜杠" class="headerlink" title="4.10 反斜杠\"></a>4.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h4 id="4-11-符号’-’"><a href="#4-11-符号’-’" class="headerlink" title="4.11 符号’`’"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p><blockquote><p>`ctrl+a`</p></blockquote><p>效果：</p><blockquote><p><code>ctrl+a</code>    </p></blockquote><h4 id="5-谁在用？"><a href="#5-谁在用？" class="headerlink" title="5. 谁在用？"></a>5. <em>谁</em>在用？</h4><p>Markdown的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h4 id="6-尝试一下"><a href="#6-尝试一下" class="headerlink" title="6. 尝试一下"></a>6. 尝试一下</h4><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的dillinger.io评价也不错   </li><li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。    </li><li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的ReText不错。    </li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化 :)。</strong></p><hr><p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。<br>虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber]<br>(<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/" target="_blank" rel="noopener">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/</a> )。</p><hr><p>以上基本是所有traditonal markdown的语法。</p><h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p><p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p><table><thead><tr><th align="center">代码库</th><th>链接</th></tr></thead><tbody><tr><td align="center">MarkDown</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr><tr><td align="center">MarkDownCopy</td><td><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr></tbody></table><hr><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p><video src="http://structr.learn-anything.cn/video/道理/陈铭：像我这种老好人，根本没什么真朋友！不jue亲戚的人，根本没什么真亲戚！.mp4" width="320" height="180" controls="controls"></video> </p><p>关于其它扩展语法可参见具体工具的使用说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据类型和变量</title>
    <link href="http://yoursite.com/2018/03/01/python-type/"/>
    <id>http://yoursite.com/2018/03/01/python-type/</id>
    <published>2018-02-28T20:28:19.000Z</published>
    <updated>2019-07-03T16:26:05.094Z</updated>
    
    <content type="html"><![CDATA[<p>Python 数据类型和变量</p><a id="more"></a><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p><p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p><p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以单引号’或双引号”括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。如果’本身也是一个字符，那就可以用””括起来，比如”I’m OK”包含的字符是I，’，m，空格，O，K这6个字符。</p><p>如果字符串内部既包含’又包含”怎么办？可以用转义字符\来标识，比如：</p><p><code>&#39;I\&#39;m \&quot;OK\&quot;!&#39;</code><br>表示的字符串内容是：</p><p><code>I&#39;m &quot;OK&quot;!</code><br>转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\表示的字符就是\，可以在Python的交互式命令行用print()打印字符串看看：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m ok.&apos;)</span><br><span class="line">I&apos;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m learning\nPython.&apos;)</span><br><span class="line">I&apos;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&apos;\\\n\\&apos;)</span><br><span class="line"></span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r’’表示’’内部的字符串默认不转义，可以自己试试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用’’’…’’’的格式表示多行内容，可以自己试试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><p>上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为…，提示你可以接着上一行输入，注意…是提示符，不是代码的一部分：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────┐</span><br><span class="line">│Command Prompt - python                           _ □ x │</span><br><span class="line">├────────────────────────────────────────────────────────┤</span><br><span class="line">│&gt;&gt;&gt; print(&apos;&apos;&apos;line1                                      │</span><br><span class="line">│... line2                                               │</span><br><span class="line">│... line3&apos;&apos;&apos;)                                           │</span><br><span class="line">│line1                                                   │</span><br><span class="line">│line2                                                   │</span><br><span class="line">│line3                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│&gt;&gt;&gt; _                                                   │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">│                                                        │</span><br><span class="line">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>当输入完结束符<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果写成程序并存为.py文件，就是：</span><br></pre></td></tr></table></figure></p><p>print(‘’’line1<br>line2<br>line3’’’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多行字符串&apos;&apos;&apos;...&apos;&apos;&apos;还可以在前面加上r使用，请自行测试：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>print(r’’’hello,\n<br>world’’’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">### 布尔值</span><br><span class="line">布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True<br>True<br>False<br>False<br>3 &gt; 2<br>True<br>3 &gt; 5<br>False</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">布尔值可以用and、or和not运算。</span><br><span class="line"></span><br><span class="line">#### and运算是与运算，只有所有都为True，and运算结果才是True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True and True<br>True<br>True and False<br>False<br>False and False<br>False<br>5 &gt; 3 and 3 &gt; 1<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### or运算是或运算，只要其中有一个为True，or运算结果就是True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>True or True<br>True<br>True or False<br>True<br>False or False<br>False<br>5 &gt; 3 or 1 &gt; 3<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### not运算是非运算，它是一个单目运算符，把True变成False，False变成True：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>not True<br>False<br>not False<br>True<br>not 1 &gt; 2<br>True</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">布尔值经常用在条件判断中，比如：</span><br></pre></td></tr></table></figure><p>if age &gt;= 18:<br>    print(‘adult’)<br>else:<br>    print(‘teenager’)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">### 空值</span><br><span class="line">空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</span><br><span class="line"></span><br><span class="line">此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。</span><br><span class="line"></span><br><span class="line">### 变量</span><br><span class="line">变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</span><br><span class="line"></span><br><span class="line">变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：</span><br><span class="line"></span><br><span class="line">`a = 1`</span><br><span class="line">变量a是一个整数。</span><br><span class="line"></span><br><span class="line">`t_007 = &apos;T007&apos;`</span><br><span class="line">变量t_007是一个字符串。</span><br><span class="line"></span><br><span class="line">`Answer = True`</span><br><span class="line">变量Answer是一个布尔值True。</span><br><span class="line"></span><br><span class="line">在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>a = 123 # a是整数<br>print(a)<br>a = ‘ABC’ # a变为字符串<br>print(a)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</span><br></pre></td></tr></table></figure><p>int a = 123; // a是整数类型变量<br>a = “ABC”; // 错误：不能把字符串赋给整型变量</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">和静态语言相比，动态语言更灵活，就是这个原因。</span><br><span class="line"></span><br><span class="line">请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</span><br></pre></td></tr></table></figure><p>x = 10<br>x = x + 2</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</span><br><span class="line"></span><br><span class="line">最后，理解变量在计算机内存中的表示也非常重要。当我们写：</span><br><span class="line"></span><br><span class="line">`a = &apos;ABC&apos;`</span><br><span class="line">时，Python解释器干了两件事情：</span><br><span class="line"></span><br><span class="line">在内存中创建了一个&apos;ABC&apos;的字符串；</span><br><span class="line"></span><br><span class="line">在内存中创建了一个名为a的变量，并把它指向&apos;ABC&apos;。</span><br><span class="line"></span><br><span class="line">也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>a = ‘ABC’<br>b = a<br>a = ‘XYZ’<br>print(b)</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> Run</span><br><span class="line">最后一行打印出变量b的内容到底是&apos;ABC&apos;呢还是&apos;XYZ&apos;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&apos;XYZ&apos;，但实际上b的值是&apos;ABC&apos;，让我们一行一行地执行代码，就可以看到到底发生了什么事：</span><br><span class="line"></span><br><span class="line">执行a = &apos;ABC&apos;，解释器创建了字符串&apos;ABC&apos;和变量a，并把a指向&apos;ABC&apos;：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923791878255456/0)</span><br><span class="line"></span><br><span class="line">执行b = a，解释器创建了变量b，并把b指向a指向的字符串&apos;ABC&apos;：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923792058613440/0)</span><br><span class="line"></span><br><span class="line">执行a = &apos;XYZ&apos;，解释器创建了字符串&apos;XYZ&apos;，并把a的指向改为&apos;XYZ&apos;，但b并没有更改：</span><br><span class="line"></span><br><span class="line">![](https://www.liaoxuefeng.com/files/attachments/923792191637760/0)</span><br><span class="line"></span><br><span class="line">所以，最后打印变量b的结果自然是&apos;ABC&apos;了。</span><br><span class="line"></span><br><span class="line">### 常量</span><br><span class="line">所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：</span><br><span class="line"></span><br><span class="line">`PI = 3.14159265359`</span><br><span class="line">但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。</span><br><span class="line"></span><br><span class="line">最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 / 3<br>3.3333333333333335</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>9 / 3<br>3.0</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还有一种除法是//，称为地板除，两个整数的除法仍然是整数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 // 3<br>3</p></blockquote></blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。</span><br><span class="line"></span><br><span class="line">因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>10 % 3<br>1</p><pre><code>无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。</code></pre></blockquote></blockquote></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p><p>对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。<br>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 数据类型和变量&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字典、列表、数组和字符串</title>
    <link href="http://yoursite.com/2018/02/16/python/"/>
    <id>http://yoursite.com/2018/02/16/python/</id>
    <published>2018-02-16T04:28:24.000Z</published>
    <updated>2019-07-03T16:27:25.479Z</updated>
    
    <content type="html"><![CDATA[<p>Python 字典、列表、数组和字符串</p><a id="more"></a><p>字典</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">dict_1 = &#123;<span class="hljs-string">'1'</span>: <span class="hljs-string">'a'</span>, <span class="hljs-string">'2'</span>: <span class="hljs-string">'b'</span>, <span class="hljs-string">'3'</span>: <span class="hljs-string">'c'</span>&#125;</span><br><span class="line">print(dict_1)  <span class="hljs-comment"># 打印字典</span></span><br><span class="line">print(type(dict_1))  <span class="hljs-comment"># 打印新赋值的字典的类型</span></span><br><span class="line">print(str(dict_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把字典转化成字符串后打印</span></span><br><span class="line">print(tuple(dict_1), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把字典转化为元组后打印</span></span><br><span class="line">print(list(dict_1), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把字典转化为列表后打印</span></span><br></pre></td></tr></table></figure><p>元组</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">tuple_1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span><br><span class="line">print(tuple_1)  <span class="hljs-comment"># 打印元组</span></span><br><span class="line">print(type(tuple_1))  <span class="hljs-comment"># 打印新赋值的元祖的类型</span></span><br><span class="line">print(str(tuple_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把元组转化成字符串后打印</span></span><br><span class="line">print(list(tuple_1), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把元组转化为列表后打印</span></span><br></pre></td></tr></table></figure><h3 id="元组不可转化为字典"><a href="#元组不可转化为字典" class="headerlink" title="元组不可转化为字典"></a>元组不可转化为字典</h3><p>列表</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">list_1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]</span><br><span class="line">print(list_1)  <span class="hljs-comment"># 打印列表</span></span><br><span class="line">print(type(list_1))  <span class="hljs-comment"># 打印新赋值的列表的类型</span></span><br><span class="line">print(str(list_1), end=<span class="hljs-string">'字符串\n'</span>)  <span class="hljs-comment"># 把列表转化成字符串后打印</span></span><br><span class="line">print(tuple(list_1), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把列表转化为元组后打印</span></span><br></pre></td></tr></table></figure><h3 id="元组不可转化为字典-1"><a href="#元组不可转化为字典-1" class="headerlink" title="元组不可转化为字典"></a>元组不可转化为字典</h3><p>字符串</p><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">string_1 = <span class="hljs-string">'(1, 2, 3, 4, 5)'</span></span><br><span class="line">print(string_1)  <span class="hljs-comment"># 打印字符串</span></span><br><span class="line">print(type(string_1))  <span class="hljs-comment"># 打印新赋值的字符串</span></span><br><span class="line">print(tuple(eval(string_1)), end=<span class="hljs-string">'元组\n'</span>)  <span class="hljs-comment"># 把字符串转化成元组后输出</span></span><br><span class="line">print(list(eval(string_1)), end=<span class="hljs-string">'列表\n'</span>)  <span class="hljs-comment"># 把字符串转化成列表后输出</span></span><br></pre></td></tr></table></figure><h3 id="只有特殊字符串才能转化为字典"><a href="#只有特殊字符串才能转化为字典" class="headerlink" title="只有特殊字符串才能转化为字典"></a>只有特殊字符串才能转化为字典</h3><figure class="highlight python hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string_2 = <span class="hljs-string">'&#123;"name":"tom","age":6&#125;'</span></span><br><span class="line">print(string_2)  <span class="hljs-comment"># 打印新赋值的字符串</span></span><br><span class="line">print(type(string_2))  <span class="hljs-comment"># 打印新赋值的字符串的类型</span></span><br><span class="line">print(dict(eval(string_2)), end=<span class="hljs-string">'字典\n'</span>)  <span class="hljs-comment"># 把字符串转化为字典后打印</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 字典、列表、数组和字符串&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>大话Socket</title>
    <link href="http://yoursite.com/2018/02/06/socket/"/>
    <id>http://yoursite.com/2018/02/06/socket/</id>
    <published>2018-02-06T10:30:55.000Z</published>
    <updated>2019-07-03T16:28:13.576Z</updated>
    
    <content type="html"><![CDATA[<p>要了解Socket首先要了解 TCP，他们两个的关系可以说是：</p><p>Socket 是抽象出来的使用 TCP/UDP 的概念模型，屏蔽掉了晦涩的底层协议的实现，是一个接口。</p><a id="more"></a><p>最近看到了一张如此详细的 TCP 三次握手和四次挥手，打印一张放工位！摘自《图解网络硬件》249页 图5-11 《TCP的三次握手》<br><img src="https://camo.githubusercontent.com/23dfbddfdd1d08dfda64dc13436030d947ebd62b/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a7731663275646676363638706a32306d30306e6d343463" alt><br><img src="https://camo.githubusercontent.com/dc8cf3d1737ae2148250573fae94d2eea4eaba3d/687474703a2f2f7777312e73696e61696d672e636e2f6c617267652f36356534663165366a773166377532786a6f6361746a32306a383064627134362e6a7067" alt><br>所谓的X、X+1、Y、Y+1<br>对应于你收到了没、我收到了、你收到’我收到’没、我收到了不用回了,为什么用+1表示呢？那是因为前两个指的是一个人，后两个指的是一个人。<br>四组是三个连接，每个连接的序号依次是X、Y、Z。</p><p>TCP的连接过程就像两个人的对话：</p><p>想象一下，每次这俩儿人聊天，都要像下面这样一来一回三次，接下来他们才能【好好聊天了。。。】真是有点“作”。。。</p><p>我是客户端，树懒是服务端，演示三次握手、数据传输步骤<br><img src="https://camo.githubusercontent.com/83074c55d42ddfa4775100aed25d906410581346/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a77316632756467393761796d6a32306d38316d636b316c" alt><br>其实有个问题，为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>而这一设计，主要是因为“服务器不是你想关就能关”。。。</p><p>比如说两个热恋中的人正在QQ上发送一个传mp4格式的文件，</p><p>A说，我要下QQ了，</p><p>B说：我知道了，你下吧。</p><p>A说，那我关了，（想关）</p><p>但是当A尝试关闭QQ的时候，QQ弹窗说“正在传输文件，传输完成后自动关闭QQ？”</p><p>这时候A对B说，呀，正在传东西，等传完了，我就关吧。（不能关）</p><p>B说：行。既然关不掉，不行再聊会儿呗？</p><p>A：聊吧。。。传完了啊，下了啊（传输结束了–能关）</p><p>B：下吧。我也下了。。。</p><p>就是多了一个Finish报文。</p><p>或者简单点表示是这样的：<br><img src="https://camo.githubusercontent.com/770f483cf985366a20e6dafde1e355bc691f2041/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36346466643834396a77316632756a7067346235716a32307969317063716470" alt><br>图片演示了四次挥手，与三次握手相比，只多了一个被动方确认自身任务Finish的动作。<br><img src="https://camo.githubusercontent.com/101010aedc39b107a8615e6c26281e2e848dbbb1/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f36356534663165366a773166377532786a73676e386a32306a3630646b7461682e6a7067" alt><br>总结下相关的函数：</p><p>创建套接字</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket(af,type,protocol)</span><br></pre></td></tr></table></figure><p>建立地址和套接字的联系</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(sockid, local addr, addrlen)</span><br></pre></td></tr></table></figure><p>服务器端侦听客户端的请求</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen( Sockid ,quenlen)</span><br></pre></td></tr></table></figure><p>建立服务器/客户端的连接 (面向连接TCP）</p><p>客户端请求连接</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connect(sockid, destaddr, addrlen)</span><br></pre></td></tr></table></figure><p>服务器端等待从编号为Sockid的Socket上接收客户连接请求</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newsockid=accept(Sockid，Clientaddr, paddrlen)</span><br></pre></td></tr></table></figure><p>发送/接收数据</p><p>面向连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send(sockid, buff, bufflen) </span><br><span class="line">recv( )</span><br></pre></td></tr></table></figure><p>面向无连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendto(sockid,buff,…,addrlen) </span><br><span class="line">recvfrom( )</span><br></pre></td></tr></table></figure><p>释放套接字</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(sockid)</span><br></pre></td></tr></table></figure><p>至于为什么是三次握手，而不是二次握手，还有四次握手，可以看看下面的类比：</p><table><thead><tr><th>三次握手</th><th>二次握手</th><th>四次握手</th></tr></thead><tbody><tr><td><img src="https://camo.githubusercontent.com/9bf301327a629211d40aadd6e8ec65c80e242511/687474703a2f2f7777322e73696e61696d672e636e2f6c617267652f36356534663165366a77316637753536776678687a6a32307969317063337a762e6a7067" alt></td><td><img src="https://camo.githubusercontent.com/a6d5cce9b79a51f18b7c2f14b149f5416c1d5e3a/687474703a2f2f7777332e73696e61696d672e636e2f6c617267652f36356534663165366a7731663775347a6433306e706a323079693170637161642e6a7067" alt></td><td><img src="https://camo.githubusercontent.com/8f98f53f7acc4a9a8954c11b885a58f7a0d71a90/687474703a2f2f7777342e73696e61696d672e636e2f6c617267652f36356534663165366a7731663775347861736d61306a323079693170636163622e6a7067" alt></td></tr></tbody></table><p>参考：<a href="http://zhihu.com/question/24853633/answer/114872771" target="_blank" rel="noopener">知乎</a></p><p>三次握手的对话，也挺像这个的，哈哈：</p><ul><li>A: How are you?</li><li>B: I’m fine, thanks,and you?</li><li>A: I’m fine too.</li></ul><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要了解Socket首先要了解 TCP，他们两个的关系可以说是：&lt;/p&gt;
&lt;p&gt;Socket 是抽象出来的使用 TCP/UDP 的概念模型，屏蔽掉了晦涩的底层协议的实现，是一个接口。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码汇总</title>
    <link href="http://yoursite.com/2018/02/06/http/"/>
    <id>http://yoursite.com/2018/02/06/http/</id>
    <published>2018-02-06T08:32:20.000Z</published>
    <updated>2019-07-03T16:30:47.375Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP状态码</p><a id="more"></a><p><strong>HTTP状态码</strong>（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。</p><p>HTTP状态码的官方注册表由互联网号码分配局（Internet Assigned Numbers Authority）维护。</p><p>微软互联网信息服务 （Microsoft Internet Information Services）有时会使用额外的十进制子代码来获取更多具体信息，但是这些子代码仅出现在响应有效内容和文档中，而不是代替实际的HTTP状态代码。</p><!-- more --><table><thead><tr><th>编号</th><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>1️⃣❌❌</td><td>🔴🔴🔴</td><td>1xx消息 <p></p> 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</td></tr><tr><td>100</td><td>Continue</td><td>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td>102</td><td>Processing</td><td>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td>2️⃣❌❌</td><td>🔴🔴🔴</td><td>2xx成功 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</td></tr><tr><td>200</td><td>OK</td><td>请求已成功，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td>201</td><td>Created</td><td>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。</td></tr><tr><td>202</td><td>Accepted</td><td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<p></p>    如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<p></p>    由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td>205</td><td>Reset Content</td><td>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<p></p>    与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td>206</td><td>Partial Content</td><td>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<p></p>    该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。<p></p>    响应必须包含如下的头部域：<p></p>        Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<p></p>        Date ETag和／或Content-Location，假如同样的请求本应该返回200响应。<p></p>        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<p></p>    假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<p></p>    假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<p></p>    任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td>207</td><td>Multi-Status</td><td>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td>3️⃣❌❌</td><td>🔴🔴🔴</td><td>3xx重定向 <p></p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。<p></p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</td></tr><tr><td>300</td><td>Multiple Choices</td><td>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<p></p>    除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<p></p>    如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td>301</td><td>Moved Permanently</td><td>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<p></p>    新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<p></p>    注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</td></tr><tr><td>302</td><td>Found</td><td>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<p></p>    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<p></p>    注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td>303</td><td>See Other</td><td>对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<p></p>    新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<p></p>    注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td>304</td><td>Not Modified</td><td>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<p></p>    该响应必须包含以下的头信息：<p></p>        Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<p></p>        ETag和／或Content-Location，假如同样的请求本应返回200响应。<p></p>        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<p></p>    假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<p></p>    假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<p></p>    假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td>305</td><td>Use Proxy</td><td>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。<p></p>    注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td>306</td><td>Switch Proxy</td><td>在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<p></p>    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。<p></p>    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td>4️⃣❌❌</td><td>🔴🔴🔴</td><td>4xx客户端错误<p></p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<p></p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</td></tr><tr><td>400</td><td>Bad Request</td><td>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td>402</td><td>Payment Required</td><td>该状态码是为了将来可能的需求而预留的。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<p></p>    鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td>406</td><td>Not Acceptable</td><td>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<p></p>    除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td>409</td><td>Conflict</td><td>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<p></p>    冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td>410</td><td>Gone</td><td>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<p></p>    410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td>411</td><td>Length Required</td><td>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</td></tr><tr><td>412</td><td>Precondition Failed</td><td>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<p></p>    如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td>414</td><td>Request-URI Too Long</td><td>请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<p></p>        本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<p></p>        重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<p></p>        客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td>416</td><td>Requested Range Not Satisfiable</td><td>如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。<p></p>    假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。</td></tr><tr><td>417</td><td>Expectation Failed</td><td>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</td></tr><tr><td>418</td><td>I’m a teapot</td><td>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。</td></tr><tr><td>421</td><td>There are too many connections from your internet address</td><td>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td>422</td><td>Unprocessable Entity</td><td>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td></tr><tr><td>423</td><td>Locked</td><td>当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td>424</td><td>Failed Dependency</td><td>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td>425</td><td>Unordered Collection</td><td>在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。</td></tr><tr><td>426</td><td>Upgrade Required</td><td>客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td>449</td><td>Retry With</td><td>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td>5️⃣❌❌</td><td>🔴🔴🔴</td><td>5xx服务器错误 <p></p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。<p></p>这些状态码适用于任何响应方法。</td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。    注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td>506</td><td>Variant Also Negotiates</td><td>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td>507</td><td>Insufficient Storage</td><td>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）</td></tr><tr><td>509</td><td>Bandwidth Limit Exceeded</td><td>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td>510</td><td>Not Extended</td><td>获取资源所需要的策略并没有没满足。</td></tr></tbody></table><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP状态码&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端网络请求优化之 IP 测速排序方案</title>
    <link href="http://yoursite.com/2018/02/06/ip/"/>
    <id>http://yoursite.com/2018/02/06/ip/</id>
    <published>2018-02-06T08:17:03.000Z</published>
    <updated>2019-07-03T16:32:29.407Z</updated>
    
    <content type="html"><![CDATA[<p>IP 测速排序方案</p><a id="more"></a><h2 id="1-IP-测速排序方案的目的"><a href="#1-IP-测速排序方案的目的" class="headerlink" title="1. IP 测速排序方案的目的"></a>1. IP 测速排序方案的目的</h2><p>无论是从 Local DNS 解析域名，获取到 IP 列表，还是从第三方的 DNS 解析服务中，获取到域名对应的 IP 列表。我们获得多个 IP 后，总是想选取一个最优的 IP 使用，本文主要探讨如何在客户端探测 IP 的连接性以及连接速度，保证返回可用性最好的IP，以达到“IP优选”的目的。</p><h2 id="2-新浪开源的-httpdns-的-sdk-里的测速逻辑"><a href="#2-新浪开源的-httpdns-的-sdk-里的测速逻辑" class="headerlink" title="2. 新浪开源的 httpdns 的 sdk 里的测速逻辑"></a>2. 新浪开源的 httpdns 的 sdk 里的测速逻辑</h2><p>新浪开源一个 HTTPDNSLib ，里面包含了测速逻辑，GitHub地址如下：</p><ul><li><a href="https://github.com/CNSRE/HTTPDNSLib-for-iOS" target="_blank" rel="noopener">《HTTPDNSLib-for-iOS》</a></li><li><a href="https://github.com/CNSRE/HTTPDNSLib" target="_blank" rel="noopener">《HTTPDNSLib》</a></li></ul><h2 id="3-IP-测试实现原理"><a href="#3-IP-测试实现原理" class="headerlink" title="3. IP 测试实现原理"></a>3. IP 测试实现原理</h2><p>使用 linux socket connect 和 select 函数实现的。 基于以下原理：</p><ol><li>即使套接口是非阻塞的。如果连接的服务器在同一台主机上，那么在调用connect 建立连接时，连接通常会立即建立成功，我们必须处理这种情况。</li><li>源自Berkeley的实现(和Posix.1g)有两条与select 和非阻塞IO相关的规则：<br>A. 当连接建立成功时，套接口描述符变成可写；<br>B. 当连接出错时，套接口描述符变成既可读又可写。</li></ol><p>详细的测速实现如下，原理参考注释：</p><p>以 iOS 实现为例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//#define CYL_SOCKET_CONNECT_TIMEOUT 10 //单位秒</span><br><span class="line">//#define CYL_SOCKET_CONNECT_TIMEOUT_RTT 600000//10分钟 单位毫秒</span><br><span class="line"></span><br><span class="line">- (int)testSpeedOf:(NSString *)ip port:(int16_t)port &#123;</span><br><span class="line">   NSString *oldIp = ip;</span><br><span class="line">   //request time out</span><br><span class="line">   float rtt = 0.0;</span><br><span class="line">   //sock：将要被设置或者获取选项的套接字。</span><br><span class="line">   int s = 0;</span><br><span class="line">   struct sockaddr_in saddr;</span><br><span class="line">   saddr.sin_family = AF_INET;</span><br><span class="line">   // MARK: - 设置端口，这里需要根据需要自定义，默认是80端口。</span><br><span class="line">   saddr.sin_port = htons(port);</span><br><span class="line">   saddr.sin_addr.s_addr = inet_addr([ip UTF8String]);</span><br><span class="line">   //saddr.sin_addr.s_addr = inet_addr(&quot;1.1.1.123&quot;);</span><br><span class="line">   if( (s=socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, create socket failed.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   NSDate *startTime = [NSDate date];</span><br><span class="line">   NSDate *endTime;</span><br><span class="line">   //为了设置connect超时 把socket设置称为非阻塞</span><br><span class="line">   int flags = fcntl(s, F_GETFL,0);</span><br><span class="line">   fcntl(s,F_SETFL, flags | O_NONBLOCK);</span><br><span class="line">   //对于阻塞式套接字，调用connect函数将激发TCP的三次握手过程，而且仅在连接建立成功或者出错时才返回；</span><br><span class="line">   //对于非阻塞式套接字，如果调用connect函数会之间返回-1（表示出错），且错误为EINPROGRESS，表示连接建立，建立启动但是尚未完成；</span><br><span class="line">   //如果返回0，则表示连接已经建立，这通常是在服务器和客户在同一台主机上时发生。</span><br><span class="line">   int i = connect(s,(struct sockaddr*)&amp;saddr, sizeof(saddr));</span><br><span class="line">   if(i == 0) &#123;</span><br><span class="line">       //建立连接成功，返回rtt时间。 因为connect是非阻塞，所以这个时间就是一个函数执行的时间，毫秒级，没必要再测速了。</span><br><span class="line">       close(s);</span><br><span class="line">       return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   struct timeval tv;</span><br><span class="line">   int valopt;</span><br><span class="line">   socklen_t lon;</span><br><span class="line">   tv.tv_sec = CYL_SOCKET_CONNECT_TIMEOUT;</span><br><span class="line">   tv.tv_usec = 0;</span><br><span class="line">   </span><br><span class="line">   fd_set myset;</span><br><span class="line">   FD_ZERO(&amp;myset);</span><br><span class="line">   FD_SET(s, &amp;myset);</span><br><span class="line">   </span><br><span class="line">   // MARK: - 使用select函数，对套接字的IO操作设置超时。</span><br><span class="line">   /**</span><br><span class="line">    select函数</span><br><span class="line">    select是一种IO多路复用机制，它允许进程指示内核等待多个事件的任何一个发生，并且在有一个或者多个事件发生或者经历一段指定的时间后才唤醒它。</span><br><span class="line">    connect本身并不具有设置超时功能，如果想对套接字的IO操作设置超时，可使用select函数。</span><br><span class="line">    **/</span><br><span class="line">   int maxfdp = s+1;</span><br><span class="line">   int j = select(maxfdp, NULL, &amp;myset, NULL, &amp;tv);</span><br><span class="line">   </span><br><span class="line">   if (j == 0) &#123;</span><br><span class="line">       NSLog(@&quot;INFO:%s:%d, test rtt of (%@) timeout.&quot;,__FUNCTION__,__LINE__, oldIp);</span><br><span class="line">       rtt = CYL_SOCKET_CONNECT_TIMEOUT_RTT;</span><br><span class="line">       close(s);</span><br><span class="line">       return rtt;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   if (j &lt; 0) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       rtt = 0;</span><br><span class="line">       close(s);</span><br><span class="line">       return rtt;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">    对于select和非阻塞connect，注意两点：</span><br><span class="line">    [1] 当连接成功建立时，描述符变成可写； [2] 当连接建立遇到错误时，描述符变为即可读，也可写，遇到这种情况，可调用getsockopt函数。</span><br><span class="line">    **/</span><br><span class="line">   lon = sizeof(int);</span><br><span class="line">   //valopt 表示错误信息。</span><br><span class="line">   // MARK: - 测试核心逻辑，连接后，获取错误信息，如果没有错误信息就是访问成功</span><br><span class="line">   /*!</span><br><span class="line">    * //getsockopt函数可获取影响套接字的选项，比如SOCKET的出错信息</span><br><span class="line">    * (get socket option)</span><br><span class="line">    */</span><br><span class="line">   getsockopt(s, SOL_SOCKET, SO_ERROR, (void*)(&amp;valopt), &amp;lon);</span><br><span class="line">   //如果有错误信息：</span><br><span class="line">   if (valopt) &#123;</span><br><span class="line">       NSLog(@&quot;ERROR:%s:%d, select function error.&quot;,__FUNCTION__,__LINE__);</span><br><span class="line">       rtt = 0;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       endTime = [NSDate date];</span><br><span class="line">       rtt = [endTime timeIntervalSinceDate:startTime] * 1000;</span><br><span class="line">   &#125;</span><br><span class="line">   close(s);</span><br><span class="line">   return rtt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当出现错误的时候测试结果是速度是0，所以排序时不能简单地按照值大小排序，可以先删除速度为0的结果，或者将速度为零重置为超时时间，比如上面的 CYL_SOCKET_CONNECT_TIMEOUT_RTT 。避免错误IP为0，结果排序后排在前面。</p><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IP 测速排序方案&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO crash 自修复技术实现与原理解析</title>
    <link href="http://yoursite.com/2018/02/06/KVOcrash/"/>
    <id>http://yoursite.com/2018/02/06/KVOcrash/</id>
    <published>2018-02-06T07:44:53.000Z</published>
    <updated>2019-07-03T16:34:10.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>【前言】KVO API设计非常不合理，于是有很多的KVO三方库，比如 KVOController 用更优的API来规避这些crash，但是侵入性比较大，必须编码规范来约束所有人都要使用该方式。有没有什么更优雅，无感知的接入方式？</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>KVO crash 也是非常常见的 Crash 类型，在探讨 KVO crash 原因前，我们先来看一下传统的KVO写发：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#warning move this to top of .m file</span><br><span class="line">//#define MyKVOContext(A) static void * const A = (void*)&amp;A;</span><br><span class="line">static void * const MyContext = (void*)&amp;MyContext;</span><br><span class="line"></span><br><span class="line">#warning move this to viewdidload or init method </span><br><span class="line">   // KVO注册监听:</span><br><span class="line">   // _A 监听 _B  的 @&quot;keyPath&quot;  属性</span><br><span class="line">   //[self.B  addObserver: self.A forKeyPath:@&quot;keyPath&quot; options:NSKeyValueObservingOptionNew context:MyContext];</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">   // KVO反注册</span><br><span class="line">   [_B removeObserver:_A forKeyPath:@&quot;keyPath&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// KVO监听执行 </span><br><span class="line">#warning — please move this method to  the class of _A  </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">   if(context != MyContext) &#123;</span><br><span class="line">       [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   if(context == MyContext) &#123;</span><br><span class="line">   //if ([keyPath isEqualToString:@&quot;keyPath&quot;]) &#123;</span><br><span class="line">       id newKey = change[NSKeyValueChangeNewKey];</span><br><span class="line">       BOOL boolValue = [newKey boolValue];</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到如上的写发，大概我们就明白了 API 设计不合理的地方：</p><p>B 需要做的工作太多，B可能引起Crash的点也太多：</p><p>B 需要主动移除监听者的时机，否则就crash：</p><ul><li>B 在释放变为nil后，hook dealloc时机</li><li>A 在释放变为nil后 否则报错 Objective-C Thread 1: EXC_BAD_ACCESS (code=EXC_I386_GPFLT)</li></ul><p>KVO的被观察者dealloc时仍然注册着KVO导致的crash</p><p>B 不能移除监听者A的时机，否则就crash：</p><ul><li>B没有被A监听</li><li>B已经移除A的监听。</li></ul><p>添加KVO重复添加观察者或重复移除观察者（KVO 注册观察者与移除观察者不匹配）导致的crash。</p><p>采取的措施：</p><ul><li>B添加A监听的时候，避免重复添加，移除的时候避免重复移除。</li><li>B dealloc时及时移除 A</li><li>A dealloc时，让 B 移除A。</li><li>避免重复添加，避免重复移除。</li></ul><p>报错信息一览：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-01-24 16:08:54.100667+0800 BootingProtection[63487:29487624] *** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;&lt;CYLObserverView: 0x7fb287002fb0; frame = (0 0; 207 368); layer = &lt;CALayer: 0x604000039360&gt;&gt;: An -observeValueForKeyPath:ofObject:change:context: message was received but not handled.</span><br></pre></td></tr></table></figure><p>其他情况的crash</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;An instance 0x7f8827d21d20 of class XXXX was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x61000003db00&gt; (</span><br><span class="line">&lt;NSKeyValueObservance 0x61000025ae80: Observer: 0x7f882890b4c0, Key path: dataSource, Options: &lt;New: YES, Old: NO, Prior: NO&gt; Context: 0x10dfe7730, Property: 0x61000025b810&gt;</span><br><span class="line">)&apos;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">   0   CoreFoundation                      0x00000001102b0b0b __exceptionPreprocess + 171</span><br><span class="line">   1   libobjc.A.dylib                     0x00000001167eb141 objc_exception_throw + 48</span><br><span class="line">   2   CoreFoundation                      0x0000000110319625 +[NSException raise:format:] + 197</span><br><span class="line">   3   Foundation                          0x0000000111322b53 NSKVODeallocate + 294</span><br><span class="line">   4   UIKit                               0x00000001138ec544 __destroy_helper_block_.125 + 80</span><br><span class="line">   5   libsystem_blocks.dylib              0x00000001185a999d _Block_release + 111</span><br><span class="line">   6   UIKit                               0x00000001139bd187 -[UIViewAnimationBlockDelegate .cxx_destruct] + 43</span><br><span class="line">   7   libobjc.A.dylib                     0x00000001167e99bc _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</span><br><span class="line">   8   libobjc.A.dylib                     0x00000001167f5d34 objc_destructInstance + 129</span><br><span class="line">   9   libobjc.A.dylib                     0x00000001167f5d66 object_dispose + 22</span><br><span class="line">   10  libobjc.A.dylib                     0x00000001167ffb8e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">   11  CoreFoundation                      0x000000011021952d -[__NSDictionaryI dealloc] + 125</span><br><span class="line">   12  libobjc.A.dylib                     0x00000001167ffb8e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">   13  libobjc.A.dylib                     0x00000001168002fa _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 866</span><br><span class="line">   14  CoreFoundation                      0x00000001101ffe96 _CFAutoreleasePoolPop + 22</span><br><span class="line">   15  CoreFoundation                      0x000000011023baec __CFRunLoopRun + 2172</span><br><span class="line">   16  CoreFoundation                      0x000000011023b016 CFRunLoopRunSpecific + 406</span><br><span class="line">   17  GraphicsServices                    0x0000000118f1ea24 GSEventRunModal + 62</span><br><span class="line">   18  UIKit                               0x0000000113904134 UIApplicationMain + 159</span><br><span class="line">   19  HaiDiLao                            0x000000010d50b5ef main + 111</span><br><span class="line">   20  libdyld.dylib                       0x000000011856265d start + 1</span><br><span class="line">   21  ???                                 0x0000000000000001 0x0 + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><h2 id="防crash措施"><a href="#防crash措施" class="headerlink" title="防crash措施"></a>防crash措施</h2><p>于是有很多的KVO三方库，比如 KVOController 用更优的API来规避这些crash，但是侵入性比较大，必须编码规范来约束所有人都要使用该方式。有没有什么更优雅，无感知的接入方式？</p><p>那便是我们下面要讲的 KVO crash 防护机制。</p><p>我们可以对比下其他的一些KVO防护方案：</p><p>网络上有一些类似的方案，“大白健康系统”方案大致如下：</p><blockquote><p>KVO的被观察者dealloc时仍然注册着KVO导致的crash 的情况，可以将NSObject的dealloc swizzle， 在object dealloc的时候自动将其对应的kvodelegate所有和kvo相关的数据清空，然后将kvodelegate也置空。避免出现KVO的被观察者dealloc时仍然注册着KVO而产生的crash</p></blockquote><p>这样未免太过麻烦，我们可以借助第三方库 CYLDeallocBlockExecutor hook 任意一个对象的 dealloc 时机，然后在 dealloc 前进行我们需要进行的操作，因此也就不需要为 NSObject 加 flag 来进行全局的筛选。flag 效率非常底，影响 app 性能。</p><p>“大白健康系统”思路是建立一个delegate，观察者和被观察者通过delegate间接建立联系，由于没有demo源码，这种方案比较繁琐。可以考虑建立一个哈希表，用来保存观察者、keyPath的信息，如果哈希表里已经有了相关的观察者，keyPath信息，那么继续添加观察者的话，就不载进行添加，同样移除观察的时候，也现在哈希表中进行查找，如果存在观察者，keypath信息，那么移除，如果没有的话就不执行相关的移除操作。要实现这样的思路就需要用到methodSwizzle来进行方法交换。我这通过写了一个NSObject的cagegory来进行方法交换。示例代码如下：<br>下面是核心的swizzle方法：</p><table><thead><tr><th>原函数</th><th>swizzle后的函数</th></tr></thead><tbody><tr><td><code>addObserver:forKeyPath:options:context:</code></td><td><code>cyl_crashProtectaddObserver:forKeyPath:options:context:</code></td></tr><tr><td><code>removeObserver:forKeyPath:</code></td><td><code>cyl_crashProtectremoveObserver:forKeyPath:</code></td></tr><tr><td><code>removeObserver:forKeyPath:context:</code></td><td><code>cyl_crashProtectremoveObserver:forKeyPath:context</code></td></tr></tbody></table><blockquote></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)cyl_crashProtectaddObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context&#123;</span><br><span class="line"></span><br><span class="line">   if (!observer || !keyPath || keyPath.length == 0) &#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @synchronized (self) &#123;</span><br><span class="line">       NSInteger kvoHash = [self _cyl_crashProtectHash:observer :keyPath];</span><br><span class="line">       if (!self.KVOHashTable) &#123;</span><br><span class="line">           self.KVOHashTable = [NSHashTable hashTableWithOptions:NSPointerFunctionsStrongMemory];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if (![self.KVOHashTable containsObject:@(kvoHash)]) &#123;</span><br><span class="line">           [self.KVOHashTable addObject:@(kvoHash)];</span><br><span class="line">           [self cyl_crashProtectaddObserver:observer forKeyPath:keyPath options:options context:context];</span><br><span class="line">           [self cyl_willDeallocWithSelfCallback:^(__unsafe_unretained id observedOwner, NSUInteger identifier) &#123;</span><br><span class="line">               [observedOwner cyl_crashProtectremoveObserver:observer forKeyPath:keyPath context:context];</span><br><span class="line">           &#125;];</span><br><span class="line">           __unsafe_unretained typeof(self) unsafeUnretainedSelf = self;</span><br><span class="line">           [observer cyl_willDeallocWithSelfCallback:^(__unsafe_unretained id observerOwner, NSUInteger identifier) &#123;</span><br><span class="line">               [unsafeUnretainedSelf cyl_crashProtectremoveObserver:observerOwner forKeyPath:keyPath context:context];</span><br><span class="line">           &#125;];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cyl_crashProtectremoveObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context &#123;</span><br><span class="line">   //TODO:  加上 context 限制，防止父类、子类使用同一个keyPath。</span><br><span class="line">   [self cyl_crashProtectremoveObserver:observer forKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cyl_crashProtectremoveObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath&#123;</span><br><span class="line">   //TODO:  white list</span><br><span class="line">   if (!observer || !keyPath || keyPath.length == 0) &#123;</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br><span class="line">   @synchronized (self) &#123;</span><br><span class="line">       if (!observer) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       NSInteger kvoHash = [self _cyl_crashProtectHash:observer :keyPath];</span><br><span class="line">       NSHashTable *hashTable = [self KVOHashTable];</span><br><span class="line">       if (!hashTable) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       if ([hashTable containsObject:@(kvoHash)]) &#123;</span><br><span class="line">           [self cyl_crashProtectremoveObserver:observer forKeyPath:keyPath];</span><br><span class="line">           [hashTable removeObject:@(kvoHash)];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以模拟dealloc中不写removeObserver，同时也可以写，<br>同时也可以多次 addObserver、removeObserver 这样就完全不干扰我们平时的代码书写逻辑了。</p><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;【前言】KVO API设计非常不合理，于是有很多的KVO三方库，比如 KVOController 用更优的API来规避这些crash，但是侵入性比较大，必须编码规范来约束所有人都要使用该方式。有没有什么更优雅，无感知的接入方式？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>连续启动 crash 自修复技术实现与原理解析</title>
    <link href="http://yoursite.com/2018/02/06/crash/"/>
    <id>http://yoursite.com/2018/02/06/crash/</id>
    <published>2018-02-06T07:21:18.000Z</published>
    <updated>2019-07-03T15:52:56.291Z</updated>
    
    <content type="html"><![CDATA[<ul><li>前言</li><li>实现原理</li><li>优化：降低50%以上误报机率</li><li>对原有API设计的几点优化意见</li><li><ol><li>机制状态应当用枚举来做为API透出</li></ol></li><li><ol start="2"><li>关键数值应当做为初始化参数供用户设置</li></ol></li><li><ol start="3"><li>修复、上报逻辑应当支持用户异步操作</li></ol></li><li>什么时候会出现该异常？</li><li>连续启动 crash 自修复技术实现与原理解析</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><blockquote><p>如果 app 连续 crash 两次无法启动，用户往往会选择卸载。</p></blockquote><p>连续启动 crash 应该是 crash 类型中最严重的一类，该问题常常与数据库操作有关，比如：数据库损坏、服务端返回数据错误，存入数据库，app 读取时产生数组越界、找不到方法。</p><p>那么除了热修复，能否“自修复”该问题呢？</p><p>在微信读书团队发布的<a href="https://wereadteam.github.io/2016/05/23/GYBootingProtection/" target="_blank" rel="noopener">《iOS 启动连续闪退保护方案》</a> 一文中，给出了连续启动crash的自修复技术的思路讲解，并在GitHub上给出了技术实现，并开源了<a href="https://github.com/liuslevis/GYBootingProtection" target="_blank" rel="noopener"> GYBootingProtection</a>。方案思路很好，很轻量级。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><hr><p>在微信读书团队给出的文章中已经有比较详细的阐述，在此不做赘述，实现的流程图如下所示：<br><a href></a><br>但有个实现上可以优化下，可以降低50%以上误报机率，监听用户手动划掉 APP 这个事件，其中一些特定场景，是可以获取的。另外在这里也给出对其 API 设计的建议。最后给出优化后的实现。</p><h2 id="优化：降低50-以上误报机率"><a href="#优化：降低50-以上误报机率" class="headerlink" title="优化：降低50%以上误报机率"></a>优化：降低50%以上误报机率</h2><hr><p>用户主动 kill 掉 APP 分为两种情况：</p><ul><li>App在前台时用户手动划掉APP的时候</li><li>APP在后台时划掉APP</li></ul><p>第一种场景更为常见，可以通过监听 UIApplicationWillTerminateNotification 来捕获该动作，捕获后恢复计数。第二种情况，无法监听到。但也足以降低 50% 以上的误报机率。</p><h3 id="对原有API设计的几点优化意见"><a href="#对原有API设计的几点优化意见" class="headerlink" title="对原有API设计的几点优化意见"></a>对原有API设计的几点优化意见</h3><h4 id="1-机制状态应当用枚举来做为API透出"><a href="#1-机制状态应当用枚举来做为API透出" class="headerlink" title="1. 机制状态应当用枚举来做为API透出"></a>1. 机制状态应当用枚举来做为API透出</h4><p>该机制当前所处的状态，比如：NeedFix 、isFixing，建议用枚举来做为API透出。比如：</p><ul><li>APP 启动正常</li><li>正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值</li><li>APP 出现连续启动 Crash，需要采取修复措施</li><li>APP 出现连续启动 Crash，正在修复中</li></ul><h4 id="2-关键数值应当做为初始化参数供用户设置"><a href="#2-关键数值应当做为初始化参数供用户设置" class="headerlink" title="2. 关键数值应当做为初始化参数供用户设置"></a>2. 关键数值应当做为初始化参数供用户设置</h4><ul><li>当前启动Crash的状态</li><li>达到需要执行上报操作的“连续启动崩溃计数”个数。</li><li>达到需要执行修复操作的“连续启动崩溃计数”个数。</li><li>APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零</li></ul><h4 id="3-修复、上报逻辑应当支持用户异步操作"><a href="#3-修复、上报逻辑应当支持用户异步操作" class="headerlink" title="3. 修复、上报逻辑应当支持用户异步操作"></a>3. 修复、上报逻辑应当支持用户异步操作</h4><p><code>reportBlock</code> 上报逻辑，<br><code>repairtBlock</code> 修复逻辑</p><p>比如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^BoolCompletionHandler)(BOOL succeeded, NSError *error);</span><br><span class="line">typedef void (^RepairBlock)(ABSBoolCompletionHandler completionHandler);</span><br></pre></td></tr></table></figure><p>用户执行 BoolCompletionHandler 后即可知道是否执行完毕，并且支持异步操作。</p><p>异步操作带来的问题，可以通过前面提到的枚举API来实时监测状态，来决定各种其他操作。</p><h2 id="什么时候会出现该异常？"><a href="#什么时候会出现该异常？" class="headerlink" title="什么时候会出现该异常？"></a>什么时候会出现该异常？</h2><h3 id="连续启动-crash-自修复技术实现与原理解析"><a href="#连续启动-crash-自修复技术实现与原理解析" class="headerlink" title="连续启动 crash 自修复技术实现与原理解析"></a>连续启动 crash 自修复技术实现与原理解析</h3><p>下面给出优化后的代码实现：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  CYLBootingProtection.h</span><br><span class="line">//  </span><br><span class="line">//</span><br><span class="line">//  Created by ChenYilong on 18/01/10.</span><br><span class="line">//  Copyright © 2018年 ChenYilong. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">typedef void (^ABSBoolCompletionHandler)(BOOL succeeded, NSError *error);</span><br><span class="line">typedef void (^ABSRepairBlock)(ABSBoolCompletionHandler completionHandler);</span><br><span class="line">typedef void (^ABSReportBlock)(NSUInteger crashCounts);</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, BootingProtectionStatus) &#123;</span><br><span class="line">   BootingProtectionStatusNormal,  /**&lt;  APP 启动正常 */</span><br><span class="line">   BootingProtectionStatusNormalChecking,  /**&lt; 正在检测是否会在特定时间内是否会 Crash，注意：检测状态下“连续启动崩溃计数”个数小于或等于上限值 */</span><br><span class="line">   BootingProtectionStatusNeedFix, /**&lt; APP 出现连续启动 Crash，需要采取修复措施 */</span><br><span class="line">   BootingProtectionStatusFixing,   /**&lt; APP 出现连续启动 Crash，正在修复中... */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 启动连续 crash 保护。</span><br><span class="line">* 启动后 `_crashOnLaunchTimeIntervalThreshold` 秒内 crash，反复超过 `_continuousCrashOnLaunchNeedToReport` 次则上报日志，超过 `_continuousCrashOnLaunchNeedToFix` 则启动修复操作。</span><br><span class="line">*/</span><br><span class="line">@interface CYLBootingProtection : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 启动连续 crash 保护方法。</span><br><span class="line">* 前置条件：在 App 启动时注册 crash 处理函数，在 crash 时调用[CYLBootingProtection addCrashCountIfNeeded]。</span><br><span class="line">* 启动后一定时间内（`crashOnLaunchTimeIntervalThreshold`秒内）crash，反复超过一定次数（`continuousCrashOnLaunchNeedToReport`次）则上报日志，超过一定次数（`continuousCrashOnLaunchNeedToFix`次）则启动修复程序；在一定时间内（`crashOnLaunchTimeIntervalThreshold`秒） 秒后若没有 crash 将“连续启动崩溃计数”计数置零。</span><br><span class="line"> `reportBlock` 上报逻辑，</span><br><span class="line"> `repairtBlock` 修复逻辑，完成后执行 `[self setCrashCount:0]`</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">- (void)launchContinuousCrashProtect;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 当前启动Crash的状态</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, assign, readonly) BootingProtectionStatus bootingProtectionStatus;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 达到需要执行上报操作的“连续启动崩溃计数”个数。</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToReport;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 达到需要执行修复操作的“连续启动崩溃计数”个数。</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, assign, readonly) NSUInteger continuousCrashOnLaunchNeedToFix;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* APP 启动后经过多少秒，可以将“连续启动崩溃计数”清零</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, assign, readonly) NSTimeInterval crashOnLaunchTimeIntervalThreshold;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *context;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* @details 启动后kCrashOnLaunchTimeIntervalThreshold秒内crash，反复超过continuousCrashOnLaunchNeedToReport次则上报日志，超过continuousCrashOnLaunchNeedToFix则启动修复程序；当所有操作完成后，执行 completion。在 crashOnLaunchTimeIntervalThreshold 秒后若没有 crash 将 kContinuousCrashOnLaunchCounterKey 计数置零。</span><br><span class="line">* @param context 借助 context 可以让多个模块注册事件，并且事件 block 能独立执行，互不干扰。</span><br><span class="line">*/</span><br><span class="line">- (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport</span><br><span class="line">                          continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix</span><br><span class="line">                        crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold</span><br><span class="line">                                                   context:(NSString *)context;</span><br><span class="line">/*!</span><br><span class="line">* 当前“连续启动崩溃“的状态</span><br><span class="line">*/</span><br><span class="line">+ (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 设置上报逻辑，参数 crashCounts 为启动连续 crash 次数</span><br><span class="line">*/</span><br><span class="line">- (void)setReportBlock:(ABSReportBlock)reportBlock;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 设置修复逻辑</span><br><span class="line">*/</span><br><span class="line">- (void)setRepairBlock:(ABSRepairBlock)repairtBlock;</span><br><span class="line"></span><br><span class="line">+ (void)setLogger:(void (^)(NSString *))logger;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  CYLBootingProtection.m</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//  Created by ChenYilong on 18/01/10.</span><br><span class="line">//  Copyright © 2018年 ChenYilong. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;CYLBootingProtection.h&quot;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">static dispatch_queue_t _exceptionOperationQueue = 0;</span><br><span class="line">void (^Logger)(NSString *log);</span><br><span class="line"></span><br><span class="line">@interface CYLBootingProtection ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToReport;</span><br><span class="line">@property (nonatomic, assign) NSUInteger continuousCrashOnLaunchNeedToFix;</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval crashOnLaunchTimeIntervalThreshold;</span><br><span class="line">@property (nonatomic, copy) NSString *context;</span><br><span class="line">@property (nonatomic, copy) ABSReportBlock reportBlock;</span><br><span class="line">@property (nonatomic, copy) ABSRepairBlock repairBlock;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 设置“连续启动崩溃计数”个数</span><br><span class="line">*/</span><br><span class="line">- (void)setCrashCount:(NSInteger)count;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 设置“连续启动崩溃计数”个数</span><br><span class="line">*/</span><br><span class="line">+ (void)setCrashCount:(NSUInteger)count context:(NSString *)context;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* “连续启动崩溃计数”个数</span><br><span class="line">*/</span><br><span class="line">- (NSUInteger)crashCount;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* “连续启动崩溃计数”个数</span><br><span class="line">*/</span><br><span class="line">+ (NSUInteger)crashCountWithContext:(NSString *)context;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation CYLBootingProtection</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       _exceptionOperationQueue = dispatch_queue_create(&quot;com.ChenYilong.CYLBootingProtection.fileCacheQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)initWithContinuousCrashOnLaunchNeedToReport:(NSUInteger)continuousCrashOnLaunchNeedToReport</span><br><span class="line">                          continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix</span><br><span class="line">                        crashOnLaunchTimeIntervalThreshold:(NSTimeInterval)crashOnLaunchTimeIntervalThreshold</span><br><span class="line">                                                   context:(NSString *)context &#123;</span><br><span class="line">   if (!(self = [super init])) &#123;</span><br><span class="line">       return nil;</span><br><span class="line">   &#125;</span><br><span class="line">   _continuousCrashOnLaunchNeedToReport = continuousCrashOnLaunchNeedToReport;</span><br><span class="line">   _continuousCrashOnLaunchNeedToFix = continuousCrashOnLaunchNeedToFix;</span><br><span class="line">   _crashOnLaunchTimeIntervalThreshold = crashOnLaunchTimeIntervalThreshold;</span><br><span class="line">   _context = [context copy];</span><br><span class="line">   [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                            selector:@selector(applicationWillTerminate:)</span><br><span class="line">                                                name:UIApplicationWillTerminateNotification</span><br><span class="line">                                              object:[UIApplication sharedApplication]];</span><br><span class="line">   return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* App在前台时用户手动划掉APP的时候，不计入检测。</span><br><span class="line">* 但是APP在后台时划掉APP，无法检测出来。</span><br><span class="line">* 见：https://stackoverflow.com/a/35041565/3395008</span><br><span class="line">*/</span><br><span class="line">- (void)applicationWillTerminate:(NSNotification *)note &#123;</span><br><span class="line">   BOOL isNormalChecking = [self isNormalChecking];</span><br><span class="line">   if (isNormalChecking) &#123;</span><br><span class="line">       [self decreaseCrashCount];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">   [[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">支持同步修复、异步修复，两种修复方式</span><br><span class="line">- 异步修复，不卡顿主UI，但有修复未完成就被再次触发crash、或者用户kill掉的可能。需要用户手动根据修复状态，来选择性地进行操作，应该有回掉。</span><br><span class="line">- 同步修复，最简单直观，在主线程删除或者下载修复包。</span><br><span class="line">*/</span><br><span class="line">- (void)launchContinuousCrashProtect &#123;</span><br><span class="line">   NSAssert(_repairBlock, @&quot;_repairBlock is nil!&quot;);</span><br><span class="line">   [[self class] Logger:@&quot;CYLBootingProtection: Launch continuous crash report&quot;];</span><br><span class="line">   [self resetBootingProtectionStatus];</span><br><span class="line">   </span><br><span class="line">   NSUInteger launchCrashes = [self crashCount];</span><br><span class="line">   // 上报</span><br><span class="line">   if (launchCrashes &gt;= self.continuousCrashOnLaunchNeedToReport) &#123;</span><br><span class="line">       NSString *logString = [NSString stringWithFormat:@&quot;CYLBootingProtection: App has continuously crashed for %@ times. Now synchronize uploading crash report and begin fixing procedure.&quot;, @(launchCrashes)];</span><br><span class="line">       [[self class] Logger:logString];</span><br><span class="line">       if (_reportBlock) &#123;</span><br><span class="line">           dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">               _reportBlock(launchCrashes);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 修复</span><br><span class="line">   if ([self isUpToBootingProtectionCount]) &#123;</span><br><span class="line">       [[self class] Logger:@&quot;need to repair&quot;];</span><br><span class="line">       [self setIsFixing:YES];</span><br><span class="line">       if (_repairBlock) &#123;</span><br><span class="line">           ABSBoolCompletionHandler completionHandler = ^(BOOL succeeded, NSError *__nullable error)&#123;</span><br><span class="line">               if (succeeded) &#123;</span><br><span class="line">                   [self resetCrashCount];</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   [[self class] Logger:error.description];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">               _repairBlock(completionHandler);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       [self increaseCrashCount:launchCrashes];</span><br><span class="line">       // 正常流程，无需修复</span><br><span class="line">       [[self class] Logger:@&quot;need no repair&quot;];</span><br><span class="line">       </span><br><span class="line">       // 记录启动时刻，用于计算启动连续 crash</span><br><span class="line">       // 重置启动 crash 计数</span><br><span class="line">       dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.crashOnLaunchTimeIntervalThreshold * NSEC_PER_SEC)), dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">           // APP活过了阈值时间，重置崩溃计数</span><br><span class="line">           NSString *logString = [NSString stringWithFormat:@&quot;CYLBootingProtection: long live the app ( more than %@ seconds ), now reset crash counts&quot;, @(self.crashOnLaunchTimeIntervalThreshold)];</span><br><span class="line">           [[self class] Logger:logString];</span><br><span class="line">           [self resetCrashCount];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//减少计数的时机：用户手动划掉APP</span><br><span class="line">- (void)decreaseCrashCount &#123;</span><br><span class="line">   NSUInteger oldCrashCount = [self crashCount];</span><br><span class="line">   [self decreaseCrashCountWithOldCrashCount:oldCrashCount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)decreaseCrashCountWithOldCrashCount:(NSUInteger)oldCrashCount &#123;</span><br><span class="line">   dispatch_sync(_exceptionOperationQueue, ^&#123;</span><br><span class="line">       if (oldCrashCount &gt; 0) &#123;</span><br><span class="line">           [self setCrashCount:oldCrashCount-1];</span><br><span class="line">       &#125;</span><br><span class="line">       [self resetBootingProtectionStatus];</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重制计数的时机：修复完成、或者用户手动划掉APP</span><br><span class="line">- (void)resetCrashCount &#123;</span><br><span class="line">   [self setCrashCount:0];</span><br><span class="line">   [self resetBootingProtectionStatus];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//只在未达到计数上限时才会增加计数</span><br><span class="line">- (void)increaseCrashCount:(NSUInteger)oldCrashCount &#123;</span><br><span class="line">   dispatch_sync(_exceptionOperationQueue, ^&#123;</span><br><span class="line">       [self setIsNormalChecking:YES];</span><br><span class="line">       [self setCrashCount:oldCrashCount+1];</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resetBootingProtectionStatus &#123;</span><br><span class="line">   [self setIsNormalChecking:NO];</span><br><span class="line">   [self setIsFixing:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BootingProtectionStatus)bootingProtectionStatus &#123;</span><br><span class="line">   return [[self class] bootingProtectionStatusWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">*</span><br><span class="line">@attention 注意之所以要检查 `BootingProtectionStatusNormalChecking` 原因如下：</span><br><span class="line"></span><br><span class="line">`-launchContinuousCrashProtect` 方法与 `-bootingProtectionStatus` 方法，如果 `-launchContinuousCrashProtect` 先执行，那么会造成如下问题：</span><br><span class="line">假设n为上限，但crash（n-1）次，但是用 `-bootingProtectionStatus` 判断出来，当前已经处于n次了。原因如下：</span><br><span class="line"></span><br><span class="line">crash（n-1）次，正常流程，计数+1，变成n次，</span><br><span class="line">随后在检查 `-bootingProtectionStatus` 时，发现已经处于异常状态了，实际是正常状态。所以需要使用`BootingProtectionStatusNormalChecking` 来进行区分。</span><br><span class="line">*/</span><br><span class="line">+ (BootingProtectionStatus)bootingProtectionStatusWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix &#123;</span><br><span class="line">   </span><br><span class="line">   BOOL isNormalChecking = [self isNormalCheckingWithContext:context];</span><br><span class="line">   if (isNormalChecking) &#123;</span><br><span class="line">       return BootingProtectionStatusNormalChecking;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   BOOL isUpToBootingProtectionCount = [self isUpToBootingProtectionCountWithContext:context</span><br><span class="line">                                                    continuousCrashOnLaunchNeedToFix:continuousCrashOnLaunchNeedToFix];</span><br><span class="line">   if (!isUpToBootingProtectionCount) &#123;</span><br><span class="line">       return BootingProtectionStatusNormal;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   BootingProtectionStatus type;</span><br><span class="line">   BOOL isFixingCrash = [self isFixingCrashWithContext:context];</span><br><span class="line">   if (isFixingCrash) &#123;</span><br><span class="line">       type = BootingProtectionStatusFixing;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       type = BootingProtectionStatusNeedFix;</span><br><span class="line">   &#125;</span><br><span class="line">   return type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)crashCount &#123;</span><br><span class="line">   return [[self class] crashCountWithContext:_context];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setCrashCount:(NSInteger)count &#123;</span><br><span class="line">   if (count &gt;=0) &#123;</span><br><span class="line">       [[self class] setCrashCount:count context:_context];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setIsFixing:(BOOL)isFixingCrash &#123;</span><br><span class="line">   [[self class] setIsFixing:isFixingCrash context:_context];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 是否正在修复</span><br><span class="line">*/</span><br><span class="line">- (BOOL)isFixingCrash &#123;</span><br><span class="line">   return [[self class] isFixingCrashWithContext:_context];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setIsNormalChecking:(BOOL)isNormalChecking &#123;</span><br><span class="line">   [[self class] setIsNormalChecking:isNormalChecking context:_context];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">* 是否正在检查</span><br><span class="line">*/</span><br><span class="line">- (BOOL)isNormalChecking &#123;</span><br><span class="line">   return [[self class] isNormalCheckingWithContext:_context];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSUInteger)crashCountWithContext:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context];</span><br><span class="line">   NSUInteger crashCount = [[NSUserDefaults standardUserDefaults] integerForKey:continuousCrashOnLaunchCounterKey];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;crashCount:%@&quot;, @(crashCount)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   return crashCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setCrashCount:(NSUInteger)count context:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashOnLaunchCounterKey = [self continuousCrashOnLaunchCounterKeyWithContext:context];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;setCrashCount:%@&quot;, @(count)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">   [defaults setInteger:count forKey:continuousCrashOnLaunchCounterKey];</span><br><span class="line">   [defaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setIsFixing:(BOOL)isFixingCrash context:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;setisFixingCrash:&#123;%@&#125;&quot;, @(isFixingCrash)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">   [defaults setBool:isFixingCrash forKey:continuousCrashFixingKey];</span><br><span class="line">   [defaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isFixingCrashWithContext:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashFixingKey = [[self class] continuousCrashFixingKeyWithContext:context];</span><br><span class="line">   BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;isFixingCrash:%@&quot;, @(isFixingCrash)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   return isFixingCrash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setIsNormalChecking:(BOOL)isNormalChecking context:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashNormalCheckingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;setIsNormalChecking:&#123;%@&#125;&quot;, @(isNormalChecking)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">   [defaults setBool:isNormalChecking forKey:continuousCrashNormalCheckingKey];</span><br><span class="line">   [defaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isNormalCheckingWithContext:(NSString *)context &#123;</span><br><span class="line">   NSString *continuousCrashFixingKey = [[self class] continuousCrashNormalCheckingKeyWithContext:context];</span><br><span class="line">   BOOL isFixingCrash = [[NSUserDefaults standardUserDefaults] boolForKey:continuousCrashFixingKey];</span><br><span class="line">   NSString *logString = [NSString stringWithFormat:@&quot;isIsNormalChecking:%@&quot;, @(isFixingCrash)];</span><br><span class="line">   [[self class] Logger:logString];</span><br><span class="line">   return isFixingCrash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isUpToBootingProtectionCount &#123;</span><br><span class="line">   return [[self class] isUpToBootingProtectionCountWithContext:_context continuousCrashOnLaunchNeedToFix:_continuousCrashOnLaunchNeedToFix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isUpToBootingProtectionCountWithContext:(NSString *)context continuousCrashOnLaunchNeedToFix:(NSUInteger)continuousCrashOnLaunchNeedToFix &#123;</span><br><span class="line">   BOOL isUpToCount = [self crashCountWithContext:context] &gt;= continuousCrashOnLaunchNeedToFix;</span><br><span class="line">   if (isUpToCount) &#123;</span><br><span class="line">       return YES;</span><br><span class="line">   &#125;</span><br><span class="line">   return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setReportBlock:(ABSReportBlock)block &#123;</span><br><span class="line">   _reportBlock = block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setRepairBlock:(ABSRepairBlock)block &#123;</span><br><span class="line">   _repairBlock = block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">*  “连续启动崩溃计数”个数，对应的Key</span><br><span class="line">*  默认为 &quot;_CONTINUOUS_CRASH_COUNTER_KEY&quot;</span><br><span class="line">*/</span><br><span class="line">+ (NSString *)continuousCrashOnLaunchCounterKeyWithContext:(NSString *)context &#123;</span><br><span class="line">   BOOL isValid = [[self class] isValidString:context];</span><br><span class="line">   NSString *validContext = isValid ? context : @&quot;&quot;;</span><br><span class="line">   NSString *continuousCrashOnLaunchCounterKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_COUNTER_KEY&quot;, validContext];</span><br><span class="line">   return continuousCrashOnLaunchCounterKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">*  是否正在修复记录，对应的Key</span><br><span class="line">*  默认为 &quot;_CONTINUOUS_CRASH_FIXING_KEY&quot;</span><br><span class="line">*/</span><br><span class="line">+ (NSString *)continuousCrashFixingKeyWithContext:(NSString *)context &#123;</span><br><span class="line">   BOOL isValid = [[self class] isValidString:context];</span><br><span class="line">   NSString *validContext = isValid ? context : @&quot;&quot;;</span><br><span class="line">   NSString *continuousCrashFixingKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_FIXING_KEY&quot;, validContext];</span><br><span class="line">   return continuousCrashFixingKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*!</span><br><span class="line">*  是否正在检查是否在特定时间内会Crash，对应的Key</span><br><span class="line">*  默认为 &quot;_CONTINUOUS_CRASH_CHECKING_KEY&quot;</span><br><span class="line">*/</span><br><span class="line">+ (NSString *)continuousCrashNormalCheckingKeyWithContext:(NSString *)context &#123;</span><br><span class="line">   BOOL isValid = [[self class] isValidString:context];</span><br><span class="line">   NSString *validContext = isValid ? context : @&quot;&quot;;</span><br><span class="line">   NSString *continuousCrashFixingKey = [NSString stringWithFormat:@&quot;%@_CONTINUOUS_CRASH_CHECKING_KEY&quot;, validContext];</span><br><span class="line">   return continuousCrashFixingKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -</span><br><span class="line">#pragma mark - log and util Methods</span><br><span class="line"></span><br><span class="line">+ (void)setLogger:(void (^)(NSString *))logger &#123;</span><br><span class="line">   Logger = [logger copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)Logger:(NSString *)log &#123;</span><br><span class="line">   if (Logger) Logger(log);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isValidString:(id)notValidString &#123;</span><br><span class="line">   if (!notValidString) &#123;</span><br><span class="line">       return NO;</span><br><span class="line">   &#125;</span><br><span class="line">   if (![notValidString isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">       return NO;</span><br><span class="line">   &#125;</span><br><span class="line">   NSInteger stringLength = 0;</span><br><span class="line">   @try &#123;</span><br><span class="line">       stringLength = [notValidString length];</span><br><span class="line">   &#125; @catch (NSException *exception) &#123;&#125;</span><br><span class="line">   if (stringLength == 0) &#123;</span><br><span class="line">       return NO;</span><br><span class="line">   &#125;</span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>下面是相应的验证步骤：</p><p>等待15秒会有对应计数清零的操作日志输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2018-01-18 16:25:37.162980+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: Launch continuous crash report</span><br><span class="line">2018-01-18 16:25:37.163140+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:&#123;0&#125;</span><br><span class="line">2018-01-18 16:25:37.165738+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:&#123;0&#125;</span><br><span class="line">2018-01-18 16:25:37.166883+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:0</span><br><span class="line">2018-01-18 16:25:37.167102+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：crashCount:0</span><br><span class="line">2018-01-18 16:25:37.167253+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:&#123;1&#125;</span><br><span class="line">2018-01-18 16:25:37.167938+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:1</span><br><span class="line">2018-01-18 16:25:37.168806+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：need no repair</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2018-01-18 16:25:52.225197+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：CYLBootingProtection: long live the app ( more than 15 seconds ), now reset crash counts</span><br><span class="line">2018-01-18 16:25:52.225378+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setCrashCount:0</span><br><span class="line">2018-01-18 16:25:52.226234+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setIsNormalChecking:&#123;0&#125;</span><br><span class="line">2018-01-18 16:25:52.226595+0800 BootingProtection[89773:15553277] 🔴类名与方法名：-[AppDelegate onBeforeBootingProtection]_block_invoke（在第45行），描述：setisFixingCrash:&#123;0&#125;</span><br></pre></td></tr></table></figure><hr><p>Posted by <a href="http://weibo.com/luohanchenyilong/" target="_blank" rel="noopener">微博@iOS程序犭袁</a><br>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">Creative Commons BY-NC-ND 3.0</a></p><p align="center"><a href="http://weibo.com/u/1692391497?s=6uyXnP" target="_blank"><img border="0" src="http://service.t.sina.com.cn/widget/qmd/1692391497/b46c844b/1.png"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;实现原理&lt;/li&gt;
&lt;li&gt;优化：降低50%以上误报机率&lt;/li&gt;
&lt;li&gt;对原有API设计的几点优化意见&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;机制状态应当用枚举来做为API透出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol star
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://yoursite.com/2018/02/03/nginx/"/>
    <id>http://yoursite.com/2018/02/03/nginx/</id>
    <published>2018-02-03T09:11:38.000Z</published>
    <updated>2019-07-03T16:01:08.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h3><p>Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p><h3 id="什么是反向代理？"><a href="#什么是反向代理？" class="headerlink" title="什么是反向代理？"></a>什么是反向代理？</h3><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。<br><img src="https://policx.github.io/post-images/1560762929102.jpg" alt></p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>nginx官网下载地址：<a href="http://nginx.org，发布版本分为" target="_blank" rel="noopener">http://nginx.org，发布版本分为</a> Linux 和 windows 版本。</p><p>也可以下载源码，编译后运行。</p><p>从源代码编译 Nginx</p><p>把源码解压缩之后，在终端里运行如下命令：</p><p> <img src="https://policx.github.io/post-images/1560763025695.png" alt></p><p>默认情况下，Nginx 会被安装在 /usr/local/nginx。通过设定编译选项，你可以改变这个设定。</p><p>Windows 安装</p><p>为了安装 Nginx / Win32，需先下载它。然后解压之，然后运行即可。下面以 C 盘根目录为例说明下：<br><img src="https://policx.github.io/post-images/1560763082984.png" alt></p><p>Nginx / Win32 是运行在一个控制台程序，而非 windows 服务方式的。服务器方式目前还是开发尝试中。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>nginx 的使用比较简单，就是几条命令。</p><p>常用到的命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop ：快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line"></span><br><span class="line">nginx -s quit ：平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line"></span><br><span class="line">nginx -s reload ：因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line"></span><br><span class="line">nginx -s reopen ：重新打开日志文件。</span><br><span class="line"></span><br><span class="line">nginx -c filename ：为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line"></span><br><span class="line">nginx -t ：不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line"></span><br><span class="line">nginx -v：显示 nginx 的版本。</span><br><span class="line"></span><br><span class="line">nginx -V：显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure><p>如果不想每次都敲命令，可以在nginx安装目录下新添一个启动批处理文件startup.bat，双击即可运行。内容如下：</p><p><img src="https://policx.github.io/post-images/1560763707256.png" alt></p><p>如果是运行在 Linux 下，写一个 shell 脚本，大同小异。</p><h3 id="nginx-配置实战"><a href="#nginx-配置实战" class="headerlink" title="nginx 配置实战"></a>nginx 配置实战</h3><p>我始终认为，各种开发工具的配置还是结合实战来讲述，会让人更易理解。</p><p>http反向代理配置</p><p>我们先实现一个小目标：不考虑复杂的配置，仅仅是完成一个 http 反向代理。</p><p>nginx.conf 配置文件如下：</p><p>注：conf / nginx.conf 是 nginx 的默认配置文件。你也可以使用 nginx -c 指定你的配置文件<br><img src="https://policx.github.io/post-images/1560763254253.png" alt><br><img src="https://policx.github.io/post-images/1560763292164.png" alt><br><img src="https://policx.github.io/post-images/1560763319108.png" alt></p><p>好了，让我们来试试吧：</p><p>启动 webapp，注意启动绑定的端口要和nginx中的 upstream 设置的端口保持一致。</p><p>更改 host：</p><p>在 C:Windows\System32\drivers\etc 目录下的host文件中添加一条DNS 记录127.0.0.1 <a href="http://www.javastack.cn" target="_blank" rel="noopener">www.javastack.cn</a> 启动前文中 startup.bat 的命令</p><p>在浏览器中访问 <a href="http://www.javastack.cn，不出意外，已经可以访问了。" target="_blank" rel="noopener">www.javastack.cn，不出意外，已经可以访问了。</a></p><p>负载均衡配置</p><p>上一个例子中，代理仅仅指向一个服务器。</p><p>但是，网站在实际运营过程中，多半都是有多台服务器运行着同样的app，这时需要使用负载均衡来分流。</p><p>nginx也可以实现简单的负载均衡功能。</p><p>假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台linux环境的服务器上。网站域名叫 <a href="http://www.javastack.cn，公网IP为" target="_blank" rel="noopener">www.javastack.cn，公网IP为</a> 192.168.1.11。在公网IP所在的服务器上部署 nginx，对所有请求做负载均衡处理。</p><p>nginx.conf 配置如下：<br><img src="https://policx.github.io/post-images/1560763351082.png" alt><br><img src="https://policx.github.io/post-images/1560763380502.png" alt></p><p>网站有多个webapp的配置</p><p>当一个网站功能越来越丰富时，往往需要将一些功能相对独立的模块剥离出来，独立维护。这样的话，通常，会有多个 webapp。</p><p>举个例子：假如 <a href="http://www.javastack.cn" target="_blank" rel="noopener">www.javastack.cn</a> 站点有好几个webapp，finance（金融）、product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分:</p><p><a href="http://www.javastack.cn/finance/" target="_blank" rel="noopener">www.javastack.cn/finance/</a></p><p><a href="http://www.javastack.cnproduct/" target="_blank" rel="noopener">www.javastack.cnproduct/</a></p><p><a href="http://www.javastack.cn/admin/" target="_blank" rel="noopener">www.javastack.cn/admin/</a></p><p>我们知道，http的默认端口号是80，如果在一台服务器上同时启动这3个 webapp 应用，都用80端口，肯定是不成的。所以，这三个应用需要分别绑定不同的端口号。</p><p>那么，问题来了，用户在实际访问 <a href="http://www.javastack.cn" target="_blank" rel="noopener">www.javastack.cn</a> 站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，你再次需要用到反向代理来做处理。</p><p>配置也不难，来看看怎么做吧：<br><img src="https://policx.github.io/post-images/1560764455305.png" alt><br>https反向代理配置</p><p>一些对安全性要求比较高的站点，可能会使用 HTTPS（一种使用ssl通信标准的安全HTTP协议）。</p><p>这里不科普 HTTP 协议和 SSL 标准。但是，使用 nginx 配置 https 需要知道几点：</p><p>HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口</p><p>SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key</p><p>其他和 http 反向代理基本一样，只是在 Server 部分配置有些不同。<br><img src="https://policx.github.io/post-images/1560763429270.png" alt></p><p>静态站点配置</p><p>有时候，我们需要配置静态站点(即 html 文件和一堆静态资源)。</p><p>举例来说：如果所有的静态资源都放在了 /app/dist 目录下，我们只需要在 nginx.conf 中指定首页以及这个站点的 host 即可。</p><p>配置如下：<br><img src="https://policx.github.io/post-images/1560764012451.png" alt><br>然后，添加 HOST：</p><p>127.0.0.1 static.zp.cn，此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。</p><p>跨域解决方案</p><p>web 领域开发中，经常采用前后端分离模式。这种模式下，前端和后端分别是独立的 web 应用程序，例如：后端是 Java 程序，前端是 React 或 Vue 应用</p><p>各自独立的 web app 在互相访问时，势必存在跨域问题。解决跨域问题一般有两种思路：</p><p>CORS</p><p>在后端服务器设置 HTTP 响应头，把你需要运行访问的域名加入加入 Access-Control-Allow-Origin 中。</p><p>jsonp</p><p>把后端根据请求，构造json数据，并返回，前端用 jsonp 跨域。</p><p>这两种思路，本文不展开讨论。</p><p>需要说明的是，nginx 根据第一种思路，也提供了一种解决跨域的解决方案。</p><p>举例：<a href="http://www.javastack.cn" target="_blank" rel="noopener">www.javastack.cn</a> 网站是由一个前端 app ，一个后端 app 组成的。前端端口号为 9000， 后端端口号为 8080。</p><p>前端和后端如果使用 http 进行交互时，请求会被拒绝，因为存在跨域问题。来看看，nginx 是怎么解决的吧：</p><p>首先，在 enable-cors.conf 文件中设置 cors ：<br><img src="https://policx.github.io/post-images/1560764290710.png" alt><br>接下来，在你的服务器中 include enable-cors.conf 来引入跨域配置：<br><img src="https://policx.github.io/post-images/1560764335044.png" alt><br>到此，就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Nginx&quot;&gt;&lt;a href=&quot;#什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是Nginx?&quot;&gt;&lt;/a&gt;什么是Nginx?&lt;/h3&gt;&lt;p&gt;Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮
      
    
    </summary>
    
    
  </entry>
  
</feed>
